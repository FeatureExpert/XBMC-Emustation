Index: .
===================================================================
--- .	(revision 33042)
+++ .	(working copy)

Property changes on: .
___________________________________________________________________
Modified: svn:ignore
## -12,3 +12,5 ##
 Profile
 Profile_FastCap
 cache
+Build Emustation.bat
+XBMC4XBOX.zip
Index: Build Emustation LTCG.bat
===================================================================
--- Build Emustation LTCG.bat	(nonexistent)
+++ Build Emustation LTCG.bat	(working copy)
@@ -0,0 +1,306 @@
+@Echo off
+goto getadminwrites >NUL
+
+pause
+:start
+@ECHO OFF
+CD "%~dp0"
+rem CLS
+COLOR 1B
+TITLE Emustation edits
+rem ----PURPOSE----
+rem - Create a working XBMC build with a single click
+rem -------------------------------------------------------------
+rem Usage: built.bat [noprompt] [nocompress] [noclean] [build1-4]
+rem -------------------------------------------------------------
+rem Config
+rem If you get an error that Visual studio was not found, SET your path for VSNET main executable.
+rem ONLY needed if you have a very old bios, SET the path for xbepatch. Not needed otherwise.
+rem -------------------------------------------------------------
+rem CONFIG START
+
+SET XBE_PATCH=tools\xbepatch\xbepatch.exe
+
+SET COMPRESS_FILE=XBMC4XBOX.zip
+SET COMPRESS=C:\Program Files\7-zip\7z.exe
+SET COMPRESS_OPTS=a %COMPRESS_FILE%
+
+SET Silent=0
+SET SkipCompression=0
+SET Clean=1
+SET Compile=1
+
+IF "%VS71COMNTOOLS%"=="" (
+  SET NET="%ProgramFiles%\Microsoft Visual Studio .NET 2003\Common7\IDE\devenv.com"
+) ELSE (
+  SET NET="%VS71COMNTOOLS%\..\IDE\devenv.com"
+)
+
+IF NOT EXIST %NET% (
+  CALL:ERROR "Visual Studio .NET 2003 was not found."
+  GOTO:EOF
+)
+
+:GETPARAMS
+  set IN=%1
+  IF "%IN%" EQU "noprompt" (
+    SET Silent=1
+  ) ELSE IF "%IN%" EQU "nocompress" (
+    SET SkipCompression=1
+  ) ELSE IF "%IN%" EQU "noclean" (
+    SET Clean=0
+  ) ELSE IF "%IN:~0,5%" EQU "build" (
+    SET XBMC_COMPILE_ANSWER=%IN:~5,1%
+    SET Silent=1
+  ) ELSE IF "%IN%" EQU "" (
+    GOTO ENDPARAMS
+  )
+  SHIFT
+  GOTO GETPARAMS
+:ENDPARAMS
+
+IF %Silent% EQU 0 (
+  CALL:MENU
+)
+
+SET DEST=BUILD
+
+IF %XBMC_COMPILE_ANSWER% EQU 1 (
+  SET VS_PATH=.
+  SET VS_SOL=xbmc.sln
+  SET VS_CONF=Release
+  SET VS_BIN=default.xbe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU 2 (
+  SET VS_PATH=.
+  SET VS_SOL=xbmc.sln
+  SET VS_CONF=Release_LTCG
+  SET VS_BIN=default.xbe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU 3 (
+  SET VS_PATH=.
+  SET VS_SOL=xbmc.sln
+  SET VS_CONF=Debug
+  SET VS_BIN=default.xbe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU 4 (
+  SET DEST=BUILD_WIN32
+  SET VS_PATH=tools\Win32
+  SET VS_SOL=XBMC_PC.sln
+  SET VS_CONF=Release
+  SET VS_BIN=XBMC_PC.exe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU "" GOTO:EOF
+
+IF %Silent% EQU 0 (
+  IF EXIST %VS_PATH%\%VS_CONF%\%VS_BIN% (
+    CALL:BIN_EXISTS
+  )
+)
+
+IF %Compile% EQU 1 (
+  CALL:COMPILE
+)
+
+CALL:MAKE_BUILD %DEST%
+
+ECHO ------------------------------------------------------------
+ECHO Build Succeeded!
+IF %SkipCompression%==0 (
+  CALL:COMPRESS %DEST%
+)
+
+IF %Silent% EQU 0 (
+  CALL:VIEWLOG
+)
+
+pause
+GOTO:EOF
+
+:MENU
+  ECHO    ВВВВВВВББББББББААААААА
+  ECHO  ВлллллллллллллллллллллллВВВВВВБББББАААААА     пппВмм
+  ECHO олллллллллллллллллллллллллллллллллллллллллВВВВБББАА  ппм
+  ECHO ВлллллллллллллллллллллллллллллллллллллллллллллллллллВА  н
+  ECHO ВлллллллллллллллллллплллллллллллллллллллллллллллллллллА В
+  ECHO БллллллллллллллллллнАлллллллллллллллллллллллллллллллллл о
+  ECHO АллллллВБА  плп           плллп    пВп    плллп   АВллл о
+  ECHO  ллллллллллн   млллн Влллм олн мВлм   мллм ол  мллллллл о
+  ECHO  Влллллллллл  лллллн лллллн л оллллн оллллн н олллллллл В
+  ECHO  Блллллллллн олллллн лллллн л лллллн лллллн   ВлллллллВ н
+  ECHO  АВлллллллп   пллллн плллп он лллллн лллллн А плллллллн н
+  ECHO   БлллВБА мллм АБВллм     млВмллллллмлллллВ лм   АВлллно
+  ECHO   АВлллллллллллллллллллллллллллллллллллллллллллллллллл В
+  ECHO    Блллллпппплпплппллпллпллллпплпплппплпплпплппллллллл н
+  ECHO    АВлллл но л пл л л лнмоллл лл пл л лнол пл пмлллллБ н
+  ECHO     Блллл но л пл пмл л м ллл пл пл л лнол пл л лллллАо
+  ECHO     АВллллллллллллллллллллллллллллллллллллллллллллллВ
+  ECHO      БАммммммммммммммммммммммммммммммммммммм  АБВВВВ
+  ECHO      АВллллллллллллллллллллллллллллллллллллллВААБВп
+  ECHO       БВлллллллллллллллллллллллллллллВлВВпппп
+  ECHO        ВВллллллллллллллллллВлВВпппп
+  ECHO         пВллллВлВВВпппппп
+  ECHO ------------------------------------------------------------
+  ECHO XBMC prepare menu
+  ECHO ------------------------------------------------------------
+  ECHO [1] Build XBMC XBE      ( for XBOX use )
+  ECHO [2] Build LTCG XBMC XBE ( for XBOX use )
+  ECHO [3] Build DEBUG XBE     ( for XBOX use )
+  ECHO [4] Build XBMC_WIN32    ( for Windows use)
+  ECHO ------------------------------------------------------------
+  SET XBMC_COMPILE_ANSWER=2
+  ::SET /P XBMC_COMPILE_ANSWER=Please enter the number you want to build [1/2/3/4]:
+  GOTO:EOF
+
+:BIN_EXISTS
+  ECHO ------------------------------------------------------------
+  ECHO Found a previous Compiled binary - %VS_PATH%\%VS_CONF%\%VS_BIN% !
+  ECHO [1] a NEW binary will be compiled for the BUILD 
+  ECHO [2] existing binary will be updated (quick mode compile) for the BUILD
+  ECHO [3] existing binary will be used for the BUILD 
+  ECHO ------------------------------------------------------------
+  SET XBMC_COMPILE_ANSWER=2
+  ::SET /P XBMC_COMPILE_ANSWER=Compile a new binary? [1/2/3]:
+  IF /I %XBMC_COMPILE_ANSWER% EQU 1 SET Clean=1
+  IF /I %XBMC_COMPILE_ANSWER% EQU 2 SET Clean=0
+  IF /I %XBMC_COMPILE_ANSWER% EQU 3 SET Compile=0
+  GOTO:EOF
+  
+:COMPILE
+  ECHO Wait while preparing the build.
+  ECHO ------------------------------------------------------------
+  Echo CStdString strOutPutPathHeaderFile("E:/TDATA/Rocky5 needs these Logs/XBMC-Emustation/");>"xbmc\lib\libPython\XBPyErrorPath.h"
+  IF %Clean% EQU 1 (
+    ECHO Cleaning Solution...
+    %NET% %VS_PATH%\%VS_SOL% /clean %VS_CONF%
+    DEL %VS_PATH%\%VS_CONF%\xbmc.map 2>NUL
+  )
+  ECHO Compiling Solution...
+  %NET% %VS_PATH%\%VS_SOL% /build %VS_CONF%
+  IF NOT EXIST %VS_PATH%\%VS_CONF%\%VS_BIN% (
+    CALL:ERROR "%VS_BIN% failed to build!  See .\%VS_CONF%\BuildLog.htm for details."
+    CALL:VIEWLOG
+    PAUSE
+    EXIT
+  )
+  ECHO Done!
+  ECHO ------------------------------------------------------------
+  GOTO:EOF
+
+:MAKE_BUILD
+
+  RMDIR %~1 /S /Q
+  if not exist "BUILD" md "BUILD"
+  
+  ECHO Copying files to %~1 ...
+  
+  xcopy /Y %VS_PATH%\%VS_CONF%\%VS_BIN% BUILD\
+  
+  IF "%~1" EQU "BUILD" (
+    ECHO - XBE Patching %VS_PATH%\%VS_CONF%\%VS_BIN%
+    %XBE_PATCH% "BUILD\%VS_BIN%"
+    ECHO - Patching Done!
+  )
+  
+  if "%clean%"=="0" pause & Goto start
+  
+  ECHO .svn>exclude.txt
+  ECHO Thumbs.db>>exclude.txt
+  ECHO Desktop.ini>>exclude.txt
+  ECHO dsstdfx.bin>>exclude.txt
+  ECHO exclude.txt>>exclude.txt
+
+  xcopy UserData %~1\UserData /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy *.txt %~1 /EXCLUDE:exclude.txt
+
+  SET RUN_ME=%~1\run_me.bat
+  IF "%~1" EQU "BUILD_WIN32" (
+    ECHO subst q: .>%RUN_ME%
+    ECHO subst p: q:\userdata >>%RUN_ME%
+    ECHO subst t: q:\userdata >>%RUN_ME%
+    ECHO if not exist q:\Temp md Temp >>%RUN_ME%
+    ECHO subst z: Temp >>%RUN_ME%
+    ECHO XBMC_PC.exe >>%RUN_ME%
+    ECHO subst z: /D >>%RUN_ME%
+    ECHO subst t: /D >>%RUN_ME%
+    ECHO subst p: /D >>%RUN_ME%
+    ECHO subst q: /D >>%RUN_ME%
+  )
+
+  cd "skin\Confluence Lite"
+  CALL build.bat
+  cd ..\..
+  xcopy "skin\Confluence Lite\BUILD\Confluence Lite" "%~1\skin\Confluence Lite" /E /Q /I /Y /EXCLUDE:exclude.txt
+  
+  rem xcopy credits %~1\credits /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy language %~1\language /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy screensavers %~1\screensavers /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy visualisations %~1\visualisations /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy system %~1\system /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy web\XBMC_Reloaded %~1\web /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy media   %~1\media   /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy plugins %~1\plugins /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy sounds  %~1\sounds  /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy scripts %~1\scripts /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy mplayer\codecs %~1\system\players\mplayer\codecs /E /Q /I /Y /EXCLUDE:exclude.txt
+  
+  del exclude.txt
+  GOTO:EOF
+
+
+:COMPRESS
+  ECHO ------------------------------------------------------------
+  ECHO Compressing build to XBMC4XBOX.zip file...
+  ECHO ------------------------------------------------------------
+  IF EXIST "%COMPRESS%" (
+    DEL %COMPRESS_FILE%
+    "%COMPRESS%" %COMPRESS_OPTS% %~1
+  ) ELSE ( 
+    ECHO 7-Zip not installed!  Skipping compression...
+  )
+  ECHO ------------------------------------------------------------
+  GOTO:EOF
+  
+:ERROR
+  ECHO ------------------------------------------------------------
+  ECHO !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
+  ECHO    ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR
+  ECHO !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
+  ECHO ERROR %~1
+  ECHO ------------------------------------------------------------
+  GOTO:EOF
+  
+:VIEWLOG
+  SET /P XBMC_BUILD_ANSWER=View the build log in your HTML browser? [y/n]
+  if /I "%XBMC_BUILD_ANSWER%" EQU "y" (
+    start /D"%~dp0%VS_PATH%\%VS_CONF%" BuildLog.htm"
+  )
+  GOTO:EOF
+
+:getadminwrites
+REM  --> Check for permissions
+    IF "%PROCESSOR_ARCHITECTURE%" EQU "amd64" (
+>nul 2>&1 "%SYSTEMROOT%\SysWOW64\cacls.exe" "%SYSTEMROOT%\SysWOW64\config\system"
+) ELSE (
+>nul 2>&1 "%SYSTEMROOT%\system32\cacls.exe" "%SYSTEMROOT%\system32\config\system"
+)
+REM --> If error flag set, we do not have admin.
+if '%errorlevel%' NEQ '0' (
+    echo Requesting administrative privileges...
+    goto UACPrompt
+) else ( goto gotAdmin )
+:UACPrompt
+    echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
+    set params = %*:"=""
+    echo UAC.ShellExecute "cmd.exe", "/c ""%~s0"" %params%", "", "runas", 1 >> "%temp%\getadmin.vbs"
+    "%temp%\getadmin.vbs"
+    del "%temp%\getadmin.vbs"
+    exit /B
+:gotAdmin
+    pushd "%CD%"
+    CD /D "%~dp0"
+   goto start
\ No newline at end of file
Index: Build Emustation.bat
===================================================================
--- Build Emustation.bat	(nonexistent)
+++ Build Emustation.bat	(working copy)
@@ -0,0 +1,306 @@
+@Echo off
+goto getadminwrites >NUL
+
+pause
+:start
+@ECHO OFF
+CD "%~dp0"
+rem CLS
+COLOR 1B
+TITLE Emustation edits
+rem ----PURPOSE----
+rem - Create a working XBMC build with a single click
+rem -------------------------------------------------------------
+rem Usage: built.bat [noprompt] [nocompress] [noclean] [build1-4]
+rem -------------------------------------------------------------
+rem Config
+rem If you get an error that Visual studio was not found, SET your path for VSNET main executable.
+rem ONLY needed if you have a very old bios, SET the path for xbepatch. Not needed otherwise.
+rem -------------------------------------------------------------
+rem CONFIG START
+
+SET XBE_PATCH=tools\xbepatch\xbepatch.exe
+
+SET COMPRESS_FILE=XBMC4XBOX.zip
+SET COMPRESS=C:\Program Files\7-zip\7z.exe
+SET COMPRESS_OPTS=a %COMPRESS_FILE%
+
+SET Silent=0
+SET SkipCompression=0
+SET Clean=1
+SET Compile=1
+
+IF "%VS71COMNTOOLS%"=="" (
+  SET NET="%ProgramFiles%\Microsoft Visual Studio .NET 2003\Common7\IDE\devenv.com"
+) ELSE (
+  SET NET="%VS71COMNTOOLS%\..\IDE\devenv.com"
+)
+
+IF NOT EXIST %NET% (
+  CALL:ERROR "Visual Studio .NET 2003 was not found."
+  GOTO:EOF
+)
+
+:GETPARAMS
+  set IN=%1
+  IF "%IN%" EQU "noprompt" (
+    SET Silent=1
+  ) ELSE IF "%IN%" EQU "nocompress" (
+    SET SkipCompression=1
+  ) ELSE IF "%IN%" EQU "noclean" (
+    SET Clean=0
+  ) ELSE IF "%IN:~0,5%" EQU "build" (
+    SET XBMC_COMPILE_ANSWER=%IN:~5,1%
+    SET Silent=1
+  ) ELSE IF "%IN%" EQU "" (
+    GOTO ENDPARAMS
+  )
+  SHIFT
+  GOTO GETPARAMS
+:ENDPARAMS
+
+IF %Silent% EQU 0 (
+  CALL:MENU
+)
+
+SET DEST=BUILD
+
+IF %XBMC_COMPILE_ANSWER% EQU 1 (
+  SET VS_PATH=.
+  SET VS_SOL=xbmc.sln
+  SET VS_CONF=Release
+  SET VS_BIN=default.xbe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU 2 (
+  SET VS_PATH=.
+  SET VS_SOL=xbmc.sln
+  SET VS_CONF=Release_LTCG
+  SET VS_BIN=default.xbe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU 3 (
+  SET VS_PATH=.
+  SET VS_SOL=xbmc.sln
+  SET VS_CONF=Debug
+  SET VS_BIN=default.xbe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU 4 (
+  SET DEST=BUILD_WIN32
+  SET VS_PATH=tools\Win32
+  SET VS_SOL=XBMC_PC.sln
+  SET VS_CONF=Release
+  SET VS_BIN=XBMC_PC.exe
+)
+
+IF %XBMC_COMPILE_ANSWER% EQU "" GOTO:EOF
+
+IF %Silent% EQU 0 (
+  IF EXIST %VS_PATH%\%VS_CONF%\%VS_BIN% (
+    CALL:BIN_EXISTS
+  )
+)
+
+IF %Compile% EQU 1 (
+  CALL:COMPILE
+)
+
+CALL:MAKE_BUILD %DEST%
+
+ECHO ------------------------------------------------------------
+ECHO Build Succeeded!
+IF %SkipCompression%==0 (
+  CALL:COMPRESS %DEST%
+)
+
+IF %Silent% EQU 0 (
+  CALL:VIEWLOG
+)
+
+pause
+GOTO:EOF
+
+:MENU
+  ECHO    ВВВВВВВББББББББААААААА
+  ECHO  ВлллллллллллллллллллллллВВВВВВБББББАААААА     пппВмм
+  ECHO олллллллллллллллллллллллллллллллллллллллллВВВВБББАА  ппм
+  ECHO ВлллллллллллллллллллллллллллллллллллллллллллллллллллВА  н
+  ECHO ВлллллллллллллллллллплллллллллллллллллллллллллллллллллА В
+  ECHO БллллллллллллллллллнАлллллллллллллллллллллллллллллллллл о
+  ECHO АллллллВБА  плп           плллп    пВп    плллп   АВллл о
+  ECHO  ллллллллллн   млллн Влллм олн мВлм   мллм ол  мллллллл о
+  ECHO  Влллллллллл  лллллн лллллн л оллллн оллллн н олллллллл В
+  ECHO  Блллллллллн олллллн лллллн л лллллн лллллн   ВлллллллВ н
+  ECHO  АВлллллллп   пллллн плллп он лллллн лллллн А плллллллн н
+  ECHO   БлллВБА мллм АБВллм     млВмллллллмлллллВ лм   АВлллно
+  ECHO   АВлллллллллллллллллллллллллллллллллллллллллллллллллл В
+  ECHO    Блллллпппплпплппллпллпллллпплпплппплпплпплппллллллл н
+  ECHO    АВлллл но л пл л л лнмоллл лл пл л лнол пл пмлллллБ н
+  ECHO     Блллл но л пл пмл л м ллл пл пл л лнол пл л лллллАо
+  ECHO     АВллллллллллллллллллллллллллллллллллллллллллллллВ
+  ECHO      БАммммммммммммммммммммммммммммммммммммм  АБВВВВ
+  ECHO      АВллллллллллллллллллллллллллллллллллллллВААБВп
+  ECHO       БВлллллллллллллллллллллллллллллВлВВпппп
+  ECHO        ВВллллллллллллллллллВлВВпппп
+  ECHO         пВллллВлВВВпппппп
+  ECHO ------------------------------------------------------------
+  ECHO XBMC prepare menu
+  ECHO ------------------------------------------------------------
+  ECHO [1] Build XBMC XBE      ( for XBOX use )
+  ECHO [2] Build LTCG XBMC XBE ( for XBOX use )
+  ECHO [3] Build DEBUG XBE     ( for XBOX use )
+  ECHO [4] Build XBMC_WIN32    ( for Windows use)
+  ECHO ------------------------------------------------------------
+  SET XBMC_COMPILE_ANSWER=1
+  ::SET /P XBMC_COMPILE_ANSWER=Please enter the number you want to build [1/2/3/4]:
+  GOTO:EOF
+
+:BIN_EXISTS
+  ECHO ------------------------------------------------------------
+  ECHO Found a previous Compiled binary - %VS_PATH%\%VS_CONF%\%VS_BIN% !
+  ECHO [1] a NEW binary will be compiled for the BUILD 
+  ECHO [2] existing binary will be updated (quick mode compile) for the BUILD
+  ECHO [3] existing binary will be used for the BUILD 
+  ECHO ------------------------------------------------------------
+  SET XBMC_COMPILE_ANSWER=2
+  ::SET /P XBMC_COMPILE_ANSWER=Compile a new binary? [1/2/3]:
+  IF /I %XBMC_COMPILE_ANSWER% EQU 1 SET Clean=1
+  IF /I %XBMC_COMPILE_ANSWER% EQU 2 SET Clean=0
+  IF /I %XBMC_COMPILE_ANSWER% EQU 3 SET Compile=0
+  GOTO:EOF
+  
+:COMPILE
+  ECHO Wait while preparing the build.
+  ECHO ------------------------------------------------------------
+  Echo CStdString strOutPutPathHeaderFile("E:/TDATA/Rocky5 needs these Logs/XBMC-Emustation/");>"xbmc\lib\libPython\XBPyErrorPath.h"
+  IF %Clean% EQU 1 (
+    ECHO Cleaning Solution...
+    %NET% %VS_PATH%\%VS_SOL% /clean %VS_CONF%
+    DEL %VS_PATH%\%VS_CONF%\xbmc.map 2>NUL
+  )
+  ECHO Compiling Solution...
+  %NET% %VS_PATH%\%VS_SOL% /build %VS_CONF%
+  IF NOT EXIST %VS_PATH%\%VS_CONF%\%VS_BIN% (
+    CALL:ERROR "%VS_BIN% failed to build!  See .\%VS_CONF%\BuildLog.htm for details."
+    CALL:VIEWLOG
+    PAUSE
+    EXIT
+  )
+  ECHO Done!
+  ECHO ------------------------------------------------------------
+  GOTO:EOF
+
+:MAKE_BUILD
+
+  RMDIR %~1 /S /Q
+  if not exist "BUILD" md "BUILD"
+  
+  ECHO Copying files to %~1 ...
+  
+  xcopy /Y %VS_PATH%\%VS_CONF%\%VS_BIN% BUILD\
+  
+  IF "%~1" EQU "BUILD" (
+    ECHO - XBE Patching %VS_PATH%\%VS_CONF%\%VS_BIN%
+    %XBE_PATCH% "BUILD\%VS_BIN%"
+    ECHO - Patching Done!
+  )
+  
+  if "%clean%"=="0" pause & Goto start
+  
+  ECHO .svn>exclude.txt
+  ECHO Thumbs.db>>exclude.txt
+  ECHO Desktop.ini>>exclude.txt
+  ECHO dsstdfx.bin>>exclude.txt
+  ECHO exclude.txt>>exclude.txt
+
+  xcopy UserData %~1\UserData /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy *.txt %~1 /EXCLUDE:exclude.txt
+
+  SET RUN_ME=%~1\run_me.bat
+  IF "%~1" EQU "BUILD_WIN32" (
+    ECHO subst q: .>%RUN_ME%
+    ECHO subst p: q:\userdata >>%RUN_ME%
+    ECHO subst t: q:\userdata >>%RUN_ME%
+    ECHO if not exist q:\Temp md Temp >>%RUN_ME%
+    ECHO subst z: Temp >>%RUN_ME%
+    ECHO XBMC_PC.exe >>%RUN_ME%
+    ECHO subst z: /D >>%RUN_ME%
+    ECHO subst t: /D >>%RUN_ME%
+    ECHO subst p: /D >>%RUN_ME%
+    ECHO subst q: /D >>%RUN_ME%
+  )
+
+  cd "skin\Confluence Lite"
+  CALL build.bat
+  cd ..\..
+  xcopy "skin\Confluence Lite\BUILD\Confluence Lite" "%~1\skin\Confluence Lite" /E /Q /I /Y /EXCLUDE:exclude.txt
+  
+  rem xcopy credits %~1\credits /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy language %~1\language /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy screensavers %~1\screensavers /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy visualisations %~1\visualisations /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy system %~1\system /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy web\XBMC_Reloaded %~1\web /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy media   %~1\media   /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy plugins %~1\plugins /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy sounds  %~1\sounds  /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy scripts %~1\scripts /E /Q /I /Y /EXCLUDE:exclude.txt
+  xcopy mplayer\codecs %~1\system\players\mplayer\codecs /E /Q /I /Y /EXCLUDE:exclude.txt
+  
+  del exclude.txt
+  GOTO:EOF
+
+
+:COMPRESS
+  ECHO ------------------------------------------------------------
+  ECHO Compressing build to XBMC4XBOX.zip file...
+  ECHO ------------------------------------------------------------
+  IF EXIST "%COMPRESS%" (
+    DEL %COMPRESS_FILE%
+    "%COMPRESS%" %COMPRESS_OPTS% %~1
+  ) ELSE ( 
+    ECHO 7-Zip not installed!  Skipping compression...
+  )
+  ECHO ------------------------------------------------------------
+  GOTO:EOF
+  
+:ERROR
+  ECHO ------------------------------------------------------------
+  ECHO !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
+  ECHO    ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR
+  ECHO !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
+  ECHO ERROR %~1
+  ECHO ------------------------------------------------------------
+  GOTO:EOF
+  
+:VIEWLOG
+  SET /P XBMC_BUILD_ANSWER=View the build log in your HTML browser? [y/n]
+  if /I "%XBMC_BUILD_ANSWER%" EQU "y" (
+    start /D"%~dp0%VS_PATH%\%VS_CONF%" BuildLog.htm"
+  )
+  GOTO:EOF
+
+:getadminwrites
+REM  --> Check for permissions
+    IF "%PROCESSOR_ARCHITECTURE%" EQU "amd64" (
+>nul 2>&1 "%SYSTEMROOT%\SysWOW64\cacls.exe" "%SYSTEMROOT%\SysWOW64\config\system"
+) ELSE (
+>nul 2>&1 "%SYSTEMROOT%\system32\cacls.exe" "%SYSTEMROOT%\system32\config\system"
+)
+REM --> If error flag set, we do not have admin.
+if '%errorlevel%' NEQ '0' (
+    echo Requesting administrative privileges...
+    goto UACPrompt
+) else ( goto gotAdmin )
+:UACPrompt
+    echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
+    set params = %*:"=""
+    echo UAC.ShellExecute "cmd.exe", "/c ""%~s0"" %params%", "", "runas", 1 >> "%temp%\getadmin.vbs"
+    "%temp%\getadmin.vbs"
+    del "%temp%\getadmin.vbs"
+    exit /B
+:gotAdmin
+    pushd "%CD%"
+    CD /D "%~dp0"
+   goto start
\ No newline at end of file
Index: language/English (US)/strings.po
===================================================================
--- language/English (US)/strings.po	(revision 33042)
+++ language/English (US)/strings.po	(working copy)
@@ -8272,3 +8272,11 @@
 msgctxt "#34005"
 msgid "Flac"
 msgstr "Flac"
+
+msgctxt "#34006"
+msgid "- Primary DNS"
+msgstr ""
+
+msgctxt "#34007"
+msgid "- Secondary DNS"
+msgstr ""
\ No newline at end of file
Index: language/English/strings.po
===================================================================
--- language/English/strings.po	(revision 33042)
+++ language/English/strings.po	(working copy)
@@ -8688,3 +8688,11 @@
 msgctxt "#34005"
 msgid "Flac"
 msgstr ""
+
+msgctxt "#34006"
+msgid "- Primary DNS"
+msgstr ""
+
+msgctxt "#34007"
+msgid "- Secondary DNS"
+msgstr ""
Index: sources/screensavers/Asteroids
===================================================================
--- sources/screensavers/Asteroids	(revision 33042)
+++ sources/screensavers/Asteroids	(working copy)

Property changes on: sources/screensavers/Asteroids
___________________________________________________________________
Added: svn:ignore
## -0,0 +1,2 ##
+Asteroids.ncb
+Asteroids.suo
Index: sources/screensavers/Asteroids/Asteroids.vcproj
===================================================================
--- sources/screensavers/Asteroids/Asteroids.vcproj	(revision 33042)
+++ sources/screensavers/Asteroids/Asteroids.vcproj	(working copy)
@@ -19,7 +19,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;_XBOX"
 				MinimalRebuild="FALSE"
 				BasicRuntimeChecks="0"
@@ -72,7 +72,7 @@
 				Optimization="2"
 				FavorSizeOrSpeed="1"
 				OptimizeForProcessor="2"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/Asteroids/main.cpp
===================================================================
--- sources/screensavers/Asteroids/main.cpp	(revision 33042)
+++ sources/screensavers/Asteroids/main.cpp	(working copy)
@@ -155,7 +155,7 @@
 #ifdef _TEST
 	strcpy(szXMLFile, "Asteroids.xml");
 #else
-	strcpy(szXMLFile, "Q:\\screensavers\\");
+	strcpy(szXMLFile, "Q:\\system\\screensavers\\");
 	strcat(szXMLFile, gScrName);
 	strcat(szXMLFile, ".xml");
 #endif
Index: sources/screensavers/AsterWave
===================================================================
--- sources/screensavers/AsterWave	(revision 33042)
+++ sources/screensavers/AsterWave	(working copy)

Property changes on: sources/screensavers/AsterWave
___________________________________________________________________
Added: svn:ignore
## -0,0 +1,2 ##
+AsterWave.ncb
+AsterWave.suo
Index: sources/screensavers/AsterWave/AsterWave.vcproj
===================================================================
--- sources/screensavers/AsterWave/AsterWave.vcproj	(revision 33042)
+++ sources/screensavers/AsterWave/AsterWave.vcproj	(working copy)
@@ -20,7 +20,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				MinimalRebuild="FALSE"
 				BasicRuntimeChecks="0"
@@ -73,7 +73,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/BioGenesis
===================================================================
--- sources/screensavers/BioGenesis	(revision 33042)
+++ sources/screensavers/BioGenesis	(working copy)

Property changes on: sources/screensavers/BioGenesis
___________________________________________________________________
Added: svn:ignore
## -0,0 +1,2 ##
+BioGenesis.ncb
+BioGenesis.suo
Index: sources/screensavers/BioGenesis/BioGenesis.vcproj
===================================================================
--- sources/screensavers/BioGenesis/BioGenesis.vcproj	(revision 33042)
+++ sources/screensavers/BioGenesis/BioGenesis.vcproj	(working copy)
@@ -20,7 +20,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="0"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;SPECTRUM_EXPORTS"
 				MinimalRebuild="FALSE"
 				BasicRuntimeChecks="3"
@@ -71,7 +71,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/cpBlobs/cpBlobs.vcproj
===================================================================
--- sources/screensavers/cpBlobs/cpBlobs.vcproj	(revision 33042)
+++ sources/screensavers/cpBlobs/cpBlobs.vcproj	(working copy)
@@ -69,7 +69,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="&quot;C:\Program Files\Microsoft Xbox SDK\xbox\include&quot;;h:\xdk5849\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/CrystalMorph/CrystalMorph.vcproj
===================================================================
--- sources/screensavers/CrystalMorph/CrystalMorph.vcproj	(revision 33042)
+++ sources/screensavers/CrystalMorph/CrystalMorph.vcproj	(working copy)
@@ -20,7 +20,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="0"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;SPECTRUM_EXPORTS"
 				MinimalRebuild="FALSE"
 				BasicRuntimeChecks="3"
@@ -71,7 +71,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/Drempels/main.cpp
===================================================================
--- sources/screensavers/Drempels/main.cpp	(revision 33042)
+++ sources/screensavers/Drempels/main.cpp	(working copy)
@@ -134,7 +134,7 @@
 
 float time_between_textures = 20.0f;
 float texture_fade_time = 5.0f;
-char  szTexPath[MAX_PATH] = "q:\\screensavers\\Drempels";
+char  szTexPath[MAX_PATH] = "Q:\\system\\screensavers\\Drempels";
 //char  szTexPathCurrent[MAX_PATH] = "c:\\program files\\drempels";
 int   g_nTimeBetweenSubdirs = 120;
 int   g_subdirIndices[9] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
Index: sources/screensavers/GreyNetic/GreyNetic.cpp
===================================================================
--- sources/screensavers/GreyNetic/GreyNetic.cpp	(revision 33042)
+++ sources/screensavers/GreyNetic/GreyNetic.cpp	(working copy)
@@ -251,7 +251,7 @@
 	SetDefaults();
 
 	char szXMLFile[1024];
-	strcpy(szXMLFile, "Q:\\screensavers\\");
+	strcpy(szXMLFile, "Q:\\system\\screensavers\\");
 	strcat(szXMLFile, m_szScrName);
 	strcat(szXMLFile, ".xml");
 
Index: sources/screensavers/GreyNetic/GreyNetic.vcproj
===================================================================
--- sources/screensavers/GreyNetic/GreyNetic.vcproj	(revision 33042)
+++ sources/screensavers/GreyNetic/GreyNetic.vcproj	(working copy)
@@ -69,7 +69,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/MatrixTrails/main.cpp
===================================================================
--- sources/screensavers/MatrixTrails/main.cpp	(revision 33042)
+++ sources/screensavers/MatrixTrails/main.cpp	(working copy)
@@ -156,7 +156,7 @@
 #ifdef _TEST
 	strcpy(szXMLFile, "MatrixTrails.xml");
 #else
-	strcpy(szXMLFile, "Q:\\screensavers\\");
+	strcpy(szXMLFile, "Q:\\system\\screensavers\\");
 	strcat(szXMLFile, gScrName);
 	strcat(szXMLFile, ".xml");
 #endif
Index: sources/screensavers/MatrixTrails/matrixtrails.cpp
===================================================================
--- sources/screensavers/MatrixTrails/matrixtrails.cpp	(revision 33042)
+++ sources/screensavers/MatrixTrails/matrixtrails.cpp	(working copy)
@@ -60,7 +60,7 @@
 #ifdef _TEST
 	DVERIFY(D3DXCreateTextureFromFileA(d3dDevice, "matrixtrails.tga", &m_Texture))
 #else
-	DVERIFY(D3DXCreateTextureFromFileA(d3dDevice, "q:\\screensavers\\matrixtrails.tga", &m_Texture))
+	DVERIFY(D3DXCreateTextureFromFileA(d3dDevice, "Q:\\system\\screensavers\\matrixtrails.tga", &m_Texture))
 #endif
 
 	m_CharSize.x	= (f32)render->m_Width  / (f32)m_NumColumns;
Index: sources/screensavers/MatrixTrails/matrixtrails.vcproj
===================================================================
--- sources/screensavers/MatrixTrails/matrixtrails.vcproj	(revision 33042)
+++ sources/screensavers/MatrixTrails/matrixtrails.vcproj	(working copy)
@@ -19,7 +19,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;_XBOX"
 				MinimalRebuild="FALSE"
 				BasicRuntimeChecks="0"
@@ -72,7 +72,7 @@
 				Optimization="2"
 				FavorSizeOrSpeed="1"
 				OptimizeForProcessor="2"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/PingPong/main.cpp
===================================================================
--- sources/screensavers/PingPong/main.cpp	(revision 33042)
+++ sources/screensavers/PingPong/main.cpp	(working copy)
@@ -114,7 +114,7 @@
 	SetDefaults();
 
 	char szXMLFile[1024];
-	strcpy(szXMLFile, "Q:\\screensavers\\");
+	strcpy(szXMLFile, "Q:\\system\\screensavers\\");
 	strcat(szXMLFile, gScrName);
 	strcat(szXMLFile, ".xml");
 
Index: sources/screensavers/PingPong/pingpong.vcproj
===================================================================
--- sources/screensavers/PingPong/pingpong.vcproj	(revision 33042)
+++ sources/screensavers/PingPong/pingpong.vcproj	(working copy)
@@ -19,7 +19,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;_XBOX"
 				MinimalRebuild="FALSE"
 				BasicRuntimeChecks="0"
@@ -72,7 +72,7 @@
 				Optimization="2"
 				FavorSizeOrSpeed="1"
 				OptimizeForProcessor="2"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/PlaneState/main.cpp
===================================================================
--- sources/screensavers/PlaneState/main.cpp	(revision 33042)
+++ sources/screensavers/PlaneState/main.cpp	(working copy)
@@ -110,7 +110,7 @@
 	SetDefaults();
 
 	char szXMLFile[1024];
-	strcpy(szXMLFile, "Q:\\screensavers\\");
+	strcpy(szXMLFile, "Q:\\system\\screensavers\\");
 	strcat(szXMLFile, gScrName);
 	strcat(szXMLFile, ".xml");
 
Index: sources/screensavers/PlaneState/planestate.vcproj
===================================================================
--- sources/screensavers/PlaneState/planestate.vcproj	(revision 33042)
+++ sources/screensavers/PlaneState/planestate.vcproj	(working copy)
@@ -19,7 +19,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;_XBOX"
 				MinimalRebuild="FALSE"
 				BasicRuntimeChecks="0"
@@ -72,7 +72,7 @@
 				Optimization="2"
 				FavorSizeOrSpeed="1"
 				OptimizeForProcessor="2"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/Pyro/Pyro.vcproj
===================================================================
--- sources/screensavers/Pyro/Pyro.vcproj	(revision 33042)
+++ sources/screensavers/Pyro/Pyro.vcproj	(working copy)
@@ -69,7 +69,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/ShadeWorm/ShadeWorm.vcproj
===================================================================
--- sources/screensavers/ShadeWorm/ShadeWorm.vcproj	(revision 33042)
+++ sources/screensavers/ShadeWorm/ShadeWorm.vcproj	(working copy)
@@ -69,7 +69,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;SCREENSAVERPLUGIN_EXPORTS;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/screensavers/Stars/Stars.cpp
===================================================================
--- sources/screensavers/Stars/Stars.cpp	(revision 33042)
+++ sources/screensavers/Stars/Stars.cpp	(working copy)
@@ -110,7 +110,7 @@
 	CXmlDocument doc;
 
 	char szXMLFile[1024];
-	strcpy(szXMLFile, "Q:\\screensavers\\");
+	strcpy(szXMLFile, "Q:\\system\\screensavers\\");
 	strcat(szXMLFile, g_Settings.szScrName);
 	strcat(szXMLFile, ".xml");
 
Index: sources/screensavers/Stars/Stars.vcproj
===================================================================
--- sources/screensavers/Stars/Stars.vcproj	(revision 33042)
+++ sources/screensavers/Stars/Stars.vcproj	(working copy)
@@ -69,7 +69,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;_XBOX"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="FALSE"
Index: sources/visualisations/Milkdrop
===================================================================
--- sources/visualisations/Milkdrop	(revision 33042)
+++ sources/visualisations/Milkdrop	(working copy)

Property changes on: sources/visualisations/Milkdrop
___________________________________________________________________
Added: svn:ignore
## -0,0 +1,2 ##
+Plugin.ncb
+Plugin.suo
Index: sources/visualisations/Milkdrop/MilkdropXBMC.cpp
===================================================================
--- sources/visualisations/Milkdrop/MilkdropXBMC.cpp	(revision 33042)
+++ sources/visualisations/Milkdrop/MilkdropXBMC.cpp	(working copy)
@@ -106,7 +106,7 @@
   int numPacks = 0;
   VisSetting setting10(VisSetting::SPIN, "Preset Pack");
   char searchFolder[255];
-  sprintf(searchFolder, "Q:\\visualisations\\%s\\*", g_packFolder);
+  sprintf(searchFolder, "Q:\\system\\visualisations\\%s\\*", g_packFolder);
 
   if( (hFile = _findfirst(searchFolder, &c_file )) != -1L )		// note: returns filename -without- path
   {
@@ -190,7 +190,7 @@
         if (len >= 4 && strcmpi(nodeStr + len - 4, ".zip") == 0)
         {
           // Zip file
-          strcpy(g_plugin->m_szPresetDir, "zip://q%3A%5Cvisualisations%5C"); 
+          strcpy(g_plugin->m_szPresetDir, "zip://q%3A%5Csystem%5Cvisualisations%5C"); 
           strcat(g_plugin->m_szPresetDir,  g_packFolder);
           strcat(g_plugin->m_szPresetDir,  "%5C");
           strcat(g_plugin->m_szPresetDir,  nodeStr);
@@ -199,7 +199,7 @@
         else if (len >= 4 && strcmpi(nodeStr + len - 4, ".rar") == 0)
         {
           // Rar file
-          strcpy(g_plugin->m_szPresetDir, "rar://q%3A%5Cvisualisations%5C"); 
+          strcpy(g_plugin->m_szPresetDir, "rar://q%3A%5Csystem%5Cvisualisations%5C"); 
           strcat(g_plugin->m_szPresetDir,  g_packFolder);
           strcat(g_plugin->m_szPresetDir,  "%5C");
           strcat(g_plugin->m_szPresetDir,  nodeStr);
@@ -208,7 +208,7 @@
         else        
 				{
 					// Normal folder
-					strcpy(g_plugin->m_szPresetDir,  "Q:\\visualisations\\");
+					strcpy(g_plugin->m_szPresetDir,  "Q:\\system\\visualisations\\");
           strcat(g_plugin->m_szPresetDir,  g_packFolder);
           strcat(g_plugin->m_szPresetDir,  "\\");
 					strcat(g_plugin->m_szPresetDir,  nodeStr);
@@ -489,7 +489,7 @@
     if (len >= 4 && strcmpi(setting.entry[setting.current] + len - 4, ".zip") == 0)
     {
       // Zip file
-      strcpy(g_plugin->m_szPresetDir, "zip://q%3A%5Cvisualisations%5C"); 
+      strcpy(g_plugin->m_szPresetDir, "zip://q%3A%5Csystem%5Cvisualisations%5C"); 
       strcat(g_plugin->m_szPresetDir,  g_packFolder);
       strcat(g_plugin->m_szPresetDir,  "%5C");
       strcat(g_plugin->m_szPresetDir,  setting.entry[setting.current]);
@@ -498,7 +498,7 @@
     else if (len >= 4 && strcmpi(setting.entry[setting.current] + len - 4, ".rar") == 0)
     {
       // Rar file
-      strcpy(g_plugin->m_szPresetDir, "rar://q%3A%5Cvisualisations%5C"); 
+      strcpy(g_plugin->m_szPresetDir, "rar://q%3A%5Csystem%5Cvisualisations%5C"); 
       strcat(g_plugin->m_szPresetDir,  g_packFolder);
       strcat(g_plugin->m_szPresetDir,  "%5C");
       strcat(g_plugin->m_szPresetDir,  setting.entry[setting.current]);
@@ -507,7 +507,7 @@
     else        
     {
       // Normal folder
-      strcpy(g_plugin->m_szPresetDir,  "Q:\\visualisations\\");
+      strcpy(g_plugin->m_szPresetDir,  "Q:\\system\\visualisations\\");
       strcat(g_plugin->m_szPresetDir,  g_packFolder);
       strcat(g_plugin->m_szPresetDir,  "\\");
       strcat(g_plugin->m_szPresetDir,  setting.entry[setting.current]);
Index: sources/visualisations/Milkdrop/Plugin.vcproj
===================================================================
--- sources/visualisations/Milkdrop/Plugin.vcproj	(revision 33042)
+++ sources/visualisations/Milkdrop/Plugin.vcproj	(working copy)
@@ -19,7 +19,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="&quot;C:\Program Files\Microsoft Xbox SDK\xbox\include&quot;"
+				AdditionalIncludeDirectories="&quot;C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include&quot;"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;PLUGIN_EXPORTS"
 				MinimalRebuild="TRUE"
 				BasicRuntimeChecks="3"
@@ -72,7 +72,7 @@
 				GlobalOptimizations="TRUE"
 				EnableIntrinsicFunctions="TRUE"
 				OptimizeForProcessor="2"
-				AdditionalIncludeDirectories="C:\Program Files\Microsoft Xbox SDK\xbox\include"
+				AdditionalIncludeDirectories="C:\Program Files (x86)\Microsoft Xbox SDK\xbox\include"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;PLUGIN_EXPORTS;"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="0"
Index: sources/visualisations/Milkdrop/vis_milkdrop/pluginshell.cpp
===================================================================
--- sources/visualisations/Milkdrop/vis_milkdrop/pluginshell.cpp	(revision 33042)
+++ sources/visualisations/Milkdrop/vis_milkdrop/pluginshell.cpp	(working copy)
@@ -1006,7 +1006,7 @@
 //        char *p = m_szPluginsDirPath + strlen(m_szPluginsDirPath);
 //        while (p >= m_szPluginsDirPath && *p != '\\') p--;
 //        if (++p >= m_szPluginsDirPath) *p = 0;
-		sprintf(m_szPluginsDirPath, "q:\\visualisations\\");
+		sprintf(m_szPluginsDirPath, "q:\\system\\visualisations\\");
 //		sprintf(m_szPluginsDirPath, "d:\\");
 	}    
     sprintf(m_szConfigIniFile, "%s%s", m_szPluginsDirPath, INIFILE);
Index: xbelogo
===================================================================
--- xbelogo	(revision 33042)
+++ xbelogo	(working copy)

Property changes on: xbelogo
___________________________________________________________________
Modified: svn:ignore
## -1,2 +1,6 ##
 *.h
-*.xbx
\ No newline at end of property
+*.xbx
+saveimage-updater.bmp
+saveimage-updater.rdf
+titleimage-updater.bmp
+titleimage-updater.rdf
Index: xbelogo/saveimage.bmp
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: xbelogo/titleimage.bmp
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: xbelogo/titleimage.psd
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: xbmc.vcproj
===================================================================
--- xbmc.vcproj	(revision 33042)
+++ xbmc.vcproj	(working copy)
@@ -58,6 +58,7 @@
 				Name="VCPreLinkEventTool"/>
 			<Tool
 				Name="XboxDeploymentTool"
+				ExcludedFromBuild="TRUE"
 				RemotePath="xe:\xbmc\xbmcd.xbe"
 				Progress="FALSE"/>
 			<Tool
@@ -69,7 +70,7 @@
 				FormatUD="TRUE"
 				NoLibWarn="TRUE"
 				NoPreload="LIBXBMS;LIBSMB;ISO9660;LIBHTTP;LIBMP4;LIBXDAAP;PLATINUM;LCODE"
-				TitleID="0xFACE008"
+				TitleID="0x9999991"
 				MediaTypes="0x80000007"
 				TitleName="XBMC Debug"/>
 		</Configuration>
@@ -132,7 +133,7 @@
 				InsertFile=".\media\dsstdfx.bin,dsstdfx,r"
 				NoLibWarn="TRUE"
 				NoPreload="LIBXBMS;LIBSMB;ISO9660;LIBHTTP;LIBMP4;LIBXDAAP;PLATINUM;LCODE"
-				TitleID="0xFACE008"
+				TitleID="0x9999991"
 				MediaTypes="0x80000007"
 				TitleName="XBMC Profile"/>
 		</Configuration>
@@ -196,7 +197,7 @@
 				InsertFile=".\media\dsstdfx.bin,dsstdfx,r"
 				NoLibWarn="TRUE"
 				NoPreload="LIBXBMS;LIBSMB;ISO9660;LIBHTTP;LIBMP4;LIBXDAAP;PLATINUM;LCODE"
-				TitleID="0xFACE008"
+				TitleID="0x9999991"
 				MediaTypes="0x80000007"
 				TitleName="XBMC Profile_FastCap"/>
 		</Configuration>
@@ -251,6 +252,7 @@
 				Name="VCPreLinkEventTool"/>
 			<Tool
 				Name="XboxDeploymentTool"
+				ExcludedFromBuild="TRUE"
 				RemotePath="xe:\xbmc\default.xbe"/>
 			<Tool
 				Name="XboxImageTool"
@@ -259,9 +261,9 @@
 				InsertFile=".\media\dsstdfx.bin,dsstdfx,r"
 				FormatUD="TRUE"
 				NoPreload="LIBXBMS;LIBSMB;ISO9660;LIBHTTP;LIBMP4;LIBXDAAP;PLATINUM;LCODE"
-				TitleID="0xFACE008"
+				TitleID="0x9999991"
 				MediaTypes="0x80000007"
-				TitleName="XBMC"
+				TitleName="XBMC-Emustation"
 				TitleImage="$(ProjectDir)xbelogo\titleimage.xbx"
 				SaveGameImage="$(ProjectDir)xbelogo\saveimage.xbx"/>
 		</Configuration>
@@ -313,7 +315,8 @@
 			<Tool
 				Name="VCPreLinkEventTool"/>
 			<Tool
-				Name="XboxDeploymentTool"/>
+				Name="XboxDeploymentTool"
+				ExcludedFromBuild="TRUE"/>
 			<Tool
 				Name="XboxImageTool"
 				FileName="$(TargetDir)default.xbe"
@@ -320,9 +323,9 @@
 				StackSize="0x80000"
 				InsertFile=".\media\dsstdfx.bin,dsstdfx,r"
 				NoPreload="LIBXBMS;LIBSMB;ISO9660;LIBHTTP;LIBMP4;LIBXDAAP;PLATINUM;LCODE"
-				TitleID="0xFACE008"
+				TitleID="0x9999991"
 				MediaTypes="0x80000007"
-				TitleName="XBMC"/>
+				TitleName="XBMC-Emustation"/>
 		</Configuration>
 		<Configuration
 			Name="Debug Xbox No Memory Tracking|Xbox"
@@ -379,9 +382,9 @@
 				InsertFile=".\media\dsstdfx.bin,dsstdfx,r"
 				NoLibWarn="TRUE"
 				NoPreload="LIBXBMS;LIBSMB;ISO9660;LIBHTTP;LIBMP4;LIBXDAAP;PLATINUM;LCODE"
-				TitleID="0xFACE008"
+				TitleID="0x9999991"
 				MediaTypes="0x80000007"
-				TitleName="XBMC"/>
+				TitleName="XBMC-Emustation"/>
 		</Configuration>
 	</Configurations>
 	<References>
Index: xbmc/AddonDatabase.cpp
===================================================================
--- xbmc/AddonDatabase.cpp	(revision 33042)
+++ xbmc/AddonDatabase.cpp	(working copy)
@@ -29,13 +29,13 @@
  */
 bool CAddonDatabase::HasAddon(const CStdString& addonID) {
   // Check if exists as full path.
-  // e.g. "special://home/scripts/XBMC Subtitles"
+  // e.g. "special://home/system/scripts/XBMC Subtitles"
   if (CDirectory::Exists(addonID)) {
     return true;
   }
 
   // Check if "script.NAME" exists.
-  // Allows for "script.xbmc.subtitles" -> "special://home/scripts/xbmc subtitles"
+  // Allows for "script.xbmc.subtitles" -> "special://home/system/scripts/xbmc subtitles"
   if (addonID.Left(7).Equals("script.")) {
     CStdString scriptName = addonID.Mid(7);
     scriptName.Replace(".", " ");
Index: xbmc/Application.cpp
===================================================================
--- xbmc/Application.cpp	(revision 33042)
+++ xbmc/Application.cpp	(working copy)
@@ -1,22 +1,22 @@
 /*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
 
 #include "system.h"
 #include "utils/log.h"
@@ -219,59 +219,59 @@
 #endif
 
 #if defined(_DEBUG) && !defined(USE_RELEASE_LIBS)
- #ifdef HAS_FILESYSTEM
-  #pragma comment (lib,"xbmc/lib/libXBMS/libXBMSd.lib")    // SECTIONNAME=LIBXBMS
-  #pragma comment (lib,"xbmc/lib/libsmb/libsmbd.lib")      // SECTIONNAME=LIBSMB
-  #pragma comment (lib,"xbmc/lib/libxdaap/libxdaapd.lib") // SECTIONNAME=LIBXDAAP
-  #pragma comment (lib,"xbmc/lib/libRTV/libRTVd.lib")    // SECTIONNAME=LIBRTV
- #endif
- #ifdef _XBOX
-  #pragma comment (lib,"xbmc/lib/libGoAhead/goaheadd.lib") // SECTIONNAME=LIBHTTP
-  #pragma comment (lib,"xbmc/lib/sqLite/libSQLite3d.lib")
-  #pragma comment (lib,"xbmc/lib/libshout/libshoutd.lib" )
-  #pragma comment (lib,"xbmc/lib/libcdio/libcdiod.lib" )
-  #pragma comment (lib,"xbmc/lib/libiconv/libiconvd.lib")
-  #pragma comment (lib,"xbmc/lib/libfribidi/libfribidid.lib")
-  #pragma comment (lib,"xbmc/lib/libpcre/libpcred.lib")
- #else
-  #pragma comment (lib,"../../xbmc/lib/libGoAhead/goahead_win32d.lib") // SECTIONNAME=LIBHTTP
-  #pragma comment (lib,"../../xbmc/lib/sqLite/libSQLite3_win32d.lib")
-  #pragma comment (lib,"../../xbmc/lib/libcdio/libcdio_win32d.lib" )
-  #pragma comment (lib,"../../xbmc/lib/libiconv/libiconvd.lib")
-  #pragma comment (lib,"../../xbmc/lib/libfribidi/libfribidid.lib")
-  #pragma comment (lib,"../../xbmc/lib/libpcre/libpcred.lib")
- #endif
- #ifdef HAS_MIKMOD
-  #pragma comment (lib,"xbmc/lib/mikxbox/mikxboxd.lib")  // SECTIONNAME=MOD_RW,MOD_RX
- #endif
+#ifdef HAS_FILESYSTEM
+#pragma comment (lib,"xbmc/lib/libXBMS/libXBMSd.lib")    // SECTIONNAME=LIBXBMS
+#pragma comment (lib,"xbmc/lib/libsmb/libsmbd.lib")      // SECTIONNAME=LIBSMB
+#pragma comment (lib,"xbmc/lib/libxdaap/libxdaapd.lib") // SECTIONNAME=LIBXDAAP
+#pragma comment (lib,"xbmc/lib/libRTV/libRTVd.lib")    // SECTIONNAME=LIBRTV
+#endif
+#ifdef _XBOX
+#pragma comment (lib,"xbmc/lib/libGoAhead/goaheadd.lib") // SECTIONNAME=LIBHTTP
+#pragma comment (lib,"xbmc/lib/sqLite/libSQLite3d.lib")
+#pragma comment (lib,"xbmc/lib/libshout/libshoutd.lib" )
+#pragma comment (lib,"xbmc/lib/libcdio/libcdiod.lib" )
+#pragma comment (lib,"xbmc/lib/libiconv/libiconvd.lib")
+#pragma comment (lib,"xbmc/lib/libfribidi/libfribidid.lib")
+#pragma comment (lib,"xbmc/lib/libpcre/libpcred.lib")
 #else
- #ifdef HAS_FILESYSTEM
-  #pragma comment (lib,"xbmc/lib/libXBMS/libXBMS.lib")
-  #pragma comment (lib,"xbmc/lib/libsmb/libsmb.lib")
-  #pragma comment (lib,"xbmc/lib/libxdaap/libxdaap.lib") // SECTIONNAME=LIBXDAAP
-  #pragma comment (lib,"xbmc/lib/libRTV/libRTV.lib")
- #endif
- #ifdef _XBOX
-  #pragma comment (lib,"xbmc/lib/libGoAhead/goahead.lib")
-  #pragma comment (lib,"xbmc/lib/sqLite/libSQLite3.lib")
-  #pragma comment (lib,"xbmc/lib/libcdio/libcdio.lib")
-  #pragma comment (lib,"xbmc/lib/libshout/libshout.lib")
-  #pragma comment (lib,"xbmc/lib/libiconv/libiconv.lib")
-  #pragma comment (lib,"xbmc/lib/libfribidi/libfribidi.lib")
-  #pragma comment (lib,"xbmc/lib/libpcre/libpcre.lib")
- #else
-  #pragma comment (lib,"../../xbmc/lib/libGoAhead/goahead_win32.lib")
-  #pragma comment (lib,"../../xbmc/lib/sqLite/libSQLite3_win32.lib")
-  #pragma comment (lib,"../../xbmc/lib/libshout/libshout_win32.lib" )
-  #pragma comment (lib,"../../xbmc/lib/libcdio/libcdio_win32.lib" )
-  #pragma comment (lib,"../../xbmc/lib/libiconv/libiconv.lib")
-  #pragma comment (lib,"../../xbmc/lib/libfribidi/libfribidi.lib")
-  #pragma comment (lib,"../../xbmc/lib/libpcre/libpcre.lib")
- #endif
- #ifdef HAS_MIKMOD
-  #pragma comment (lib,"xbmc/lib/mikxbox/mikxbox.lib")
- #endif
+#pragma comment (lib,"../../xbmc/lib/libGoAhead/goahead_win32d.lib") // SECTIONNAME=LIBHTTP
+#pragma comment (lib,"../../xbmc/lib/sqLite/libSQLite3_win32d.lib")
+#pragma comment (lib,"../../xbmc/lib/libcdio/libcdio_win32d.lib" )
+#pragma comment (lib,"../../xbmc/lib/libiconv/libiconvd.lib")
+#pragma comment (lib,"../../xbmc/lib/libfribidi/libfribidid.lib")
+#pragma comment (lib,"../../xbmc/lib/libpcre/libpcred.lib")
 #endif
+#ifdef HAS_MIKMOD
+#pragma comment (lib,"xbmc/lib/mikxbox/mikxboxd.lib")  // SECTIONNAME=MOD_RW,MOD_RX
+#endif
+#else
+#ifdef HAS_FILESYSTEM
+#pragma comment (lib,"xbmc/lib/libXBMS/libXBMS.lib")
+#pragma comment (lib,"xbmc/lib/libsmb/libsmb.lib")
+#pragma comment (lib,"xbmc/lib/libxdaap/libxdaap.lib") // SECTIONNAME=LIBXDAAP
+#pragma comment (lib,"xbmc/lib/libRTV/libRTV.lib")
+#endif
+#ifdef _XBOX
+#pragma comment (lib,"xbmc/lib/libGoAhead/goahead.lib")
+#pragma comment (lib,"xbmc/lib/sqLite/libSQLite3.lib")
+#pragma comment (lib,"xbmc/lib/libcdio/libcdio.lib")
+#pragma comment (lib,"xbmc/lib/libshout/libshout.lib")
+#pragma comment (lib,"xbmc/lib/libiconv/libiconv.lib")
+#pragma comment (lib,"xbmc/lib/libfribidi/libfribidi.lib")
+#pragma comment (lib,"xbmc/lib/libpcre/libpcre.lib")
+#else
+#pragma comment (lib,"../../xbmc/lib/libGoAhead/goahead_win32.lib")
+#pragma comment (lib,"../../xbmc/lib/sqLite/libSQLite3_win32.lib")
+#pragma comment (lib,"../../xbmc/lib/libshout/libshout_win32.lib" )
+#pragma comment (lib,"../../xbmc/lib/libcdio/libcdio_win32.lib" )
+#pragma comment (lib,"../../xbmc/lib/libiconv/libiconv.lib")
+#pragma comment (lib,"../../xbmc/lib/libfribidi/libfribidi.lib")
+#pragma comment (lib,"../../xbmc/lib/libpcre/libpcre.lib")
+#endif
+#ifdef HAS_MIKMOD
+#pragma comment (lib,"xbmc/lib/mikxbox/mikxbox.lib")
+#endif
+#endif
 
 #define MAX_FFWD_SPEED 5
 
@@ -281,13 +281,13 @@
 static void WaitCallback(DWORD flags)
 {
 #ifndef PROFILE
-  /* if cpu is far ahead of gpu, sleep instead of yield */
-  if( flags & D3DWAIT_PRESENT )
-    while(D3DDevice::GetPushDistance(D3DDISTANCE_FENCES_TOWAIT) > 0)
-      Sleep(1);
-  else if( flags & (D3DWAIT_OBJECTLOCK | D3DWAIT_BLOCKONFENCE | D3DWAIT_BLOCKUNTILIDLE) )
-    while(D3DDevice::GetPushDistance(D3DDISTANCE_FENCES_TOWAIT) > 1)
-      Sleep(1);
+	/* if cpu is far ahead of gpu, sleep instead of yield */
+	if( flags & D3DWAIT_PRESENT )
+	while(D3DDevice::GetPushDistance(D3DDISTANCE_FENCES_TOWAIT) > 0)
+	Sleep(1);
+	else if( flags & (D3DWAIT_OBJECTLOCK | D3DWAIT_BLOCKONFENCE | D3DWAIT_BLOCKUNTILIDLE) )
+	while(D3DDevice::GetPushDistance(D3DDISTANCE_FENCES_TOWAIT) > 1)
+	Sleep(1);
 #endif
 }
 #endif
@@ -295,41 +295,41 @@
 //extern IDirectSoundRenderer* m_pAudioDecoder;
 CApplication::CApplication(void) : m_ctrDpad(220, 220), m_itemCurrentFile(new CFileItem), m_progressTrackingItem(new CFileItem)
 {
-  m_iPlaySpeed = 1;
-  m_bSpinDown = false;
-  m_bNetworkSpinDown = false;
-  m_dwSpinDownTime = timeGetTime();
-  m_pWebServer = NULL;
-  m_pXbmcHttp = NULL;
-  m_prevMedia="";
-  m_pFileZilla = NULL;
-  m_pPlayer = NULL;
+	m_iPlaySpeed = 1;
+	m_bSpinDown = false;
+	m_bNetworkSpinDown = false;
+	m_dwSpinDownTime = timeGetTime();
+	m_pWebServer = NULL;
+	m_pXbmcHttp = NULL;
+	m_prevMedia="";
+	m_pFileZilla = NULL;
+	m_pPlayer = NULL;
 #ifdef HAS_XBOX_HARDWARE
-  XSetProcessQuantumLength(5); //default=20msec
-  XSetFileCacheSize (256*1024); //default=64kb
+	XSetProcessQuantumLength(20); //default=20msec
+	XSetFileCacheSize (256*1000); //default=64kb
 #endif
-  m_bScreenSave = false;   // CB: SCREENSAVER PATCH
-  m_iScreenSaveLock = 0;
-  m_skinReloadTime = 0;
-  m_bInitializing = true;
-  m_eForcedNextPlayer = EPC_NONE;
-  m_strPlayListFile = "";
-  m_nextPlaylistItem = -1;
-  m_bPlaybackStarting = false;
+	m_bScreenSave = false;   // CB: SCREENSAVER PATCH
+	m_iScreenSaveLock = 0;
+	m_skinReloadTime = 0;
+	m_bInitializing = true;
+	m_eForcedNextPlayer = EPC_NONE;
+	m_strPlayListFile = "";
+	m_nextPlaylistItem = -1;
+	m_bPlaybackStarting = false;
 
-  //true while we in IsPaused mode! Workaround for OnPaused, which must be add. after v2.0
-  m_bIsPaused = false;
+	//true while we in IsPaused mode! Workaround for OnPaused, which must be add. after v2.0
+	m_bIsPaused = false;
 
-  /* for now always keep this around */
+	/* for now always keep this around */
 #ifdef HAS_KARAOKE
-  m_pCdgParser = new CCdgParser();
+	m_pCdgParser = new CCdgParser();
 #endif
-  m_currentStack = new CFileItemList;
+	m_currentStack = new CFileItemList;
 }
 
 CApplication::~CApplication(void)
 {
-  delete m_currentStack;
+	delete m_currentStack;
 }
 
 // text out routine for below
@@ -336,27 +336,27 @@
 #ifdef HAS_XFONT
 static void __cdecl FEH_TextOut(XFONT* pFont, int iLine, const wchar_t* fmt, ...)
 {
-  wchar_t buf[100];
-  va_list args;
-  va_start(args, fmt);
-  _vsnwprintf(buf, 100, fmt, args);
-  va_end(args);
+	wchar_t buf[100];
+	va_list args;
+	va_start(args, fmt);
+	_vsnwprintf(buf, 100, fmt, args);
+	va_end(args);
 
-  if (!(iLine & 0x8000))
-    CLog::Log(LOGFATAL, "%S", buf);
+	if (!(iLine & 0x8000))
+	CLog::Log(LOGFATAL, "%S", buf);
 
-  bool Center = (iLine & 0x10000) > 0;
-  pFont->SetTextAlignment(Center ? XFONT_TOP | XFONT_CENTER : XFONT_TOP | XFONT_LEFT);
+	bool Center = (iLine & 0x10000) > 0;
+	pFont->SetTextAlignment(Center ? XFONT_TOP | XFONT_CENTER : XFONT_TOP | XFONT_LEFT);
 
-  iLine &= 0x7fff;
+	iLine &= 0x7fff;
 
-  for (int i = 0; i < 2; i++)
-  {
-    D3DRECT rc = { 0, 50 + 25 * iLine, 720, 50 + 25 * (iLine + 1) };
-    D3DDevice::Clear(1, &rc, D3DCLEAR_TARGET, 0, 0, 0);
-    pFont->TextOut(g_application.m_pBackBuffer, buf, -1, Center ? 360 : 80, 50 + 25*iLine);
-    D3DDevice::Present(0, 0, 0, 0);
-  }
+	for (int i = 0; i < 2; i++)
+	{
+		D3DRECT rc = { 0, 50 + 25 * iLine, 720, 50 + 25 * (iLine + 1) };
+		D3DDevice::Clear(1, &rc, D3DCLEAR_TARGET, 0, 0, 0);
+		pFont->TextOut(g_application.m_pBackBuffer, buf, -1, Center ? 360 : 80, 50 + 25*iLine);
+		D3DDevice::Present(0, 0, 0, 0);
+	}
 }
 #else
 static void __cdecl FEH_TextOut(void* pFont, int iLine, const wchar_t* fmt, ...) {}
@@ -366,343 +366,359 @@
 
 void CApplication::InitBasicD3D()
 {
-  bool bPal = g_videoConfig.HasPAL();
-  CLog::Log(LOGINFO, "Init display in default mode: %s", bPal ? "PAL" : "NTSC");
-  // init D3D with defaults (NTSC or PAL standard res)
-  m_d3dpp.BackBufferWidth = 720;
-  m_d3dpp.BackBufferHeight = bPal ? 576 : 480;
-  m_d3dpp.BackBufferFormat = D3DFMT_LIN_X8R8G8B8;
-  m_d3dpp.BackBufferCount = 1;
-  m_d3dpp.EnableAutoDepthStencil = FALSE;
-  m_d3dpp.SwapEffect = D3DSWAPEFFECT_COPY;
+	bool bPal = g_videoConfig.HasPAL();
+	CLog::Log(LOGINFO, "Init display in default mode: %s", bPal ? "PAL" : "NTSC");
+	// init D3D with defaults (NTSC or PAL standard res)
+	m_d3dpp.BackBufferWidth = 720;
+	m_d3dpp.BackBufferHeight = bPal ? 576 : 480;
+	m_d3dpp.BackBufferFormat = D3DFMT_LIN_X8R8G8B8;
+	m_d3dpp.BackBufferCount = 1;
+	m_d3dpp.EnableAutoDepthStencil = FALSE;
+	m_d3dpp.SwapEffect = D3DSWAPEFFECT_COPY;
 #ifdef HAS_XBOX_D3D
-  m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
+	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
 #else
-  m_d3dpp.FullScreen_PresentationInterval = 0;
-  m_d3dpp.Windowed = TRUE;
-  m_d3dpp.hDeviceWindow = g_hWnd;
+	m_d3dpp.FullScreen_PresentationInterval = 0;
+	m_d3dpp.Windowed = TRUE;
+	m_d3dpp.hDeviceWindow = g_hWnd;
 #endif
 
-  if (!(m_pD3D = Direct3DCreate8(D3D_SDK_VERSION)))
-  {
-    CLog::Log(LOGFATAL, "FATAL ERROR: Unable to create Direct3D!");
-    Sleep(INFINITE); // die
-  }
+	if (!(m_pD3D = Direct3DCreate8(D3D_SDK_VERSION)))
+	{
+		CLog::Log(LOGFATAL, "FATAL ERROR: Unable to create Direct3D!");
+		Sleep(INFINITE); // die
+	}
 
-  // Check if we have the required modes available
-  g_videoConfig.GetModes(m_pD3D);
-  if (!g_graphicsContext.IsValidResolution(g_guiSettings.m_LookAndFeelResolution))
-  {
-    // Oh uh - doesn't look good for starting in their wanted screenmode
-    CLog::Log(LOGERROR, "The screen resolution requested is not valid, resetting to a valid mode");
-    g_guiSettings.m_LookAndFeelResolution = g_videoConfig.GetSafeMode();
-    CLog::Log(LOGERROR, "Resetting to mode %s", g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].strMode);
-    CLog::Log(LOGERROR, "Done reset");
-  }
+	// Check if we have the required modes available
+	g_videoConfig.GetModes(m_pD3D);
+	if (!g_graphicsContext.IsValidResolution(g_guiSettings.m_LookAndFeelResolution))
+	{
+		// Oh uh - doesn't look good for starting in their wanted screenmode
+		CLog::Log(LOGERROR, "The screen resolution requested is not valid, resetting to a valid mode");
+		g_guiSettings.m_LookAndFeelResolution = g_videoConfig.GetSafeMode();
+		CLog::Log(LOGERROR, "Resetting to mode %s", g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].strMode);
+		CLog::Log(LOGERROR, "Done reset");
+	}
 
-  // Transfer the resolution information to our graphics context
-  g_graphicsContext.SetD3DParameters(&m_d3dpp);
-  g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE);
+	// Transfer the resolution information to our graphics context
+	g_graphicsContext.SetD3DParameters(&m_d3dpp);
+	g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE);
 
-  // Create the device
+	// Create the device
 #ifdef HAS_XBOX_D3D
-  // Xbox MUST use HAL / Hardware Vertex Processing!
-  if (m_pD3D->CreateDevice(0, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &m_d3dpp, &m_pd3dDevice) != S_OK)
-  {
-    CLog::Log(LOGFATAL, "FATAL ERROR: Unable to create D3D Device!");
-    Sleep(INFINITE); // die
-  }
-  m_pd3dDevice->GetBackBuffer(0, 0, &m_pBackBuffer);
+	// Xbox MUST use HAL / Hardware Vertex Processing!
+	if (m_pD3D->CreateDevice(0, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &m_d3dpp, &m_pd3dDevice) != S_OK)
+	{
+		CLog::Log(LOGFATAL, "FATAL ERROR: Unable to create D3D Device!");
+		Sleep(INFINITE); // die
+	}
+	m_pd3dDevice->GetBackBuffer(0, 0, &m_pBackBuffer);
 #else
-  if (m_pD3D->CreateDevice(0, D3DDEVTYPE_REF, NULL, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &m_d3dpp, &m_pd3dDevice) != S_OK)
-  {
-    CLog::Log(LOGFATAL, "FATAL ERROR: Unable to create D3D Device!");
-    Sleep(INFINITE); // die
-  }
+	if (m_pD3D->CreateDevice(0, D3DDEVTYPE_REF, NULL, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &m_d3dpp, &m_pd3dDevice) != S_OK)
+	{
+		CLog::Log(LOGFATAL, "FATAL ERROR: Unable to create D3D Device!");
+		Sleep(INFINITE); // die
+	}
 #endif
 
-  if (m_splash)
-  {
-    m_splash->Stop();
-  }
+	if (m_splash)
+	{
+		m_splash->Stop();
+	}
 
-  m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
-  m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
+	m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
+	m_pd3dDevice->Present( NULL, NULL, NULL, NULL );  
 }
 
 // This function does not return!
 void CApplication::FatalErrorHandler(bool InitD3D, bool MapDrives, bool InitNetwork)
 {
-  // XBMC couldn't start for some reason...
-  // g_LoadErrorStr should contain the reason
-  CLog::Log(LOGWARNING, "Emergency recovery console starting...");
+	// XBMC couldn't start for some reason...
+	// g_LoadErrorStr should contain the reason
+	CLog::Log(LOGWARNING, "Emergency recovery console starting...");
 
-  bool HaveGamepad = true; // should always have the gamepad when we get here
-  if (InitD3D)
-    InitBasicD3D();
+	bool HaveGamepad = true; // should always have the gamepad when we get here
+	if (InitD3D)
+	InitBasicD3D();
 
-  if (m_splash)
-  {
-    m_splash->Stop();
-  }
+	if (m_splash)
+	{
+		m_splash->Stop();
+	}
 
-  m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
-  m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
+	m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
+	m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
 
-  // D3D is up, load default font
+	// D3D is up, load default font
 #ifdef HAS_XFONT
-  XFONT* pFont;
-  if (XFONT_OpenDefaultFont(&pFont) != S_OK)
-  {
-    CLog::Log(LOGFATAL, "FATAL ERROR: Unable to open default font!");
-    Sleep(INFINITE); // die
-  }
+	XFONT* pFont;
+	if (XFONT_OpenDefaultFont(&pFont) != S_OK)
+	{
+		CLog::Log(LOGFATAL, "FATAL ERROR: Unable to open default font!");
+		Sleep(INFINITE); // die
+	}
 
-  // defaults for text
-  pFont->SetBkMode(XFONT_OPAQUE);
-  pFont->SetBkColor(D3DCOLOR_XRGB(0, 0, 0));
-  pFont->SetTextColor(D3DCOLOR_XRGB(0xff, 0x20, 0x20));
+	// defaults for text
+	pFont->SetBkMode(XFONT_OPAQUE);
+	pFont->SetBkColor(D3DCOLOR_XRGB(0, 0, 0));
+	if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE])
+	{
+		pFont->SetTextColor(D3DCOLOR_XRGB(0xff, 0xff, 0x33));
+	}
+	else
+	{
+		pFont->SetTextColor(D3DCOLOR_XRGB(0xff, 0x20, 0x20));
+	}
 #else
-  void *pFont = NULL;
+	void *pFont = NULL;
 #endif
-  int iLine = 0;
-  FEH_TextOut(pFont, iLine++, L"XBMC Fatal Error:");
-  char buf[500];
-  strncpy(buf, g_LoadErrorStr.c_str(), 500);
-  buf[499] = 0;
-  char* pNewline = strtok(buf, "\n");
-  while (pNewline)
-  {
-    FEH_TextOut(pFont, iLine++, L"%S", pNewline);
-    pNewline = strtok(NULL, "\n");
-  }
-  ++iLine;
+	int iLine = 0;
+	if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE])
+	{
+		FEH_TextOut(pFont, iLine++, L"Forced XBMC Recover Menu:");
+	}
+	else
+	{
+		FEH_TextOut(pFont, iLine++, L"XBMC Fatal Error:");
+	}
+	char buf[500];
+	strncpy(buf, g_LoadErrorStr.c_str(), 500);
+	buf[499] = 0;
+	char* pNewline = strtok(buf, "\n");
+	while (pNewline)
+	{
+		FEH_TextOut(pFont, iLine++, L"%S", pNewline);
+		pNewline = strtok(NULL, "\n");
+	}
+	++iLine;
 
 #ifdef HAS_XBOX_HARDWARE
-  if (MapDrives)
-  {
-    // map in default drives
-    CIoSupport::RemapDriveLetter('C',"Harddisk0\\Partition2");
-    CIoSupport::RemapDriveLetter('D',"Cdrom0");
-    CIoSupport::RemapDriveLetter('E',"Harddisk0\\Partition1");
+	if (MapDrives)
+	{
+		// map in default drives
+		CIoSupport::RemapDriveLetter('C',"Harddisk0\\Partition2");
+		CIoSupport::RemapDriveLetter('D',"Cdrom0");
+		CIoSupport::RemapDriveLetter('E',"Harddisk0\\Partition1");
 
-    //Add. also Drive F/G
-    if (CIoSupport::PartitionExists(6)) 
-      CIoSupport::RemapDriveLetter('F',"Harddisk0\\Partition6");
-    if (CIoSupport::PartitionExists(7))
-      CIoSupport::RemapDriveLetter('G',"Harddisk0\\Partition7");
-  }
+		//Add. also Drive F/G
+		if (CIoSupport::PartitionExists(6)) 
+		CIoSupport::RemapDriveLetter('F',"Harddisk0\\Partition6");
+		if (CIoSupport::PartitionExists(7))
+		CIoSupport::RemapDriveLetter('G',"Harddisk0\\Partition7");
+	}
 #endif
-  bool Pal = g_graphicsContext.GetVideoResolution() == PAL_4x3;
+	bool Pal = g_graphicsContext.GetVideoResolution() == PAL_4x3;
 
-  if (HaveGamepad)
-    FEH_TextOut(pFont, (Pal ? 16 : 12) | 0x18000, L"Press any button to reboot");
+	if (HaveGamepad)
+	FEH_TextOut(pFont, (Pal ? 16 : 12) | 0x18000, L"Press any button to reboot");
 
-  bool NetworkUp = false;
+	bool NetworkUp = false;
 
-  // Boot up the network for FTP
-  if (InitNetwork)
-  {
-    std::vector<int> netorder;
-    if (m_bXboxMediacenterLoaded)
-    {
-      if (g_guiSettings.GetInt("network.assignment") == NETWORK_DHCP)
-      {
-        netorder.push_back(NETWORK_DHCP);
-        netorder.push_back(NETWORK_STATIC);
-      }
-      else if (g_guiSettings.GetInt("network.assignment") == NETWORK_STATIC)
-      {
-        netorder.push_back(NETWORK_STATIC);
-        netorder.push_back(NETWORK_DHCP);
-      }
-      else
-      {
-        netorder.push_back(NETWORK_DASH);
-        netorder.push_back(NETWORK_DHCP);
-        netorder.push_back(NETWORK_STATIC);
-      }
-    }
-    else
-    {
-      netorder.push_back(NETWORK_DASH);
-      netorder.push_back(NETWORK_DHCP);
-      netorder.push_back(NETWORK_STATIC);
-    }
+	// Boot up the network for FTP
+	if (InitNetwork)
+	{
+		std::vector<int> netorder;
+		if (m_bXboxMediacenterLoaded)
+		{
+			if (g_guiSettings.GetInt("network.assignment") == NETWORK_DHCP)
+			{
+				netorder.push_back(NETWORK_DHCP);
+				netorder.push_back(NETWORK_STATIC);
+			}
+			else if (g_guiSettings.GetInt("network.assignment") == NETWORK_STATIC)
+			{
+				netorder.push_back(NETWORK_STATIC);
+				netorder.push_back(NETWORK_DHCP);
+			}
+			else
+			{
+				netorder.push_back(NETWORK_DASH);
+				netorder.push_back(NETWORK_DHCP);
+				netorder.push_back(NETWORK_STATIC);
+			}
+		}
+		else
+		{
+			netorder.push_back(NETWORK_DASH);
+			netorder.push_back(NETWORK_DHCP);
+			netorder.push_back(NETWORK_STATIC);
+		}
 
-    while(1)
-    {
-      std::vector<int>::iterator it;
-      for( it = netorder.begin();it != netorder.end(); it++)
-      {
-        m_network.Deinitialize();
+		while(1)
+		{
+			std::vector<int>::iterator it;
+			for( it = netorder.begin();it != netorder.end(); it++)
+			{
+				m_network.Deinitialize();
 
 #ifdef HAS_XBOX_NETWORK
-        if (!m_network.IsEthernetConnected())
-        {
-          FEH_TextOut(pFont, iLine, L"Network cable unplugged");
-          break;
-        }
+				if (!m_network.IsEthernetConnected())
+				{
+					FEH_TextOut(pFont, iLine, L"Network cable unplugged");
+					break;
+				}
 #endif
-        switch( (*it) )
-        {
-          case NETWORK_DASH:
-            FEH_TextOut(pFont, iLine, L"Init network using dash settings...");
-            m_network.Initialize(NETWORK_DASH, "","","","");
-            break;
-          case NETWORK_DHCP:
-            FEH_TextOut(pFont, iLine, L"Init network using DHCP...");
-            m_network.Initialize(NETWORK_DHCP, "","","","");
-            break;
-          default:
-            FEH_TextOut(pFont, iLine, L"Init network using static ip...");
-            if( m_bXboxMediacenterLoaded )
-            {
-              m_network.Initialize(NETWORK_STATIC,
-                    g_guiSettings.GetString("network.ipaddress").c_str(),
-                    g_guiSettings.GetString("network.subnet").c_str(),
-                    g_guiSettings.GetString("network.gateway").c_str(),
-                    g_guiSettings.GetString("network.dns").c_str() );
-            }
-            else
-            {
-              m_network.Initialize(NETWORK_STATIC,
-                    "192.168.0.42",
-                    "255.255.255.0",
-                    "192.168.0.1",
-                    "192.168.0.1" );
-            }
-            break;
-        }
+				switch( (*it) )
+				{
+				case NETWORK_DASH:
+					FEH_TextOut(pFont, iLine, L"Init network using dash settings...");
+					m_network.Initialize(NETWORK_DASH, "","","","","");
+					break;
+				case NETWORK_DHCP:
+					FEH_TextOut(pFont, iLine, L"Init network using DHCP...");
+					m_network.Initialize(NETWORK_DHCP, "","","","","");
+					break;
+				default:
+					FEH_TextOut(pFont, iLine, L"Init network using static ip...");
+					if( m_bXboxMediacenterLoaded )
+					{
+						m_network.Initialize(NETWORK_STATIC,
+						g_guiSettings.GetString("network.ipaddress").c_str(),
+						g_guiSettings.GetString("network.subnet").c_str(),
+						g_guiSettings.GetString("network.gateway").c_str(),
+						g_guiSettings.GetString("network.dns").c_str(),
+						g_guiSettings.GetString("network.dns2").c_str() );
+					}
+					else
+					{
+						m_network.Initialize(NETWORK_STATIC,
+						"192.168.0.42",
+						"255.255.255.0",
+						"192.168.0.1",
+						"192.168.0.1",
+						"0.0.0.0" );
+					}
+					break;
+				}
 
 #ifdef HAS_XBOX_NETWORK
-        DWORD dwState = XNET_GET_XNADDR_PENDING;
+				DWORD dwState = XNET_GET_XNADDR_PENDING;
 
-        while (dwState == XNET_GET_XNADDR_PENDING)
-        {
-          dwState = m_network.UpdateState();
+				while (dwState == XNET_GET_XNADDR_PENDING)
+				{
+					dwState = m_network.UpdateState();
 
-          if (HaveGamepad && AnyButtonDown())
-            m_applicationMessenger.Restart();
+					if (HaveGamepad && AnyButtonDown())
+					m_applicationMessenger.Restart();
 
-          Sleep(50);
-        }
+					Sleep(50);
+				}
 
-        if ((dwState & XNET_GET_XNADDR_DHCP || dwState & XNET_GET_XNADDR_STATIC) && !(dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT))
-        {
-          /* yay, we got network */
-          NetworkUp = true;
-          break;
-        }
+				if ((dwState & XNET_GET_XNADDR_DHCP || dwState & XNET_GET_XNADDR_STATIC) && !(dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT))
+				{
+					/* yay, we got network */
+					NetworkUp = true;
+					break;
+				}
 #endif
-        /* increment line before next attempt */
-        ++iLine;
-      }
+				/* increment line before next attempt */
+				++iLine;
+			}
 
-      /* break out of the continous loop if we have network*/
-      if( NetworkUp )
-        break;
-      else
-      {
-        int n = 10;
-        while (n)
-        {
-          FEH_TextOut(pFont, (iLine + 1) | 0x8000, L"Unable to init network, retrying in %d seconds", n--);
-          for (int i = 0; i < 20; ++i)
-          {
-            Sleep(50);
+			/* break out of the continous loop if we have network*/
+			if( NetworkUp )
+			break;
+			else
+			{
+				int n = 10;
+				while (n)
+				{
+					FEH_TextOut(pFont, (iLine + 1) | 0x8000, L"Unable to init network, retrying in %d seconds", n--);
+					for (int i = 0; i < 20; ++i)
+					{
+						Sleep(50);
 
-            if (HaveGamepad && AnyButtonDown())
-              m_applicationMessenger.Restart();
-          }
-        }
-      }
-    }
-  }
+						if (HaveGamepad && AnyButtonDown())
+						m_applicationMessenger.Restart();
+					}
+				}
+			}
+		}
+	}
 
-  if( NetworkUp )
-  {
-    FEH_TextOut(pFont, iLine++, L"IP Address: %S", m_network.m_networkinfo.ip);
-    ++iLine;
-  }
+	if( NetworkUp )
+	{
+		FEH_TextOut(pFont, iLine++, L"IP Address: %S", m_network.m_networkinfo.ip);
+		++iLine;
+	}
 
-  if (NetworkUp)
-  {
+	if (NetworkUp)
+	{
 #ifdef HAS_FTP_SERVER
-    if (!m_pFileZilla)
-    {
-      // Start FTP with default settings
-      FEH_TextOut(pFont, iLine++, L"Starting FTP server...");
-      StartFtpEmergencyRecoveryMode();
-    }
+		if (!m_pFileZilla)
+		{
+			// Start FTP with default settings
+			FEH_TextOut(pFont, iLine++, L"Starting FTP server...");
+			StartFtpEmergencyRecoveryMode();
+		}
 
-    FEH_TextOut(pFont, iLine++, L"FTP server running on port %d, login: xbox/xbox", m_pFileZilla->mSettings.GetServerPort());
+		FEH_TextOut(pFont, iLine++, L"FTP server running on port %d, login: xbox/xbox", m_pFileZilla->mSettings.GetServerPort());
 #endif
-    ++iLine;
-  }
+		++iLine;
+	}
 
-  if (HaveGamepad)
-  {
-    for (;;)
-    {
-      Sleep(50);
-      if (AnyButtonDown())
-      {
-        g_application.Stop();
-        Sleep(200);
+	if (HaveGamepad)
+	{
+		for (;;)
+		{
+			Sleep(50);
+			if (AnyButtonDown())
+			{
+				g_application.Stop();
+				Sleep(200);
 #ifdef _XBOX
 #ifndef _DEBUG  // don't actually shut off if debug build, it hangs VS for a long time
-        XKUtils::XBOXPowerCycle();
+				XKUtils::XBOXPowerCycle();
 #endif
 #else
-        SendMessage(g_hWnd, WM_CLOSE, 0, 0);
+				SendMessage(g_hWnd, WM_CLOSE, 0, 0);
 #endif
-      }
-    }
-  }
-  else
-  {
+			}
+		}
+	}
+	else
+	{
 #ifdef _XBOX
-    Sleep(INFINITE);
+		Sleep(INFINITE);
 #else
-    SendMessage(g_hWnd, WM_CLOSE, 0, 0);
+		SendMessage(g_hWnd, WM_CLOSE, 0, 0);
 #endif
-  }
+	}
 }
 
 LONG WINAPI CApplication::UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
 {
-  PCSTR pExceptionString = "Unknown exception code";
+	PCSTR pExceptionString = "Unknown exception code";
 
 #define STRINGIFY_EXCEPTION(code) case code: pExceptionString = #code; break
 
-  switch (ExceptionInfo->ExceptionRecord->ExceptionCode)
-  {
-    STRINGIFY_EXCEPTION(EXCEPTION_ACCESS_VIOLATION);
-    STRINGIFY_EXCEPTION(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
-    STRINGIFY_EXCEPTION(EXCEPTION_BREAKPOINT);
-    STRINGIFY_EXCEPTION(EXCEPTION_FLT_DENORMAL_OPERAND);
-    STRINGIFY_EXCEPTION(EXCEPTION_FLT_DIVIDE_BY_ZERO);
-    STRINGIFY_EXCEPTION(EXCEPTION_FLT_INEXACT_RESULT);
-    STRINGIFY_EXCEPTION(EXCEPTION_FLT_INVALID_OPERATION);
-    STRINGIFY_EXCEPTION(EXCEPTION_FLT_OVERFLOW);
-    STRINGIFY_EXCEPTION(EXCEPTION_FLT_STACK_CHECK);
-    STRINGIFY_EXCEPTION(EXCEPTION_ILLEGAL_INSTRUCTION);
-    STRINGIFY_EXCEPTION(EXCEPTION_INT_DIVIDE_BY_ZERO);
-    STRINGIFY_EXCEPTION(EXCEPTION_INT_OVERFLOW);
-    STRINGIFY_EXCEPTION(EXCEPTION_INVALID_DISPOSITION);
-    STRINGIFY_EXCEPTION(EXCEPTION_NONCONTINUABLE_EXCEPTION);
-    STRINGIFY_EXCEPTION(EXCEPTION_SINGLE_STEP);
-  }
+	switch (ExceptionInfo->ExceptionRecord->ExceptionCode)
+	{
+		STRINGIFY_EXCEPTION(EXCEPTION_ACCESS_VIOLATION);
+		STRINGIFY_EXCEPTION(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);
+		STRINGIFY_EXCEPTION(EXCEPTION_BREAKPOINT);
+		STRINGIFY_EXCEPTION(EXCEPTION_FLT_DENORMAL_OPERAND);
+		STRINGIFY_EXCEPTION(EXCEPTION_FLT_DIVIDE_BY_ZERO);
+		STRINGIFY_EXCEPTION(EXCEPTION_FLT_INEXACT_RESULT);
+		STRINGIFY_EXCEPTION(EXCEPTION_FLT_INVALID_OPERATION);
+		STRINGIFY_EXCEPTION(EXCEPTION_FLT_OVERFLOW);
+		STRINGIFY_EXCEPTION(EXCEPTION_FLT_STACK_CHECK);
+		STRINGIFY_EXCEPTION(EXCEPTION_ILLEGAL_INSTRUCTION);
+		STRINGIFY_EXCEPTION(EXCEPTION_INT_DIVIDE_BY_ZERO);
+		STRINGIFY_EXCEPTION(EXCEPTION_INT_OVERFLOW);
+		STRINGIFY_EXCEPTION(EXCEPTION_INVALID_DISPOSITION);
+		STRINGIFY_EXCEPTION(EXCEPTION_NONCONTINUABLE_EXCEPTION);
+		STRINGIFY_EXCEPTION(EXCEPTION_SINGLE_STEP);
+	}
 #undef STRINGIFY_EXCEPTION
 
-  g_LoadErrorStr.Format("%s (0x%08x)\n at 0x%08x",
-                        pExceptionString, ExceptionInfo->ExceptionRecord->ExceptionCode,
-                        ExceptionInfo->ExceptionRecord->ExceptionAddress);
+	g_LoadErrorStr.Format("%s (0x%08x)\n at 0x%08x",
+	pExceptionString, ExceptionInfo->ExceptionRecord->ExceptionCode,
+	ExceptionInfo->ExceptionRecord->ExceptionAddress);
 
-  CLog::Log(LOGFATAL, "%s", g_LoadErrorStr.c_str());
+	CLog::Log(LOGFATAL, "%s", g_LoadErrorStr.c_str());
 
-  return ExceptionInfo->ExceptionRecord->ExceptionCode;
+	return ExceptionInfo->ExceptionRecord->ExceptionCode;
 }
 
 #ifdef _XBOX
@@ -716,798 +732,905 @@
 {
 
 #ifdef HAS_XBOX_HARDWARE
-  // better 128mb ram support
-  // set MTRRDefType memory type to write-back as done in other XBox apps - seems a bit of a hack as really the def type
-  // should be uncachable and the mtrr/mask for ram instead set up for 128MB with writeback as is done in cromwell.
-  m_128MBHack = false;
-  MEMORYSTATUS status;
-  GlobalMemoryStatus( &status );
-  // if we have more than 64MB free
-  if( status.dwTotalPhys > 67108864 )
-  {
-    __asm
-    {
-      mov ecx, 0x2ff
-      rdmsr
-      mov al, 0x06
-      wrmsr
-    }
-    m_128MBHack = true;
-  }
+	// better 128mb ram support
+	// set MTRRDefType memory type to write-back as done in other XBox apps - seems a bit of a hack as really the def type
+	// should be uncachable and the mtrr/mask for ram instead set up for 128MB with writeback as is done in cromwell.
+	m_128MBHack = false;
+	MEMORYSTATUS status;
+	GlobalMemoryStatus( &status );
+	// if we have more than 64MB free
+	if( status.dwTotalPhys > 67108864 )
+	{
+		__asm
+		{
+			mov ecx, 0x2ff
+			rdmsr
+			mov al, 0x06
+			wrmsr
+		}
+		m_128MBHack = true;
+	}
 #endif
 
 #ifdef _DEBUG
-  g_advancedSettings.m_logLevel     = LOG_LEVEL_DEBUG;
-  g_advancedSettings.m_logLevelHint = LOG_LEVEL_DEBUG;
+	g_advancedSettings.m_logLevel     = LOG_LEVEL_DEBUG;
+	g_advancedSettings.m_logLevelHint = LOG_LEVEL_DEBUG;
 #else
-  g_advancedSettings.m_logLevel     = LOG_LEVEL_NORMAL;
-  g_advancedSettings.m_logLevelHint = LOG_LEVEL_NORMAL;
+	g_advancedSettings.m_logLevel     = LOG_LEVEL_NORMAL;
+	g_advancedSettings.m_logLevelHint = LOG_LEVEL_NORMAL;
 #endif
-  CLog::SetLogLevel(g_advancedSettings.m_logLevel);
+	CLog::SetLogLevel(g_advancedSettings.m_logLevel);
 
-  g_guiSettings.Initialize();  // Initialize default Settings
-  g_settings.Initialize(); //Initialize default AdvancedSettings
+	g_guiSettings.Initialize();  // Initialize default Settings
+	g_settings.Initialize(); //Initialize default AdvancedSettings
 
-  g_hWnd = hWnd;
+	g_hWnd = hWnd;
 
-  HRESULT hr;
-  //grab a handle to our thread to be used later in identifying the render thread
-  m_threadID = GetCurrentThreadId();
+	HRESULT hr;
+	//grab a handle to our thread to be used later in identifying the render thread
+	m_threadID = GetCurrentThreadId();
 
-  //floating point precision to 24 bits (faster performance)
-  _controlfp(_PC_24, _MCW_PC);
+	//floating point precision to 24 bits (faster performance)
+	_controlfp(_PC_24, _MCW_PC);
 
-  init_emu_environ();
+	init_emu_environ();
 
-  /* install win32 exception translator, win32 exceptions
-   * can now be caught using c++ try catch */
-  win32_exception::install_handler();
+	/* install win32 exception translator, win32 exceptions
+* can now be caught using c++ try catch */
+	win32_exception::install_handler();
 
-  CStdString strExecutablePath;
-  char szDevicePath[MAX_PATH];
+	CStdString strExecutablePath;
+	char szDevicePath[MAX_PATH];
 
-  // map Q to home drive of xbe to load the config file
-  CUtil::GetHomePath(strExecutablePath);
-  CIoSupport::GetPartition(strExecutablePath.c_str()[0], szDevicePath);
-  strcat(szDevicePath, &strExecutablePath.c_str()[2]);
-  CIoSupport::RemapDriveLetter('Q', szDevicePath);
- 
-  // Do all the special:// & driveletter mapping & setup profiles
-  InitDirectoriesXbox();
-  
-  CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
-  CLog::Log(LOGNOTICE, "Starting XBMC4Xbox %s (SVN:%s, compiler %i). Built on %s ", VERSION_STRING, SVN_REV, _MSC_VER, __DATE__);
-  CSpecialProtocol::LogPaths();
+	// map Q to home drive of xbe to load the config file
+	CUtil::GetHomePath(strExecutablePath);
+	CIoSupport::GetPartition(strExecutablePath.c_str()[0], szDevicePath);
+	strcat(szDevicePath, &strExecutablePath.c_str()[2]);
+	CIoSupport::RemapDriveLetter('Q', szDevicePath);
 
-  char szXBEFileName[1024];
-  CIoSupport::GetXbePath(szXBEFileName);
-  CLog::Log(LOGNOTICE, "The executable running is: %s", szXBEFileName);
-  CLog::Log(LOGNOTICE, "Log File is located: %sxbmc.log", g_settings.m_logFolder.c_str());
-  CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
+	// Do all the special:// & driveletter mapping & setup profiles
+	InitDirectoriesXbox();
 
-  // if we are running from DVD our UserData location will be TDATA
-  if (URIUtils::IsDVD(strExecutablePath))
-  {
-    // TODO: Should we copy over any UserData folder from the DVD?
-    if (!CFile::Exists("special://masterprofile/guisettings.xml")) // first run - cache userdata folder
-    {
-      CFileItemList items;
-      CUtil::GetRecursiveListing("special://xbmc/userdata",items,"");
-      for (int i=0;i<items.Size();++i)
-          CFile::Cache(items[i]->GetPath(),"special://masterprofile/"+URIUtils::GetFileName(items[i]->GetPath()));
-    }
-    g_settings.m_logFolder = "special://masterprofile/";
-  }
-  else
-  {
-    CStdString strMnt = _P(g_settings.GetUserDataFolder());
-    if (strMnt.Left(2).Equals("Q:"))
-    {
-      CUtil::GetHomePath(strMnt);
-      strMnt += _P(g_settings.GetUserDataFolder()).substr(2);
-    }
+	CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
+	CLog::Log(LOGNOTICE, "Starting XBMC4Xbox %s (SVN:%s, compiler %i). Built on %s ", VERSION_STRING, SVN_REV, _MSC_VER, __DATE__);
+	CSpecialProtocol::LogPaths();
 
-    CIoSupport::GetPartition(strMnt.c_str()[0], szDevicePath);
-    strcat(szDevicePath, &strMnt.c_str()[2]);
-    CIoSupport::RemapDriveLetter('T', szDevicePath);
-  }
+	char szXBEFileName[1024];
+	CIoSupport::GetXbePath(szXBEFileName);
+	CLog::Log(LOGNOTICE, "The executable running is: %s", szXBEFileName);
+	CLog::Log(LOGNOTICE, "Log File is located: %sxbmc.log", g_settings.m_logFolder.c_str());
+	CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
 
-  if (m_128MBHack)
-    CLog::Log(LOGNOTICE, "128MB hack enabled");
+	// if we are running from DVD our UserData location will be TDATA
+	if (URIUtils::IsDVD(strExecutablePath))
+	{
+		// TODO: Should we copy over any UserData folder from the DVD?
+		if (!CFile::Exists("special://masterprofile/guisettings.xml")) // first run - cache userdata folder
+		{
+			CFileItemList items;
+			CUtil::GetRecursiveListing("special://xbmc/userdata",items,"");
+			for (int i=0;i<items.Size();++i)
+			CFile::Cache(items[i]->GetPath(),"special://masterprofile/"+URIUtils::GetFileName(items[i]->GetPath()));
+		}
+		g_settings.m_logFolder = "special://masterprofile/";
+	}
+	else
+	{
+		CStdString strMnt = _P(g_settings.GetUserDataFolder());
+		if (strMnt.Left(2).Equals("Q:"))
+		{
+			CUtil::GetHomePath(strMnt);
+			strMnt += _P(g_settings.GetUserDataFolder()).substr(2);
+		}
 
-  CLog::Log(LOGNOTICE, "Setup DirectX");
-  // Create the Direct3D object
-  if ( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
-  {
-    CLog::Log(LOGFATAL, "XBAppEx: Unable to create Direct3D!" );
-    return E_FAIL;
-  }
+		CIoSupport::GetPartition(strMnt.c_str()[0], szDevicePath);
+		strcat(szDevicePath, &strMnt.c_str()[2]);
+		CIoSupport::RemapDriveLetter('T', szDevicePath);
+	}
 
-  //list available videomodes
-  g_videoConfig.GetModes(m_pD3D);
-  //init the present parameters with values that are supported
-  RESOLUTION initialResolution = g_videoConfig.GetInitialMode(m_pD3D, &m_d3dpp);
-  // Transfer the resolution information to our graphics context
-  g_graphicsContext.SetD3DParameters(&m_d3dpp);
-  g_graphicsContext.SetVideoResolution(initialResolution, TRUE);
+	if (m_128MBHack)
+	CLog::Log(LOGNOTICE, "128MB hack enabled");
 
-  // Initialize core peripheral port support. Note: If these parameters
-  // are 0 and NULL, respectively, then the default number and types of
-  // controllers will be initialized.
+	CLog::Log(LOGNOTICE, "Setup DirectX");
+	// Create the Direct3D object
+	if ( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
+	{
+		CLog::Log(LOGFATAL, "XBAppEx: Unable to create Direct3D!" );
+		return E_FAIL;
+	}
+
+	//list available videomodes
+	g_videoConfig.GetModes(m_pD3D);
+	//init the present parameters with values that are supported
+	RESOLUTION initialResolution = g_videoConfig.GetInitialMode(m_pD3D, &m_d3dpp);
+	// Transfer the resolution information to our graphics context
+	g_graphicsContext.SetD3DParameters(&m_d3dpp);
+	g_graphicsContext.SetVideoResolution(initialResolution, TRUE);
+
+	// Initialize core peripheral port support. Note: If these parameters
+	// are 0 and NULL, respectively, then the default number and types of
+	// controllers will be initialized.
 #ifdef HAS_XBOX_HARDWARE
-  XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );
+	XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );
 
-  // Create the gamepad devices
-  if ( FAILED(hr = XBInput_CreateGamepads(&m_Gamepad)) )
-  {
-    CLog::Log(LOGERROR, "XBAppEx: Call to CreateGamepads() failed!" );
-    return hr;
-  }
+	// Create the gamepad devices
+	if ( FAILED(hr = XBInput_CreateGamepads(&m_Gamepad)) )
+	{
+		CLog::Log(LOGERROR, "XBAppEx: Call to CreateGamepads() failed!" );
+		return hr;
+	}
 
-  if ( FAILED(hr = XBInput_CreateIR_Remotes()) )
-  {
-    CLog::Log(LOGERROR, "XBAppEx: Call to CreateIRRemotes() failed!" );
-    return hr;
-  }
+	if ( FAILED(hr = XBInput_CreateIR_Remotes()) )
+	{
+		CLog::Log(LOGERROR, "XBAppEx: Call to CreateIRRemotes() failed!" );
+		return hr;
+	}
 #endif
 
-  // Create the Mouse and Keyboard devices
-  g_Mouse.Initialize(&hWnd);
-  g_Keyboard.Initialize(hWnd);
+	// Create the Mouse and Keyboard devices
+	g_Mouse.Initialize(&hWnd);
+	g_Keyboard.Initialize(hWnd);
 
 #ifdef HAS_XBOX_HARDWARE
-  // Wait for controller polling to finish. in an elegant way, instead of a Sleep(1000)
-  while (XGetDeviceEnumerationStatus() == XDEVICE_ENUMERATION_BUSY)
-  {
-    ReadInput();
-  }
-  Sleep(10); // needed or the readinput doesnt fetch anything
-  ReadInput();
+	// Wait for controller polling to finish. in an elegant way, instead of a Sleep(1000)
+	while (XGetDeviceEnumerationStatus() == XDEVICE_ENUMERATION_BUSY)
+	{
+		ReadInput();
+	}
+	Sleep(10); // needed or the readinput doesnt fetch anything
+	ReadInput();
 #endif
 #ifdef HAS_GAMEPAD
-  //Check for LTHUMBCLICK+RTHUMBCLICK and BLACK+WHITE, no LTRIGGER+RTRIGGER
-  if (((m_DefaultGamepad.wButtons & (XINPUT_GAMEPAD_LEFT_THUMB + XINPUT_GAMEPAD_RIGHT_THUMB)) && !(m_DefaultGamepad.wButtons & (KEY_BUTTON_LEFT_TRIGGER+KEY_BUTTON_RIGHT_TRIGGER))) ||
-      ((m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE]) && !(m_DefaultGamepad.wButtons & KEY_BUTTON_LEFT_TRIGGER+KEY_BUTTON_RIGHT_TRIGGER)))
-  {
-    CLog::Log(LOGINFO, "Key combination detected for userdata deletion (LTHUMB+RTHUMB or BLACK+WHITE)");
-    InitBasicD3D();
-    // D3D is up, load default font
-    XFONT* pFont;
-    if (XFONT_OpenDefaultFont(&pFont) != S_OK)
-    {
-      CLog::Log(LOGFATAL, "FATAL ERROR: Unable to open default font!");
-      Sleep(INFINITE); // die
-    }
-    // defaults for text
-    pFont->SetBkMode(XFONT_OPAQUE);
-    pFont->SetBkColor(D3DCOLOR_XRGB(0, 0, 0));
-    pFont->SetTextColor(D3DCOLOR_XRGB(0xff, 0x20, 0x20));
-    int iLine = 0;
-    FEH_TextOut(pFont, iLine++, L"Key combination for userdata deletion detected!");
-    FEH_TextOut(pFont, iLine++, L"Are you sure you want to proceed?");
-    iLine++;
-    FEH_TextOut(pFont, iLine++, L"A for yes, any other key for no");
-    bool bAnyAnalogKey = false;
-    while (m_DefaultGamepad.wPressedButtons != XBGAMEPAD_NONE) // wait for user to let go of lclick + rclick
-    {
-      ReadInput();
-    }
-    while (m_DefaultGamepad.wPressedButtons == XBGAMEPAD_NONE && !bAnyAnalogKey)
-    {
-      ReadInput();
-      bAnyAnalogKey = m_DefaultGamepad.bPressedAnalogButtons[0] || m_DefaultGamepad.bPressedAnalogButtons[1] || m_DefaultGamepad.bPressedAnalogButtons[2] || m_DefaultGamepad.bPressedAnalogButtons[3] || m_DefaultGamepad.bPressedAnalogButtons[4] || m_DefaultGamepad.bPressedAnalogButtons[5] || m_DefaultGamepad.bPressedAnalogButtons[6] || m_DefaultGamepad.bPressedAnalogButtons[7];
-    }
-    if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
-    {
-      CUtil::DeleteGUISettings();
-      CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"database\\"));
-      CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"thumbnails\\"));
-      CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"playlists\\"));
-      CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"cache\\"));
-      CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"profiles\\"));
-      CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"visualisations\\"));
-      CFile::Delete(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"avpacksettings.xml"));
-      g_settings.DeleteAllProfiles();
+	//Check for LTHUMBCLICK+RTHUMBCLICK and BLACK+WHITE, no LTRIGGER+RTRIGGER
+	if (((m_DefaultGamepad.wButtons & (XINPUT_GAMEPAD_LEFT_THUMB + XINPUT_GAMEPAD_RIGHT_THUMB)) && !(m_DefaultGamepad.wButtons & (KEY_BUTTON_LEFT_TRIGGER+KEY_BUTTON_RIGHT_TRIGGER))) ||
+			((m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE]) && !(m_DefaultGamepad.wButtons & KEY_BUTTON_LEFT_TRIGGER+KEY_BUTTON_RIGHT_TRIGGER)))
+	{
+		CLog::Log(LOGINFO, "Key combination detected for userdata deletion (LTHUMB+RTHUMB or BLACK+WHITE)");
+		InitBasicD3D();
+		// D3D is up, load default font
+		XFONT* pFont;
+		if (XFONT_OpenDefaultFont(&pFont) != S_OK)
+		{
+			CLog::Log(LOGFATAL, "FATAL ERROR: Unable to open default font!");
+			Sleep(INFINITE); // die
+		}
+		// defaults for text
+		pFont->SetBkMode(XFONT_OPAQUE);
+		pFont->SetBkColor(D3DCOLOR_XRGB(0, 0, 0));
+		pFont->SetTextColor(D3DCOLOR_XRGB(0xff, 0x20, 0x20));
+		int iLine = 0;
+		FEH_TextOut(pFont, iLine++, L"Key combination for userdata deletion detected!");
+		FEH_TextOut(pFont, iLine++, L"Are you sure you want to proceed?");
+		iLine++;
+		FEH_TextOut(pFont, iLine++, L"A for yes, any other key for no");
+		bool bAnyAnalogKey = false;
+		while (m_DefaultGamepad.wPressedButtons != XBGAMEPAD_NONE) // wait for user to let go of lclick + rclick
+		{
+			ReadInput();
+		}
+		while (m_DefaultGamepad.wPressedButtons == XBGAMEPAD_NONE && !bAnyAnalogKey)
+		{
+			ReadInput();
+			bAnyAnalogKey = m_DefaultGamepad.bPressedAnalogButtons[0] || m_DefaultGamepad.bPressedAnalogButtons[1] || m_DefaultGamepad.bPressedAnalogButtons[2] || m_DefaultGamepad.bPressedAnalogButtons[3] || m_DefaultGamepad.bPressedAnalogButtons[4] || m_DefaultGamepad.bPressedAnalogButtons[5] || m_DefaultGamepad.bPressedAnalogButtons[6] || m_DefaultGamepad.bPressedAnalogButtons[7];
+		}
+		if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
+		{
+			CUtil::DeleteGUISettings();
+			CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"database\\"));
+			CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"thumbnails\\"));
+			CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"playlists\\"));
+			CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"cache\\"));
+			CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"profiles\\"));
+			CUtil::WipeDir(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"visualisations\\"));
+			CFile::Delete(URIUtils::AddFileToFolder(g_settings.GetUserDataFolder(),"avpacksettings.xml"));
+			g_settings.DeleteAllProfiles();
 
-      g_settings.SaveProfiles(PROFILES_FILE);
+			g_settings.SaveProfiles(PROFILES_FILE);
 
-      char szXBEFileName[1024];
+			char szXBEFileName[1024];
 
-      CIoSupport::GetXbePath(szXBEFileName);
-      CUtil::RunXBE(szXBEFileName);
-    }
-    m_pd3dDevice->Release();
-  }
+			CIoSupport::GetXbePath(szXBEFileName);
+			CUtil::RunXBE(szXBEFileName);
+		}
+		m_pd3dDevice->Release();
+	}
 #endif
 
-  CIoSupport::RemapDriveLetter('C', "Harddisk0\\Partition2");
-  CIoSupport::RemapDriveLetter('E', "Harddisk0\\Partition1");
+	CIoSupport::RemapDriveLetter('C', "Harddisk0\\Partition2");
+	CIoSupport::RemapDriveLetter('E', "Harddisk0\\Partition1");
 
-  CIoSupport::Dismount("Cdrom0");
-  CIoSupport::RemapDriveLetter('D', "Cdrom0");
+	CIoSupport::Dismount("Cdrom0");
+	CIoSupport::RemapDriveLetter('D', "Cdrom0");
 
-  // Attempt to read the LBA48 v3 patch partition table, if kernel supports the command and it exists.
-  CIoSupport::ReadPartitionTable();
-  if (CIoSupport::HasPartitionTable())
-  {
-    // Mount up to Partition15 if they are available.
-    for (int i=EXTEND_PARTITION_BEGIN; i <= (EXTEND_PARTITION_BEGIN+EXTEND_PARTITIONS_LIMIT-1); i++)
-    {
-      char szDevice[32];
-      if (CIoSupport::PartitionExists(i))
-      {
-        char cDriveLetter = 'A' + i - 1;
-        
-        char extendDriveLetter = CIoSupport::GetExtendedPartitionDriveLetter(cDriveLetter-EXTEND_DRIVE_BEGIN);
-        CLog::Log(LOGNOTICE, "  map extended drive %c:", extendDriveLetter);
-		
-        sprintf(szDevice, "Harddisk0\\Partition%u", i);
+	// Attempt to read the LBA48 v3 patch partition table, if kernel supports the command and it exists.
+	CIoSupport::ReadPartitionTable();
+	if (CIoSupport::HasPartitionTable())
+	{
+		// Mount up to Partition15 if they are available.
+		for (int i=EXTEND_PARTITION_BEGIN; i <= (EXTEND_PARTITION_BEGIN+EXTEND_PARTITIONS_LIMIT-1); i++)
+		{
+			char szDevice[32];
+			if (CIoSupport::PartitionExists(i))
+			{
+				char cDriveLetter = 'A' + i - 1;
+				
+				char extendDriveLetter = CIoSupport::GetExtendedPartitionDriveLetter(cDriveLetter-EXTEND_DRIVE_BEGIN);
+				CLog::Log(LOGNOTICE, "  map extended drive %c:", extendDriveLetter);
+				
+				sprintf(szDevice, "Harddisk0\\Partition%u", i);
 
-        CIoSupport::RemapDriveLetter(extendDriveLetter, szDevice);
-      }
-    }
-  }
-  else
-  {
-    if (CIoSupport::DriveExists('F'))
-      CIoSupport::RemapDriveLetter('F', "Harddisk0\\Partition6");
-    if (CIoSupport::DriveExists('G'))
-      CIoSupport::RemapDriveLetter('G', "Harddisk0\\Partition7");
-  }
+				CIoSupport::RemapDriveLetter(extendDriveLetter, szDevice);
+			}
+		}
+	}
+	else
+	{
+		if (CIoSupport::DriveExists('F'))
+		CIoSupport::RemapDriveLetter('F', "Harddisk0\\Partition6");
+		if (CIoSupport::DriveExists('G'))
+		CIoSupport::RemapDriveLetter('G', "Harddisk0\\Partition7");
+	}
 
-  CIoSupport::RemapDriveLetter('X',"Harddisk0\\Partition3");
-  CIoSupport::RemapDriveLetter('Y',"Harddisk0\\Partition4");
+	CIoSupport::RemapDriveLetter('X',"Harddisk0\\Partition3");
+	CIoSupport::RemapDriveLetter('Y',"Harddisk0\\Partition4");
 #ifdef HAS_XBOX_HARDWARE
-  CIoSupport::RemapDriveLetter('Z',"Harddisk0\\Partition5");
+	CIoSupport::RemapDriveLetter('Z',"Harddisk0\\Partition5");
 #endif
 
-  CLog::Log(LOGINFO, "Drives are mapped");
+	CLog::Log(LOGINFO, "Drives are mapped");
 
-  CLog::Log(LOGNOTICE, "load settings...");
-  g_LoadErrorStr = "Unable to load settings";
-  
-  m_bAllSettingsLoaded = g_settings.Load(m_bXboxMediacenterLoaded, m_bSettingsLoaded);
-  if (!m_bAllSettingsLoaded)
-    FatalErrorHandler(true, true, true);
+	CLog::Log(LOGNOTICE, "load settings...");
+	g_LoadErrorStr = "Unable to load settings";
 
-  update_emu_environ();//apply the GUI settings
+	m_bAllSettingsLoaded = g_settings.Load(m_bXboxMediacenterLoaded, m_bSettingsLoaded);
+	if (!m_bAllSettingsLoaded)
+	FatalErrorHandler(true, true, true);
 
-  // Check for WHITE + Y for forced Error Handler (to recover if something screwy happens)
+	update_emu_environ();//apply the GUI settings
+
+	// Check for WHITE + Y for forced Error Handler (to recover if something screwy happens)
 #ifdef HAS_GAMEPAD
-  if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE])
-  {
-    g_LoadErrorStr = "Key code detected for Error Recovery mode";
-    FatalErrorHandler(true, true, true);
-  }
+	if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE])
+	{
+		g_LoadErrorStr = "Key code detected for Forced XBMC Recover Menu";
+		FatalErrorHandler(true, true, true);
+	}
 #endif
 
-  //Check for X+Y - if pressed, set debug log mode and mplayer debuging on
-  CheckForDebugButtonCombo();
+	//Check for X+Y - if pressed, set debug log mode and mplayer debuging on
+	CheckForDebugButtonCombo();	
 
 #ifdef HAS_XBOX_HARDWARE
-  bool bNeedReboot = false;
-  char temp[1024];
-  CIoSupport::GetXbePath(temp);
-  char temp2[1024];
-  char temp3;
-  temp3 = temp[0];
-  CIoSupport::GetPartition(temp3,temp2);
-  CStdString strTemp(temp+2);
-  int iLastSlash = strTemp.rfind('\\');
-  strcat(temp2,strTemp.substr(0,iLastSlash).c_str());
-  F_VIDEO ForceVideo = VIDEO_NULL;
-  F_COUNTRY ForceCountry = COUNTRY_NULL;
+	bool bNeedReboot = false;
+	char temp[1024];
+	CIoSupport::GetXbePath(temp);
+	char temp2[1024];
+	char temp3;
+	temp3 = temp[0];
+	CIoSupport::GetPartition(temp3,temp2);
+	CStdString strTemp(temp+2);
+	int iLastSlash = strTemp.rfind('\\');
+	strcat(temp2,strTemp.substr(0,iLastSlash).c_str());
+	F_VIDEO ForceVideo = VIDEO_NULL;
+	F_COUNTRY ForceCountry = COUNTRY_NULL;
 
-  if (CUtil::RemoveTrainer())
-    bNeedReboot = true;
+	if (CUtil::RemoveTrainer())
+	bNeedReboot = true;
 
-// now check if we are switching video modes. if, are we in the wrong mode according to eeprom?
-  if (g_guiSettings.GetBool("myprograms.gameautoregion"))
-  {
-    bool fDoPatchTest = false;
+	// now check if we are switching video modes. if, are we in the wrong mode according to eeprom?
+	if (g_guiSettings.GetBool("myprograms.gameautoregion"))
+	{
+		bool fDoPatchTest = false;
 
-    // should use xkeeprom.h :/
-    EEPROMDATA EEPROM;
-    ZeroMemory(&EEPROM, sizeof(EEPROMDATA));
+		// should use xkeeprom.h :/
+		EEPROMDATA EEPROM;
+		ZeroMemory(&EEPROM, sizeof(EEPROMDATA));
 
-    if( XKUtils::ReadEEPROMFromXBOX((LPBYTE)&EEPROM))
-    {
-      DWORD DWVideo = *(LPDWORD)(&EEPROM.VideoStandard[0]);
-      char temp[1024];
-      CIoSupport::GetXbePath(temp);
-      char temp2[1024];
-      char temp3;
-      temp3 = temp[0];
-      CIoSupport::GetPartition(temp3,temp2);
-      CStdString strTemp(temp+2);
-      int iLastSlash = strTemp.rfind('\\');
-      strcat(temp2,strTemp.substr(0,iLastSlash).c_str());
+		if( XKUtils::ReadEEPROMFromXBOX((LPBYTE)&EEPROM))
+		{
+			DWORD DWVideo = *(LPDWORD)(&EEPROM.VideoStandard[0]);
+			char temp[1024];
+			CIoSupport::GetXbePath(temp);
+			char temp2[1024];
+			char temp3;
+			temp3 = temp[0];
+			CIoSupport::GetPartition(temp3,temp2);
+			CStdString strTemp(temp+2);
+			int iLastSlash = strTemp.rfind('\\');
+			strcat(temp2,strTemp.substr(0,iLastSlash).c_str());
 
-      if ((DWVideo == XKEEPROM::VIDEO_STANDARD::NTSC_M) && ((XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) || (XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_J) || initialResolution > 5))
-      {
-        CLog::Log(LOGINFO, "Rebooting to change resolution from %s back to NTSC_M", (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) ? "PAL" : "NTSC_J");
-        ForceVideo = VIDEO_NTSCM;
-        ForceCountry = COUNTRY_USA;
-        bNeedReboot = true;
-        fDoPatchTest = true;
-      }
-      else if ((DWVideo == XKEEPROM::VIDEO_STANDARD::PAL_I) && ((XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_M) || (XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_J) || initialResolution < 6))
-      {
-        CLog::Log(LOGINFO, "Rebooting to change resolution from %s back to PAL_I", (XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_M) ? "NTSC_M" : "NTSC_J");
-        ForceVideo = VIDEO_PAL50;
-        ForceCountry = COUNTRY_EUR;
-        bNeedReboot = true;
-        fDoPatchTest = true;
-      }
-      else if ((DWVideo == XKEEPROM::VIDEO_STANDARD::NTSC_J) && ((XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_M) || (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) || initialResolution > 5))
-      {
-        CLog::Log(LOGINFO, "Rebooting to change resolution from %s back to NTSC_J", (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) ? "PAL" : "NTSC_M");
-        ForceVideo = VIDEO_NTSCJ;
-        ForceCountry = COUNTRY_JAP;
-        bNeedReboot = true;
-        fDoPatchTest = true;
-      }
-      else
-        CUtil::RemoveKernelPatch(); // This removes the Resolution patch from the kernel if it is not needed (if actual resolution matches eeprom setting)
+			if ((DWVideo == XKEEPROM::VIDEO_STANDARD::NTSC_M) && ((XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) || (XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_J) || initialResolution > 5))
+			{
+				CLog::Log(LOGINFO, "Rebooting to change resolution from %s back to NTSC_M", (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) ? "PAL" : "NTSC_J");
+				ForceVideo = VIDEO_NTSCM;
+				ForceCountry = COUNTRY_USA;
+				bNeedReboot = true;
+				fDoPatchTest = true;
+			}
+			else if ((DWVideo == XKEEPROM::VIDEO_STANDARD::PAL_I) && ((XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_M) || (XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_J) || initialResolution < 6))
+			{
+				CLog::Log(LOGINFO, "Rebooting to change resolution from %s back to PAL_I", (XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_M) ? "NTSC_M" : "NTSC_J");
+				ForceVideo = VIDEO_PAL50;
+				ForceCountry = COUNTRY_EUR;
+				bNeedReboot = true;
+				fDoPatchTest = true;
+			}
+			else if ((DWVideo == XKEEPROM::VIDEO_STANDARD::NTSC_J) && ((XGetVideoStandard() == XC_VIDEO_STANDARD_NTSC_M) || (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) || initialResolution > 5))
+			{
+				CLog::Log(LOGINFO, "Rebooting to change resolution from %s back to NTSC_J", (XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I) ? "PAL" : "NTSC_M");
+				ForceVideo = VIDEO_NTSCJ;
+				ForceCountry = COUNTRY_JAP;
+				bNeedReboot = true;
+				fDoPatchTest = true;
+			}
+			else
+			CUtil::RemoveKernelPatch(); // This removes the Resolution patch from the kernel if it is not needed (if actual resolution matches eeprom setting)
 
-      if (fDoPatchTest) // Is set if we have to test whether our patch is in the kernel & therefore responsible for the mismatch of resolution & eeprom setting
-      {
-        if (!CUtil::LookForKernelPatch()) // If our patch is not present we are not responsible for the mismatch of current resolution & eeprom setting
-        {
-          // We do a hard reset to come back to default resolution and avoid infinite reboots
-          CLog::Log(LOGINFO, "No infinite reboot loop...");
-          m_applicationMessenger.Reset();
-        }
-      }
-    }
-  }
+			if (fDoPatchTest) // Is set if we have to test whether our patch is in the kernel & therefore responsible for the mismatch of resolution & eeprom setting
+			{
+				if (!CUtil::LookForKernelPatch()) // If our patch is not present we are not responsible for the mismatch of current resolution & eeprom setting
+				{
+					// We do a hard reset to come back to default resolution and avoid infinite reboots
+					CLog::Log(LOGINFO, "No infinite reboot loop...");
+					m_applicationMessenger.Reset();
+				}
+			}
+		}
+	}
 
-  if (bNeedReboot)
-  {
-    Destroy();
-    CUtil::LaunchXbe(temp2,("D:\\"+strTemp.substr(iLastSlash+1)).c_str(),NULL,ForceVideo,ForceCountry);
-  }
+	if (bNeedReboot)
+	{
+		Destroy();
+		CUtil::LaunchXbe(temp2,("D:\\"+strTemp.substr(iLastSlash+1)).c_str(),NULL,ForceVideo,ForceCountry);
+	}
 #endif
 
-  // initialize our charset converter
-  g_charsetConverter.reset();
+	// initialize our charset converter
+	g_charsetConverter.reset();
 
-  // Load the langinfo to have user charset <-> utf-8 conversion
-  CStdString strLanguage = g_guiSettings.GetString("locale.language");
-  strLanguage[0] = toupper(strLanguage[0]);
+	// Load the langinfo to have user charset <-> utf-8 conversion
+	CStdString strLanguage = g_guiSettings.GetString("locale.language");
+	strLanguage[0] = toupper(strLanguage[0]);
 
-  // Load the langinfo to have user charset <-> utf-8 conversion
-  CStdString strLangInfoPath;
-  strLangInfoPath.Format("special://xbmc/language/%s/langinfo.xml", strLanguage.c_str());
+	// Load the langinfo to have user charset <-> utf-8 conversion
+	CStdString strLangInfoPath;
+	strLangInfoPath.Format("special://xbmc/system/language/%s/langinfo.xml", strLanguage.c_str());
 
-  CLog::Log(LOGINFO, "load language info file:%s", strLangInfoPath.c_str());
-  g_langInfo.Load(strLangInfoPath);
+	CLog::Log(LOGINFO, "load language info file:%s", strLangInfoPath.c_str());
+	g_langInfo.Load(strLangInfoPath);
 
-  CStdString strKeyboardLayoutConfigurationPath;
-  strKeyboardLayoutConfigurationPath.Format("Q:\\language\\%s\\keyboardmap.xml", g_guiSettings.GetString("locale.language"));
-  CLog::Log(LOGINFO, "load keyboard layout configuration info file: %s", strKeyboardLayoutConfigurationPath.c_str());
-  g_keyboardLayoutConfiguration.Load(strKeyboardLayoutConfigurationPath);
+	CStdString strKeyboardLayoutConfigurationPath;
+	strKeyboardLayoutConfigurationPath.Format("Q:\\system\\language\\%s\\keyboardmap.xml", g_guiSettings.GetString("locale.language"));
+	CLog::Log(LOGINFO, "load keyboard layout configuration info file: %s", strKeyboardLayoutConfigurationPath.c_str());
+	g_keyboardLayoutConfiguration.Load(strKeyboardLayoutConfigurationPath);
 
-  CStdString strLanguagePath = "special://xbmc/language/";
+	CStdString strLanguagePath = "special://xbmc/system/language/";
 
-  CLog::Log(LOGINFO, "load %s language file, from path: %s", strLanguage.c_str(), strLanguagePath.c_str());
-  if (!g_localizeStrings.Load(strLanguagePath, strLanguage))
-    FatalErrorHandler(true, false, true);
+	CLog::Log(LOGINFO, "load %s language file, from path: %s", strLanguage.c_str(), strLanguagePath.c_str());
+	if (!g_localizeStrings.Load(strLanguagePath, strLanguage))
+	FatalErrorHandler(true, false, true);
 
-  CLog::Log(LOGINFO, "load keymapping");
-  if (!CButtonTranslator::GetInstance().Load())
-    FatalErrorHandler(true, false, true);
+	CLog::Log(LOGINFO, "load keymapping");
+	if (!CButtonTranslator::GetInstance().Load())
+	FatalErrorHandler(true, false, true);
 
-  // check the skin file for testing purposes
-  CStdString strSkinBase = "special://xbmc/skin/";
-  CStdString strSkinPath = strSkinBase + g_guiSettings.GetString("lookandfeel.skin");
-  CLog::Log(LOGINFO, "Checking skin version of: %s", g_guiSettings.GetString("lookandfeel.skin").c_str());
-  if (!g_SkinInfo.Check(strSkinPath))
-  {
-    // reset to the default skin (DEFAULT_SKIN)
-    CLog::Log(LOGINFO, "The above skin isn't suitable - checking the version of the default: %s", DEFAULT_SKIN);
-    strSkinPath = strSkinBase + DEFAULT_SKIN;
-    if (!g_SkinInfo.Check(strSkinPath))
-    {
-      g_LoadErrorStr.Format("No suitable skin version found.\nWe require at least version %5.4f \n", g_SkinInfo.GetMinVersion());
-      FatalErrorHandler(true, false, true);
-    }
-  }
+	// check the skin file for testing purposes
+	CStdString strSkinBase = "special://xbmc/emustation/themes/";
+	CStdString strSkinPath = strSkinBase + g_guiSettings.GetString("lookandfeel.skin");
+	CLog::Log(LOGINFO, "Checking skin version of: %s", g_guiSettings.GetString("lookandfeel.skin").c_str());
+	if (!g_SkinInfo.Check(strSkinPath))
+	{
+		// reset to the default skin (DEFAULT_SKIN)
+		CLog::Log(LOGINFO, "The above skin isn't suitable - checking the version of the default: %s", DEFAULT_SKIN);
+		strSkinPath = strSkinBase + DEFAULT_SKIN;
+		if (!g_SkinInfo.Check(strSkinPath))
+		{
+			g_LoadErrorStr.Format("No suitable skin version found.\nWe require at least version %5.4f \n", g_SkinInfo.GetMinVersion());
+			FatalErrorHandler(true, false, true);
+		}
+	}
 
-  if (!g_graphicsContext.IsValidResolution(g_guiSettings.m_LookAndFeelResolution))
-  {
-    // Oh uh - doesn't look good for starting in their wanted screenmode
-    CLog::Log(LOGERROR, "The screen resolution requested is not valid, resetting to a valid mode");
-    g_guiSettings.m_LookAndFeelResolution = initialResolution;
-  }
-  // Transfer the new resolution information to our graphics context
+	if (!g_graphicsContext.IsValidResolution(g_guiSettings.m_LookAndFeelResolution))
+	{
+		// Oh uh - doesn't look good for starting in their wanted screenmode
+		CLog::Log(LOGERROR, "The screen resolution requested is not valid, resetting to a valid mode");
+		g_guiSettings.m_LookAndFeelResolution = initialResolution;
+	}
+	// Transfer the new resolution information to our graphics context
 #ifndef HAS_XBOX_D3D
-  m_d3dpp.Windowed = TRUE;
-  m_d3dpp.hDeviceWindow = g_hWnd;
+	m_d3dpp.Windowed = TRUE;
+	m_d3dpp.hDeviceWindow = g_hWnd;
 #else
 #define D3DCREATE_MULTITHREADED 0
 #endif
 
-  g_graphicsContext.SetD3DParameters(&m_d3dpp);
-  g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE);
-  
-  if ( FAILED( hr = m_pD3D->CreateDevice(0, D3DDEVTYPE_HAL, NULL,
-                                         D3DCREATE_MULTITHREADED | D3DCREATE_HARDWARE_VERTEXPROCESSING,
-                                         &m_d3dpp, &m_pd3dDevice ) ) )
-  {
-    // try software vertex processing
-    if ( FAILED( hr = m_pD3D->CreateDevice(0, D3DDEVTYPE_HAL, NULL,
-                                          D3DCREATE_MULTITHREADED | D3DCREATE_SOFTWARE_VERTEXPROCESSING,
-                                          &m_d3dpp, &m_pd3dDevice ) ) )
-    {
-      // and slow as arse reference processing
-      if ( FAILED( hr = m_pD3D->CreateDevice(0, D3DDEVTYPE_REF, NULL,
-                                            D3DCREATE_MULTITHREADED | D3DCREATE_SOFTWARE_VERTEXPROCESSING,
-                                            &m_d3dpp, &m_pd3dDevice ) ) )
-      {
+	g_graphicsContext.SetD3DParameters(&m_d3dpp);
+	g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE);
 
-        CLog::Log(LOGFATAL, "XBAppEx: Could not create D3D device!" );
-        CLog::Log(LOGFATAL, " width/height:(%ix%i)" , m_d3dpp.BackBufferWidth, m_d3dpp.BackBufferHeight);
-        CLog::Log(LOGFATAL, " refreshrate:%i" , m_d3dpp.FullScreen_RefreshRateInHz);
-        if (m_d3dpp.Flags & D3DPRESENTFLAG_WIDESCREEN)
-          CLog::Log(LOGFATAL, " 16:9 widescreen");
-        else
-          CLog::Log(LOGFATAL, " 4:3");
+	if ( FAILED( hr = m_pD3D->CreateDevice(0, D3DDEVTYPE_HAL, NULL,
+					D3DCREATE_MULTITHREADED | D3DCREATE_HARDWARE_VERTEXPROCESSING,
+					&m_d3dpp, &m_pd3dDevice ) ) )
+	{
+		// try software vertex processing
+		if ( FAILED( hr = m_pD3D->CreateDevice(0, D3DDEVTYPE_HAL, NULL,
+						D3DCREATE_MULTITHREADED | D3DCREATE_SOFTWARE_VERTEXPROCESSING,
+						&m_d3dpp, &m_pd3dDevice ) ) )
+		{
+			// and slow as arse reference processing
+			if ( FAILED( hr = m_pD3D->CreateDevice(0, D3DDEVTYPE_REF, NULL,
+							D3DCREATE_MULTITHREADED | D3DCREATE_SOFTWARE_VERTEXPROCESSING,
+							&m_d3dpp, &m_pd3dDevice ) ) )
+			{
 
-        if (m_d3dpp.Flags & D3DPRESENTFLAG_INTERLACED)
-          CLog::Log(LOGFATAL, " interlaced");
-        if (m_d3dpp.Flags & D3DPRESENTFLAG_PROGRESSIVE)
-          CLog::Log(LOGFATAL, " progressive");
-        return hr;
-      }
-    }
-  }
+				CLog::Log(LOGFATAL, "XBAppEx: Could not create D3D device!" );
+				CLog::Log(LOGFATAL, " width/height:(%ix%i)" , m_d3dpp.BackBufferWidth, m_d3dpp.BackBufferHeight);
+				CLog::Log(LOGFATAL, " refreshrate:%i" , m_d3dpp.FullScreen_RefreshRateInHz);
+				if (m_d3dpp.Flags & D3DPRESENTFLAG_WIDESCREEN)
+				CLog::Log(LOGFATAL, " 16:9 widescreen");
+				else
+				CLog::Log(LOGFATAL, " 4:3");
 
-  g_graphicsContext.SetD3DDevice(m_pd3dDevice);
-  g_graphicsContext.CaptureStateBlock();
-  // set filters
-  g_graphicsContext.Get3DDevice()->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR /*g_settings.m_minFilter*/ );
-  g_graphicsContext.Get3DDevice()->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR /*g_settings.m_maxFilter*/ );
-  CUtil::InitGamma();
-  
-  // set GUI res and force the clear of the screen
-  g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE, true);
+				if (m_d3dpp.Flags & D3DPRESENTFLAG_INTERLACED)
+				CLog::Log(LOGFATAL, " interlaced");
+				if (m_d3dpp.Flags & D3DPRESENTFLAG_PROGRESSIVE)
+				CLog::Log(LOGFATAL, " progressive");
+				return hr;
+			}
+		}
+	}
 
-  m_splash = new CSplash("Q:\\media\\splash.png");
-  m_splash->Start();
+	g_graphicsContext.SetD3DDevice(m_pd3dDevice);
+	g_graphicsContext.CaptureStateBlock();
+	// set filters
+	g_graphicsContext.Get3DDevice()->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR /*g_settings.m_minFilter*/ );
+	g_graphicsContext.Get3DDevice()->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR /*g_settings.m_maxFilter*/ );
+	CUtil::InitGamma();
 
-  int iResolution = g_graphicsContext.GetVideoResolution();
-  CLog::Log(LOGINFO, "GUI format %ix%i %s",
-            g_settings.m_ResInfo[iResolution].iWidth,
-            g_settings.m_ResInfo[iResolution].iHeight,
-            g_settings.m_ResInfo[iResolution].strMode);
-  g_windowManager.Initialize();
+	// set GUI res and force the clear of the screen
+	g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE, true);	
 
-  // show recovery console on fatal error instead of freezing
-  CLog::Log(LOGINFO, "install unhandled exception filter");
-  SetUnhandledExceptionFilter(UnhandledExceptionFilter);
+	// Set current theme for special://theme/ on startup
+	CSpecialProtocol::SetCurrentThemePath("Q:\\emustation\\themes\\"+URIUtils::ReplaceExtension(g_guiSettings.GetString("lookandfeel.skintheme"), ""));
+	m_splash = new CSplash("Q:\\emustation\\themes\\simple\\splash.png");
+	m_splash->Start();
 
+	int iResolution = g_graphicsContext.GetVideoResolution();
+	CLog::Log(LOGINFO, "GUI format %ix%i %s",
+	g_settings.m_ResInfo[iResolution].iWidth,
+	g_settings.m_ResInfo[iResolution].iHeight,
+	g_settings.m_ResInfo[iResolution].strMode);
+	g_windowManager.Initialize();
+
+	// show recovery console on fatal error instead of freezing
+	CLog::Log(LOGINFO, "install unhandled exception filter");
+	SetUnhandledExceptionFilter(UnhandledExceptionFilter);
+
 #ifdef HAS_XBOX_D3D
-  D3DDevice::SetWaitCallback(WaitCallback);
+	D3DDevice::SetWaitCallback(WaitCallback);
 #endif
 
-  g_Mouse.SetEnabled(g_guiSettings.GetBool("lookandfeel.enablemouse"));
+	g_Mouse.SetEnabled(g_guiSettings.GetBool("lookandfeel.enablemouse"));
 
-  CUtil::InitRandomSeed();
+	CUtil::InitRandomSeed();
 
-  return CXBApplicationEx::Create(hWnd);
+	return CXBApplicationEx::Create(hWnd);
 }
 
 
 HRESULT CApplication::Initialize()
-{
-  CLog::Log(LOGINFO, "creating subdirectories");
+{	
+	CLog::Log(LOGINFO, "creating subdirectories");
 
-  CLog::Log(LOGINFO, "userdata folder: %s", g_settings.GetProfileUserDataFolder().c_str());
-  CLog::Log(LOGINFO, "recording folder: %s", g_guiSettings.GetString("audiocds.recordingpath",false).c_str());
-  CLog::Log(LOGINFO, "screenshots folder: %s", g_guiSettings.GetString("debug.screenshotpath",false).c_str());
+	CLog::Log(LOGINFO, "userdata folder: %s", g_settings.GetProfileUserDataFolder().c_str());
+	CLog::Log(LOGINFO, "recording folder: %s", g_guiSettings.GetString("audiocds.recordingpath",false).c_str());
+	CLog::Log(LOGINFO, "screenshots folder: %s", g_guiSettings.GetString("debug.screenshotpath",false).c_str());
 
-  // UserData folder layout:
-  // UserData/
-  //   Database/
-  //     CDDb/
-  //   Thumbnails/
-  //     Music/
-  //       temp/
-  //     0 .. F/
+	// UserData folder layout:
+	// UserData/
+	//   Database/
+	//     CDDb/
+	//   Thumbnails/
+	//     Music/
+	//       temp/
+	//     0 .. F/
 
-  CDirectory::Create(g_settings.GetUserDataFolder());
-  CDirectory::Create(g_settings.GetProfileUserDataFolder());
-  g_settings.CreateProfileFolders();
+	CDirectory::Create(g_settings.GetUserDataFolder());
+	CDirectory::Create(g_settings.GetProfileUserDataFolder());
+	g_settings.CreateProfileFolders();
 
-  CDirectory::Create(g_settings.GetProfilesThumbFolder());
+	CDirectory::Create(g_settings.GetProfilesThumbFolder());
 
-  CUtil::WipeDir("Z:\\");
-  CreateDirectory("Z:\\temp", NULL); // temp directory for python and dllGetTempPathA
-  CreateDirectory("Q:\\scripts", NULL);
-  CreateDirectory("Q:\\plugins", NULL);
-  CreateDirectory("Q:\\plugins\\music", NULL);
-  CreateDirectory("Q:\\plugins\\video", NULL);
-  CreateDirectory("Q:\\plugins\\pictures", NULL);
-  CreateDirectory("Q:\\plugins\\programs", NULL);
-  CreateDirectory("Q:\\language", NULL);
-  CreateDirectory("Q:\\visualisations", NULL);
-  CreateDirectory("Q:\\sounds", NULL);
-  CreateDirectory(g_settings.GetUserDataFolder()+"\\visualisations",NULL);
+	CUtil::WipeDir("Z:\\");
+	CreateDirectory("Z:\\temp", NULL); // temp directory for python and dllGetTempPathA
+	CreateDirectory("Q:\\system\\scripts", NULL);
+	CreateDirectory("Q:\\system\\plugins", NULL);
+	// CreateDirectory("Q:\\system\\plugins\\music", NULL);
+	// CreateDirectory("Q:\\system\\plugins\\video", NULL);
+	// CreateDirectory("Q:\\system\\plugins\\pictures", NULL);
+	// CreateDirectory("Q:\\system\\plugins\\programs", NULL);
+	CreateDirectory("Q:\\system\\language", NULL);
+	CreateDirectory("Q:\\system\\screenshots", NULL);
+	CreateDirectory("Q:\\system\\trainers", NULL);
+	CreateDirectory("Q:\\system\\visualisations", NULL);
 
-  // initialize network
-  if (!m_bXboxMediacenterLoaded)
-  {
-    CLog::Log(LOGINFO, "using default network settings");
-    g_guiSettings.SetString("network.ipaddress", "192.168.0.100");
-    g_guiSettings.SetString("network.subnet", "255.255.255.0");
-    g_guiSettings.SetString("network.gateway", "192.168.0.1");
-    g_guiSettings.SetString("network.dns", "192.168.0.1");
-    g_guiSettings.SetBool("services.ftpserver", true);
-    g_guiSettings.SetBool("services.webserver", false);
-    g_guiSettings.SetBool("locale.timeserver", false);
-  }
+	// initialize network
+	if (!m_bXboxMediacenterLoaded)
+	{
+		CLog::Log(LOGINFO, "using default network settings");
+		g_guiSettings.SetString("network.ipaddress", "192.168.0.100");
+		g_guiSettings.SetString("network.subnet", "255.255.255.0");
+		g_guiSettings.SetString("network.gateway", "192.168.0.1");
+		g_guiSettings.SetString("network.dns", "192.168.0.1");
+		g_guiSettings.SetBool("services.ftpserver", true);
+		g_guiSettings.SetBool("services.webserver", false);
+		g_guiSettings.SetBool("locale.timeserver", false);
+	}	
+	
+	/* setup network based on our settings */
+	/* network will start it's init procedure */
+	m_network.SetupNetwork();
+	
+	StartServices();
+	
+	g_windowManager.Add(new CGUIWindowHome);                     // window id = 0
 
-  /* setup network based on our settings */
-  /* network will start it's init procedure */
-  m_network.SetupNetwork();
+	CLog::Log(LOGNOTICE, "load simple skin:[%s]", g_guiSettings.GetString("lookandfeel.skin").c_str());
+	LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
 
-  StartServices();
+	g_windowManager.Add(new CGUIWindowPrograms);                 // window id = 1
+	g_windowManager.Add(new CGUIWindowPictures);                 // window id = 2
+	g_windowManager.Add(new CGUIWindowFileManager);      // window id = 3
+	g_windowManager.Add(new CGUIWindowVideoFiles);          // window id = 6
+	g_windowManager.Add(new CGUIWindowSettings);                 // window id = 4
+	g_windowManager.Add(new CGUIWindowSystemInfo);               // window id = 7
+	g_windowManager.Add(new CGUIWindowSettingsScreenCalibration); // window id = 11
+	g_windowManager.Add(new CGUIWindowSettingsCategory);         // window id = 12 slideshow:window id 2007
+	g_windowManager.Add(new CGUIWindowScripts);                  // window id = 20
+	g_windowManager.Add(new CGUIWindowVideoNav);                 // window id = 36
+	g_windowManager.Add(new CGUIWindowVideoPlaylist);            // window id = 28
+	g_windowManager.Add(new CGUIWindowLoginScreen);            // window id = 29
+	g_windowManager.Add(new CGUIWindowSettingsProfile);          // window id = 34
+	g_windowManager.Add(new CGUIWindowGameSaves);               // window id = 35
+	g_windowManager.Add(new CGUIDialogYesNo);              // window id = 100
+	g_windowManager.Add(new CGUIDialogProgress);           // window id = 101
+	g_windowManager.Add(new CGUIDialogKeyboard);           // window id = 103
+	g_windowManager.Add(&m_guiDialogVolumeBar);          // window id = 104
+	g_windowManager.Add(&m_guiDialogSeekBar);            // window id = 115
+	g_windowManager.Add(new CGUIDialogSubMenu);            // window id = 105
+	g_windowManager.Add(new CGUIDialogContextMenu);        // window id = 106
+	g_windowManager.Add(&m_guiDialogKaiToast);           // window id = 107
+	g_windowManager.Add(new CGUIDialogNumeric);            // window id = 109
+	g_windowManager.Add(new CGUIDialogGamepad);            // window id = 110
+	g_windowManager.Add(new CGUIDialogButtonMenu);         // window id = 111
+	g_windowManager.Add(new CGUIDialogMusicScan);          // window id = 112
+	g_windowManager.Add(new CGUIDialogPlayerControls);     // window id = 113
+	g_windowManager.Add(new CGUIDialogSlider);             // window id = 145
+	g_windowManager.Add(new CGUIDialogMusicOSD);           // window id = 120
+	g_windowManager.Add(new CGUIDialogVisualisationSettings);     // window id = 121
+	g_windowManager.Add(new CGUIDialogVisualisationPresetList);   // window id = 122
+	g_windowManager.Add(new CGUIDialogVideoSettings);             // window id = 123
+	g_windowManager.Add(new CGUIDialogAudioSubtitleSettings);     // window id = 124
+	g_windowManager.Add(new CGUIDialogVideoBookmarks);      // window id = 125
+	// Don't add the filebrowser dialog - it's created and added when it's needed
+	g_windowManager.Add(new CGUIDialogTrainerSettings);  // window id = 127
+	g_windowManager.Add(new CGUIDialogNetworkSetup);  // window id = 128
+	g_windowManager.Add(new CGUIDialogMediaSource);   // window id = 129
+	g_windowManager.Add(new CGUIDialogProfileSettings); // window id = 130
+	g_windowManager.Add(new CGUIDialogVideoScan);      // window id = 133
+	g_windowManager.Add(new CGUIDialogFavourites);     // window id = 134
+	g_windowManager.Add(new CGUIDialogSongInfo);       // window id = 135
+	g_windowManager.Add(new CGUIDialogSmartPlaylistEditor);       // window id = 136
+	g_windowManager.Add(new CGUIDialogSmartPlaylistRule);       // window id = 137
+	g_windowManager.Add(new CGUIDialogBusy);      // window id = 138
+	g_windowManager.Add(new CGUIDialogPictureInfo);      // window id = 139
+	g_windowManager.Add(new CGUIDialogPluginSettings);      // window id = 140
+	g_windowManager.Add(new CGUIDialogTextViewer);              // window id = 147
 
-  g_windowManager.Add(new CGUIWindowHome);                     // window id = 0
+	g_windowManager.Add(new CGUIDialogLockSettings); // window id = 131
 
-  CLog::Log(LOGNOTICE, "load default skin:[%s]", g_guiSettings.GetString("lookandfeel.skin").c_str());
-  LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
+	g_windowManager.Add(new CGUIDialogContentSettings);        // window id = 132
 
-  g_windowManager.Add(new CGUIWindowPrograms);                 // window id = 1
-  g_windowManager.Add(new CGUIWindowPictures);                 // window id = 2
-  g_windowManager.Add(new CGUIWindowFileManager);      // window id = 3
-  g_windowManager.Add(new CGUIWindowVideoFiles);          // window id = 6
-  g_windowManager.Add(new CGUIWindowSettings);                 // window id = 4
-  g_windowManager.Add(new CGUIWindowSystemInfo);               // window id = 7
-  g_windowManager.Add(new CGUIWindowSettingsScreenCalibration); // window id = 11
-  g_windowManager.Add(new CGUIWindowSettingsCategory);         // window id = 12 slideshow:window id 2007
-  g_windowManager.Add(new CGUIWindowScripts);                  // window id = 20
-  g_windowManager.Add(new CGUIWindowVideoNav);                 // window id = 36
-  g_windowManager.Add(new CGUIWindowVideoPlaylist);            // window id = 28
-  g_windowManager.Add(new CGUIWindowLoginScreen);            // window id = 29
-  g_windowManager.Add(new CGUIWindowSettingsProfile);          // window id = 34
-  g_windowManager.Add(new CGUIWindowGameSaves);               // window id = 35
-  g_windowManager.Add(new CGUIDialogYesNo);              // window id = 100
-  g_windowManager.Add(new CGUIDialogProgress);           // window id = 101
-  g_windowManager.Add(new CGUIDialogKeyboard);           // window id = 103
-  g_windowManager.Add(&m_guiDialogVolumeBar);          // window id = 104
-  g_windowManager.Add(&m_guiDialogSeekBar);            // window id = 115
-  g_windowManager.Add(new CGUIDialogSubMenu);            // window id = 105
-  g_windowManager.Add(new CGUIDialogContextMenu);        // window id = 106
-  g_windowManager.Add(&m_guiDialogKaiToast);           // window id = 107
-  g_windowManager.Add(new CGUIDialogNumeric);            // window id = 109
-  g_windowManager.Add(new CGUIDialogGamepad);            // window id = 110
-  g_windowManager.Add(new CGUIDialogButtonMenu);         // window id = 111
-  g_windowManager.Add(new CGUIDialogMusicScan);          // window id = 112
-  g_windowManager.Add(new CGUIDialogPlayerControls);     // window id = 113
-  g_windowManager.Add(new CGUIDialogSlider);             // window id = 145
-  g_windowManager.Add(new CGUIDialogMusicOSD);           // window id = 120
-  g_windowManager.Add(new CGUIDialogVisualisationSettings);     // window id = 121
-  g_windowManager.Add(new CGUIDialogVisualisationPresetList);   // window id = 122
-  g_windowManager.Add(new CGUIDialogVideoSettings);             // window id = 123
-  g_windowManager.Add(new CGUIDialogAudioSubtitleSettings);     // window id = 124
-  g_windowManager.Add(new CGUIDialogVideoBookmarks);      // window id = 125
-  // Don't add the filebrowser dialog - it's created and added when it's needed
-  g_windowManager.Add(new CGUIDialogTrainerSettings);  // window id = 127
-  g_windowManager.Add(new CGUIDialogNetworkSetup);  // window id = 128
-  g_windowManager.Add(new CGUIDialogMediaSource);   // window id = 129
-  g_windowManager.Add(new CGUIDialogProfileSettings); // window id = 130
-  g_windowManager.Add(new CGUIDialogVideoScan);      // window id = 133
-  g_windowManager.Add(new CGUIDialogFavourites);     // window id = 134
-  g_windowManager.Add(new CGUIDialogSongInfo);       // window id = 135
-  g_windowManager.Add(new CGUIDialogSmartPlaylistEditor);       // window id = 136
-  g_windowManager.Add(new CGUIDialogSmartPlaylistRule);       // window id = 137
-  g_windowManager.Add(new CGUIDialogBusy);      // window id = 138
-  g_windowManager.Add(new CGUIDialogPictureInfo);      // window id = 139
-  g_windowManager.Add(new CGUIDialogPluginSettings);      // window id = 140
-  g_windowManager.Add(new CGUIDialogTextViewer);              // window id = 147
+	g_windowManager.Add(new CGUIWindowMusicPlayList);          // window id = 500
+	g_windowManager.Add(new CGUIWindowMusicSongs);             // window id = 501
+	g_windowManager.Add(new CGUIWindowMusicNav);               // window id = 502
+	g_windowManager.Add(new CGUIWindowMusicPlaylistEditor);    // window id = 503
 
-  g_windowManager.Add(new CGUIDialogLockSettings); // window id = 131
+	g_windowManager.Add(new CGUIDialogSelect);             // window id = 2000
+	g_windowManager.Add(new CGUIWindowMusicInfo);                // window id = 2001
+	g_windowManager.Add(new CGUIDialogOK);                 // window id = 2002
+	g_windowManager.Add(new CGUIWindowVideoInfo);                // window id = 2003
+	g_windowManager.Add(new CGUIWindowScriptsInfo);              // window id = 2004
+	g_windowManager.Add(new CGUIWindowFullScreen);         // window id = 2005
+	g_windowManager.Add(new CGUIWindowVisualisation);      // window id = 2006
+	g_windowManager.Add(new CGUIWindowSlideShow);          // window id = 2007
+	g_windowManager.Add(new CGUIDialogFileStacking);       // window id = 2008
 
-  g_windowManager.Add(new CGUIDialogContentSettings);        // window id = 132
+	g_windowManager.Add(new CGUIWindowOSD);                // window id = 2901
+	g_windowManager.Add(new CGUIWindowMusicOverlay);       // window id = 2903
+	g_windowManager.Add(new CGUIWindowVideoOverlay);       // window id = 2904
+	g_windowManager.Add(new CGUIWindowScreensaver);        // window id = 2900 Screensaver
+	g_windowManager.Add(new CGUIWindowWeather);            // window id = 2600 WEATHER
+	g_windowManager.Add(new CGUIWindowStartup);            // startup window (id 2999)
 
-  g_windowManager.Add(new CGUIWindowMusicPlayList);          // window id = 500
-  g_windowManager.Add(new CGUIWindowMusicSongs);             // window id = 501
-  g_windowManager.Add(new CGUIWindowMusicNav);               // window id = 502
-  g_windowManager.Add(new CGUIWindowMusicPlaylistEditor);    // window id = 503
+	if (CFile::Exists("Special://root/updater/default.xbe"))
+	{
+		if (CGUIDialogYesNo::ShowAndGetInput(g_localizeStrings.Get(33049), "Updater found.", "Would you like to continue with the update?", "", "No", "Yes"))
+		{
+			CUtil::RunXBE("Special://root/updater/default.xbe");
+		}
+	}
+	
+	CBuiltins::Execute("skin.setstring(xberegion,)");
+	
+	// if (CFile::Exists("Special://root/skins/profile skin/extras/disc artwork.zip"))
+	// {
+		// CLog::Log(LOGNOTICE, "GUI format");
+		// CGUIDialogOK *dialog = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_OK);
+		// if (dialog)
+		// {
+			// dialog->SetHeading("Cleanup");
+			// dialog->SetLine(0, "");
+			// dialog->SetLine(1, "That's you updated to the latest version.");
+			// dialog->SetLine(2, "I will now cleanup left over file.");
+			// dialog->DoModal();
+		// }
+		// Sleep(500);
+		// CopyFile("Special://root/updater/system/xbmc.log","Special://root/system/xbmc-updater.log",1);
+		// CUtil::WipeDir("Special://root/updater");
+	// }
+	int iResolution = g_graphicsContext.GetVideoResolution();
+	if (g_settings.m_ResInfo[iResolution].iWidth == 1920)
+	{
+		CLog::Log(LOGNOTICE, "GUI format");
+		CGUIDialogOK *dialog = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_OK);
+		if (dialog)
+		{
+			dialog->SetHeading("1080i Resolution Detected");
+			dialog->SetLine(0, "Due to the complexity of this dashboard 1080i must");
+			dialog->SetLine(1, "be disabled. I will disable it now.");
+			dialog->SetLine(2, "");;
+			dialog->DoModal();
+		}
+		g_guiSettings.SetBool("videooutput.hd1080i", false);
+		RESOLUTION res = HDTV_720p;
+		g_guiSettings.SetInt("videoscreen.resolution", res);
+		//set the gui resolution, if newRes is AUTORES newRes will be set to the highest available resolution
+		g_graphicsContext.SetVideoResolution(res, TRUE);
+		//set our lookandfeelres to the resolution set in graphiccontext
+		g_guiSettings.m_LookAndFeelResolution = res;
+		// CUtil::BootToDash();
+	}
+	if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_X] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_B])
+	{
+		g_advancedSettings.m_logLevel = LOG_LEVEL_DEBUG_FREEMEM;
+		CLog::SetLogLevel(g_advancedSettings.m_logLevel);
+		CLog::Log(LOGINFO, "Key combination detected for disable advance video modes (X+B)");
+		g_guiSettings.SetBool("videooutput.hd480p", false);
+		g_guiSettings.SetBool("videooutput.hd720p", false);
+		g_guiSettings.SetBool("videooutput.hd1080i", false);
+		RESOLUTION res = NTSC_4x3;
+		g_guiSettings.SetInt("videoscreen.resolution", res);
+		//set the gui resolution, if newRes is AUTORES newRes will be set to the highest available resolution
+		g_graphicsContext.SetVideoResolution(res, TRUE);
+		//set our lookandfeelres to the resolution set in graphiccontext
+		g_guiSettings.m_LookAndFeelResolution = res;
+	}
 
-  g_windowManager.Add(new CGUIDialogSelect);             // window id = 2000
-  g_windowManager.Add(new CGUIWindowMusicInfo);                // window id = 2001
-  g_windowManager.Add(new CGUIDialogOK);                 // window id = 2002
-  g_windowManager.Add(new CGUIWindowVideoInfo);                // window id = 2003
-  g_windowManager.Add(new CGUIWindowScriptsInfo);              // window id = 2004
-  g_windowManager.Add(new CGUIWindowFullScreen);         // window id = 2005
-  g_windowManager.Add(new CGUIWindowVisualisation);      // window id = 2006
-  g_windowManager.Add(new CGUIWindowSlideShow);          // window id = 2007
-  g_windowManager.Add(new CGUIDialogFileStacking);       // window id = 2008
+	/* window id's 3000 - 3100 are reserved for python */
+	g_DownloadManager.Initialize();
+	
+	m_ctrDpad.SetDelays(100, 500); //g_settings.m_iMoveDelayController, g_settings.m_iRepeatDelayController);
 
-  g_windowManager.Add(new CGUIWindowOSD);                // window id = 2901
-  g_windowManager.Add(new CGUIWindowMusicOverlay);       // window id = 2903
-  g_windowManager.Add(new CGUIWindowVideoOverlay);       // window id = 2904
-  g_windowManager.Add(new CGUIWindowScreensaver);        // window id = 2900 Screensaver
-  g_windowManager.Add(new CGUIWindowWeather);            // window id = 2600 WEATHER
-  g_windowManager.Add(new CGUIWindowStartup);            // startup window (id 2999)
+	SAFE_DELETE(m_splash);
+	
+	if (g_guiSettings.GetBool("masterlock.startuplock") && 
+			g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+			!g_settings.GetMasterProfile().getLockCode().IsEmpty())
+	{
+		g_passwordManager.CheckStartUpLock();
+	}
 
-  /* window id's 3000 - 3100 are reserved for python */
-  g_DownloadManager.Initialize();
 
-  m_ctrDpad.SetDelays(100, 500); //g_settings.m_iMoveDelayController, g_settings.m_iRepeatDelayController);
+	if (!g_advancedSettings.m_splashImage && g_advancedSettings.m_enableintro && !CFile::Exists("Special://root/system//introplay"))
+	{
+		if ( CFile::Exists("Special://root/intro.mp4") )
+		{
+			ExecuteXBMCAction("Special://root/intro.mp4");
+		}
+		else if ( CFile::Exists("Special://root/system/intro/intro.mp4") )
+		{
+			ExecuteXBMCAction("Special://root/system/intro/intro.mp4");
+		}
+		g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+		
+		while (1)
+		{
+			Sleep(10);
+			
+			ReadInput();
+			if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_B])
+			{
+				m_pPlayer->CloseFile();
+			}
+			if (!g_application.IsPlayingVideo())
+			{
+				if (g_settings.UsingLoginScreen())
+				{
+					g_windowManager.ActivateWindow(WINDOW_LOGIN_SCREEN);
+					break;
+				}
+				else
+				{
+					g_windowManager.ActivateWindow(g_SkinInfo.GetFirstWindow());
+					break;
+				}
+			}
+		}
+	}
+	else
+	{
+		if (g_settings.UsingLoginScreen())
+		{
+			g_windowManager.ActivateWindow(WINDOW_LOGIN_SCREEN);
+		}
+		else
+		{
+			g_windowManager.ActivateWindow(g_SkinInfo.GetFirstWindow());
+		}
+	}
+	
+	g_pythonParser.bStartup = true;
+	//g_sysinfo.Refresh();
 
-  SAFE_DELETE(m_splash);
+	CLog::Log(LOGINFO, "removing tempfiles");
+	CUtil::initilise();
+	CUtil::RemoveTempFiles();
 
-  if (g_guiSettings.GetBool("masterlock.startuplock") && 
-      g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
-     !g_settings.GetMasterProfile().getLockCode().IsEmpty())
-  {
-     g_passwordManager.CheckStartUpLock();
-  }
+	if (!m_bAllSettingsLoaded)
+	{
+		CLog::Log(LOGWARNING, "settings not correct, show dialog");
+		CStdString test;
+		CUtil::GetHomePath(test);
+		CGUIDialogOK *dialog = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_OK);
+		if (dialog)
+		{
+			dialog->SetHeading(279);
+			dialog->SetLine(0, "Error while loading settings");
+			dialog->SetLine(1, test);
+			dialog->SetLine(2, "");;
+			dialog->DoModal();
+		}
+	}
 
-  // check if we should use the login screen
-  if (g_settings.UsingLoginScreen())
-  {
-    g_windowManager.ActivateWindow(WINDOW_LOGIN_SCREEN);
-  }
-  else
-  {
-    g_windowManager.ActivateWindow(g_SkinInfo.GetFirstWindow());
-  }
+	//  Show mute symbol
+	if (g_settings.m_nVolumeLevel == VOLUME_MINIMUM)
+	Mute();
 
-  g_pythonParser.bStartup = true;
-  //g_sysinfo.Refresh();
+	// if the user shutoff the xbox during music scan
+	// restore the settings
+	if (g_settings.m_bMyMusicIsScanning)
+	{
+		CLog::Log(LOGWARNING,"System rebooted during music scan! ... restoring UseTags and FindRemoteThumbs");
+		RestoreMusicScanSettings();
+	}
 
-  CLog::Log(LOGINFO, "removing tempfiles");
-  CUtil::RemoveTempFiles();
+	if (!g_settings.UsingLoginScreen())
+	UpdateLibraries();
 
-  if (!m_bAllSettingsLoaded)
-  {
-    CLog::Log(LOGWARNING, "settings not correct, show dialog");
-    CStdString test;
-    CUtil::GetHomePath(test);
-    CGUIDialogOK *dialog = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_OK);
-    if (dialog)
-    {
-      dialog->SetHeading(279);
-      dialog->SetLine(0, "Error while loading settings");
-      dialog->SetLine(1, test);
-      dialog->SetLine(2, "");;
-      dialog->DoModal();
-    }
-  }
+	m_slowTimer.StartZero();
 
-  //  Show mute symbol
-  if (g_settings.m_nVolumeLevel == VOLUME_MINIMUM)
-    Mute();
-
-  // if the user shutoff the xbox during music scan
-  // restore the settings
-  if (g_settings.m_bMyMusicIsScanning)
-  {
-    CLog::Log(LOGWARNING,"System rebooted during music scan! ... restoring UseTags and FindRemoteThumbs");
-    RestoreMusicScanSettings();
-  }
-
-  if (!g_settings.UsingLoginScreen())
-    UpdateLibraries();
-
-  m_slowTimer.StartZero();
-
 #ifdef __APPLE__
-  g_xbmcHelper.CaptureAllInput();
+	g_xbmcHelper.CaptureAllInput();
 #endif
 
-  CLog::Log(LOGNOTICE, "initialize done");
+	CLog::Log(LOGNOTICE, "initialize done");
 
-  m_bInitializing = false;
+	m_bInitializing = false;
 
-  // final check for debugging combo
-  CheckForDebugButtonCombo();
+	// final check for debugging combo
+	CheckForDebugButtonCombo();
 
-  // reset our screensaver (starts timers etc.)
-  ResetScreenSaver();
-  return S_OK;
+	// reset our screensaver (starts timers etc.)
+	ResetScreenSaver();
+
+	return S_OK;
 }
 
 void CApplication::PrintXBEToLCD(const char* xbePath)
 {
 #ifdef HAS_LCD
-  int pLine = 0;
-  CStdString strXBEName;
-  if (!CUtil::GetXBEDescription(xbePath, strXBEName))
-  {
-    CUtil::GetDirectoryName(xbePath, strXBEName);
-    CUtil::ShortenFileName(strXBEName);
-    CUtil::RemoveIllegalChars(strXBEName);
-  }
-  // crop to LCD screen size
-  if ((int)strXBEName.size() > g_advancedSettings.m_lcdColumns)
-    strXBEName = strXBEName.Left(g_advancedSettings.m_lcdColumns);
-  if (g_lcd)
-  {
-    g_infoManager.SetLaunchingXBEName(strXBEName);
-    g_lcd->Render(ILCD::LCD_MODE_XBE_LAUNCH);
-  }
+	int pLine = 0;
+	CStdString strXBEName;
+	if (!CUtil::GetXBEDescription(xbePath, strXBEName))
+	{
+		CUtil::GetDirectoryName(xbePath, strXBEName);
+		CUtil::ShortenFileName(strXBEName);
+		CUtil::RemoveIllegalChars(strXBEName);
+	}
+	// crop to LCD screen size
+	if ((int)strXBEName.size() > g_advancedSettings.m_lcdColumns)
+	strXBEName = strXBEName.Left(g_advancedSettings.m_lcdColumns);
+	if (g_lcd)
+	{
+		g_infoManager.SetLaunchingXBEName(strXBEName);
+		g_lcd->Render(ILCD::LCD_MODE_XBE_LAUNCH);
+	}
 #endif
 }
 
 void CApplication::StartIdleThread()
 {
-  m_idleThread.Create(false, 0x100);
+	m_idleThread.Create(false, 0x100);
 }
 
 void CApplication::StopIdleThread()
 {
-  m_idleThread.StopThread();
+	m_idleThread.StopThread();
 }
 
 void CApplication::StartWebServer()
 {
-  if (g_guiSettings.GetBool("services.webserver") && m_network.IsAvailable() )
-  {
-    CLog::Log(LOGNOTICE, "Webserver: Starting...");
-    CSectionLoader::Load("LIBHTTP");
-    m_pWebServer = new CWebServer();
-    m_pWebServer->Start(m_network.m_networkinfo.ip, atoi(g_guiSettings.GetString("services.webserverport")), "Q:\\web", false);
-    if (m_pWebServer)
-    {
-      m_pWebServer->SetUserName(g_guiSettings.GetString("services.webserverusername").c_str());
-       m_pWebServer->SetPassword(g_guiSettings.GetString("services.webserverpassword").c_str());
-    }
-    if (m_pWebServer && m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-      m_applicationMessenger.HttpApi("broadcastlevel; StartUp;1");
-  }
+	if (g_guiSettings.GetBool("services.webserver") && m_network.IsAvailable() )
+	{
+		CLog::Log(LOGNOTICE, "Webserver: Starting...");
+		CSectionLoader::Load("LIBHTTP");
+		m_pWebServer = new CWebServer();
+		m_pWebServer->Start(m_network.m_networkinfo.ip, atoi(g_guiSettings.GetString("services.webserverport")), "Q:\\system\\web", false);
+		if (m_pWebServer)
+		{
+			m_pWebServer->SetUserName(g_guiSettings.GetString("services.webserverusername").c_str());
+			m_pWebServer->SetPassword(g_guiSettings.GetString("services.webserverpassword").c_str());
+		}
+		if (m_pWebServer && m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		m_applicationMessenger.HttpApi("broadcastlevel; StartUp;1");
+	}
 }
 
 void CApplication::StopWebServer()
 {
-  if (m_pWebServer)
-  {
-    CLog::Log(LOGNOTICE, "Webserver: Stopping...");
-    m_pWebServer->Stop();
-    delete m_pWebServer;
-    m_pWebServer = NULL;
-    CSectionLoader::Unload("LIBHTTP");
-    CLog::Log(LOGNOTICE, "Webserver: Stopped...");
-  }
+	if (m_pWebServer)
+	{
+		CLog::Log(LOGNOTICE, "Webserver: Stopping...");
+		m_pWebServer->Stop();
+		delete m_pWebServer;
+		m_pWebServer = NULL;
+		CSectionLoader::Unload("LIBHTTP");
+		CLog::Log(LOGNOTICE, "Webserver: Stopped...");
+	}
 }
 
 void CApplication::StartFtpServer()
 {
 #ifdef HAS_FTP_SERVER
-  if ( g_guiSettings.GetBool("services.ftpserver") && m_network.IsAvailable() )
-  {
-    CLog::Log(LOGNOTICE, "XBFileZilla: Starting...");
-    if (!m_pFileZilla)
-    {
-      CStdString xmlpath = "special://xbmc/system/";
-      // if user didn't upgrade properly,
-      // check whether UserData/FileZilla Server.xml exists
-      if (CFile::Exists(g_settings.GetUserDataItem("FileZilla Server.xml")))
-        xmlpath = g_settings.GetUserDataFolder();
+	if ( g_guiSettings.GetBool("services.ftpserver") && m_network.IsAvailable() )
+	{
+		CLog::Log(LOGNOTICE, "XBFileZilla: Starting...");
+		if (!m_pFileZilla)
+		{
+			CStdString xmlpath = "special://xbmc/system/";
+			// if user didn't upgrade properly,
+			// check whether UserData/FileZilla Server.xml exists
+			if (CFile::Exists(g_settings.GetUserDataItem("FileZilla Server.xml")))
+			xmlpath = g_settings.GetUserDataFolder();
 
-      // check file size and presence
-      CFile xml;
-      if (xml.Open(xmlpath+"FileZilla Server.xml") && xml.GetLength() > 0)
-      {
-        m_pFileZilla = new CXBFileZilla(_P(xmlpath));
-        m_pFileZilla->Start(false);
-      }
-      else
-      {
-        // 'FileZilla Server.xml' does not exist or is corrupt, 
-        // falling back to ftp emergency recovery mode
-        CLog::Log(LOGNOTICE, "XBFileZilla: 'FileZilla Server.xml' is missing or is corrupt!");
-        CLog::Log(LOGNOTICE, "XBFileZilla: Starting ftp emergency recovery mode");
-        StartFtpEmergencyRecoveryMode();
-      }
-      xml.Close();
-    }
-  }
+			// check file size and presence
+			CFile xml;
+			if (xml.Open(xmlpath+"FileZilla Server.xml") && xml.GetLength() > 0)
+			{
+				m_pFileZilla = new CXBFileZilla(_P(xmlpath));
+				m_pFileZilla->Start(false);
+			}
+			else
+			{
+				// 'FileZilla Server.xml' does not exist or is corrupt, 
+				// falling back to ftp emergency recovery mode
+				CLog::Log(LOGNOTICE, "XBFileZilla: 'FileZilla Server.xml' is missing or is corrupt!");
+				CLog::Log(LOGNOTICE, "XBFileZilla: Starting ftp emergency recovery mode");
+				StartFtpEmergencyRecoveryMode();
+			}
+			xml.Close();
+		}
+	}
 #endif
 }
 
@@ -1514,27 +1637,27 @@
 void CApplication::StopFtpServer()
 {
 #ifdef HAS_FTP_SERVER
-  if (m_pFileZilla)
-  {
-    CLog::Log(LOGINFO, "XBFileZilla: Stopping...");
-/*
-    std::vector<SXFConnection> mConnections;
-    std::vector<SXFConnection>::iterator it;
+	if (m_pFileZilla)
+	{
+		CLog::Log(LOGINFO, "XBFileZilla: Stopping...");
+		/*
+	std::vector<SXFConnection> mConnections;
+	std::vector<SXFConnection>::iterator it;
 
-    m_pFileZilla->GetAllConnections(mConnections);
+	m_pFileZilla->GetAllConnections(mConnections);
 
-    for(it = mConnections.begin();it != mConnections.end();it++)
-    {
-      CLog(LOGDEBUG, "%s - Closing FTP connection %i", it->mId);
-      m_pFileZilla->CloseConnection(it->mId);
-    }
+	for(it = mConnections.begin();it != mConnections.end();it++)
+	{
+	CLog(LOGDEBUG, "%s - Closing FTP connection %i", it->mId);
+	m_pFileZilla->CloseConnection(it->mId);
+	}
 */
-    m_pFileZilla->Stop();
-    delete m_pFileZilla;
-    m_pFileZilla = NULL;
+		m_pFileZilla->Stop();
+		delete m_pFileZilla;
+		m_pFileZilla = NULL;
 
-    CLog::Log(LOGINFO, "XBFileZilla: Stopped");
-  }
+		CLog::Log(LOGINFO, "XBFileZilla: Stopped");
+	}
 #endif
 }
 
@@ -1541,17 +1664,17 @@
 void CApplication::StartTimeServer()
 {
 #ifdef HAS_TIME_SERVER
-  if (g_guiSettings.GetBool("locale.timeserver") && m_network.IsAvailable() )
-  {
-    if( !m_psntpClient )
-    {
-      CSectionLoader::Load("SNTP");
-      CLog::Log(LOGNOTICE, "start timeserver client");
+		if (g_guiSettings.GetBool("locale.timeserver") && m_network.IsAvailable() )
+		{
+			if( !m_psntpClient )
+			{
+				CSectionLoader::Load("SNTP");
+				CLog::Log(LOGNOTICE, "start timeserver client");
 
-      m_psntpClient = new CSNTPClient();
-      m_psntpClient->Update();
-    }
-  }
+				m_psntpClient = new CSNTPClient();
+				m_psntpClient->Update();
+			}
+		}
 #endif
 }
 
@@ -1558,12 +1681,12 @@
 void CApplication::StopTimeServer()
 {
 #ifdef HAS_TIME_SERVER
-  if( m_psntpClient )
-  {
-    CLog::Log(LOGNOTICE, "stop time server client");
-    SAFE_DELETE(m_psntpClient);
-    CSectionLoader::Unload("SNTP");
-  }
+	if( m_psntpClient )
+	{
+		CLog::Log(LOGNOTICE, "stop time server client");
+		SAFE_DELETE(m_psntpClient);
+		CSectionLoader::Unload("SNTP");
+	}
 #endif
 }
 
@@ -1570,8 +1693,8 @@
 void CApplication::StartUPnP()
 {
 #ifdef HAS_UPNP
-  StartUPnPServer();
-  StartUPnPRenderer();
+		StartUPnPServer();
+		StartUPnPRenderer();
 #endif
 }
 
@@ -1578,11 +1701,11 @@
 void CApplication::StopUPnP(bool bWait)
 {
 #ifdef HAS_UPNP
-  if (CUPnP::IsInstantiated())
-  {
-    CLog::Log(LOGNOTICE, "stopping upnp");
-    CUPnP::ReleaseInstance(bWait);
-  }
+	if (CUPnP::IsInstantiated())
+	{
+		CLog::Log(LOGNOTICE, "stopping upnp");
+		CUPnP::ReleaseInstance(bWait);
+	}
 #endif
 }
 
@@ -1589,17 +1712,17 @@
 void CApplication::StartEventServer()
 {
 #ifdef HAS_EVENT_SERVER
-  CEventServer* server = CEventServer::GetInstance();
-  if (!server)
-  {
-    CLog::Log(LOGERROR, "ES: Out of memory");
-    return;
-  }
-  if (g_guiSettings.GetBool("services.esenabled"))
-  {
-    CLog::Log(LOGNOTICE, "ES: Starting event server");
-    server->StartServer();
-  }
+		CEventServer* server = CEventServer::GetInstance();
+		if (!server)
+		{
+			CLog::Log(LOGERROR, "ES: Out of memory");
+			return;
+		}
+		if (g_guiSettings.GetBool("services.esenabled"))
+		{
+			CLog::Log(LOGNOTICE, "ES: Starting event server");
+			server->StartServer();
+		}
 #endif
 }
 
@@ -1606,43 +1729,43 @@
 bool CApplication::StopEventServer(bool promptuser)
 {
 #ifdef HAS_EVENT_SERVER
-  CEventServer* server = CEventServer::GetInstance();
-  if (!server)
-  {
-    CLog::Log(LOGERROR, "ES: Out of memory");
-    return false;
-  }
-  if (promptuser)
-  {
-    if (server->GetNumberOfClients() > 0)
-    {
-      bool cancelled = false;
-      if (!CGUIDialogYesNo::ShowAndGetInput(13140, 13141, 13142, 20022,
-                                            -1, -1, cancelled, 10000)
-          || cancelled)
-      {
-        CLog::Log(LOGNOTICE, "ES: Not stopping event server");
-        return false;
-      }
-    }
-    CLog::Log(LOGNOTICE, "ES: Stopping event server with confirmation");
-  }
-  else
-  {
-    CLog::Log(LOGNOTICE, "ES: Stopping event server");
-  }
-  CEventServer::GetInstance()->StopServer();
+	CEventServer* server = CEventServer::GetInstance();
+	if (!server)
+	{
+		CLog::Log(LOGERROR, "ES: Out of memory");
+		return false;
+	}
+	if (promptuser)
+	{
+		if (server->GetNumberOfClients() > 0)
+		{
+			bool cancelled = false;
+			if (!CGUIDialogYesNo::ShowAndGetInput(13140, 13141, 13142, 20022,
+						-1, -1, cancelled, 10000)
+					|| cancelled)
+			{
+				CLog::Log(LOGNOTICE, "ES: Not stopping event server");
+				return false;
+			}
+		}
+		CLog::Log(LOGNOTICE, "ES: Stopping event server with confirmation");
+	}
+	else
+	{
+		CLog::Log(LOGNOTICE, "ES: Stopping event server");
+	}
+	CEventServer::GetInstance()->StopServer();
 #endif
-  return true;
+	return true;
 }
 
 void CApplication::RefreshEventServer()
 {
 #ifdef HAS_EVENT_SERVER
-  if (g_guiSettings.GetBool("services.esenabled"))
-  {
-    CEventServer::GetInstance()->RefreshSettings();
-  }
+	if (g_guiSettings.GetBool("services.esenabled"))
+	{
+		CEventServer::GetInstance()->RefreshSettings();
+	}
 #endif
 }
 
@@ -1649,11 +1772,11 @@
 void CApplication::StartUPnPRenderer()
 {
 #ifdef HAS_UPNP
-  if (g_guiSettings.GetBool("services.upnprenderer"))
-  {
-    CLog::Log(LOGNOTICE, "starting upnp renderer");
-    CUPnP::GetInstance()->StartRenderer();
-  }
+	if (g_guiSettings.GetBool("services.upnprenderer"))
+	{
+		CLog::Log(LOGNOTICE, "starting upnp renderer");
+		CUPnP::GetInstance()->StartRenderer();
+	}
 #endif
 }
 
@@ -1660,11 +1783,11 @@
 void CApplication::StopUPnPRenderer()
 {
 #ifdef HAS_UPNP
-  if (CUPnP::IsInstantiated())
-  {
-    CLog::Log(LOGNOTICE, "stopping upnp renderer");
-    CUPnP::GetInstance()->StopRenderer();
-  }
+	if (CUPnP::IsInstantiated())
+	{
+		CLog::Log(LOGNOTICE, "stopping upnp renderer");
+		CUPnP::GetInstance()->StopRenderer();
+	}
 #endif
 }
 
@@ -1671,11 +1794,11 @@
 void CApplication::StartUPnPServer()
 {
 #ifdef HAS_UPNP
-  if (g_guiSettings.GetBool("services.upnpserver"))
-  {
-    CLog::Log(LOGNOTICE, "starting upnp server");
-    CUPnP::GetInstance()->StartServer();
-  }
+	if (g_guiSettings.GetBool("services.upnpserver"))
+	{
+		CLog::Log(LOGNOTICE, "starting upnp server");
+		CUPnP::GetInstance()->StartServer();
+	}
 #endif
 }
 
@@ -1682,11 +1805,11 @@
 void CApplication::StopUPnPServer()
 {
 #ifdef HAS_UPNP
-  if (CUPnP::IsInstantiated())
-  {
-    CLog::Log(LOGNOTICE, "stopping upnp server");
-    CUPnP::GetInstance()->StopServer();
-  }
+	if (CUPnP::IsInstantiated())
+	{
+		CLog::Log(LOGNOTICE, "stopping upnp server");
+		CUPnP::GetInstance()->StopServer();
+	}
 #endif
 }
 
@@ -1693,17 +1816,17 @@
 void CApplication::StartLEDControl(bool switchoff)
 {
 #ifdef HAS_XBOX_HARDWARE
-  if (switchoff && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_NO_CHANGE)
-  {
-    if ( IsPlayingVideo() && (g_guiSettings.GetInt("system.leddisableonplayback") == LED_PLAYBACK_VIDEO))
-      ILED::CLEDControl(LED_COLOUR_OFF);
-    if ( IsPlayingAudio() && (g_guiSettings.GetInt("system.leddisableonplayback") == LED_PLAYBACK_MUSIC))
-      ILED::CLEDControl(LED_COLOUR_OFF);
-    if ( ((IsPlayingVideo() || IsPlayingAudio())) && (g_guiSettings.GetInt("system.leddisableonplayback") == LED_PLAYBACK_VIDEO_MUSIC))
-      ILED::CLEDControl(LED_COLOUR_OFF);
-  }
-  else if (!switchoff)
-    ILED::CLEDControl(g_guiSettings.GetInt("system.ledcolour"));
+	if (switchoff && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_NO_CHANGE)
+	{
+		if ( IsPlayingVideo() && (g_guiSettings.GetInt("system.leddisableonplayback") == LED_PLAYBACK_VIDEO))
+		ILED::CLEDControl(LED_COLOUR_OFF);
+		if ( IsPlayingAudio() && (g_guiSettings.GetInt("system.leddisableonplayback") == LED_PLAYBACK_MUSIC))
+		ILED::CLEDControl(LED_COLOUR_OFF);
+		if ( ((IsPlayingVideo() || IsPlayingAudio())) && (g_guiSettings.GetInt("system.leddisableonplayback") == LED_PLAYBACK_VIDEO_MUSIC))
+		ILED::CLEDControl(LED_COLOUR_OFF);
+	}
+	else if (!switchoff)
+	ILED::CLEDControl(g_guiSettings.GetInt("system.ledcolour"));
 #endif
 }
 
@@ -1710,17 +1833,17 @@
 void CApplication::DimLCDOnPlayback(bool dim)
 {
 #ifdef HAS_LCD
-  if(g_lcd && dim && (g_guiSettings.GetInt("lcd.disableonplayback") != LED_PLAYBACK_OFF) && (g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE))
-  {
-    if ( (IsPlayingVideo()) && g_guiSettings.GetInt("lcd.disableonplayback") == LED_PLAYBACK_VIDEO)
-      g_lcd->SetBackLight(0);
-    if ( (IsPlayingAudio()) && g_guiSettings.GetInt("lcd.disableonplayback") == LED_PLAYBACK_MUSIC)
-      g_lcd->SetBackLight(0);
-    if ( ((IsPlayingVideo() || IsPlayingAudio())) && g_guiSettings.GetInt("lcd.disableonplayback") == LED_PLAYBACK_VIDEO_MUSIC)
-      g_lcd->SetBackLight(0);
-  }
-  else if(!dim)
-    g_lcd->SetBackLight(g_guiSettings.GetInt("lcd.backlight"));
+	if(g_lcd && dim && (g_guiSettings.GetInt("lcd.disableonplayback") != LED_PLAYBACK_OFF) && (g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE))
+	{
+		if ( (IsPlayingVideo()) && g_guiSettings.GetInt("lcd.disableonplayback") == LED_PLAYBACK_VIDEO)
+		g_lcd->SetBackLight(0);
+		if ( (IsPlayingAudio()) && g_guiSettings.GetInt("lcd.disableonplayback") == LED_PLAYBACK_MUSIC)
+		g_lcd->SetBackLight(0);
+		if ( ((IsPlayingVideo() || IsPlayingAudio())) && g_guiSettings.GetInt("lcd.disableonplayback") == LED_PLAYBACK_VIDEO_MUSIC)
+		g_lcd->SetBackLight(0);
+	}
+	else if(!dim)
+	g_lcd->SetBackLight(g_guiSettings.GetInt("lcd.backlight"));
 #endif
 }
 
@@ -1727,4118 +1850,4240 @@
 void CApplication::StartServices()
 {
 #ifdef HAS_XBOX_HARDWARE
-  if (g_advancedSettings.m_bPowerSave)
-  {
-    CLog::Log(LOGNOTICE, "Using idle thread with HLT (power saving)");
-    StartIdleThread();
-  }
-  else
-    CLog::Log(LOGNOTICE, "Not using idle thread with HLT (no power saving)");
+	if (g_advancedSettings.m_bPowerSave)
+	{
+		CLog::Log(LOGNOTICE, "Using idle thread with HLT (power saving)");
+		StartIdleThread();
+	}
+	else
+	CLog::Log(LOGNOTICE, "Not using idle thread with HLT (no power saving)");
 #endif
 
-  CheckDate();
-  StartLEDControl(false);
+	CheckDate();
+	StartLEDControl(false);
 
-  // Start Thread for DVD Mediatype detection
-  CLog::Log(LOGNOTICE, "start dvd mediatype detection");
-  m_DetectDVDType.Create(false, THREAD_MINSTACKSIZE);
+	// Start Thread for DVD Mediatype detection
+	CLog::Log(LOGNOTICE, "start dvd mediatype detection");
+	m_DetectDVDType.Create(false, THREAD_MINSTACKSIZE);
 
-  CLog::Log(LOGNOTICE, "initializing playlistplayer");
-  g_playlistPlayer.SetRepeat(PLAYLIST_MUSIC, g_settings.m_bMyMusicPlaylistRepeat ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
-  g_playlistPlayer.SetShuffle(PLAYLIST_MUSIC, g_settings.m_bMyMusicPlaylistShuffle);
-  g_playlistPlayer.SetRepeat(PLAYLIST_VIDEO, g_settings.m_bMyVideoPlaylistRepeat ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
-  g_playlistPlayer.SetShuffle(PLAYLIST_VIDEO, g_settings.m_bMyVideoPlaylistShuffle);
-  CLog::Log(LOGNOTICE, "DONE initializing playlistplayer");
+	CLog::Log(LOGNOTICE, "initializing playlistplayer");
+	g_playlistPlayer.SetRepeat(PLAYLIST_MUSIC, g_settings.m_bMyMusicPlaylistRepeat ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
+	g_playlistPlayer.SetShuffle(PLAYLIST_MUSIC, g_settings.m_bMyMusicPlaylistShuffle);
+	g_playlistPlayer.SetRepeat(PLAYLIST_VIDEO, g_settings.m_bMyVideoPlaylistRepeat ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
+	g_playlistPlayer.SetShuffle(PLAYLIST_VIDEO, g_settings.m_bMyVideoPlaylistShuffle);
+	CLog::Log(LOGNOTICE, "DONE initializing playlistplayer");
 
 #ifdef HAS_LCD
-  CLCDFactory factory;
-  g_lcd = factory.Create();
-  if (g_lcd)
-  {
-    g_lcd->Initialize();
-  }
+	CLCDFactory factory;
+	g_lcd = factory.Create();
+	if (g_lcd)
+	{
+		g_lcd->Initialize();
+	}
 #endif
 
 #ifdef HAS_XBOX_HARDWARE
-  if (g_guiSettings.GetBool("system.autotemperature"))
-  {
-    CLog::Log(LOGNOTICE, "start fancontroller");
-    CFanController::Instance()->Start(g_guiSettings.GetInt("system.targettemperature"), g_guiSettings.GetInt("system.minfanspeed"));
-  }
-  else if (g_guiSettings.GetBool("system.fanspeedcontrol"))
-  {
-    CLog::Log(LOGNOTICE, "setting fanspeed");
-    CFanController::Instance()->SetFanSpeed(g_guiSettings.GetInt("system.fanspeed"));
-  }
-  int setting_level = g_guiSettings.GetInt("harddisk.aamlevel");
-  if (setting_level == AAM_QUIET)
-    XKHDD::SetAAMLevel(0x80);
-  else if (setting_level == AAM_FAST)
-    XKHDD::SetAAMLevel(0xFE);
-  setting_level = g_guiSettings.GetInt("harddisk.apmlevel");
-  switch(setting_level)
-  {
-  case APM_LOPOWER:
-    XKHDD::SetAPMLevel(0x80);
-    break;
-  case APM_HIPOWER:
-    XKHDD::SetAPMLevel(0xFE);
-    break;
-  case APM_LOPOWER_STANDBY:
-    XKHDD::SetAPMLevel(0x01);
-    break;
-  case APM_HIPOWER_STANDBY:
-    XKHDD::SetAPMLevel(0x7F);
-    break;
-  }
+	if (g_guiSettings.GetBool("system.autotemperature"))
+	{
+		CLog::Log(LOGNOTICE, "start fancontroller");
+		CFanController::Instance()->Start(g_guiSettings.GetInt("system.targettemperature"), g_guiSettings.GetInt("system.minfanspeed"));
+	}
+	else if (g_guiSettings.GetBool("system.fanspeedcontrol"))
+	{
+		CLog::Log(LOGNOTICE, "setting fanspeed");
+		CFanController::Instance()->SetFanSpeed(g_guiSettings.GetInt("system.fanspeed"));
+	}
+	int setting_level = g_guiSettings.GetInt("harddisk.aamlevel");
+	if (setting_level == AAM_QUIET)
+	XKHDD::SetAAMLevel(0x80);
+	else if (setting_level == AAM_FAST)
+	XKHDD::SetAAMLevel(0xFE);
+	setting_level = g_guiSettings.GetInt("harddisk.apmlevel");
+	switch(setting_level)
+	{
+	case APM_LOPOWER:
+		XKHDD::SetAPMLevel(0x80);
+		break;
+	case APM_HIPOWER:
+		XKHDD::SetAPMLevel(0xFE);
+		break;
+	case APM_LOPOWER_STANDBY:
+		XKHDD::SetAPMLevel(0x01);
+		break;
+	case APM_HIPOWER_STANDBY:
+		XKHDD::SetAPMLevel(0x7F);
+		break;
+	}
 #endif
 }
 
 void CApplication::CheckDate()
 {
-  CLog::Log(LOGNOTICE, "Checking the Date!");
-  // Check the Date: Year, if it is  above 2099 set to 2004!
-  SYSTEMTIME CurTime;
-  SYSTEMTIME NewTime;
-  GetLocalTime(&CurTime);
-  GetLocalTime(&NewTime);
-  CLog::Log(LOGINFO, "Current Date is: %i-%i-%i", CurTime.wDay, CurTime.wMonth, CurTime.wYear);
-  if ((CurTime.wYear > 2099) || (CurTime.wYear < 2001) )        // XBOX MS Dashboard also uses min/max DateYear 2001/2099 !!
-  {
-    CLog::Log(LOGNOTICE, "- The Date is Wrong: Setting New Date!");
-    NewTime.wYear       = 2004; // 2004
-    NewTime.wMonth      = 1;  // January
-    NewTime.wDayOfWeek  = 1;  // Monday
-    NewTime.wDay        = 5;  // Monday 05.01.2004!!
-    NewTime.wHour       = 12;
-    NewTime.wMinute     = 0;
+	CLog::Log(LOGNOTICE, "Checking the Date!");
+	// Check the Date: Year, if it is  above 2099 set to 2004!
+	SYSTEMTIME CurTime;
+	SYSTEMTIME NewTime;
+	GetLocalTime(&CurTime);
+	GetLocalTime(&NewTime);
+	CLog::Log(LOGINFO, "Current Date is: %i-%i-%i", CurTime.wDay, CurTime.wMonth, CurTime.wYear);
+	if ((CurTime.wYear > 2099) || (CurTime.wYear < 2001) )        // XBOX MS Dashboard also uses min/max DateYear 2001/2099 !!
+	{
+		CLog::Log(LOGNOTICE, "- The Date is Wrong: Setting New Date!");
+		NewTime.wYear       = 2020; // 2020
+		NewTime.wMonth      = 1;  // January
+		NewTime.wDayOfWeek  = 1;  // Monday
+		NewTime.wDay        = 1;  // Monday 01.01.2019!!
+		NewTime.wHour       = 12;
+		NewTime.wMinute     = 0;
 
-    FILETIME stNewTime, stCurTime;
-    SystemTimeToFileTime(&NewTime, &stNewTime);
-    SystemTimeToFileTime(&CurTime, &stCurTime);
+		FILETIME stNewTime, stCurTime;
+		SystemTimeToFileTime(&NewTime, &stNewTime);
+		SystemTimeToFileTime(&CurTime, &stCurTime);
 #ifdef HAS_XBOX_HARDWARE
-    NtSetSystemTime(&stNewTime, &stCurTime);    // Set a Default Year 2004!
+		NtSetSystemTime(&stNewTime, &stCurTime);    // Set a Default Year 2020!
 #endif
-    CLog::Log(LOGNOTICE, "- New Date is now: %i-%i-%i",NewTime.wDay, NewTime.wMonth, NewTime.wYear);
-  }
-  return ;
+		CLog::Log(LOGNOTICE, "- New Date is now: %i-%i-%i",NewTime.wDay, NewTime.wMonth, NewTime.wYear);
+	}
+	return ;
 }
 
 void CApplication::StopServices()
 {
-  m_network.NetworkMessage(CNetwork::SERVICES_DOWN, 0);
+	m_network.NetworkMessage(CNetwork::SERVICES_DOWN, 0);
 
-  CLog::Log(LOGNOTICE, "stop dvd detect media");
-  m_DetectDVDType.StopThread();
+	CLog::Log(LOGNOTICE, "stop dvd detect media");
+	m_DetectDVDType.StopThread();
 
 #ifdef HAS_XBOX_HARDWARE
-  CLog::Log(LOGNOTICE, "stop fancontroller");
-  CFanController::Instance()->Stop();
-  CFanController::RemoveInstance();
-  if (g_advancedSettings.m_bPowerSave)
-    StopIdleThread();
+	CLog::Log(LOGNOTICE, "stop fancontroller");
+	CFanController::Instance()->Stop();
+	CFanController::RemoveInstance();
+	if (g_advancedSettings.m_bPowerSave)
+	StopIdleThread();
 #endif  
 }
 
 void CApplication::DelayLoadSkin()
 {
-  m_skinReloadTime = CTimeUtils::GetFrameTime() + 2000;
-  return ;
+	m_skinReloadTime = CTimeUtils::GetFrameTime() + 2000;
+	return ;
 }
 
 void CApplication::CancelDelayLoadSkin()
 {
-  m_skinReloadTime = 0;
+	m_skinReloadTime = 0;
 }
 
 void CApplication::ReloadSkin()
 {
-  CGUIMessage msg(GUI_MSG_LOAD_SKIN, -1, g_windowManager.GetActiveWindow());
-  g_windowManager.SendMessage(msg);
-  // Reload the skin, restoring the previously focused control.  We need this as
-  // the window unload will reset all control states.
-  CGUIWindow* pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
-  int iCtrlID = pWindow->GetFocusedControlID();
-  g_application.LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
-  pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
-  if (pWindow && pWindow->HasSaveLastControl())
-  {
-    CGUIMessage msg3(GUI_MSG_SETFOCUS, g_windowManager.GetActiveWindow(), iCtrlID, 0);
-    pWindow->OnMessage(msg3);
-  }
+	CGUIMessage msg(GUI_MSG_LOAD_SKIN, -1, g_windowManager.GetActiveWindow());
+	g_windowManager.SendMessage(msg);
+	// Reload the skin, restoring the previously focused control.  We need this as
+	// the window unload will reset all control states.
+	CGUIWindow* pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
+	int iCtrlID = pWindow->GetFocusedControlID();
+	g_application.LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
+	pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
+	if (pWindow && pWindow->HasSaveLastControl())
+	{
+		CGUIMessage msg3(GUI_MSG_SETFOCUS, g_windowManager.GetActiveWindow(), iCtrlID, 0);
+		pWindow->OnMessage(msg3);
+	}
 }
 
 void CApplication::LoadSkin(const CStdString& strSkin)
 {
-  bool bPreviousPlayingState=false;
-  bool bPreviousRenderingState=false;
-  if (g_application.m_pPlayer && g_application.IsPlayingVideo())
-  {
-    bPreviousPlayingState = !g_application.m_pPlayer->IsPaused();
-    if (bPreviousPlayingState)
-      g_application.m_pPlayer->Pause();
+	bool bPreviousPlayingState=false;
+	bool bPreviousRenderingState=false;
+	if (g_application.m_pPlayer && g_application.IsPlayingVideo())
+	{
+		bPreviousPlayingState = !g_application.m_pPlayer->IsPaused();
+		if (bPreviousPlayingState)
+		g_application.m_pPlayer->Pause();
 #ifdef HAS_VIDEO_PLAYBACK
-    if (!g_renderManager.Paused())
-    {
-      if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
-     {
-        g_windowManager.ActivateWindow(WINDOW_HOME);
-        bPreviousRenderingState = true;
-      }
-    }
+		if (!g_renderManager.Paused())
+		{
+			if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+			{
+				g_windowManager.ActivateWindow(WINDOW_HOME);
+				bPreviousRenderingState = true;
+			}
+		}
 #endif
-  }
-  //stop the busy renderer if it's running before we lock the graphiccontext or we could deadlock.
-  g_ApplicationRenderer.Stop();
-  // close the music and video overlays (they're re-opened automatically later)
-  CSingleLock lock(g_graphicsContext);
+	}
+	//stop the busy renderer if it's running before we lock the graphiccontext or we could deadlock.
+	g_ApplicationRenderer.Stop();
+	// close the music and video overlays (they're re-opened automatically later)
+	CSingleLock lock(g_graphicsContext);
 
-  m_skinReloadTime = 0;
+	m_skinReloadTime = 0;
 
-  CStdString strHomePath;
-  CStdString strSkinPath = "Q:\\skin\\" + strSkin;
+	CStdString strHomePath;
+	CStdString strSkinPath = "special://xbmc/emustation/themes/" + strSkin;
 
-  CLog::Log(LOGINFO, "  load skin from:%s", strSkinPath.c_str());
+	CLog::Log(LOGINFO, "  load skin from:%s", strSkinPath.c_str());
 
-  // save the current window details
-  int currentWindow = g_windowManager.GetActiveWindow();
-  vector<int> currentModelessWindows;
-  g_windowManager.GetActiveModelessWindows(currentModelessWindows);
+	// save the current window details
+	int currentWindow = g_windowManager.GetActiveWindow();
+	vector<int> currentModelessWindows;
+	g_windowManager.GetActiveModelessWindows(currentModelessWindows);
 
-  CLog::Log(LOGINFO, "  delete old skin...");
-  UnloadSkin();
+	CLog::Log(LOGINFO, "  delete old skin...");
+	UnloadSkin();
 
-  // Load in the skin.xml file if it exists
-  g_SkinInfo.Load(strSkinPath);
+	// Load in the skin.xml file if it exists
+	g_SkinInfo.Load(strSkinPath);
 
-  CLog::Log(LOGINFO, "  load fonts for skin...");
-  g_graphicsContext.SetMediaDir(strSkinPath);
-  g_directoryCache.ClearSubPaths(strSkinPath);
-  if (g_langInfo.ForceUnicodeFont() && !g_fontManager.IsFontSetUnicode(g_guiSettings.GetString("lookandfeel.font")))
-  {
-    CLog::Log(LOGINFO, "    language needs a ttf font, loading first ttf font available");
-    CStdString strFontSet;
-    if (g_fontManager.GetFirstFontSetUnicode(strFontSet))
-    {
-      CLog::Log(LOGINFO, "    new font is '%s'", strFontSet.c_str());
-      g_guiSettings.SetString("lookandfeel.font", strFontSet);
-      g_settings.Save();
-    }
-    else
-      CLog::Log(LOGERROR, "    no ttf font found, but needed for the language %s.", g_guiSettings.GetString("locale.language").c_str());
-  }
-  g_colorManager.Load(g_guiSettings.GetString("lookandfeel.skincolors"));
+	CLog::Log(LOGINFO, "  load fonts for skin...");
+	g_graphicsContext.SetMediaDir(strSkinPath);
+	g_directoryCache.ClearSubPaths(strSkinPath);
+	if (g_langInfo.ForceUnicodeFont() && !g_fontManager.IsFontSetUnicode(g_guiSettings.GetString("lookandfeel.font")))
+	{
+		CLog::Log(LOGINFO, "    language needs a ttf font, loading first ttf font available");
+		CStdString strFontSet;
+		if (g_fontManager.GetFirstFontSetUnicode(strFontSet))
+		{
+			CLog::Log(LOGINFO, "    new font is '%s'", strFontSet.c_str());
+			g_guiSettings.SetString("lookandfeel.font", strFontSet);
+			g_settings.Save();
+		}
+		else
+		CLog::Log(LOGERROR, "    no ttf font found, but needed for the language %s.", g_guiSettings.GetString("locale.language").c_str());
+	}
+	g_colorManager.Load(g_guiSettings.GetString("lookandfeel.skincolors"));
 
-  g_fontManager.LoadFonts(g_guiSettings.GetString("lookandfeel.font"));
+	g_fontManager.LoadFonts(g_guiSettings.GetString("lookandfeel.font"));
 
-  // load in the skin strings
-  CStdString langPath;
-  URIUtils::AddFileToFolder(strSkinPath, "language", langPath);
-  URIUtils::AddSlashAtEnd(langPath);
+	// load in the skin strings
+	CStdString langPath;
+	URIUtils::AddFileToFolder(strSkinPath, "language", langPath);
+	URIUtils::AddSlashAtEnd(langPath);
 
-  g_localizeStrings.LoadSkinStrings(langPath, g_guiSettings.GetString("locale.language"));
+	g_localizeStrings.LoadSkinStrings(langPath, g_guiSettings.GetString("locale.language"));
 
-  LARGE_INTEGER start;
-  QueryPerformanceCounter(&start);
+	LARGE_INTEGER start;
+	QueryPerformanceCounter(&start);
 
-  CLog::Log(LOGINFO, "  load new skin...");
-  CGUIWindowHome *pHome = (CGUIWindowHome *)g_windowManager.GetWindow(WINDOW_HOME);
-  if (!g_SkinInfo.Check(strSkinPath) || !pHome || !pHome->Load("Home.xml"))
-  {
-    // failed to load home.xml
-    // fallback to default skin
-    if ( strcmpi(strSkin.c_str(), DEFAULT_SKIN) != 0)
-    {
-      CLog::Log(LOGERROR, "failed to load home.xml for skin:%s, fallback to \"%s\" skin", strSkin.c_str(), DEFAULT_SKIN);
-      g_guiSettings.SetString("lookandfeel.skin", DEFAULT_SKIN);
-      LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
-      return ;
-    }
-  }
+	CLog::Log(LOGINFO, "  load new skin...");
+	CGUIWindowHome *pHome = (CGUIWindowHome *)g_windowManager.GetWindow(WINDOW_HOME);
+	if (!g_SkinInfo.Check(strSkinPath) || !pHome || !pHome->Load("Home.xml"))
+	{
+		// failed to load home.xml
+		// fallback to default skin
+		if ( strcmpi(strSkin.c_str(), DEFAULT_SKIN) != 0)
+		{
+			CLog::Log(LOGERROR, "failed to load home.xml for skin:%s, fallback to \"%s\" skin", strSkin.c_str(), DEFAULT_SKIN);
+			g_guiSettings.SetString("lookandfeel.skin", DEFAULT_SKIN);
+			LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
+			return ;
+		}
+	}
 
-  // Load the user windows
-  LoadUserWindows();
+	// Load the user windows
+	LoadUserWindows();
+	LoadUserWindowsalt();
 
-  LARGE_INTEGER end, freq;
-  QueryPerformanceCounter(&end);
-  QueryPerformanceFrequency(&freq);
-  CLog::Log(LOGDEBUG,"Load Skin XML: %.2fms", 1000.f * (end.QuadPart - start.QuadPart) / freq.QuadPart);
+	LARGE_INTEGER end, freq;
+	QueryPerformanceCounter(&end);
+	QueryPerformanceFrequency(&freq);
+	CLog::Log(LOGDEBUG,"Load Skin XML: %.2fms", 1000.f * (end.QuadPart - start.QuadPart) / freq.QuadPart);
 
-  CLog::Log(LOGINFO, "  initialize new skin...");
-  m_guiPointer.AllocResources(true);
-  m_guiDialogVolumeBar.AllocResources(true);
-  m_guiDialogSeekBar.AllocResources(true);
-  m_guiDialogKaiToast.AllocResources(true);
-  m_guiDialogMuteBug.AllocResources(true);
-  g_windowManager.AddMsgTarget(this);
-  g_windowManager.AddMsgTarget(&g_playlistPlayer);
-  g_windowManager.AddMsgTarget(&g_infoManager);
-  g_windowManager.SetCallback(*this);
-  g_windowManager.Initialize();
-  g_audioManager.Initialize(CAudioContext::DEFAULT_DEVICE);
-  g_audioManager.Load();
+	CLog::Log(LOGINFO, "  initialize new skin...");
+	m_guiPointer.AllocResources(true);
+	m_guiDialogVolumeBar.AllocResources(true);
+	m_guiDialogSeekBar.AllocResources(true);
+	m_guiDialogKaiToast.AllocResources(true);
+	m_guiDialogMuteBug.AllocResources(true);
+	g_windowManager.AddMsgTarget(this);
+	g_windowManager.AddMsgTarget(&g_playlistPlayer);
+	g_windowManager.AddMsgTarget(&g_infoManager);
+	g_windowManager.SetCallback(*this);
+	g_windowManager.Initialize();
+	g_audioManager.Initialize(CAudioContext::DEFAULT_DEVICE);
+	g_audioManager.Load();
 
-  if (g_SkinInfo.HasSkinFile("DialogFullScreenInfo.xml"))
-    g_windowManager.Add(new CGUIDialogFullScreenInfo);
+	if (g_SkinInfo.HasSkinFile("DialogFullScreenInfo.xml"))
+	g_windowManager.Add(new CGUIDialogFullScreenInfo);
 
-  CLog::Log(LOGINFO, "  skin loaded...");
+	CLog::Log(LOGINFO, "  skin loaded...");
 
-  // leave the graphics lock
-  lock.Leave();
-  g_ApplicationRenderer.Start();
+	// leave the graphics lock
+	lock.Leave();
+	g_ApplicationRenderer.Start();
 
-  // restore windows
-  if (currentWindow != WINDOW_INVALID)
-  {
-    g_windowManager.ActivateWindow(currentWindow);
-    for (unsigned int i = 0; i < currentModelessWindows.size(); i++)
-    {
-      CGUIDialog *dialog = (CGUIDialog *)g_windowManager.GetWindow(currentModelessWindows[i]);
-      if (dialog) dialog->Show();
-    }
-  }
+	// restore windows
+	if (currentWindow != WINDOW_INVALID)
+	{
+		g_windowManager.ActivateWindow(currentWindow);
+		for (unsigned int i = 0; i < currentModelessWindows.size(); i++)
+		{
+			CGUIDialog *dialog = (CGUIDialog *)g_windowManager.GetWindow(currentModelessWindows[i]);
+			if (dialog) dialog->Show();
+		}
+	}
 
-  if (g_application.m_pPlayer && g_application.IsPlayingVideo())
-  {
-    if (bPreviousPlayingState)
-      g_application.m_pPlayer->Pause();
-    if (bPreviousRenderingState)
-      g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
-  }
+	if (g_application.m_pPlayer && g_application.IsPlayingVideo())
+	{
+		if (bPreviousPlayingState)
+		g_application.m_pPlayer->Pause();
+		if (bPreviousRenderingState)
+		g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+	}
 }
 
 void CApplication::UnloadSkin()
 {
-  g_ApplicationRenderer.Stop();
-  g_audioManager.DeInitialize(CAudioContext::DEFAULT_DEVICE);
+	g_ApplicationRenderer.Stop();
+	g_audioManager.DeInitialize(CAudioContext::DEFAULT_DEVICE);
 
-  g_windowManager.DeInitialize();
+	g_windowManager.DeInitialize();
 
-  //These windows are not handled by the windowmanager (why not?) so we should unload them manually
-  CGUIMessage msg(GUI_MSG_WINDOW_DEINIT, 0, 0);
-  m_guiPointer.OnMessage(msg);
-  m_guiPointer.ResetControlStates();
-  m_guiPointer.FreeResources(true);
-  m_guiDialogMuteBug.OnMessage(msg);
-  m_guiDialogMuteBug.ResetControlStates();
-  m_guiDialogMuteBug.FreeResources(true);
+	//These windows are not handled by the windowmanager (why not?) so we should unload them manually
+	CGUIMessage msg(GUI_MSG_WINDOW_DEINIT, 0, 0);
+	m_guiPointer.OnMessage(msg);
+	m_guiPointer.ResetControlStates();
+	m_guiPointer.FreeResources(true);
+	m_guiDialogMuteBug.OnMessage(msg);
+	m_guiDialogMuteBug.ResetControlStates();
+	m_guiDialogMuteBug.FreeResources(true);
 
-  // remove the skin-dependent window
-  g_windowManager.Delete(WINDOW_DIALOG_FULLSCREEN_INFO);
+	// remove the skin-dependent window
+	g_windowManager.Delete(WINDOW_DIALOG_FULLSCREEN_INFO);
 
-  g_TextureManager.Cleanup();
+	g_TextureManager.Cleanup();
 
-  g_fontManager.Clear();
+	g_fontManager.Clear();
 
-  g_colorManager.Clear();
+	g_colorManager.Clear();
 
-  g_charsetConverter.reset();
+	g_charsetConverter.reset();
 
-  g_infoManager.Clear();
+	g_infoManager.Clear();
 }
 
 bool CApplication::LoadUserWindows()
 {
-  // Start from wherever home.xml is
+	// Start from wherever home.xml is
 
-  std::vector<CStdString> vecSkinPath;
-  g_SkinInfo.GetSkinPaths(vecSkinPath);
-  for (unsigned int i = 0;i < vecSkinPath.size();++i)
-  {
-    CStdString strPath = URIUtils::AddFileToFolder(vecSkinPath[i], "custom*.xml");
-    CLog::Log(LOGINFO, "Loading user windows, path %s", vecSkinPath[i].c_str());
-    WIN32_FIND_DATA NextFindFileData;
-    HANDLE hFind = FindFirstFile(_P(strPath).c_str(), &NextFindFileData);
-    while (hFind != INVALID_HANDLE_VALUE)
-    {
-      WIN32_FIND_DATA FindFileData = NextFindFileData;
+	std::vector<CStdString> vecSkinPath;
+	g_SkinInfo.GetSkinPaths(vecSkinPath);
+	for (unsigned int i = 0;i < vecSkinPath.size();++i)
+	{
+		CStdString strPath = URIUtils::AddFileToFolder(vecSkinPath[i], "custom*.xml");
+		CLog::Log(LOGINFO, "Loading user windows, path %s", vecSkinPath[i].c_str());
+		WIN32_FIND_DATA NextFindFileData;
+		HANDLE hFind = FindFirstFile(_P(strPath).c_str(), &NextFindFileData);
+		while (hFind != INVALID_HANDLE_VALUE)
+		{
+			WIN32_FIND_DATA FindFileData = NextFindFileData;
 
-      if (!FindNextFile(hFind, &NextFindFileData))
-      {
-        FindClose(hFind);
-        hFind = INVALID_HANDLE_VALUE;
-      }
+			if (!FindNextFile(hFind, &NextFindFileData))
+			{
+				FindClose(hFind);
+				hFind = INVALID_HANDLE_VALUE;
+			}
 
-      // skip "up" directories, which come in all queries
-      if (!strcmp(FindFileData.cFileName, ".") || !strcmp(FindFileData.cFileName, ".."))
-        continue;
+			// skip "up" directories, which come in all queries
+			if (!strcmp(FindFileData.cFileName, ".") || !strcmp(FindFileData.cFileName, ".."))
+			continue;
 
-      CStdString strFileName = URIUtils::AddFileToFolder(vecSkinPath[i], FindFileData.cFileName);
-      CLog::Log(LOGINFO, "Loading skin file: %s", strFileName.c_str());
-      CStdString strLower(FindFileData.cFileName);
-      strLower.MakeLower();
-      strLower = URIUtils::AddFileToFolder(vecSkinPath[i], strLower);
-      TiXmlDocument xmlDoc;
-      if (!xmlDoc.LoadFile(strFileName) && !xmlDoc.LoadFile(strLower))
-      {
-        CLog::Log(LOGERROR, "unable to load:%s, Line %d\n%s", strFileName.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
-        continue;
-      }
+			CStdString strFileName = URIUtils::AddFileToFolder(vecSkinPath[i], FindFileData.cFileName);
+			CLog::Log(LOGINFO, "Loading skin file: %s", strFileName.c_str());
+			CStdString strLower(FindFileData.cFileName);
+			strLower.MakeLower();
+			strLower = URIUtils::AddFileToFolder(vecSkinPath[i], strLower);
+			TiXmlDocument xmlDoc;
+			if (!xmlDoc.LoadFile(strFileName) && !xmlDoc.LoadFile(strLower))
+			{
+				CLog::Log(LOGERROR, "unable to load:%s, Line %d\n%s", strFileName.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+				continue;
+			}
 
-      // Root element should be <window>
-      TiXmlElement* pRootElement = xmlDoc.RootElement();
-      CStdString strValue = pRootElement->Value();
-      if (!strValue.Equals("window"))
-      {
-        CLog::Log(LOGERROR, "file :%s doesnt contain <window>", strFileName.c_str());
-        continue;
-      }
+			// Root element should be <window>
+			TiXmlElement* pRootElement = xmlDoc.RootElement();
+			CStdString strValue = pRootElement->Value();
+			if (!strValue.Equals("window"))
+			{
+				CLog::Log(LOGERROR, "file :%s doesnt contain <window>", strFileName.c_str());
+				continue;
+			}
 
-      // Read the <type> element to get the window type to create
-      // If no type is specified, create a CGUIWindow as default
-      CGUIWindow* pWindow = NULL;
-      CStdString strType;
-      if (pRootElement->Attribute("type"))
-        strType = pRootElement->Attribute("type");
-      else
-      {
-        const TiXmlNode *pType = pRootElement->FirstChild("type");
-        if (pType && pType->FirstChild())
-          strType = pType->FirstChild()->Value();
-      }
-      int id = WINDOW_INVALID;
-      if (!pRootElement->Attribute("id", &id))
-      {
-        const TiXmlNode *pType = pRootElement->FirstChild("id");
-        if (pType && pType->FirstChild())
-          id = atol(pType->FirstChild()->Value());
-      }
-      int visibleCondition = 0;
-      CGUIControlFactory::GetConditionalVisibility(pRootElement, visibleCondition);
+			// Read the <type> element to get the window type to create
+			// If no type is specified, create a CGUIWindow as default
+			CGUIWindow* pWindow = NULL;
+			CStdString strType;
+			if (pRootElement->Attribute("type"))
+			strType = pRootElement->Attribute("type");
+			else
+			{
+				const TiXmlNode *pType = pRootElement->FirstChild("type");
+				if (pType && pType->FirstChild())
+				strType = pType->FirstChild()->Value();
+			}
+			int id = WINDOW_INVALID;
+			if (!pRootElement->Attribute("id", &id))
+			{
+				const TiXmlNode *pType = pRootElement->FirstChild("id");
+				if (pType && pType->FirstChild())
+				id = atol(pType->FirstChild()->Value());
+			}
+			int visibleCondition = 0;
+			CGUIControlFactory::GetConditionalVisibility(pRootElement, visibleCondition);
 
-      if (strType.Equals("dialog"))
-        pWindow = new CGUIDialog(id + WINDOW_HOME, FindFileData.cFileName);
-      else if (strType.Equals("submenu"))
-        pWindow = new CGUIDialogSubMenu(id + WINDOW_HOME, FindFileData.cFileName);
-      else if (strType.Equals("buttonmenu"))
-        pWindow = new CGUIDialogButtonMenu(id + WINDOW_HOME, FindFileData.cFileName);
-      else
-        pWindow = new CGUIStandardWindow(id + WINDOW_HOME, FindFileData.cFileName);
+			if (strType.Equals("dialog"))
+			pWindow = new CGUIDialog(id + WINDOW_HOME, FindFileData.cFileName);
+			else if (strType.Equals("submenu"))
+			pWindow = new CGUIDialogSubMenu(id + WINDOW_HOME, FindFileData.cFileName);
+			else if (strType.Equals("buttonmenu"))
+			pWindow = new CGUIDialogButtonMenu(id + WINDOW_HOME, FindFileData.cFileName);
+			else
+			pWindow = new CGUIStandardWindow(id + WINDOW_HOME, FindFileData.cFileName);
 
-      // Check to make sure the pointer isn't still null
-      if (pWindow == NULL)
-      {
-        CLog::Log(LOGERROR, "Out of memory / Failed to create new object in LoadUserWindows");
-        return false;
-      }
-      if (id == WINDOW_INVALID || g_windowManager.GetWindow(WINDOW_HOME + id))
-      {
-        delete pWindow;
-        continue;
-      }
-      pWindow->SetVisibleCondition(visibleCondition, false);
-      g_windowManager.AddCustomWindow(pWindow);
-    }
-    CloseHandle(hFind);
-  }
-  return true;
+			// Check to make sure the pointer isn't still null
+			if (pWindow == NULL)
+			{
+				CLog::Log(LOGERROR, "Out of memory / Failed to create new object in LoadUserWindows");
+				return false;
+			}
+			if (id == WINDOW_INVALID || g_windowManager.GetWindow(WINDOW_HOME + id))
+			{
+				delete pWindow;
+				continue;
+			}
+			pWindow->SetVisibleCondition(visibleCondition, false);
+			g_windowManager.AddCustomWindow(pWindow);
+		}
+		CloseHandle(hFind);
+	}
+	return true;
 }
 
+bool CApplication::LoadUserWindowsalt()
+{
+	// Start from wherever home.xml is
+
+	std::vector<CStdString> vecSkinPath;
+	g_SkinInfo.GetSkinPaths(vecSkinPath);
+	for (unsigned int i = 0;i < vecSkinPath.size();++i)
+	{
+		CStdString strPath = URIUtils::AddFileToFolder(vecSkinPath[i], "_script*.xml");
+		CLog::Log(LOGINFO, "Loading user windows, path %s", vecSkinPath[i].c_str());
+		WIN32_FIND_DATA NextFindFileData;
+		HANDLE hFind = FindFirstFile(_P(strPath).c_str(), &NextFindFileData);
+		while (hFind != INVALID_HANDLE_VALUE)
+		{
+			WIN32_FIND_DATA FindFileData = NextFindFileData;
+
+			if (!FindNextFile(hFind, &NextFindFileData))
+			{
+				FindClose(hFind);
+				hFind = INVALID_HANDLE_VALUE;
+			}
+
+			// skip "up" directories, which come in all queries
+			if (!strcmp(FindFileData.cFileName, ".") || !strcmp(FindFileData.cFileName, ".."))
+			continue;
+
+			CStdString strFileName = URIUtils::AddFileToFolder(vecSkinPath[i], FindFileData.cFileName);
+			CLog::Log(LOGINFO, "Loading skin file: %s", strFileName.c_str());
+			CStdString strLower(FindFileData.cFileName);
+			strLower.MakeLower();
+			strLower = URIUtils::AddFileToFolder(vecSkinPath[i], strLower);
+			TiXmlDocument xmlDoc;
+			if (!xmlDoc.LoadFile(strFileName) && !xmlDoc.LoadFile(strLower))
+			{
+				CLog::Log(LOGERROR, "unable to load:%s, Line %d\n%s", strFileName.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+				continue;
+			}
+
+			// Root element should be <window>
+			TiXmlElement* pRootElement = xmlDoc.RootElement();
+			CStdString strValue = pRootElement->Value();
+			if (!strValue.Equals("window"))
+			{
+				CLog::Log(LOGERROR, "file :%s doesnt contain <window>", strFileName.c_str());
+				continue;
+			}
+
+			// Read the <type> element to get the window type to create
+			// If no type is specified, create a CGUIWindow as default
+			CGUIWindow* pWindow = NULL;
+			CStdString strType;
+			if (pRootElement->Attribute("type"))
+			strType = pRootElement->Attribute("type");
+			else
+			{
+				const TiXmlNode *pType = pRootElement->FirstChild("type");
+				if (pType && pType->FirstChild())
+				strType = pType->FirstChild()->Value();
+			}
+			int id = WINDOW_INVALID;
+			if (!pRootElement->Attribute("id", &id))
+			{
+				const TiXmlNode *pType = pRootElement->FirstChild("id");
+				if (pType && pType->FirstChild())
+				id = atol(pType->FirstChild()->Value());
+			}
+			int visibleCondition = 0;
+			CGUIControlFactory::GetConditionalVisibility(pRootElement, visibleCondition);
+
+			if (strType.Equals("dialog"))
+			pWindow = new CGUIDialog(id + WINDOW_HOME, FindFileData.cFileName);
+			else if (strType.Equals("submenu"))
+			pWindow = new CGUIDialogSubMenu(id + WINDOW_HOME, FindFileData.cFileName);
+			else if (strType.Equals("buttonmenu"))
+			pWindow = new CGUIDialogButtonMenu(id + WINDOW_HOME, FindFileData.cFileName);
+			else
+			pWindow = new CGUIStandardWindow(id + WINDOW_HOME, FindFileData.cFileName);
+
+			// Check to make sure the pointer isn't still null
+			if (pWindow == NULL)
+			{
+				CLog::Log(LOGERROR, "Out of memory / Failed to create new object in LoadUserWindows");
+				return false;
+			}
+			if (id == WINDOW_INVALID || g_windowManager.GetWindow(WINDOW_HOME + id))
+			{
+				delete pWindow;
+				continue;
+			}
+			pWindow->SetVisibleCondition(visibleCondition, false);
+			g_windowManager.AddCustomWindow(pWindow);
+		}
+		CloseHandle(hFind);
+	}
+	return true;
+}
+
 #ifdef HAS_XBOX_D3D  // needed for screenshot
 void CApplication::Render()
 {
 #else
-void CApplication::RenderNoPresent()
-{
+	void CApplication::RenderNoPresent()
+	{
 #endif
-  // don't do anything that would require graphiccontext to be locked before here in fullscreen.
-  // that stuff should go into renderfullscreen instead as that is called from the renderin thread
+		// don't do anything that would require graphiccontext to be locked before here in fullscreen.
+		// that stuff should go into renderfullscreen instead as that is called from the renderin thread
 #ifdef HAS_XBOX_HARDWARE  // Win32 renders from the main thread, not from the player thread
-  // dont show GUI when playing full screen video
-  if (g_graphicsContext.IsFullScreenVideo() && IsPlaying() && !IsPaused())
-  {
-    Sleep(50);
-    ResetScreenSaver();
-    g_infoManager.ResetCache();
-    return;
-  }
+		// dont show GUI when playing full screen video
+		if (g_graphicsContext.IsFullScreenVideo() && IsPlaying() && !IsPaused())
+		{
+			Sleep(50);
+			ResetScreenSaver();
+			g_infoManager.ResetCache();
+			return;
+		}
 #endif
 
-  g_ApplicationRenderer.Render();
-}
+		g_ApplicationRenderer.Render();
+	}
 
-void CApplication::DoRender()
-{
-  if(!m_pd3dDevice)
-    return;
+	void CApplication::DoRender()
+	{
+		if(!m_pd3dDevice)
+		return;
 
-  g_graphicsContext.Lock();
+		g_graphicsContext.Lock();
 
-  m_pd3dDevice->BeginScene();
+		m_pd3dDevice->BeginScene();
 
-  g_windowManager.UpdateModelessVisibility();
+		g_windowManager.UpdateModelessVisibility();
 
-  //SWATHWIDTH of 4 improves fillrates (performance investigator)
+		//SWATHWIDTH of 4 improves fillrates (performance investigator)
 #ifdef HAS_XBOX_D3D
-  m_pd3dDevice->SetRenderState(D3DRS_SWATHWIDTH, 4);
+		m_pd3dDevice->SetRenderState(D3DRS_SWATHWIDTH, 4);
 #endif
-  g_windowManager.Render();
+		g_windowManager.Render();
 
-  // if we're recording an audio stream then show blinking REC
-  if (!g_graphicsContext.IsFullScreenVideo())
-  {
-    if (m_pPlayer && m_pPlayer->IsRecording() )
-    {
-      static int iBlinkRecord = 0;
-      iBlinkRecord++;
-      if (iBlinkRecord > 25)
-      {
-        CGUIFont* pFont = g_fontManager.GetFont("font13");
-        CGUITextLayout::DrawText(pFont, 60, 50, 0xffff0000, 0, "REC", 0);
-      }
+		// if we're recording an audio stream then show blinking REC
+		if (!g_graphicsContext.IsFullScreenVideo())
+		{
+			if (m_pPlayer && m_pPlayer->IsRecording() )
+			{
+				static int iBlinkRecord = 0;
+				iBlinkRecord++;
+				if (iBlinkRecord > 25)
+				{
+					CGUIFont* pFont = g_fontManager.GetFont("debuglogging");
+					CGUITextLayout::DrawText(pFont, 60, 50, 0xffff0000, 0, "REC", 0);
+				}
 
-      if (iBlinkRecord > 50)
-        iBlinkRecord = 0;
-    }
-  }
+				if (iBlinkRecord > 50)
+				iBlinkRecord = 0;
+			}
+		}
 
-  // Now render any dialogs
-  g_windowManager.RenderDialogs();
+		// Now render any dialogs
+		g_windowManager.RenderDialogs();
 
-  // Render the mouse pointer
-  if (g_Mouse.IsActive())
-  {
-    m_guiPointer.Render();
-  }
+		// Render the mouse pointer
+		if (g_Mouse.IsActive())
+		{
+			m_guiPointer.Render();
+		}
 
-  {
-    // free memory if we got les then 10megs free ram
-    MEMORYSTATUS stat;
-    GlobalMemoryStatus(&stat);
-    DWORD dwMegFree = (DWORD)(stat.dwAvailPhys / (1024 * 1024));
-    if (dwMegFree <= 10)
-    {
-      g_TextureManager.Flush();
-    }
+		{
+			// free memory if we got less then 13 meg free ram
+			MEMORYSTATUS stat;
+			GlobalMemoryStatus(&stat);
+			DWORD dwMegFree = (DWORD)(stat.dwAvailPhys / (1024 * 1024));
+			// if (dwMegFree <= 13)
+			// {
+			// g_TextureManager.Flush();
+			// }
+			// free memory if we got les then 13 meg free ram and show dialog telling user
+			if (dwMegFree <= 13)
+			{
+				// CLog::Log(LOGWARNING, "Ram hit less than 13MB, flushing texture cache.");
+				g_TextureManager.Flush();
+			}
 
-    // reset image scaling and effect states
-    g_graphicsContext.SetRenderingResolution(g_graphicsContext.GetVideoResolution(), false);
+			// reset image scaling and effect states
+			g_graphicsContext.SetRenderingResolution(g_graphicsContext.GetVideoResolution(), false);
 
-    // If we have the remote codes enabled, then show them
-    if (g_advancedSettings.m_displayRemoteCodes)
-    {
+			// If we have the remote codes enabled, then show them
+			if (g_advancedSettings.m_displayRemoteCodes)
+			{
 #ifdef HAS_IR_REMOTE
-      XBIR_REMOTE* pRemote = &m_DefaultIR_Remote;
-      static iRemoteCode = 0;
-      static iShowRemoteCode = 0;
-      if (pRemote->wButtons)
-      {
-        iRemoteCode = 255 - pRemote->wButtons; // remote OBC code is 255-wButtons
-        iShowRemoteCode = 50;
-      }
-      if (iShowRemoteCode > 0)
-      {
-        CStdStringW wszText;
-        wszText.Format(L"Remote Code: %i", iRemoteCode);
-        float x = 0.08f * g_graphicsContext.GetWidth();
-        float y = 0.12f * g_graphicsContext.GetHeight();
+				XBIR_REMOTE* pRemote = &m_DefaultIR_Remote;
+				static iRemoteCode = 0;
+				static iShowRemoteCode = 0;
+				if (pRemote->wButtons)
+				{
+					iRemoteCode = 255 - pRemote->wButtons; // remote OBC code is 255-wButtons
+					iShowRemoteCode = 50;
+				}
+				if (iShowRemoteCode > 0)
+				{
+					CStdStringW wszText;
+					wszText.Format(L"Remote Code: %i", iRemoteCode);
+					float x = 0.08f * g_graphicsContext.GetWidth();
+					float y = 0.12f * g_graphicsContext.GetHeight();
 #ifndef _DEBUG
-        if (LOG_LEVEL_DEBUG_FREEMEM > g_advancedSettings.m_logLevel)
-          y = 0.08f * g_graphicsContext.GetHeight();
+					if (LOG_LEVEL_DEBUG_FREEMEM > g_advancedSettings.m_logLevel)
+					y = 0.08f * g_graphicsContext.GetHeight();
 #endif
-        CGUITextLayout::DrawOutlineText(g_fontManager.GetFont("font13"), x, y, 0xffffffff, 0xff000000, 2, wszText);
-        iShowRemoteCode--;
-      }
+					CGUITextLayout::DrawOutlineText(g_fontManager.GetFont("debuglogging"), x, y, 0xffffffff, 0xff000000, 2, wszText);
+					iShowRemoteCode--;
+				}
 #endif
-    }
+			}
 
-    RenderMemoryStatus();
-  }
+			RenderMemoryStatus();
+		}
 
-  m_pd3dDevice->EndScene();
+		m_pd3dDevice->EndScene();
 #ifdef HAS_XBOX_D3D
-  m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
+		m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
 #endif
-  g_graphicsContext.Unlock();
+		g_graphicsContext.Unlock();
 
-  // reset our info cache - we do this at the end of Render so that it is
-  // fresh for the next process(), or after a windowclose animation (where process()
-  // isn't called)
-  g_infoManager.ResetCache();
-}
+		// reset our info cache - we do this at the end of Render so that it is
+		// fresh for the next process(), or after a windowclose animation (where process()
+		// isn't called)
+		g_infoManager.ResetCache();
+	}
 
 #ifndef HAS_XBOX_D3D
-void CApplication::Render()
-{
-  g_graphicsContext.Lock();
-  { // frame rate limiter (really bad, but it does the trick :p)
-    const static unsigned int singleFrameTime = 10;
-    static unsigned int lastFrameTime = 0;
-    unsigned int currentTime = timeGetTime();
-    if (lastFrameTime + singleFrameTime > currentTime)
-      Sleep(lastFrameTime + singleFrameTime - currentTime);
-    lastFrameTime = timeGetTime();
-  }
-  RenderNoPresent();
-  // Present the backbuffer contents to the display
-  if (m_pd3dDevice) m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
-  CTimeUtils::UpdateFrameTime();
-  g_graphicsContext.Unlock();
-}
+	void CApplication::Render()
+	{
+		g_graphicsContext.Lock();
+		{ // frame rate limiter (really bad, but it does the trick :p)
+			const static unsigned int singleFrameTime = 10;
+			static unsigned int lastFrameTime = 0;
+			unsigned int currentTime = timeGetTime();
+			if (lastFrameTime + singleFrameTime > currentTime)
+			Sleep(lastFrameTime + singleFrameTime - currentTime);
+			lastFrameTime = timeGetTime();
+		}
+		RenderNoPresent();
+		// Present the backbuffer contents to the display
+		if (m_pd3dDevice) m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
+		CTimeUtils::UpdateFrameTime();
+		g_graphicsContext.Unlock();
+	}
 #endif
 
-void CApplication::RenderMemoryStatus()
-{
-  g_infoManager.UpdateFPS();
+	void CApplication::RenderMemoryStatus()
+	{
+		g_infoManager.UpdateFPS();
 #if !defined(_DEBUG) && !defined(PROFILE)
-  if (LOG_LEVEL_DEBUG_FREEMEM <= g_advancedSettings.m_logLevel)
+		if (LOG_LEVEL_DEBUG_FREEMEM <= g_advancedSettings.m_logLevel)
 #endif
-  {
-    // reset the window scaling and fade status
-    RESOLUTION res = g_graphicsContext.GetVideoResolution();
-    g_graphicsContext.SetRenderingResolution(res, false);
+		{
+			// reset the window scaling and fade status
+			RESOLUTION res = g_graphicsContext.GetVideoResolution();
+			g_graphicsContext.SetRenderingResolution(res, false);
 
-    CStdStringW wszText;
-    MEMORYSTATUS stat;
-    GlobalMemoryStatus(&stat);
-    wszText.Format(L"FreeMem %d/%d KB, FPS %2.1f, CPU %2.0f%%", stat.dwAvailPhys/1024, stat.dwTotalPhys/1024, g_infoManager.GetFPS(), (1.0f - m_idleThread.GetRelativeUsage())*100);
+			CStdStringW wszText;
+			MEMORYSTATUS stat;
+			GlobalMemoryStatus(&stat);
+			wszText.Format(L"FreeMem %d KB - %d/%d MB, FPS %2.1f, CPU %2.0f%%", stat.dwAvailPhys/1024, stat.dwAvailPhys / (1024 * 1024), stat.dwTotalPhys / (1024 * 1024), g_infoManager.GetFPS(), (1.0f - m_idleThread.GetRelativeUsage())*100);
 
-    float x = 0.04f * g_graphicsContext.GetWidth() + g_settings.m_ResInfo[res].Overscan.left;
-    float y = 0.04f * g_graphicsContext.GetHeight() + g_settings.m_ResInfo[res].Overscan.top;
-    CGUITextLayout::DrawOutlineText(g_fontManager.GetFont("font13"), x, y, 0xffffffff, 0xff000000, 2, wszText);
-  }
-}
+			float x = 0.28f * g_graphicsContext.GetWidth() + g_settings.m_ResInfo[res].Overscan.left; // default position is 0.04f same for below
+			float y = 0.00f * g_graphicsContext.GetHeight() + g_settings.m_ResInfo[res].Overscan.top;
+			CGUITextLayout::DrawOutlineText(g_fontManager.GetFont("debuglogging"), x, y, 0xffffffff, 0xff000000, 2, wszText);
+		}
+	}
 
-// OnKey() translates the key into a CAction which is sent on to our Window Manager.
-// The window manager will return true if the event is processed, false otherwise.
-// If not already processed, this routine handles global keypresses.  It returns
-// true if the key has been processed, false otherwise.
+	// OnKey() translates the key into a CAction which is sent on to our Window Manager.
+	// The window manager will return true if the event is processed, false otherwise.
+	// If not already processed, this routine handles global keypresses.  It returns
+	// true if the key has been processed, false otherwise.
 
-bool CApplication::OnKey(CKey& key)
-{
-  // Turn the mouse off, as we've just got a keypress from controller or remote
-  g_Mouse.SetInactive();
-  
-  // get the current active window
-  int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
+	bool CApplication::OnKey(CKey& key)
+	{
+		// Turn the mouse off, as we've just got a keypress from controller or remote
+		g_Mouse.SetInactive();
 
-  // this will be checked for certain keycodes that need
-  // special handling if the screensaver is active
-  CAction action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+		// get the current active window
+		int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
 
-  // a key has been pressed.
-  // Reset the screensaver timer
-  // but not for the analog thumbsticks/triggers
-  if (!key.IsAnalogButton())
-  {
-    // reset harddisk spindown timer
-    m_bSpinDown = false;
-    m_bNetworkSpinDown = false;
+		// this will be checked for certain keycodes that need
+		// special handling if the screensaver is active
+		CAction action = CButtonTranslator::GetInstance().GetAction(iWin, key);
 
-    // reset Idle Timer
-    m_idleTimer.StartZero();
+		// a key has been pressed.
+		// Reset the screensaver timer
+		// but not for the analog thumbsticks/triggers
+		if (!key.IsAnalogButton())
+		{
+			// reset harddisk spindown timer
+			m_bSpinDown = false;
+			m_bNetworkSpinDown = false;
 
-    ResetScreenSaver();
+			// reset Idle Timer
+			m_idleTimer.StartZero();
 
-    // allow some keys to be processed while the screensaver is active
-    if (ResetScreenSaverWindow())
-    {
-      return true;
-    }  
-  }
+			ResetScreenSaver();
 
-  // change this if we have a dialog up
-  if (g_windowManager.HasModalDialog())
-  {
-    iWin = g_windowManager.GetTopMostModalDialogID() & WINDOW_ID_MASK;
-  }
-  if (iWin == WINDOW_DIALOG_FULLSCREEN_INFO)
-  { // fullscreen info dialog - special case
-    action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+			// allow some keys to be processed while the screensaver is active
+			if (ResetScreenSaverWindow())
+			{
+				return true;
+			}  
+		}
 
+		// change this if we have a dialog up
+		if (g_windowManager.HasModalDialog())
+		{
+			iWin = g_windowManager.GetTopMostModalDialogID() & WINDOW_ID_MASK;
+		}
+		if (iWin == WINDOW_DIALOG_FULLSCREEN_INFO)
+		{ // fullscreen info dialog - special case
+			action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+
 #ifdef HAS_SDL
-    g_Keyboard.Reset();
+			g_Keyboard.Reset();
 #endif
 
-    if (!key.IsAnalogButton())
-      CLog::Log(LOGDEBUG, "%s: %i pressed, trying fullscreen info action %s", __FUNCTION__, (int) key.GetButtonCode(), action.GetName().c_str());
+			if (!key.IsAnalogButton())
+			CLog::Log(LOGDEBUG, "%s: %i pressed, trying fullscreen info action %s", __FUNCTION__, (int) key.GetButtonCode(), action.GetName().c_str());
 
-    if (OnAction(action))
-      return true;
+			if (OnAction(action))
+			return true;
 
-    // fallthrough to the main window
-    iWin = WINDOW_FULLSCREEN_VIDEO;
-  }
-  if (iWin == WINDOW_FULLSCREEN_VIDEO)
-  {
-    // current active window is full screen video.
-    if (g_application.m_pPlayer && g_application.m_pPlayer->IsInMenu())
-    {
-      // if player is in some sort of menu, (ie DVDMENU) map buttons differently
-      action = CButtonTranslator::GetInstance().GetAction(WINDOW_VIDEO_MENU, key);
-    }
-    else
-    {
-      // no then use the fullscreen window section of keymap.xml to map key->action
-      action = CButtonTranslator::GetInstance().GetAction(iWin, key);
-    }
-  }
-  else
-  {
-    // current active window isnt the fullscreen window
-    // just use corresponding section from keymap.xml
-    // to map key->action
+			// fallthrough to the main window
+			iWin = WINDOW_FULLSCREEN_VIDEO;
+		}
+		if (iWin == WINDOW_FULLSCREEN_VIDEO)
+		{
+			// current active window is full screen video.
+			if (g_application.m_pPlayer && g_application.m_pPlayer->IsInMenu())
+			{
+				// if player is in some sort of menu, (ie DVDMENU) map buttons differently
+				action = CButtonTranslator::GetInstance().GetAction(WINDOW_VIDEO_MENU, key);
+			}
+			else
+			{
+				// no then use the fullscreen window section of keymap.xml to map key->action
+				action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+			}
+		}
+		else
+		{
+			// current active window isnt the fullscreen window
+			// just use corresponding section from keymap.xml
+			// to map key->action
 
-    // first determine if we should use keyboard input directly
-    bool useKeyboard = key.FromKeyboard() && (iWin == WINDOW_DIALOG_KEYBOARD || iWin == WINDOW_DIALOG_NUMERIC);
-    CGUIWindow *window = g_windowManager.GetWindow(iWin);
-    if (window)
-    {
-      CGUIControl *control = window->GetFocusedControl();
-      if (control)
-      {
-        if (control->GetControlType() == CGUIControl::GUICONTROL_EDIT ||
-            (control->IsContainer() && g_Keyboard.GetShift()))
-          useKeyboard = true;
-      }
-    }
-    if (useKeyboard)
-    {
-      action = CAction(0); // reset our action
-      if (key.GetFromHttpApi())
-        action = CAction(key.GetButtonCode() != KEY_INVALID ? key.GetButtonCode() : 0, key.GetUnicode());
-      else
-      { // see if we've got an ascii key
-        if (g_Keyboard.GetUnicode())
-          action = CAction(g_Keyboard.GetAscii() | KEY_ASCII, g_Keyboard.GetUnicode());
-        else
-          action = CAction(g_Keyboard.GetKey() | KEY_VKEY);
-      }
+			// first determine if we should use keyboard input directly
+			bool useKeyboard = key.FromKeyboard() && (iWin == WINDOW_DIALOG_KEYBOARD || iWin == WINDOW_DIALOG_NUMERIC);
+			CGUIWindow *window = g_windowManager.GetWindow(iWin);
+			if (window)
+			{
+				CGUIControl *control = window->GetFocusedControl();
+				if (control)
+				{
+					if (control->GetControlType() == CGUIControl::GUICONTROL_EDIT ||
+							(control->IsContainer() && g_Keyboard.GetShift()))
+					useKeyboard = true;
+				}
+			}
+			if (useKeyboard)
+			{
+				action = CAction(0); // reset our action
+				if (key.GetFromHttpApi())
+				action = CAction(key.GetButtonCode() != KEY_INVALID ? key.GetButtonCode() : 0, key.GetUnicode());
+				else
+				{ // see if we've got an ascii key
+					if (g_Keyboard.GetUnicode())
+					action = CAction(g_Keyboard.GetAscii() | KEY_ASCII, g_Keyboard.GetUnicode());
+					else
+					action = CAction(g_Keyboard.GetKey() | KEY_VKEY);
+				}
 #ifdef HAS_SDL
-      g_Keyboard.Reset();
+				g_Keyboard.Reset();
 #endif
 
-      CLog::Log(LOGDEBUG, "%s: %i pressed, trying keyboard action %i", __FUNCTION__, (int) key.GetButtonCode(), action.GetID());
+				CLog::Log(LOGDEBUG, "%s: %i pressed, trying keyboard action %i", __FUNCTION__, (int) key.GetButtonCode(), action.GetID());
 
-      if (OnAction(action))
-        return true;
-      // failed to handle the keyboard action, drop down through to standard action
-    }
-    if (key.GetFromHttpApi())
-    {
-      if (key.GetButtonCode() != KEY_INVALID)
-        action = CButtonTranslator::GetInstance().GetAction(iWin, key);
-    }
-    else
-      action = CButtonTranslator::GetInstance().GetAction(iWin, key);
-  }
-  if (!key.IsAnalogButton())
-    CLog::Log(LOGDEBUG, "%s: %i pressed, action is %s", __FUNCTION__, (int) key.GetButtonCode(), action.GetName().c_str());
+				if (OnAction(action))
+				return true;
+				// failed to handle the keyboard action, drop down through to standard action
+			}
+			if (key.GetFromHttpApi())
+			{
+				if (key.GetButtonCode() != KEY_INVALID)
+				action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+			}
+			else
+			action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+		}
+		if (!key.IsAnalogButton())
+		CLog::Log(LOGDEBUG, "%s: %i pressed, action is %s", __FUNCTION__, (int) key.GetButtonCode(), action.GetName().c_str());
 
-  bool bResult = false;
+		bool bResult = false;
 
-  // play sound before the action unless the button is held, 
-  // where we execute after the action as held actions aren't fired every time.
-  if(action.GetHoldTime())
-  {
-    bResult = OnAction(action);
-    if(bResult)
-      g_audioManager.PlayActionSound(action);
-  }
-  else
-  {
-    g_audioManager.PlayActionSound(action);
-    bResult = OnAction(action);
-  }
+		// play sound before the action unless the button is held, 
+		// where we execute after the action as held actions aren't fired every time.
+		if(action.GetHoldTime())
+		{
+			bResult = OnAction(action);
+			if(bResult)
+			g_audioManager.PlayActionSound(action);
+		}
+		else
+		{
+			g_audioManager.PlayActionSound(action);
+			bResult = OnAction(action);
+		}
 
-  return bResult;
-}
+		return bResult;
+	}
 
-bool CApplication::OnAction(CAction &action)
-{
-  // Let's tell the outside world about this action
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=2)
-  {
-    CStdString tmp;
-    tmp.Format("%i",action.GetID());
-    m_applicationMessenger.HttpApi("broadcastlevel; OnAction:"+tmp+";2");
-  }
+	bool CApplication::OnAction(CAction &action)
+	{
+		// Let's tell the outside world about this action
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=2)
+		{
+			CStdString tmp;
+			tmp.Format("%i",action.GetID());
+			m_applicationMessenger.HttpApi("broadcastlevel; OnAction:"+tmp+";2");
+		}
 
-  // special case for switching between GUI & fullscreen mode.
-  if (action.GetID() == ACTION_SHOW_GUI)
-  { // Switch to fullscreen mode if we can
-    if (SwitchToFullScreen())
-    {
-      m_navigationTimer.StartZero();
-      return true;
-    }
-  }
+		// special case for switching between GUI & fullscreen mode.
+		if (action.GetID() == ACTION_SHOW_GUI)
+		{ // Switch to fullscreen mode if we can
+			if (SwitchToFullScreen())
+			{
+				m_navigationTimer.StartZero();
+				return true;
+			}
+		}
 
-  // in normal case
-  // just pass the action to the current window and let it handle it
-  if (g_windowManager.OnAction(action))
-  {
-    m_navigationTimer.StartZero();
-    return true;
-  }
+		// in normal case
+		// just pass the action to the current window and let it handle it
+		if (g_windowManager.OnAction(action))
+		{
+			m_navigationTimer.StartZero();
+			return true;
+		}
 
-  // handle extra global presses
+		// handle extra global presses
 
-  // screenshot : take a screenshot :)
-  if (action.GetID() == ACTION_TAKE_SCREENSHOT)
-  {
-    CUtil::TakeScreenshot();
-    return true;
-  }
-  // built in functions : execute the built-in
-  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
-  {
-    CBuiltins::Execute(action.GetName());
-    m_navigationTimer.StartZero();
-    return true;
-  }
+		// screenshot : take a screenshot :)
+		if (action.GetID() == ACTION_TAKE_SCREENSHOT)
+		{
+			CUtil::TakeScreenshot();
+			return true;
+		}
+		// built in functions : execute the built-in
+		if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+		{
+			CBuiltins::Execute(action.GetName());
+			m_navigationTimer.StartZero();
+			return true;
+		}
 
-  // power down : turn off after 3 seconds of button down
-  static bool PowerButtonDown = false;
-  static DWORD PowerButtonCode;
-  static DWORD MarkTime;
-  if (action.GetID() == ACTION_POWERDOWN)
-  {
-    // Hold button for 3 secs to power down
-    if (!PowerButtonDown)
-    {
-      MarkTime = GetTickCount();
-      PowerButtonDown = true;
-      PowerButtonCode = action.GetButtonCode();
-    }
-  }
-  if (PowerButtonDown)
-  {
-    if (g_application.IsButtonDown(PowerButtonCode))
-    {
-      if (GetTickCount() >= MarkTime + 3000)
-      {
-        m_applicationMessenger.Shutdown();
-        return true;
-      }
-    }
-    else
-      PowerButtonDown = false;
-  }
-  // reload keymaps
-  if (action.GetID() == ACTION_RELOAD_KEYMAPS)
-  {
-    CButtonTranslator::GetInstance().Clear();
-    CButtonTranslator::GetInstance().Load();
-  }
+		// power down : turn off after 3 seconds of button down
+		static bool PowerButtonDown = false;
+		static DWORD PowerButtonCode;
+		static DWORD MarkTime;
+		if (action.GetID() == ACTION_POWERDOWN)
+		{
+			// Hold button for 3 secs to power down
+			if (!PowerButtonDown)
+			{
+				MarkTime = GetTickCount();
+				PowerButtonDown = true;
+				PowerButtonCode = action.GetButtonCode();
+			}
+		}
+		if (PowerButtonDown)
+		{
+			if (g_application.IsButtonDown(PowerButtonCode))
+			{
+				if (GetTickCount() >= MarkTime + 3000)
+				{
+					m_applicationMessenger.Shutdown();
+					return true;
+				}
+			}
+			else
+			PowerButtonDown = false;
+		}
+		// reload keymaps
+		if (action.GetID() == ACTION_RELOAD_KEYMAPS)
+		{
+			CButtonTranslator::GetInstance().Clear();
+			CButtonTranslator::GetInstance().Load();
+		}
 
-  // show info : Shows the current video or song information
-  if (action.GetID() == ACTION_SHOW_INFO)
-  {
-    g_infoManager.ToggleShowInfo();
-    return true;
-  }
+		// show info : Shows the current video or song information
+		if (action.GetID() == ACTION_SHOW_INFO)
+		{
+			g_infoManager.ToggleShowInfo();
+			return true;
+		}
 
-  // codec info : Shows the current song, video or picture codec information
-  if (action.GetID() == ACTION_SHOW_CODEC)
-  {
-    g_infoManager.ToggleShowCodec();
-    return true;
-  }
+		// codec info : Shows the current song, video or picture codec information
+		if (action.GetID() == ACTION_SHOW_CODEC)
+		{
+			g_infoManager.ToggleShowCodec();
+			return true;
+		}
 
-  if ((action.GetID() == ACTION_INCREASE_RATING || action.GetID() == ACTION_DECREASE_RATING) && IsPlayingAudio())
-  {
-    const CMusicInfoTag *tag = g_infoManager.GetCurrentSongTag();
-    if (tag)
-    {
-      *m_itemCurrentFile->GetMusicInfoTag() = *tag;
-      char rating = tag->GetRating();
-      bool needsUpdate(false);
-      if (rating > '0' && action.GetID() == ACTION_DECREASE_RATING)
-      {
-        m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating - 1);
-        needsUpdate = true;
-      }
-      else if (rating < '5' && action.GetID() == ACTION_INCREASE_RATING)
-      {
-        m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating + 1);
-        needsUpdate = true;
-      }
-      if (needsUpdate)
-      {
-        CMusicDatabase db;
-        if (db.Open())      // OpenForWrite() ?
-        {
-          db.SetSongRating(m_itemCurrentFile->GetPath(), m_itemCurrentFile->GetMusicInfoTag()->GetRating());
-          db.Close();
-        }
-        // send a message to all windows to tell them to update the fileitem (eg playlistplayer, media windows)
-        CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_ITEM, 0, m_itemCurrentFile);
-        g_windowManager.SendMessage(msg);
-      }
-    }
-    return true;
-  }
+		if ((action.GetID() == ACTION_INCREASE_RATING || action.GetID() == ACTION_DECREASE_RATING) && IsPlayingAudio())
+		{
+			const CMusicInfoTag *tag = g_infoManager.GetCurrentSongTag();
+			if (tag)
+			{
+				*m_itemCurrentFile->GetMusicInfoTag() = *tag;
+				char rating = tag->GetRating();
+				bool needsUpdate(false);
+				if (rating > '0' && action.GetID() == ACTION_DECREASE_RATING)
+				{
+					m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating - 1);
+					needsUpdate = true;
+				}
+				else if (rating < '5' && action.GetID() == ACTION_INCREASE_RATING)
+				{
+					m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating + 1);
+					needsUpdate = true;
+				}
+				if (needsUpdate)
+				{
+					CMusicDatabase db;
+					if (db.Open())      // OpenForWrite() ?
+					{
+						db.SetSongRating(m_itemCurrentFile->GetPath(), m_itemCurrentFile->GetMusicInfoTag()->GetRating());
+						db.Close();
+					}
+					// send a message to all windows to tell them to update the fileitem (eg playlistplayer, media windows)
+					CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_ITEM, 0, m_itemCurrentFile);
+					g_windowManager.SendMessage(msg);
+				}
+			}
+			return true;
+		}
 
-  // stop : stops playing current audio song
-  if (action.GetID() == ACTION_STOP)
-  {
-    StopPlaying();
-    return true;
-  }
+		// stop : stops playing current audio song
+		if (action.GetID() == ACTION_STOP)
+		{
+			StopPlaying();
+			return true;
+		}
 
-  // previous : play previous song from playlist
-  if (action.GetID() == ACTION_PREV_ITEM)
-  {
-    // first check whether we're within 3 seconds of the start of the track
-    // if not, we just revert to the start of the track
-    if (m_pPlayer && m_pPlayer->CanSeek() && GetTime() > 3)
-    {
-      SeekTime(0);
-      SetPlaySpeed(1);
-    }
-    else
-    {
-      g_playlistPlayer.PlayPrevious();
-    }
-    return true;
-  }
+		// previous : play previous song from playlist
+		if (action.GetID() == ACTION_PREV_ITEM)
+		{
+			// first check whether we're within 3 seconds of the start of the track
+			// if not, we just revert to the start of the track
+			if (m_pPlayer && m_pPlayer->CanSeek() && GetTime() > 3)
+			{
+				SeekTime(0);
+				SetPlaySpeed(1);
+			}
+			else
+			{
+				g_playlistPlayer.PlayPrevious();
+			}
+			return true;
+		}
 
-  // next : play next song from playlist
-  if (action.GetID() == ACTION_NEXT_ITEM)
-  {
-    if (IsPlaying() && m_pPlayer->SkipNext())
-      return true;
+		// next : play next song from playlist
+		if (action.GetID() == ACTION_NEXT_ITEM)
+		{
+			if (IsPlaying() && m_pPlayer->SkipNext())
+			return true;
 
-    g_playlistPlayer.PlayNext();
+			g_playlistPlayer.PlayNext();
 
-    return true;
-  }
+			return true;
+		}
 
-  if ( IsPlaying())
-  {
-    // pause : pauses current audio song
-    if (action.GetID() == ACTION_PAUSE)
-    {
-      m_pPlayer->Pause();
-      if (!m_pPlayer->IsPaused())
-      { // unpaused - set the playspeed back to normal
-        SetPlaySpeed(1);
-      }
-      g_audioManager.Enable(m_pPlayer->IsPaused());
-      return true;
-    }
-    if (!m_pPlayer->IsPaused())
-    {
-      // if we do a FF/RW in my music then map PLAY action togo back to normal speed
-      // if we are playing at normal speed, then allow play to pause
-      if (action.GetID() == ACTION_PLAYER_PLAY)
-      {
-        if (m_iPlaySpeed != 1)
-        {
-          SetPlaySpeed(1);
-        }
-        else
-        {
-          m_pPlayer->Pause();
-        }
-        return true;
-      }
-      if (action.GetID() == ACTION_PLAYER_FORWARD || action.GetID() == ACTION_PLAYER_REWIND)
-      {
-        int iPlaySpeed = m_iPlaySpeed;
-        if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed == 1) // Enables Rewinding
-          iPlaySpeed *= -2;
-        else if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed > 1) //goes down a notch if you're FFing
-          iPlaySpeed /= 2;
-        else if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed < 1) //goes up a notch if you're RWing
-          iPlaySpeed /= 2;
-        else
-          iPlaySpeed *= 2;
+		if ( IsPlaying())
+		{
+			// pause : pauses current audio song
+			if (action.GetID() == ACTION_PAUSE)
+			{
+				m_pPlayer->Pause();
+				if (!m_pPlayer->IsPaused())
+				{ // unpaused - set the playspeed back to normal
+					SetPlaySpeed(1);
+				}
+				g_audioManager.Enable(m_pPlayer->IsPaused());
+				return true;
+			}
+			if (!m_pPlayer->IsPaused())
+			{
+				// if we do a FF/RW in my music then map PLAY action togo back to normal speed
+				// if we are playing at normal speed, then allow play to pause
+				if (action.GetID() == ACTION_PLAYER_PLAY)
+				{
+					if (m_iPlaySpeed != 1)
+					{
+						SetPlaySpeed(1);
+					}
+					else
+					{
+						m_pPlayer->Pause();
+					}
+					return true;
+				}
+				if (action.GetID() == ACTION_PLAYER_FORWARD || action.GetID() == ACTION_PLAYER_REWIND)
+				{
+					int iPlaySpeed = m_iPlaySpeed;
+					if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed == 1) // Enables Rewinding
+					iPlaySpeed *= -2;
+					else if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed > 1) //goes down a notch if you're FFing
+					iPlaySpeed /= 2;
+					else if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed < 1) //goes up a notch if you're RWing
+					iPlaySpeed /= 2;
+					else
+					iPlaySpeed *= 2;
 
-        if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed == -1) //sets iSpeed back to 1 if -1 (didn't plan for a -1)
-          iPlaySpeed = 1;
-        if (iPlaySpeed > 32 || iPlaySpeed < -32)
-          iPlaySpeed = 1;
+					if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed == -1) //sets iSpeed back to 1 if -1 (didn't plan for a -1)
+					iPlaySpeed = 1;
+					if (iPlaySpeed > 32 || iPlaySpeed < -32)
+					iPlaySpeed = 1;
 
-        SetPlaySpeed(iPlaySpeed);
-        return true;
-      }
-      else if ((action.GetAmount() || GetPlaySpeed() != 1) && (action.GetID() == ACTION_ANALOG_REWIND || action.GetID() == ACTION_ANALOG_FORWARD))
-      {
-        // calculate the speed based on the amount the button is held down
-        int iPower = (int)(action.GetAmount() * MAX_FFWD_SPEED + 0.5f);
-        // returns 0 -> MAX_FFWD_SPEED
-        int iSpeed = 1 << iPower;
-        if (iSpeed != 1 && action.GetID() == ACTION_ANALOG_REWIND)
-          iSpeed = -iSpeed;
-        g_application.SetPlaySpeed(iSpeed);
-        if (iSpeed == 1)
-          CLog::Log(LOGDEBUG,"Resetting playspeed");
-        return true;
-      }
-    }
-    // allow play to unpause
-    else
-    {
-      if (action.GetID() == ACTION_PLAYER_PLAY)
-      {
-        // unpause, and set the playspeed back to normal
-        m_pPlayer->Pause();
-        g_audioManager.Enable(m_pPlayer->IsPaused());
+					SetPlaySpeed(iPlaySpeed);
+					return true;
+				}
+				else if ((action.GetAmount() || GetPlaySpeed() != 1) && (action.GetID() == ACTION_ANALOG_REWIND || action.GetID() == ACTION_ANALOG_FORWARD))
+				{
+					// calculate the speed based on the amount the button is held down
+					int iPower = (int)(action.GetAmount() * MAX_FFWD_SPEED + 0.5f);
+					// returns 0 -> MAX_FFWD_SPEED
+					int iSpeed = 1 << iPower;
+					if (iSpeed != 1 && action.GetID() == ACTION_ANALOG_REWIND)
+					iSpeed = -iSpeed;
+					g_application.SetPlaySpeed(iSpeed);
+					if (iSpeed == 1)
+					CLog::Log(LOGDEBUG,"Resetting playspeed");
+					return true;
+				}
+			}
+			// allow play to unpause
+			else
+			{
+				if (action.GetID() == ACTION_PLAYER_PLAY)
+				{
+					// unpause, and set the playspeed back to normal
+					m_pPlayer->Pause();
+					g_audioManager.Enable(m_pPlayer->IsPaused());
 
-        g_application.SetPlaySpeed(1);
-        return true;
-      }
-    }
-  }
-  if (action.GetID() == ACTION_MUTE)
-  {
-    Mute();
-    return true;
-  }
- 
-  if (action.GetID() == ACTION_TOGGLE_DIGITAL_ANALOG)
-  { 
-    if(g_guiSettings.GetInt("audiooutput.mode")==AUDIO_DIGITAL)
-      g_guiSettings.SetInt("audiooutput.mode", AUDIO_ANALOG);
-    else
-      g_guiSettings.SetInt("audiooutput.mode", AUDIO_DIGITAL);
-    g_application.Restart();
-    if (g_windowManager.GetActiveWindow() == WINDOW_SETTINGS_SYSTEM)
-    {
-      CGUIMessage msg(GUI_MSG_WINDOW_INIT, 0,0,WINDOW_INVALID,g_windowManager.GetActiveWindow());
-      g_windowManager.SendMessage(msg);
-    }
-    return true;
-  }
+					g_application.SetPlaySpeed(1);
+					return true;
+				}
+			}
+		}
+		if (action.GetID() == ACTION_MUTE)
+		{
+			Mute();
+			return true;
+		}
 
-  // Check for global volume control
-  if (action.GetAmount() && (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN))
-  {
-    // increase or decrease the volume
-    int volume = g_settings.m_nVolumeLevel + g_settings.m_dynamicRangeCompressionLevel;
+		if (action.GetID() == ACTION_TOGGLE_DIGITAL_ANALOG)
+		{ 
+			if(g_guiSettings.GetInt("audiooutput.mode")==AUDIO_DIGITAL)
+			g_guiSettings.SetInt("audiooutput.mode", AUDIO_ANALOG);
+			else
+			g_guiSettings.SetInt("audiooutput.mode", AUDIO_DIGITAL);
+			g_application.Restart();
+			if (g_windowManager.GetActiveWindow() == WINDOW_SETTINGS_SYSTEM)
+			{
+				CGUIMessage msg(GUI_MSG_WINDOW_INIT, 0,0,WINDOW_INVALID,g_windowManager.GetActiveWindow());
+				g_windowManager.SendMessage(msg);
+			}
+			return true;
+		}
 
-    // calculate speed so that a full press will equal 1 second from min to max
-    float speed = float(VOLUME_MAXIMUM - VOLUME_MINIMUM);
-    if( action.GetRepeat() )
-      speed *= action.GetRepeat();
-    else
-      speed /= 50; //50 fps
-    if (g_settings.m_bMute)
-    {
-      // only unmute if volume is to be increased, otherwise leave muted
-      if (action.GetID() == ACTION_VOLUME_DOWN)
-        return true;
-      
-      if (g_settings.m_iPreMuteVolumeLevel == 0) 
-        SetVolume(1); 
-      else 
-      // In muted, unmute 
-        Mute();
-      return true;
-    }
-    if (action.GetID() == ACTION_VOLUME_UP)
-    {
-      volume += (int)((float)fabs(action.GetAmount()) * action.GetAmount() * speed);
-    }
-    else
-    {
-      volume -= (int)((float)fabs(action.GetAmount()) * action.GetAmount() * speed);
-    }
+		// Check for global volume control
+		if (action.GetAmount() && (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN))
+		{
+			// increase or decrease the volume
+			int volume = g_settings.m_nVolumeLevel + g_settings.m_dynamicRangeCompressionLevel;
 
-    SetHardwareVolume(volume);
+			// calculate speed so that a full press will equal 1 second from min to max
+			float speed = float(VOLUME_MAXIMUM - VOLUME_MINIMUM);
+			if( action.GetRepeat() )
+			speed *= action.GetRepeat();
+			else
+			speed /= 50; //50 fps
+			if (g_settings.m_bMute)
+			{
+				// only unmute if volume is to be increased, otherwise leave muted
+				if (action.GetID() == ACTION_VOLUME_DOWN)
+				return true;
+				
+				if (g_settings.m_iPreMuteVolumeLevel == 0) 
+				SetVolume(1); 
+				else 
+				// In muted, unmute 
+				Mute();
+				return true;
+			}
+			if (action.GetID() == ACTION_VOLUME_UP)
+			{
+				volume += (int)((float)fabs(action.GetAmount()) * action.GetAmount() * speed);
+			}
+			else
+			{
+				volume -= (int)((float)fabs(action.GetAmount()) * action.GetAmount() * speed);
+			}
+
+			SetHardwareVolume(volume);
 #ifndef HAS_SDL_AUDIO
-    g_audioManager.SetVolume(g_settings.m_nVolumeLevel);
+			g_audioManager.SetVolume(g_settings.m_nVolumeLevel);
 #else
-    g_audioManager.SetVolume((int)(128.f * (g_settings.m_nVolumeLevel - VOLUME_MINIMUM) / (float)(VOLUME_MAXIMUM - VOLUME_MINIMUM)));
+			g_audioManager.SetVolume((int)(128.f * (g_settings.m_nVolumeLevel - VOLUME_MINIMUM) / (float)(VOLUME_MAXIMUM - VOLUME_MINIMUM)));
 #endif
 
-    // show visual feedback of volume change...
-    m_guiDialogVolumeBar.Show();
-    m_guiDialogVolumeBar.OnAction(action);
-    return true;
-  }
-  // Check for global seek control
-  if (IsPlaying() && action.GetAmount() && (action.GetID() == ACTION_ANALOG_SEEK_FORWARD || action.GetID() == ACTION_ANALOG_SEEK_BACK))
-  {
-    if (!m_pPlayer->CanSeek()) return false;
-    m_guiDialogSeekBar.OnAction(action);
-    return true;
-  }
-  if (action.GetID() == ACTION_SHOW_PLAYLIST)
-  {
-    int iPlaylist = g_playlistPlayer.GetCurrentPlaylist();
-    if (iPlaylist == PLAYLIST_VIDEO && g_windowManager.GetActiveWindow() != WINDOW_VIDEO_PLAYLIST)
-      g_windowManager.ActivateWindow(WINDOW_VIDEO_PLAYLIST);
-    else if (iPlaylist == PLAYLIST_MUSIC && g_windowManager.GetActiveWindow() != WINDOW_MUSIC_PLAYLIST)
-      g_windowManager.ActivateWindow(WINDOW_MUSIC_PLAYLIST);
-    return true;
-  }
-  return false;
-}
+			// show visual feedback of volume change...
+			m_guiDialogVolumeBar.Show();
+			m_guiDialogVolumeBar.OnAction(action);
+			return true;
+		}
+		// Check for global seek control
+		if (IsPlaying() && action.GetAmount() && (action.GetID() == ACTION_ANALOG_SEEK_FORWARD || action.GetID() == ACTION_ANALOG_SEEK_BACK))
+		{
+			if (!m_pPlayer->CanSeek()) return false;
+			m_guiDialogSeekBar.OnAction(action);
+			return true;
+		}
+		if (action.GetID() == ACTION_SHOW_PLAYLIST)
+		{
+			int iPlaylist = g_playlistPlayer.GetCurrentPlaylist();
+			if (iPlaylist == PLAYLIST_VIDEO && g_windowManager.GetActiveWindow() != WINDOW_VIDEO_PLAYLIST)
+			g_windowManager.ActivateWindow(WINDOW_VIDEO_PLAYLIST);
+			else if (iPlaylist == PLAYLIST_MUSIC && g_windowManager.GetActiveWindow() != WINDOW_MUSIC_PLAYLIST)
+			g_windowManager.ActivateWindow(WINDOW_MUSIC_PLAYLIST);
+			return true;
+		}
+		return false;
+	}
 
-void CApplication::UpdateLCD()
-{
+	void CApplication::UpdateLCD()
+	{
 #ifdef HAS_LCD
-  static lTickCount = 0;
+		static lTickCount = 0;
 
-  if (!g_lcd || g_guiSettings.GetInt("lcd.type") == LCD_TYPE_NONE)
-    return ;
-  long lTimeOut = 1000;
-  if ( m_iPlaySpeed != 1)
-    lTimeOut = 0;
-  if ( ((long)GetTickCount() - lTickCount) >= lTimeOut)
-  {
-    if (g_application.NavigationIdleTime() < 5)
-      g_lcd->Render(ILCD::LCD_MODE_NAVIGATION);
-    else if (IsPlayingVideo())
-      g_lcd->Render(ILCD::LCD_MODE_VIDEO);
-    else if (IsPlayingAudio())
-      g_lcd->Render(ILCD::LCD_MODE_MUSIC);
-    else if (IsInScreenSaver())
-      g_lcd->Render(ILCD::LCD_MODE_SCREENSAVER);
-    else
-      g_lcd->Render(ILCD::LCD_MODE_GENERAL);
+		if (!g_lcd || g_guiSettings.GetInt("lcd.type") == LCD_TYPE_NONE)
+		return ;
+		long lTimeOut = 1000;
+		if ( m_iPlaySpeed != 1)
+		lTimeOut = 0;
+		if ( ((long)GetTickCount() - lTickCount) >= lTimeOut)
+		{
+			if (g_application.NavigationIdleTime() < 5)
+			g_lcd->Render(ILCD::LCD_MODE_NAVIGATION);
+			else if (IsPlayingVideo())
+			g_lcd->Render(ILCD::LCD_MODE_VIDEO);
+			else if (IsPlayingAudio())
+			g_lcd->Render(ILCD::LCD_MODE_MUSIC);
+			else if (IsInScreenSaver())
+			g_lcd->Render(ILCD::LCD_MODE_SCREENSAVER);
+			else
+			g_lcd->Render(ILCD::LCD_MODE_GENERAL);
 
-    // reset tick count
-    lTickCount = GetTickCount();
-  }
+			// reset tick count
+			lTickCount = GetTickCount();
+		}
 #endif
-}
+	}
 
-void CApplication::FrameMove()
-{
-  // currently we calculate the repeat time (ie time from last similar keypress) just global as fps
-  float frameTime = m_frameTime.GetElapsedSeconds();
-  m_frameTime.StartZero();
-  // never set a frametime less than 2 fps to avoid problems when debuggin and on breaks
-  if( frameTime > 0.5 ) frameTime = 0.5;
+	void CApplication::FrameMove()
+	{
+		// currently we calculate the repeat time (ie time from last similar keypress) just global as fps
+		float frameTime = m_frameTime.GetElapsedSeconds();
+		m_frameTime.StartZero();
+		// never set a frametime less than 2 fps to avoid problems when debuggin and on breaks
+		if( frameTime > 0.5 ) frameTime = 0.5;
 
-  g_graphicsContext.Lock();
-  // check if there are notifications to display
-  if (m_guiDialogKaiToast.DoWork())
-  {
-    if (!m_guiDialogKaiToast.IsDialogRunning())
-    {
-      m_guiDialogKaiToast.Show();
-    }
-  }
-  g_graphicsContext.Unlock();
+		g_graphicsContext.Lock();
+		// check if there are notifications to display
+		if (m_guiDialogKaiToast.DoWork())
+		{
+			if (!m_guiDialogKaiToast.IsDialogRunning())
+			{
+				m_guiDialogKaiToast.Show();
+			}
+		}
+		g_graphicsContext.Unlock();
 
-  UpdateLCD();
+		UpdateLCD();
 
-  // read raw input from controller, remote control, mouse and keyboard
-  ReadInput();
-  // process input actions
-  ProcessMouse();
-  ProcessHTTPApiButtons();
-  ProcessKeyboard();
-  ProcessRemote(frameTime);
-  ProcessGamepad(frameTime);
-  ProcessEventServer(frameTime);
+		// read raw input from controller, remote control, mouse and keyboard
+		ReadInput();
+		// process input actions
+		ProcessMouse();
+		ProcessHTTPApiButtons();
+		ProcessKeyboard();
+		ProcessRemote(frameTime);
+		ProcessGamepad(frameTime);
+		ProcessEventServer(frameTime);
 
-  g_windowManager.FrameMove();
-}
+		g_windowManager.FrameMove();
+	}
 
-bool CApplication::ProcessGamepad(float frameTime)
-{
+	bool CApplication::ProcessGamepad(float frameTime)
+	{
 #ifdef HAS_GAMEPAD
-  // Handle the gamepad button presses.  We check for button down,
-  // then call OnKey() which handles the translation to actions, and sends the
-  // action to our window manager's OnAction() function, which filters the messages
-  // to where they're supposed to end up, returning true if the message is successfully
-  // processed.  If OnKey() returns false, then the key press wasn't processed at all,
-  // and we can safely process the next key (or next check on the same key in the
-  // case of the analog sticks which can produce more than 1 key event.)
+		// Handle the gamepad button presses.  We check for button down,
+		// then call OnKey() which handles the translation to actions, and sends the
+		// action to our window manager's OnAction() function, which filters the messages
+		// to where they're supposed to end up, returning true if the message is successfully
+		// processed.  If OnKey() returns false, then the key press wasn't processed at all,
+		// and we can safely process the next key (or next check on the same key in the
+		// case of the analog sticks which can produce more than 1 key event.)
 
-  WORD wButtons = m_DefaultGamepad.wButtons;
-  WORD wDpad = wButtons & (XINPUT_GAMEPAD_DPAD_UP | XINPUT_GAMEPAD_DPAD_DOWN | XINPUT_GAMEPAD_DPAD_LEFT | XINPUT_GAMEPAD_DPAD_RIGHT);
+		WORD wButtons = m_DefaultGamepad.wButtons;
+		WORD wDpad = wButtons & (XINPUT_GAMEPAD_DPAD_UP | XINPUT_GAMEPAD_DPAD_DOWN | XINPUT_GAMEPAD_DPAD_LEFT | XINPUT_GAMEPAD_DPAD_RIGHT);
 
-  BYTE bLeftTrigger = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER];
-  BYTE bRightTrigger = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER];
-  BYTE bButtonA = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A];
-  BYTE bButtonB = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_B];
-  BYTE bButtonX = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_X];
-  BYTE bButtonY = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y];
+		BYTE bLeftTrigger = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER];
+		BYTE bRightTrigger = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER];
+		BYTE bButtonA = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A];
+		BYTE bButtonB = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_B];
+		BYTE bButtonX = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_X];
+		BYTE bButtonY = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y];
 
-  // pass them through the delay
-  WORD wDir = m_ctrDpad.DpadInput(wDpad, 0 != bLeftTrigger, 0 != bRightTrigger);
+		// pass them through the delay
+		WORD wDir = m_ctrDpad.DpadInput(wDpad, 0 != bLeftTrigger, 0 != bRightTrigger);
 
-  // map all controller & remote actions to their keys
-  if (m_DefaultGamepad.fX1 || m_DefaultGamepad.fY1)
-  {
-    CKey key(KEY_BUTTON_LEFT_THUMB_STICK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.fX2 || m_DefaultGamepad.fY2)
-  {
-    CKey key(KEY_BUTTON_RIGHT_THUMB_STICK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  // direction specific keys (for defining different actions for each direction)
-  // We need to be able to know when it last had a direction, so that we can
-  // post the reset direction code the next time around (to reset scrolling,
-  // fastforwarding and other analog actions)
+		// map all controller & remote actions to their keys
+		if (m_DefaultGamepad.fX1 || m_DefaultGamepad.fY1)
+		{
+			CKey key(KEY_BUTTON_LEFT_THUMB_STICK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.fX2 || m_DefaultGamepad.fY2)
+		{
+			CKey key(KEY_BUTTON_RIGHT_THUMB_STICK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		// direction specific keys (for defining different actions for each direction)
+		// We need to be able to know when it last had a direction, so that we can
+		// post the reset direction code the next time around (to reset scrolling,
+		// fastforwarding and other analog actions)
 
-  // For the sticks, once it is pushed in one direction (eg up) it will only
-  // detect movement in that direction of movement (eg up or down) - the other
-  // direction (eg left and right) will not be registered until the stick has
-  // been recentered for at least 2 frames.
+		// For the sticks, once it is pushed in one direction (eg up) it will only
+		// detect movement in that direction of movement (eg up or down) - the other
+		// direction (eg left and right) will not be registered until the stick has
+		// been recentered for at least 2 frames.
 
-  // first the right stick
-  static lastRightStickKey = 0;
-  int newRightStickKey = 0;
-  if (lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_UP || lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_DOWN)
-  {
-    if (m_DefaultGamepad.fY2 > 0)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
-    else if (m_DefaultGamepad.fY2 < 0)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_DOWN;
-    else if (m_DefaultGamepad.fX2 != 0)
-    {
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
-      //m_DefaultGamepad.fY2 = 0.00001f; // small amount of movement
-    }
-  }
-  else if (lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_LEFT || lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT)
-  {
-    if (m_DefaultGamepad.fX2 > 0)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
-    else if (m_DefaultGamepad.fX2 < 0)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_LEFT;
-    else if (m_DefaultGamepad.fY2 != 0)
-    {
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
-      //m_DefaultGamepad.fX2 = 0.00001f; // small amount of movement
-    }
-  }
-  else
-  {
-    if (m_DefaultGamepad.fY2 > 0 && m_DefaultGamepad.fX2*2 < m_DefaultGamepad.fY2 && -m_DefaultGamepad.fX2*2 < m_DefaultGamepad.fY2)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
-    else if (m_DefaultGamepad.fY2 < 0 && m_DefaultGamepad.fX2*2 < -m_DefaultGamepad.fY2 && -m_DefaultGamepad.fX2*2 < -m_DefaultGamepad.fY2)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_DOWN;
-    else if (m_DefaultGamepad.fX2 > 0 && m_DefaultGamepad.fY2*2 < m_DefaultGamepad.fX2 && -m_DefaultGamepad.fY2*2 < m_DefaultGamepad.fX2)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
-    else if (m_DefaultGamepad.fX2 < 0 && m_DefaultGamepad.fY2*2 < -m_DefaultGamepad.fX2 && -m_DefaultGamepad.fY2*2 < -m_DefaultGamepad.fX2)
-      newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_LEFT;
-  }
-  if (lastRightStickKey && newRightStickKey != lastRightStickKey)
-  { // was held down last time - and we have a new key now
-    // post old key reset message...
-    CKey key(lastRightStickKey, 0, 0, 0, 0, 0, 0);
-    lastRightStickKey = newRightStickKey;
-    if (OnKey(key)) return true;
-  }
-  lastRightStickKey = newRightStickKey;
-  // post the new key's message
-  if (newRightStickKey)
-  {
-    CKey key(newRightStickKey, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
+		// first the right stick
+		static lastRightStickKey = 0;
+		int newRightStickKey = 0;
+		if (lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_UP || lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_DOWN)
+		{
+			if (m_DefaultGamepad.fY2 > 0)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
+			else if (m_DefaultGamepad.fY2 < 0)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_DOWN;
+			else if (m_DefaultGamepad.fX2 != 0)
+			{
+				newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
+				//m_DefaultGamepad.fY2 = 0.00001f; // small amount of movement
+			}
+		}
+		else if (lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_LEFT || lastRightStickKey == KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT)
+		{
+			if (m_DefaultGamepad.fX2 > 0)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
+			else if (m_DefaultGamepad.fX2 < 0)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_LEFT;
+			else if (m_DefaultGamepad.fY2 != 0)
+			{
+				newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
+				//m_DefaultGamepad.fX2 = 0.00001f; // small amount of movement
+			}
+		}
+		else
+		{
+			if (m_DefaultGamepad.fY2 > 0 && m_DefaultGamepad.fX2*2 < m_DefaultGamepad.fY2 && -m_DefaultGamepad.fX2*2 < m_DefaultGamepad.fY2)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_UP;
+			else if (m_DefaultGamepad.fY2 < 0 && m_DefaultGamepad.fX2*2 < -m_DefaultGamepad.fY2 && -m_DefaultGamepad.fX2*2 < -m_DefaultGamepad.fY2)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_DOWN;
+			else if (m_DefaultGamepad.fX2 > 0 && m_DefaultGamepad.fY2*2 < m_DefaultGamepad.fX2 && -m_DefaultGamepad.fY2*2 < m_DefaultGamepad.fX2)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT;
+			else if (m_DefaultGamepad.fX2 < 0 && m_DefaultGamepad.fY2*2 < -m_DefaultGamepad.fX2 && -m_DefaultGamepad.fY2*2 < -m_DefaultGamepad.fX2)
+			newRightStickKey = KEY_BUTTON_RIGHT_THUMB_STICK_LEFT;
+		}
+		if (lastRightStickKey && newRightStickKey != lastRightStickKey)
+		{ // was held down last time - and we have a new key now
+			// post old key reset message...
+			CKey key(lastRightStickKey, 0, 0, 0, 0, 0, 0);
+			lastRightStickKey = newRightStickKey;
+			if (OnKey(key)) return true;
+		}
+		lastRightStickKey = newRightStickKey;
+		// post the new key's message
+		if (newRightStickKey)
+		{
+			CKey key(newRightStickKey, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
 
-  // now the left stick
-  static lastLeftStickKey = 0;
-  int newLeftStickKey = 0;
-  if (lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_UP || lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_DOWN)
-  {
-    if (m_DefaultGamepad.fY1 > 0)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_UP;
-    else if (m_DefaultGamepad.fY1 < 0)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_DOWN;
-  }
-  else if (lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_LEFT || lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_RIGHT)
-  {
-    if (m_DefaultGamepad.fX1 > 0)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_RIGHT;
-    else if (m_DefaultGamepad.fX1 < 0)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_LEFT;
-  }
-  else
-  { // check for a new control movement
-    if (m_DefaultGamepad.fY1 > 0 && m_DefaultGamepad.fX1 < m_DefaultGamepad.fY1 && -m_DefaultGamepad.fX1 < m_DefaultGamepad.fY1)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_UP;
-    else if (m_DefaultGamepad.fY1 < 0 && m_DefaultGamepad.fX1 < -m_DefaultGamepad.fY1 && -m_DefaultGamepad.fX1 < -m_DefaultGamepad.fY1)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_DOWN;
-    else if (m_DefaultGamepad.fX1 > 0 && m_DefaultGamepad.fY1 < m_DefaultGamepad.fX1 && -m_DefaultGamepad.fY1 < m_DefaultGamepad.fX1)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_RIGHT;
-    else if (m_DefaultGamepad.fX1 < 0 && m_DefaultGamepad.fY1 < -m_DefaultGamepad.fX1 && -m_DefaultGamepad.fY1 < -m_DefaultGamepad.fX1)
-      newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_LEFT;
-  }
+		// now the left stick
+		static lastLeftStickKey = 0;
+		int newLeftStickKey = 0;
+		if (lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_UP || lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_DOWN)
+		{
+			if (m_DefaultGamepad.fY1 > 0)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_UP;
+			else if (m_DefaultGamepad.fY1 < 0)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_DOWN;
+		}
+		else if (lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_LEFT || lastLeftStickKey == KEY_BUTTON_LEFT_THUMB_STICK_RIGHT)
+		{
+			if (m_DefaultGamepad.fX1 > 0)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_RIGHT;
+			else if (m_DefaultGamepad.fX1 < 0)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_LEFT;
+		}
+		else
+		{ // check for a new control movement
+			if (m_DefaultGamepad.fY1 > 0 && m_DefaultGamepad.fX1 < m_DefaultGamepad.fY1 && -m_DefaultGamepad.fX1 < m_DefaultGamepad.fY1)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_UP;
+			else if (m_DefaultGamepad.fY1 < 0 && m_DefaultGamepad.fX1 < -m_DefaultGamepad.fY1 && -m_DefaultGamepad.fX1 < -m_DefaultGamepad.fY1)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_DOWN;
+			else if (m_DefaultGamepad.fX1 > 0 && m_DefaultGamepad.fY1 < m_DefaultGamepad.fX1 && -m_DefaultGamepad.fY1 < m_DefaultGamepad.fX1)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_RIGHT;
+			else if (m_DefaultGamepad.fX1 < 0 && m_DefaultGamepad.fY1 < -m_DefaultGamepad.fX1 && -m_DefaultGamepad.fY1 < -m_DefaultGamepad.fX1)
+			newLeftStickKey = KEY_BUTTON_LEFT_THUMB_STICK_LEFT;
+		}
 
-  if (lastLeftStickKey && newLeftStickKey != lastLeftStickKey)
-  { // was held down last time - and we have a new key now
-    // post old key reset message...
-    CKey key(lastLeftStickKey, 0, 0, 0, 0, 0, 0);
-    lastLeftStickKey = newLeftStickKey;
-    if (OnKey(key)) return true;
-  }
-  lastLeftStickKey = newLeftStickKey;
-  // post the new key's message
-  if (newLeftStickKey)
-  {
-    CKey key(newLeftStickKey, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
+		if (lastLeftStickKey && newLeftStickKey != lastLeftStickKey)
+		{ // was held down last time - and we have a new key now
+			// post old key reset message...
+			CKey key(lastLeftStickKey, 0, 0, 0, 0, 0, 0);
+			lastLeftStickKey = newLeftStickKey;
+			if (OnKey(key)) return true;
+		}
+		lastLeftStickKey = newLeftStickKey;
+		// post the new key's message
+		if (newLeftStickKey)
+		{
+			CKey key(newLeftStickKey, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
 
-  // Trigger detection
-  static lastTriggerKey = 0;
-  int newTriggerKey = 0;
-  if (bLeftTrigger)
-    newTriggerKey = KEY_BUTTON_LEFT_ANALOG_TRIGGER;
-  else if (bRightTrigger)
-    newTriggerKey = KEY_BUTTON_RIGHT_ANALOG_TRIGGER;
-  if (lastTriggerKey && newTriggerKey != lastTriggerKey)
-  { // was held down last time - and we have a new key now
-    // post old key reset message...
-    CKey key(lastTriggerKey, 0, 0, 0, 0, 0, 0);
-    lastTriggerKey = newTriggerKey;
-    if (OnKey(key)) return true;
-  }
-  lastTriggerKey = newTriggerKey;
-  // post the new key's message
-  if (newTriggerKey)
-  {
-    CKey key(newTriggerKey, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
+		// Trigger detection
+		static lastTriggerKey = 0;
+		int newTriggerKey = 0;
+		if (bLeftTrigger)
+		newTriggerKey = KEY_BUTTON_LEFT_ANALOG_TRIGGER;
+		else if (bRightTrigger)
+		newTriggerKey = KEY_BUTTON_RIGHT_ANALOG_TRIGGER;
+		if (lastTriggerKey && newTriggerKey != lastTriggerKey)
+		{ // was held down last time - and we have a new key now
+			// post old key reset message...
+			CKey key(lastTriggerKey, 0, 0, 0, 0, 0, 0);
+			lastTriggerKey = newTriggerKey;
+			if (OnKey(key)) return true;
+		}
+		lastTriggerKey = newTriggerKey;
+		// post the new key's message
+		if (newTriggerKey)
+		{
+			CKey key(newTriggerKey, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
 
-  // Now the digital buttons...
-  if ( wDir & DC_LEFTTRIGGER)
-  {
-    CKey key(KEY_BUTTON_LEFT_TRIGGER, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if ( wDir & DC_RIGHTTRIGGER)
-  {
-    CKey key(KEY_BUTTON_RIGHT_TRIGGER, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if ( wDir & DC_LEFT )
-  {
-    CKey key(KEY_BUTTON_DPAD_LEFT, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if ( wDir & DC_RIGHT)
-  {
-    CKey key(KEY_BUTTON_DPAD_RIGHT, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if ( wDir & DC_UP )
-  {
-    CKey key(KEY_BUTTON_DPAD_UP, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if ( wDir & DC_DOWN )
-  {
-    CKey key(KEY_BUTTON_DPAD_DOWN, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
+		// Now the digital buttons...
+		if ( wDir & DC_LEFTTRIGGER)
+		{
+			CKey key(KEY_BUTTON_LEFT_TRIGGER, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if ( wDir & DC_RIGHTTRIGGER)
+		{
+			CKey key(KEY_BUTTON_RIGHT_TRIGGER, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if ( wDir & DC_LEFT )
+		{
+			CKey key(KEY_BUTTON_DPAD_LEFT, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if ( wDir & DC_RIGHT)
+		{
+			CKey key(KEY_BUTTON_DPAD_RIGHT, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if ( wDir & DC_UP )
+		{
+			CKey key(KEY_BUTTON_DPAD_UP, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if ( wDir & DC_DOWN )
+		{
+			CKey key(KEY_BUTTON_DPAD_DOWN, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
 
-  if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
-  {
-    CKey key(KEY_BUTTON_BACK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START)
-  {
-    CKey key(KEY_BUTTON_START, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_LEFT_THUMB)
-  {
-    CKey key(KEY_BUTTON_LEFT_THUMB_BUTTON, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_RIGHT_THUMB)
-  {
-    CKey key(KEY_BUTTON_RIGHT_THUMB_BUTTON, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
-  {
-    CKey key(KEY_BUTTON_A, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B])
-  {
-    CKey key(KEY_BUTTON_B, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
+		if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
+		{
+			CKey key(KEY_BUTTON_BACK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START)
+		{
+			CKey key(KEY_BUTTON_START, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_LEFT_THUMB)
+		{
+			CKey key(KEY_BUTTON_LEFT_THUMB_BUTTON, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_RIGHT_THUMB)
+		{
+			CKey key(KEY_BUTTON_RIGHT_THUMB_BUTTON, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
+		{
+			CKey key(KEY_BUTTON_A, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B])
+		{
+			CKey key(KEY_BUTTON_B, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
 
-  if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X])
-  {
-    CKey key(KEY_BUTTON_X, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y])
-  {
-    CKey key(KEY_BUTTON_Y, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
-  {
-    CKey key(KEY_BUTTON_BLACK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
-  if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
-  {
-    CKey key(KEY_BUTTON_WHITE, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
-    if (OnKey(key)) return true;
-  }
+		if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X])
+		{
+			CKey key(KEY_BUTTON_X, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y])
+		{
+			CKey key(KEY_BUTTON_Y, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
+		{
+			CKey key(KEY_BUTTON_BLACK, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
+		if (m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
+		{
+			CKey key(KEY_BUTTON_WHITE, bLeftTrigger, bRightTrigger, m_DefaultGamepad.fX1, m_DefaultGamepad.fY1, m_DefaultGamepad.fX2, m_DefaultGamepad.fY2, frameTime);
+			if (OnKey(key)) return true;
+		}
 #endif
-  return false;
-}
+		return false;
+	}
 
-bool CApplication::ProcessRemote(float frameTime)
-{
+	bool CApplication::ProcessRemote(float frameTime)
+	{
 #ifdef HAS_IR_REMOTE
-  if (m_DefaultIR_Remote.wButtons)
-  {
-    // time depends on whether the movement is repeated (held down) or not.
-    // If it is, we use the FPS timer to get a repeatable speed.
-    // If it isn't, we use 20 to get repeatable jumps.
-    float time = (m_DefaultIR_Remote.bHeldDown) ? frameTime : 0.020f;
-    CKey key(m_DefaultIR_Remote.wButtons, 0, 0, 0, 0, 0, 0, time);
-    return OnKey(key);
-  }
+		if (m_DefaultIR_Remote.wButtons)
+		{
+			// time depends on whether the movement is repeated (held down) or not.
+			// If it is, we use the FPS timer to get a repeatable speed.
+			// If it isn't, we use 20 to get repeatable jumps.
+			float time = (m_DefaultIR_Remote.bHeldDown) ? frameTime : 0.020f;
+			CKey key(m_DefaultIR_Remote.wButtons, 0, 0, 0, 0, 0, 0, time);
+			return OnKey(key);
+		}
 #endif
-  return false;
-}
+		return false;
+	}
 
-bool CApplication::ProcessMouse()
-{
-  if (!g_Mouse.IsActive())
-    return false;
-  // Reset the screensaver and idle timers
-  m_idleTimer.StartZero();
-  ResetScreenSaver();
-  if (ResetScreenSaverWindow())
-    return true;
+	bool CApplication::ProcessMouse()
+	{
+		if (!g_Mouse.IsActive())
+		return false;
+		// Reset the screensaver and idle timers
+		m_idleTimer.StartZero();
+		ResetScreenSaver();
+		if (ResetScreenSaverWindow())
+		return true;
 
-  int actionID = ACTION_MOUSE_MOVE;
-  if (g_Mouse.bClick[MOUSE_LEFT_BUTTON])
-    actionID = ACTION_MOUSE_LEFT_CLICK;
-  else if (g_Mouse.bClick[MOUSE_RIGHT_BUTTON])
-    actionID = ACTION_MOUSE_RIGHT_CLICK;
-  else if (g_Mouse.bClick[MOUSE_MIDDLE_BUTTON])
-    actionID = ACTION_MOUSE_MIDDLE_CLICK;
-  else if (g_Mouse.bDoubleClick[MOUSE_LEFT_BUTTON])
-    actionID = ACTION_MOUSE_DOUBLE_CLICK;
-  else if (g_Mouse.bHold[MOUSE_LEFT_BUTTON])
-    actionID = ACTION_MOUSE_DRAG;
-  else if (g_Mouse.GetWheel() > 0)
-    actionID = ACTION_MOUSE_WHEEL_UP;
-  else if (g_Mouse.GetWheel() < 0)
-    actionID = ACTION_MOUSE_WHEEL_DOWN;
+		int actionID = ACTION_MOUSE_MOVE;
+		if (g_Mouse.bClick[MOUSE_LEFT_BUTTON])
+		actionID = ACTION_MOUSE_LEFT_CLICK;
+		else if (g_Mouse.bClick[MOUSE_RIGHT_BUTTON])
+		actionID = ACTION_MOUSE_RIGHT_CLICK;
+		else if (g_Mouse.bClick[MOUSE_MIDDLE_BUTTON])
+		actionID = ACTION_MOUSE_MIDDLE_CLICK;
+		else if (g_Mouse.bDoubleClick[MOUSE_LEFT_BUTTON])
+		actionID = ACTION_MOUSE_DOUBLE_CLICK;
+		else if (g_Mouse.bHold[MOUSE_LEFT_BUTTON])
+		actionID = ACTION_MOUSE_DRAG;
+		else if (g_Mouse.GetWheel() > 0)
+		actionID = ACTION_MOUSE_WHEEL_UP;
+		else if (g_Mouse.GetWheel() < 0)
+		actionID = ACTION_MOUSE_WHEEL_DOWN;
 
-  CAction action(actionID, (unsigned int)g_Mouse.bHold[MOUSE_LEFT_BUTTON], g_Mouse.GetLocation().x, g_Mouse.GetLocation().y, g_Mouse.GetLastMove().x, g_Mouse.GetLastMove().y);
-  return g_windowManager.OnAction(action);
-}
+		CAction action(actionID, (unsigned int)g_Mouse.bHold[MOUSE_LEFT_BUTTON], g_Mouse.GetLocation().x, g_Mouse.GetLocation().y, g_Mouse.GetLastMove().x, g_Mouse.GetLastMove().y);
+		return g_windowManager.OnAction(action);
+	}
 
-void  CApplication::CheckForTitleChange()
-{ 
-  if (g_settings.m_HttpApiBroadcastLevel>=1)
-  {
-    if (IsPlayingVideo())
-    {
-      const CVideoInfoTag* tagVal = g_infoManager.GetCurrentMovieTag();
-      if (m_pXbmcHttp && tagVal && !(tagVal->m_strTitle.IsEmpty()))
-      {
-        CStdString msg=m_pXbmcHttp->GetOpenTag()+"MovieTitle:"+tagVal->m_strTitle+m_pXbmcHttp->GetCloseTag();
-        if (m_prevMedia!=msg && g_settings.m_HttpApiBroadcastLevel>=1)
-        {
-          m_applicationMessenger.HttpApi("broadcastlevel; MediaChanged:"+msg+";1");
-          m_prevMedia=msg;
-        }
-      }
-    }
-    else if (IsPlayingAudio())
-    {
-      const CMusicInfoTag* tagVal=g_infoManager.GetCurrentSongTag();
-      if (m_pXbmcHttp && tagVal)
-      {
-        CStdString msg="";
-        if (!tagVal->GetTitle().IsEmpty())
-          msg=m_pXbmcHttp->GetOpenTag()+"AudioTitle:"+tagVal->GetTitle()+m_pXbmcHttp->GetCloseTag();
-        if (!tagVal->GetArtist().IsEmpty())
-          msg+=m_pXbmcHttp->GetOpenTag()+"AudioArtist:"+tagVal->GetArtist()+m_pXbmcHttp->GetCloseTag();
-        if (m_prevMedia!=msg)
-        {
-          m_applicationMessenger.HttpApi("broadcastlevel; MediaChanged:"+msg+";1");
-          m_prevMedia=msg;
-        }
-      }
-    }
-  }
-}
+	void  CApplication::CheckForTitleChange()
+	{ 
+		if (g_settings.m_HttpApiBroadcastLevel>=1)
+		{
+			if (IsPlayingVideo())
+			{
+				const CVideoInfoTag* tagVal = g_infoManager.GetCurrentMovieTag();
+				if (m_pXbmcHttp && tagVal && !(tagVal->m_strTitle.IsEmpty()))
+				{
+					CStdString msg=m_pXbmcHttp->GetOpenTag()+"MovieTitle:"+tagVal->m_strTitle+m_pXbmcHttp->GetCloseTag();
+					if (m_prevMedia!=msg && g_settings.m_HttpApiBroadcastLevel>=1)
+					{
+						m_applicationMessenger.HttpApi("broadcastlevel; MediaChanged:"+msg+";1");
+						m_prevMedia=msg;
+					}
+				}
+			}
+			else if (IsPlayingAudio())
+			{
+				const CMusicInfoTag* tagVal=g_infoManager.GetCurrentSongTag();
+				if (m_pXbmcHttp && tagVal)
+				{
+					CStdString msg="";
+					if (!tagVal->GetTitle().IsEmpty())
+					msg=m_pXbmcHttp->GetOpenTag()+"AudioTitle:"+tagVal->GetTitle()+m_pXbmcHttp->GetCloseTag();
+					if (!tagVal->GetArtist().IsEmpty())
+					msg+=m_pXbmcHttp->GetOpenTag()+"AudioArtist:"+tagVal->GetArtist()+m_pXbmcHttp->GetCloseTag();
+					if (m_prevMedia!=msg)
+					{
+						m_applicationMessenger.HttpApi("broadcastlevel; MediaChanged:"+msg+";1");
+						m_prevMedia=msg;
+					}
+				}
+			}
+		}
+	}
 
-bool CApplication::ProcessHTTPApiButtons()
-{
-  if (m_pXbmcHttp)
-  {
-    // copy key from webserver, and reset it in case we're called again before
-    // whatever happens in OnKey()
-    CKey keyHttp(m_pXbmcHttp->GetKey());
-    m_pXbmcHttp->ResetKey();
-    if (keyHttp.GetButtonCode() != KEY_INVALID)
-    {
-      if (keyHttp.GetButtonCode() == KEY_VMOUSE) //virtual mouse
-      {
-        g_Mouse.SetLocation(CPoint(keyHttp.GetLeftThumbX(), keyHttp.GetLeftThumbY()));
-        int actionID = ACTION_MOUSE_MOVE;
-        if (keyHttp.GetLeftTrigger() == 1)
-          actionID = ACTION_MOUSE_LEFT_CLICK;
-        else if (keyHttp.GetLeftTrigger() == 2)
-          actionID = ACTION_MOUSE_RIGHT_CLICK;
-        else if (keyHttp.GetLeftTrigger() == 3)
-          actionID = ACTION_MOUSE_MIDDLE_CLICK;
-        else if (keyHttp.GetRightTrigger() == 1)
-          actionID = ACTION_MOUSE_DOUBLE_CLICK;
-        CAction action(actionID, keyHttp.GetLeftThumbX(), keyHttp.GetLeftThumbY());
-        g_windowManager.OnAction(action);
-      }
-      else
-        OnKey(keyHttp);
-      return true;
-    }
-  }
-  return false;
-}
+	bool CApplication::ProcessHTTPApiButtons()
+	{
+		if (m_pXbmcHttp)
+		{
+			// copy key from webserver, and reset it in case we're called again before
+			// whatever happens in OnKey()
+			CKey keyHttp(m_pXbmcHttp->GetKey());
+			m_pXbmcHttp->ResetKey();
+			if (keyHttp.GetButtonCode() != KEY_INVALID)
+			{
+				if (keyHttp.GetButtonCode() == KEY_VMOUSE) //virtual mouse
+				{
+					g_Mouse.SetLocation(CPoint(keyHttp.GetLeftThumbX(), keyHttp.GetLeftThumbY()));
+					int actionID = ACTION_MOUSE_MOVE;
+					if (keyHttp.GetLeftTrigger() == 1)
+					actionID = ACTION_MOUSE_LEFT_CLICK;
+					else if (keyHttp.GetLeftTrigger() == 2)
+					actionID = ACTION_MOUSE_RIGHT_CLICK;
+					else if (keyHttp.GetLeftTrigger() == 3)
+					actionID = ACTION_MOUSE_MIDDLE_CLICK;
+					else if (keyHttp.GetRightTrigger() == 1)
+					actionID = ACTION_MOUSE_DOUBLE_CLICK;
+					CAction action(actionID, keyHttp.GetLeftThumbX(), keyHttp.GetLeftThumbY());
+					g_windowManager.OnAction(action);
+				}
+				else
+				OnKey(keyHttp);
+				return true;
+			}
+		}
+		return false;
+	}
 
-bool CApplication::ProcessEventServer(float frameTime)
-{
+	bool CApplication::ProcessEventServer(float frameTime)
+	{
 #ifdef HAS_EVENT_SERVER
-  CEventServer* es = CEventServer::GetInstance();
-  if (!es || !es->Running() || es->GetNumberOfClients()==0)
-    return false;
+		CEventServer* es = CEventServer::GetInstance();
+		if (!es || !es->Running() || es->GetNumberOfClients()==0)
+		return false;
 
-  // process any queued up actions
-  if (es->ExecuteNextAction())
-  {
-    // reset idle timers
-    m_idleTimer.StartZero();
-    ResetScreenSaver();
-    ResetScreenSaverWindow();
-  }
+		// process any queued up actions
+		if (es->ExecuteNextAction())
+		{
+			// reset idle timers
+			m_idleTimer.StartZero();
+			ResetScreenSaver();
+			ResetScreenSaverWindow();
+		}
 
-  // now handle any buttons or axis
-  std::string joystickName;
-  bool isAxis = false;
-  float fAmount = 0.0;
+		// now handle any buttons or axis
+		std::string joystickName;
+		bool isAxis = false;
+		float fAmount = 0.0;
 
-  WORD wKeyID = es->GetButtonCode(joystickName, isAxis, fAmount);
+		WORD wKeyID = es->GetButtonCode(joystickName, isAxis, fAmount);
 
-  if (wKeyID)
-  {
-    if (joystickName.length() > 0)
-    {
-      if (isAxis == true)
-      {
-        if (fabs(fAmount) >= 0.08)
-          m_lastAxisMap[joystickName][wKeyID] = fAmount;
-        else
-          m_lastAxisMap[joystickName].erase(wKeyID);
-      }
+		if (wKeyID)
+		{
+			if (joystickName.length() > 0)
+			{
+				if (isAxis == true)
+				{
+					if (fabs(fAmount) >= 0.08)
+					m_lastAxisMap[joystickName][wKeyID] = fAmount;
+					else
+					m_lastAxisMap[joystickName].erase(wKeyID);
+				}
 
-      return ProcessJoystickEvent(joystickName, wKeyID, isAxis, fAmount);
-    }
-    else
-    {
-      CKey key;
-      if(wKeyID == KEY_BUTTON_LEFT_ANALOG_TRIGGER)
-        key = CKey(wKeyID, (BYTE)(255*fAmount), 0, 0.0, 0.0, 0.0, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_RIGHT_ANALOG_TRIGGER)
-        key = CKey(wKeyID, 0, (BYTE)(255*fAmount), 0.0, 0.0, 0.0, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_LEFT)
-        key = CKey(wKeyID, 0, 0, -fAmount, 0.0, 0.0, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_RIGHT)
-        key = CKey(wKeyID, 0, 0,  fAmount, 0.0, 0.0, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_UP)
-        key = CKey(wKeyID, 0, 0, 0.0,  fAmount, 0.0, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_DOWN)
-        key = CKey(wKeyID, 0, 0, 0.0, -fAmount, 0.0, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_LEFT)
-        key = CKey(wKeyID, 0, 0, 0.0, 0.0, -fAmount, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT)
-        key = CKey(wKeyID, 0, 0, 0.0, 0.0,  fAmount, 0.0, frameTime);
-      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_UP)
-        key = CKey(wKeyID, 0, 0, 0.0, 0.0, 0.0,  fAmount, frameTime);
-      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_DOWN)
-        key = CKey(wKeyID, 0, 0, 0.0, 0.0, 0.0, -fAmount, frameTime);
-      else
-        key = CKey(wKeyID);
-      return OnKey(key);
-    }
-  }
+				return ProcessJoystickEvent(joystickName, wKeyID, isAxis, fAmount);
+			}
+			else
+			{
+				CKey key;
+				if(wKeyID == KEY_BUTTON_LEFT_ANALOG_TRIGGER)
+				key = CKey(wKeyID, (BYTE)(255*fAmount), 0, 0.0, 0.0, 0.0, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_RIGHT_ANALOG_TRIGGER)
+				key = CKey(wKeyID, 0, (BYTE)(255*fAmount), 0.0, 0.0, 0.0, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_LEFT)
+				key = CKey(wKeyID, 0, 0, -fAmount, 0.0, 0.0, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_RIGHT)
+				key = CKey(wKeyID, 0, 0,  fAmount, 0.0, 0.0, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_UP)
+				key = CKey(wKeyID, 0, 0, 0.0,  fAmount, 0.0, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_DOWN)
+				key = CKey(wKeyID, 0, 0, 0.0, -fAmount, 0.0, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_LEFT)
+				key = CKey(wKeyID, 0, 0, 0.0, 0.0, -fAmount, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT)
+				key = CKey(wKeyID, 0, 0, 0.0, 0.0,  fAmount, 0.0, frameTime);
+				else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_UP)
+				key = CKey(wKeyID, 0, 0, 0.0, 0.0, 0.0,  fAmount, frameTime);
+				else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_DOWN)
+				key = CKey(wKeyID, 0, 0, 0.0, 0.0, 0.0, -fAmount, frameTime);
+				else
+				key = CKey(wKeyID);
+				return OnKey(key);
+			}
+		}
 
-  if (m_lastAxisMap.size() > 0)
-  {
-    // Process all the stored axis.
-    for (map<std::string, map<int, float> >::iterator iter = m_lastAxisMap.begin(); iter != m_lastAxisMap.end(); ++iter)
-    {
-      for (map<int, float>::iterator iterAxis = (*iter).second.begin(); iterAxis != (*iter).second.end(); ++iterAxis)
-        ProcessJoystickEvent((*iter).first, (*iterAxis).first, true, (*iterAxis).second);
-    }
-  }
+		if (m_lastAxisMap.size() > 0)
+		{
+			// Process all the stored axis.
+			for (map<std::string, map<int, float> >::iterator iter = m_lastAxisMap.begin(); iter != m_lastAxisMap.end(); ++iter)
+			{
+				for (map<int, float>::iterator iterAxis = (*iter).second.begin(); iterAxis != (*iter).second.end(); ++iterAxis)
+				ProcessJoystickEvent((*iter).first, (*iterAxis).first, true, (*iterAxis).second);
+			}
+		}
 
-  {
-    CPoint pos;
-    if (es->GetMousePos(pos.x, pos.y) && g_Mouse.IsEnabled())
-    {
-      g_Mouse.SetLocation(pos, true);
-      return g_windowManager.OnAction(CAction(ACTION_MOUSE_MOVE, pos.x, pos.y));
-    }
-  }
+		{
+			CPoint pos;
+			if (es->GetMousePos(pos.x, pos.y) && g_Mouse.IsEnabled())
+			{
+				g_Mouse.SetLocation(pos, true);
+				return g_windowManager.OnAction(CAction(ACTION_MOUSE_MOVE, pos.x, pos.y));
+			}
+		}
 #endif
-  return false;
-}
+		return false;
+	}
 
-bool CApplication::ProcessJoystickEvent(const std::string& joystickName, int wKeyID, bool isAxis, float fAmount, unsigned int holdTime /*=0*/)
-{
+	bool CApplication::ProcessJoystickEvent(const std::string& joystickName, int wKeyID, bool isAxis, float fAmount, unsigned int holdTime /*=0*/)
+	{
 #ifdef HAS_EVENT_SERVER
-  m_idleTimer.StartZero();
+		m_idleTimer.StartZero();
 
-   // Make sure to reset screen saver, mouse.
-   ResetScreenSaver();
-   if (ResetScreenSaverWindow())
-     return true;
+		// Make sure to reset screen saver, mouse.
+		ResetScreenSaver();
+		if (ResetScreenSaverWindow())
+		return true;
 
 #ifdef HAS_SDL_JOYSTICK
-   g_Joystick.Reset();
+		g_Joystick.Reset();
 #endif
-   g_Mouse.SetInactive();
+		g_Mouse.SetInactive();
 
-   // Figure out what window we're taking the event for.
-   int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
-   if (g_windowManager.HasModalDialog())
-       iWin = g_windowManager.GetTopMostModalDialogID() & WINDOW_ID_MASK;
+		// Figure out what window we're taking the event for.
+		int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
+		if (g_windowManager.HasModalDialog())
+		iWin = g_windowManager.GetTopMostModalDialogID() & WINDOW_ID_MASK;
 
-   // This code is copied from the OnKey handler, it should be factored out.
-   if (iWin == WINDOW_FULLSCREEN_VIDEO &&
-       g_application.m_pPlayer &&
-       g_application.m_pPlayer->IsInMenu())
-   {
-     // If player is in some sort of menu, (ie DVDMENU) map buttons differently.
-     iWin = WINDOW_VIDEO_MENU;
-   }
+		// This code is copied from the OnKey handler, it should be factored out.
+		if (iWin == WINDOW_FULLSCREEN_VIDEO &&
+				g_application.m_pPlayer &&
+				g_application.m_pPlayer->IsInMenu())
+		{
+			// If player is in some sort of menu, (ie DVDMENU) map buttons differently.
+			iWin = WINDOW_VIDEO_MENU;
+		}
 
-   int actionID;
-   CStdString actionName;
-   bool fullRange = false;
+		int actionID;
+		CStdString actionName;
+		bool fullRange = false;
 
-   // Translate using regular joystick translator.
-   if (CButtonTranslator::GetInstance().TranslateJoystickString(iWin, joystickName.c_str(), wKeyID, isAxis, actionID, actionName, fullRange))
-   {
-     CAction action(actionID, fAmount, 0.0f, actionName, holdTime);
-     bool bResult = false;
+		// Translate using regular joystick translator.
+		if (CButtonTranslator::GetInstance().TranslateJoystickString(iWin, joystickName.c_str(), wKeyID, isAxis, actionID, actionName, fullRange))
+		{
+			CAction action(actionID, fAmount, 0.0f, actionName, holdTime);
+			bool bResult = false;
 
-     // play sound before the action unless the button is held, 
-     // where we execute after the action as held actions aren't fired every time.
-     if(action.GetHoldTime())
-     {
-       bResult = OnAction(action);
-       if(bResult)
-         g_audioManager.PlayActionSound(action);
-     }
-     else
-     {
-       g_audioManager.PlayActionSound(action);
-       bResult = OnAction(action);
-     }
+			// play sound before the action unless the button is held, 
+			// where we execute after the action as held actions aren't fired every time.
+			if(action.GetHoldTime())
+			{
+				bResult = OnAction(action);
+				if(bResult)
+				g_audioManager.PlayActionSound(action);
+			}
+			else
+			{
+				g_audioManager.PlayActionSound(action);
+				bResult = OnAction(action);
+			}
 
-     return bResult;
-   }
-   else
-   {
-     CLog::Log(LOGDEBUG, "ERROR mapping joystick action");
-   }
+			return bResult;
+		}
+		else
+		{
+			CLog::Log(LOGDEBUG, "ERROR mapping joystick action");
+		}
 #endif
 
-   return false;
-}
+		return false;
+	}
 
-bool CApplication::ProcessKeyboard()
-{
-  // process the keyboard buttons etc.
-  BYTE vkey = g_Keyboard.GetKey();
-  WCHAR unicode = g_Keyboard.GetUnicode();
-  if (vkey || unicode)
-  {
-    // got a valid keypress - convert to a key code
-    int keyID;
-    if (vkey) // FIXME, every ascii has a vkey so vkey would always and ascii would never be processed, but fortunately OnKey uses wkeyID only to detect keyboard use and the real key is recalculated correctly.
-      keyID = vkey | KEY_VKEY;
-    else
-      keyID = KEY_UNICODE;
-    //  CLog::Log(LOGDEBUG,"Keyboard: time=%i key=%i", CTimeUtils::GetFrameTime(), vkey);
-    CKey key(keyID);
-    key.SetHeld(g_Keyboard.KeyHeld());
-    return OnKey(key);
-  }
-  return false;
-}
+	bool CApplication::ProcessKeyboard()
+	{
+		// process the keyboard buttons etc.
+		BYTE vkey = g_Keyboard.GetKey();
+		WCHAR unicode = g_Keyboard.GetUnicode();
+		if (vkey || unicode)
+		{
+			// got a valid keypress - convert to a key code
+			int keyID;
+			if (vkey) // FIXME, every ascii has a vkey so vkey would always and ascii would never be processed, but fortunately OnKey uses wkeyID only to detect keyboard use and the real key is recalculated correctly.
+			keyID = vkey | KEY_VKEY;
+			else
+			keyID = KEY_UNICODE;
+			//  CLog::Log(LOGDEBUG,"Keyboard: time=%i key=%i", CTimeUtils::GetFrameTime(), vkey);
+			CKey key(keyID);
+			key.SetHeld(g_Keyboard.KeyHeld());
+			return OnKey(key);
+		}
+		return false;
+	}
 
-bool CApplication::IsButtonDown(DWORD code)
-{
+	bool CApplication::IsButtonDown(DWORD code)
+	{
 #ifdef HAS_GAMEPAD
-  if (code >= KEY_BUTTON_A && code <= KEY_BUTTON_RIGHT_TRIGGER)
-  {
-    // analogue
-    return (m_DefaultGamepad.bAnalogButtons[code - KEY_BUTTON_A + XINPUT_GAMEPAD_A] > XINPUT_GAMEPAD_MAX_CROSSTALK);
-  }
-  else if (code >= KEY_BUTTON_DPAD_UP && code <= KEY_BUTTON_RIGHT_THUMB_BUTTON)
-  {
-    // digital
-    return (m_DefaultGamepad.wButtons & (1 << (code - KEY_BUTTON_DPAD_UP))) != 0;
-  }
-  else
-  {
-    // remote
-    return m_DefaultIR_Remote.wButtons == code;
-  }
+		if (code >= KEY_BUTTON_A && code <= KEY_BUTTON_RIGHT_TRIGGER)
+		{
+			// analogue
+			return (m_DefaultGamepad.bAnalogButtons[code - KEY_BUTTON_A + XINPUT_GAMEPAD_A] > XINPUT_GAMEPAD_MAX_CROSSTALK);
+		}
+		else if (code >= KEY_BUTTON_DPAD_UP && code <= KEY_BUTTON_RIGHT_THUMB_BUTTON)
+		{
+			// digital
+			return (m_DefaultGamepad.wButtons & (1 << (code - KEY_BUTTON_DPAD_UP))) != 0;
+		}
+		else
+		{
+			// remote
+			return m_DefaultIR_Remote.wButtons == code;
+		}
 #endif
-  return false;
-}
+		return false;
+	}
 
-bool CApplication::AnyButtonDown()
-{
-  ReadInput();
+	bool CApplication::AnyButtonDown()
+	{
+		ReadInput();
 #ifdef HAS_GAMEPAD
-  if (m_DefaultGamepad.wPressedButtons || m_DefaultIR_Remote.wButtons)
-    return true;
+		if (m_DefaultGamepad.wPressedButtons || m_DefaultIR_Remote.wButtons)
+		return true;
 
-  for (int i = 0; i < 6; ++i)
-  {
-    if (m_DefaultGamepad.bPressedAnalogButtons[i])
-      return true;
-  }
+		for (int i = 0; i < 6; ++i)
+		{
+			if (m_DefaultGamepad.bPressedAnalogButtons[i])
+			return true;
+		}
 #endif
-  return false;
-}
+		return false;
+	}
 
-HRESULT CApplication::Cleanup()
-{
-  try
-  {
-    g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST);
-    g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST_EDITOR);
-    g_windowManager.Delete(WINDOW_MUSIC_FILES);
-    g_windowManager.Delete(WINDOW_MUSIC_NAV);
-    g_windowManager.Delete(WINDOW_MUSIC_INFO);
-    g_windowManager.Delete(WINDOW_VIDEO_INFO);
-    g_windowManager.Delete(WINDOW_VIDEO_FILES);
-    g_windowManager.Delete(WINDOW_VIDEO_PLAYLIST);
-    g_windowManager.Delete(WINDOW_VIDEO_NAV);
-    g_windowManager.Delete(WINDOW_FILES);
-    g_windowManager.Delete(WINDOW_MUSIC_INFO);
-    g_windowManager.Delete(WINDOW_VIDEO_INFO);
-    g_windowManager.Delete(WINDOW_DIALOG_YES_NO);
-    g_windowManager.Delete(WINDOW_DIALOG_PROGRESS);
-    g_windowManager.Delete(WINDOW_DIALOG_NUMERIC);
-    g_windowManager.Delete(WINDOW_DIALOG_GAMEPAD);
-    g_windowManager.Delete(WINDOW_DIALOG_SUB_MENU);
-    g_windowManager.Delete(WINDOW_DIALOG_BUTTON_MENU);
-    g_windowManager.Delete(WINDOW_DIALOG_CONTEXT_MENU);
-    g_windowManager.Delete(WINDOW_DIALOG_MUSIC_SCAN);
-    g_windowManager.Delete(WINDOW_DIALOG_PLAYER_CONTROLS);
-    g_windowManager.Delete(WINDOW_DIALOG_MUSIC_OSD);
-    g_windowManager.Delete(WINDOW_DIALOG_VIS_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_VIS_PRESET_LIST);
-    g_windowManager.Delete(WINDOW_DIALOG_SELECT);
-    g_windowManager.Delete(WINDOW_DIALOG_OK);
-    g_windowManager.Delete(WINDOW_DIALOG_FILESTACKING);
-    g_windowManager.Delete(WINDOW_DIALOG_KEYBOARD);
-    g_windowManager.Delete(WINDOW_FULLSCREEN_VIDEO);
-    g_windowManager.Delete(WINDOW_DIALOG_TRAINER_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_PROFILE_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_LOCK_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_NETWORK_SETUP);
-    g_windowManager.Delete(WINDOW_DIALOG_MEDIA_SOURCE);
-    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OSD_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_AUDIO_OSD_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_BOOKMARKS);
-    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_SCAN);
-    g_windowManager.Delete(WINDOW_DIALOG_CONTENT_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_FAVOURITES);
-    g_windowManager.Delete(WINDOW_DIALOG_SONG_INFO);
-    g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_EDITOR);
-    g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_RULE);
-    g_windowManager.Delete(WINDOW_DIALOG_BUSY);
-    g_windowManager.Delete(WINDOW_DIALOG_PICTURE_INFO);
-    g_windowManager.Delete(WINDOW_DIALOG_PLUGIN_SETTINGS);
-    g_windowManager.Delete(WINDOW_DIALOG_SLIDER);
-    g_windowManager.Delete(WINDOW_DIALOG_TEXT_VIEWER);
+	HRESULT CApplication::Cleanup()
+	{
+		try
+		{
+			// g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST);
+			// g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST_EDITOR);
+			// g_windowManager.Delete(WINDOW_MUSIC_FILES);
+			// g_windowManager.Delete(WINDOW_MUSIC_NAV);
+			// g_windowManager.Delete(WINDOW_MUSIC_INFO);
+			// g_windowManager.Delete(WINDOW_VIDEO_INFO);
+			// g_windowManager.Delete(WINDOW_VIDEO_FILES);
+			// g_windowManager.Delete(WINDOW_VIDEO_PLAYLIST);
+			// g_windowManager.Delete(WINDOW_VIDEO_NAV);
+			// g_windowManager.Delete(WINDOW_FILES);
+			// g_windowManager.Delete(WINDOW_MUSIC_INFO);
+			// g_windowManager.Delete(WINDOW_VIDEO_INFO);
+			// g_windowManager.Delete(WINDOW_DIALOG_YES_NO);
+			// g_windowManager.Delete(WINDOW_DIALOG_PROGRESS);
+			// g_windowManager.Delete(WINDOW_DIALOG_NUMERIC);
+			// g_windowManager.Delete(WINDOW_DIALOG_GAMEPAD);
+			// g_windowManager.Delete(WINDOW_DIALOG_SUB_MENU);
+			// g_windowManager.Delete(WINDOW_DIALOG_BUTTON_MENU);
+			// g_windowManager.Delete(WINDOW_DIALOG_CONTEXT_MENU);
+			// g_windowManager.Delete(WINDOW_DIALOG_MUSIC_SCAN);
+			// g_windowManager.Delete(WINDOW_DIALOG_PLAYER_CONTROLS);
+			// g_windowManager.Delete(WINDOW_DIALOG_MUSIC_OSD);
+			// g_windowManager.Delete(WINDOW_DIALOG_VIS_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_VIS_PRESET_LIST);
+			// g_windowManager.Delete(WINDOW_DIALOG_SELECT);
+			// g_windowManager.Delete(WINDOW_DIALOG_OK);
+			// g_windowManager.Delete(WINDOW_DIALOG_FILESTACKING);
+			// g_windowManager.Delete(WINDOW_DIALOG_KEYBOARD);
+			// g_windowManager.Delete(WINDOW_FULLSCREEN_VIDEO);
+			// g_windowManager.Delete(WINDOW_DIALOG_TRAINER_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_PROFILE_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_LOCK_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_NETWORK_SETUP);
+			// g_windowManager.Delete(WINDOW_DIALOG_MEDIA_SOURCE);
+			// g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OSD_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_AUDIO_OSD_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_VIDEO_BOOKMARKS);
+			// g_windowManager.Delete(WINDOW_DIALOG_VIDEO_SCAN);
+			// g_windowManager.Delete(WINDOW_DIALOG_CONTENT_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_FAVOURITES);
+			// g_windowManager.Delete(WINDOW_DIALOG_SONG_INFO);
+			// g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_EDITOR);
+			// g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_RULE);
+			// g_windowManager.Delete(WINDOW_DIALOG_BUSY);
+			// g_windowManager.Delete(WINDOW_DIALOG_PICTURE_INFO);
+			// g_windowManager.Delete(WINDOW_DIALOG_PLUGIN_SETTINGS);
+			// g_windowManager.Delete(WINDOW_DIALOG_SLIDER);
+			// g_windowManager.Delete(WINDOW_DIALOG_TEXT_VIEWER);
 
-    g_windowManager.Delete(WINDOW_STARTUP_ANIM);
-    g_windowManager.Delete(WINDOW_LOGIN_SCREEN);
-    g_windowManager.Delete(WINDOW_VISUALISATION);
-    g_windowManager.Delete(WINDOW_SETTINGS_MENU);
-    g_windowManager.Delete(WINDOW_SETTINGS_PROFILES);
-    g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);  // all the settings categories
-    g_windowManager.Delete(WINDOW_SCREEN_CALIBRATION);
-    g_windowManager.Delete(WINDOW_SYSTEM_INFORMATION);
-    g_windowManager.Delete(WINDOW_SCREENSAVER);
-    g_windowManager.Delete(WINDOW_OSD);
-    g_windowManager.Delete(WINDOW_MUSIC_OVERLAY);
-    g_windowManager.Delete(WINDOW_VIDEO_OVERLAY);
-    g_windowManager.Delete(WINDOW_SCRIPTS_INFO);
-    g_windowManager.Delete(WINDOW_SLIDESHOW);
+			// g_windowManager.Delete(WINDOW_STARTUP_ANIM);
+			// g_windowManager.Delete(WINDOW_LOGIN_SCREEN);
+			// g_windowManager.Delete(WINDOW_VISUALISATION);
+			// g_windowManager.Delete(WINDOW_SETTINGS_MENU);
+			// g_windowManager.Delete(WINDOW_SETTINGS_PROFILES);
+			// g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);  // all the settings categories
+			// g_windowManager.Delete(WINDOW_SCREEN_CALIBRATION);
+			// g_windowManager.Delete(WINDOW_SYSTEM_INFORMATION);
+			// g_windowManager.Delete(WINDOW_SCREENSAVER);
+			// g_windowManager.Delete(WINDOW_OSD);
+			// g_windowManager.Delete(WINDOW_MUSIC_OVERLAY);
+			// g_windowManager.Delete(WINDOW_VIDEO_OVERLAY);
+			// g_windowManager.Delete(WINDOW_SCRIPTS_INFO);
+			// g_windowManager.Delete(WINDOW_SLIDESHOW);
 
-    g_windowManager.Delete(WINDOW_HOME);
-    g_windowManager.Delete(WINDOW_PROGRAMS);
-    g_windowManager.Delete(WINDOW_PICTURES);
-    g_windowManager.Delete(WINDOW_SCRIPTS);
-    g_windowManager.Delete(WINDOW_GAMESAVES);
-    g_windowManager.Delete(WINDOW_WEATHER);
+			// g_windowManager.Delete(WINDOW_HOME);
+			// g_windowManager.Delete(WINDOW_PROGRAMS);
+			// g_windowManager.Delete(WINDOW_PICTURES);
+			// g_windowManager.Delete(WINDOW_SCRIPTS);
+			// g_windowManager.Delete(WINDOW_GAMESAVES);
+			// g_windowManager.Delete(WINDOW_WEATHER);
 
-    g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);
-    g_windowManager.Remove(WINDOW_SETTINGS_MYPROGRAMS);
-    g_windowManager.Remove(WINDOW_SETTINGS_MYWEATHER);
-    g_windowManager.Remove(WINDOW_SETTINGS_MYMUSIC);
-    g_windowManager.Remove(WINDOW_SETTINGS_SYSTEM);
-    g_windowManager.Remove(WINDOW_SETTINGS_MYVIDEOS);
-    g_windowManager.Remove(WINDOW_SETTINGS_NETWORK);
-    g_windowManager.Remove(WINDOW_SETTINGS_APPEARANCE);
-    g_windowManager.Remove(WINDOW_DIALOG_KAI_TOAST);
+			// g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);
+			// g_windowManager.Remove(WINDOW_SETTINGS_MYPROGRAMS);
+			// g_windowManager.Remove(WINDOW_SETTINGS_MYWEATHER);
+			// g_windowManager.Remove(WINDOW_SETTINGS_MYMUSIC);
+			// g_windowManager.Remove(WINDOW_SETTINGS_SYSTEM);
+			// g_windowManager.Remove(WINDOW_SETTINGS_MYVIDEOS);
+			// g_windowManager.Remove(WINDOW_SETTINGS_NETWORK);
+			// g_windowManager.Remove(WINDOW_SETTINGS_APPEARANCE);
+			// g_windowManager.Remove(WINDOW_DIALOG_KAI_TOAST);
 
-    g_windowManager.Remove(WINDOW_DIALOG_SEEK_BAR);
-    g_windowManager.Remove(WINDOW_DIALOG_VOLUME_BAR);
+			// g_windowManager.Remove(WINDOW_DIALOG_SEEK_BAR);
+			// g_windowManager.Remove(WINDOW_DIALOG_VOLUME_BAR);
 
-    CLog::Log(LOGNOTICE, "unload sections");
-    CSectionLoader::UnloadAll();
-    // reset our d3d params before we destroy
-    g_graphicsContext.SetD3DDevice(NULL);
-    g_graphicsContext.SetD3DParameters(NULL);
+			CLog::Log(LOGNOTICE, "unload sections");
+			//CSectionLoader::UnloadAll();
+			// reset our d3d params before we destroy
+			g_graphicsContext.SetD3DDevice(NULL);
+			g_graphicsContext.SetD3DParameters(NULL);
 
 #ifdef _DEBUG
-    //  Shutdown as much as possible of the
-    //  application, to reduce the leaks dumped
-    //  to the vc output window before calling
-    //  _CrtDumpMemoryLeaks(). Most of the leaks
-    //  shown are no real leaks, as parts of the app
-    //  are still allocated.
+			//  Shutdown as much as possible of the
+			//  application, to reduce the leaks dumped
+			//  to the vc output window before calling
+			//  _CrtDumpMemoryLeaks(). Most of the leaks
+			//  shown are no real leaks, as parts of the app
+			//  are still allocated.
 
-    g_localizeStrings.Clear();
-    g_LangCodeExpander.Clear();
-    g_charsetConverter.clear();
-    g_directoryCache.Clear();
-    CButtonTranslator::GetInstance().Clear();
-    CLastfmScrobbler::RemoveInstance();
-    CLibrefmScrobbler::RemoveInstance();
-    CLastFmManager::RemoveInstance();
+			//g_localizeStrings.Clear();
+			//g_LangCodeExpander.Clear();
+			//g_charsetConverter.clear();
+			//g_directoryCache.Clear();
+			//CButtonTranslator::GetInstance().Clear();
+			//CLastfmScrobbler::RemoveInstance();
+			//CLibrefmScrobbler::RemoveInstance();
+			//CLastFmManager::RemoveInstance();
 #ifdef HAS_EVENT_SERVER
-    CEventServer::RemoveInstance();
+			//CEventServer::RemoveInstance();
 #endif
-    g_infoManager.Clear();
-    DllLoaderContainer::Clear();
-    g_playlistPlayer.Clear();
-    g_settings.Clear();
-    g_guiSettings.Clear();
-    g_advancedSettings.Clear();
+			//g_infoManager.Clear();
+			//DllLoaderContainer::Clear();
+			//g_playlistPlayer.Clear();
+			//g_settings.Clear();
+			//g_guiSettings.Clear();
+			//g_advancedSettings.Clear();
 #endif
 
 #ifdef _CRTDBG_MAP_ALLOC
-    _CrtDumpMemoryLeaks();
-    while(1); // execution ends
+			_CrtDumpMemoryLeaks();
+			while(1); // execution ends
 #endif
-    return S_OK;
-  }
-  catch (...)
-  {
-    CLog::Log(LOGERROR, "Exception in CApplication::Cleanup()");
-    return E_FAIL;
-  }
-}
+			return S_OK;
+		}
+		catch (...)
+		{
+			CLog::Log(LOGERROR, "Exception in CApplication::Cleanup()");
+			return E_FAIL;
+		}
+	}
 
-void CApplication::Stop(bool bLCDStop)
-{
-  try
-  {
-    if (m_pXbmcHttp)
-    {
-      if(g_settings.m_HttpApiBroadcastLevel>=1)
-        m_applicationMessenger.HttpApi("broadcastlevel; ShutDown;1");
+	void CApplication::Stop(bool bLCDStop)
+	{
+		try
+		{
+			if (m_pXbmcHttp)
+			{
+				if(g_settings.m_HttpApiBroadcastLevel>=1)
+				m_applicationMessenger.HttpApi("broadcastlevel; ShutDown;1");
 
-      m_pXbmcHttp->shuttingDown=true;
-      //Sleep(100);
-    }
+				m_pXbmcHttp->shuttingDown=true;
+				//Sleep(100);
+			}
 
-    CLog::Log(LOGNOTICE, "Storing total System Uptime");
-    g_settings.m_iSystemTimeTotalUp = g_settings.m_iSystemTimeTotalUp + (int)(CTimeUtils::GetFrameTime() / 60000);
+			CLog::Log(LOGNOTICE, "Storing total System Uptime");
+			g_settings.m_iSystemTimeTotalUp = g_settings.m_iSystemTimeTotalUp + (int)(CTimeUtils::GetFrameTime() / 60000);
 
-    // Update the settings information (volume, uptime etc. need saving)
-    if (CFile::Exists(g_settings.GetSettingsFile()))
-    {
-      CLog::Log(LOGNOTICE, "Saving settings");
-      g_settings.Save();
-    }
-    else
-      CLog::Log(LOGNOTICE, "Not saving settings (settings.xml is not present)");
+			// Update the settings information (volume, uptime etc. need saving)
+			if (CFile::Exists(g_settings.GetSettingsFile()))
+			{
+				CLog::Log(LOGNOTICE, "Saving settings");
+				g_settings.Save();
+			}
+			else
+			CLog::Log(LOGNOTICE, "Not saving settings (settings.xml is not present)");
 
-    m_bStop = true;
-    CLog::Log(LOGNOTICE, "stop all");
+			m_bStop = true;
+			CLog::Log(LOGNOTICE, "stop all");
 
-    // stop scanning before we kill the network and so on
-    CGUIDialogMusicScan *musicScan = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
-    if (musicScan)
-      musicScan->StopScanning();
+			// stop scanning before we kill the network and so on
+			CGUIDialogMusicScan *musicScan = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
+			if (musicScan)
+			musicScan->StopScanning();
 
-    CGUIDialogVideoScan *videoScan = (CGUIDialogVideoScan *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_SCAN);
-    if (videoScan)
-      videoScan->StopScanning();
+			CGUIDialogVideoScan *videoScan = (CGUIDialogVideoScan *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_SCAN);
+			if (videoScan)
+			videoScan->StopScanning();
 
-    StopServices();
-    //Sleep(5000);
+			StopServices();
+			//Sleep(5000);
 
 #ifdef __APPLE__
-    g_xbmcHelper.ReleaseAllInput();
+			g_xbmcHelper.ReleaseAllInput();
 #endif
 
-    if (m_pPlayer)
-    {
-      CLog::Log(LOGNOTICE, "stop player");
-      delete m_pPlayer;
-      m_pPlayer = NULL;
-    }
+			if (m_pPlayer)
+			{
+				CLog::Log(LOGNOTICE, "stop player");
+				delete m_pPlayer;
+				m_pPlayer = NULL;
+			}
 
 #ifdef HAS_FILESYSTEM
-    CLog::Log(LOGNOTICE, "stop daap clients");
-    g_DaapClient.Release();
+			CLog::Log(LOGNOTICE, "stop daap clients");
+			g_DaapClient.Release();
 #endif
-    //g_lcd->StopThread();
-    m_applicationMessenger.Cleanup();
+			//g_lcd->StopThread();
+			m_applicationMessenger.Cleanup();
 
-    CLog::Log(LOGNOTICE, "clean cached files!");
-    g_RarManager.ClearCache(true);
+			CLog::Log(LOGNOTICE, "clean cached files!");
+			g_RarManager.ClearCache(true);
 
-    CLog::Log(LOGNOTICE, "unload skin");
-    UnloadSkin();
+			CLog::Log(LOGNOTICE, "unload skin");
+			UnloadSkin();
 
-    CLog::Log(LOGNOTICE, "stop python");
-    g_pythonParser.FreeResources();
+			CLog::Log(LOGNOTICE, "stop python");
+			g_pythonParser.FreeResources();
 
 #ifdef HAS_LCD
-    if (g_lcd && bLCDStop)
-    {
-      g_lcd->Stop();
-      delete g_lcd;
-      g_lcd=NULL;
-    }
+			if (g_lcd && bLCDStop)
+			{
+				g_lcd->Stop();
+				delete g_lcd;
+				g_lcd=NULL;
+			}
 #endif
-    CLog::Log(LOGNOTICE, "stopped");
-  }
-  catch (...)
-  {
-    CLog::Log(LOGERROR, "Exception in CApplication::Stop()");
-  }
+			CLog::Log(LOGNOTICE, "stopped");
+		}
+		catch (...)
+		{
+			CLog::Log(LOGERROR, "Exception in CApplication::Stop()");
+		}
 
-  Destroy();
-}
+		Destroy();
+	}
 
-bool CApplication::PlayMedia(const CFileItem& item, int iPlaylist)
-{
-  if (item.IsLastFM())
-  {
-    g_partyModeManager.Disable();
-    return CLastFmManager::GetInstance()->ChangeStation(item.GetAsUrl());
-  }
-  if (item.IsSmartPlayList())
-  {
-    CDirectory dir;
-    CFileItemList items;
-    if (dir.GetDirectory(item.GetPath(), items) && items.Size())
-    {
-      CSmartPlaylist smartpl;
-      //get name and type of smartplaylist, this will always succeed as GetDirectory also did this.
-      smartpl.OpenAndReadName(item.GetPath());
-      CPlayList playlist;
-      playlist.Add(items);
-      return ProcessAndStartPlaylist(smartpl.GetName(), playlist, (smartpl.GetType() == "songs" || smartpl.GetType() == "albums") ? PLAYLIST_MUSIC:PLAYLIST_VIDEO);
-    }
-  }
-  else if (item.IsPlayList() || item.IsInternetStream())
-  {
-    //is or could be a playlist
-    auto_ptr<CPlayList> pPlayList (CPlayListFactory::Create(item));
-    if (pPlayList.get() && pPlayList->Load(item.GetPath()))
-    {
-      if (iPlaylist != PLAYLIST_NONE)
-      {
-        int track=0;
-        if (item.HasProperty("playlist_starting_track"))
-          track = item.GetPropertyInt("playlist_starting_track");
-        return ProcessAndStartPlaylist(item.GetPath(), *pPlayList, iPlaylist, track);
-      }
-      else
-      {
-        CLog::Log(LOGWARNING, "CApplication::PlayMedia called to play a playlist %s but no idea which playlist to use, playing first item", item.GetPath().c_str());
-        if(pPlayList->size())
-          return PlayFile(*(*pPlayList)[0], false);
-      }
-    }
-  }
+	bool CApplication::PlayMedia(const CFileItem& item, int iPlaylist)
+	{
+		if (item.IsLastFM())
+		{
+			g_partyModeManager.Disable();
+			return CLastFmManager::GetInstance()->ChangeStation(item.GetAsUrl());
+		}
+		if (item.IsSmartPlayList())
+		{
+			CDirectory dir;
+			CFileItemList items;
+			if (dir.GetDirectory(item.GetPath(), items) && items.Size())
+			{
+				CSmartPlaylist smartpl;
+				//get name and type of smartplaylist, this will always succeed as GetDirectory also did this.
+				smartpl.OpenAndReadName(item.GetPath());
+				CPlayList playlist;
+				playlist.Add(items);
+				return ProcessAndStartPlaylist(smartpl.GetName(), playlist, (smartpl.GetType() == "songs" || smartpl.GetType() == "albums") ? PLAYLIST_MUSIC:PLAYLIST_VIDEO);
+			}
+		}
+		else if (item.IsPlayList() || item.IsInternetStream())
+		{
+			//is or could be a playlist
+			auto_ptr<CPlayList> pPlayList (CPlayListFactory::Create(item));
+			if (pPlayList.get() && pPlayList->Load(item.GetPath()))
+			{
+				if (iPlaylist != PLAYLIST_NONE)
+				{
+					int track=0;
+					if (item.HasProperty("playlist_starting_track"))
+					track = item.GetPropertyInt("playlist_starting_track");
+					return ProcessAndStartPlaylist(item.GetPath(), *pPlayList, iPlaylist, track);
+				}
+				else
+				{
+					CLog::Log(LOGWARNING, "CApplication::PlayMedia called to play a playlist %s but no idea which playlist to use, playing first item", item.GetPath().c_str());
+					if(pPlayList->size())
+					return PlayFile(*(*pPlayList)[0], false);
+				}
+			}
+		}
 
-  //nothing special just play
-  return PlayFile(item, false);
-}
+		//nothing special just play
+		return PlayFile(item, false);
+	}
 
-// PlayStack()
-// For playing a multi-file video.  Particularly inefficient
-// on startup, as we are required to calculate the length
-// of each video, so we open + close each one in turn.
-// A faster calculation of video time would improve this
-// substantially.
-bool CApplication::PlayStack(const CFileItem& item, bool bRestart)
-{
-  if (!item.IsStack())
-    return false;
+	// PlayStack()
+	// For playing a multi-file video.  Particularly inefficient
+	// on startup, as we are required to calculate the length
+	// of each video, so we open + close each one in turn.
+	// A faster calculation of video time would improve this
+	// substantially.
+	bool CApplication::PlayStack(const CFileItem& item, bool bRestart)
+	{
+		if (!item.IsStack())
+		return false;
 
-  // see if we have the info in the database
-  // TODO: If user changes the time speed (FPS via framerate conversion stuff)
-  //       then these times will be wrong.
-  //       Also, this is really just a hack for the slow load up times we have
-  //       A much better solution is a fast reader of FPS and fileLength
-  //       that we can use on a file to get it's time.
-  vector<int> times;
-  bool haveTimes(false);
-  CVideoDatabase dbs;
-  if (dbs.Open())
-  {
-    dbs.GetVideoSettings(item.GetPath(), g_settings.m_currentVideoSettings);
-    haveTimes = dbs.GetStackTimes(item.GetPath(), times);
-    dbs.Close();
-  }
+		// see if we have the info in the database
+		// TODO: If user changes the time speed (FPS via framerate conversion stuff)
+		//       then these times will be wrong.
+		//       Also, this is really just a hack for the slow load up times we have
+		//       A much better solution is a fast reader of FPS and fileLength
+		//       that we can use on a file to get it's time.
+		vector<int> times;
+		bool haveTimes(false);
+		CVideoDatabase dbs;
+		if (dbs.Open())
+		{
+			dbs.GetVideoSettings(item.GetPath(), g_settings.m_currentVideoSettings);
+			haveTimes = dbs.GetStackTimes(item.GetPath(), times);
+			dbs.Close();
+		}
 
 
-  // calculate the total time of the stack
-  CStackDirectory dir;
-  dir.GetDirectory(item.GetPath(), *m_currentStack);
-  long totalTime = 0;
-  for (int i = 0; i < m_currentStack->Size(); i++)
-  {
-    if (haveTimes)
-      (*m_currentStack)[i]->m_lEndOffset = times[i];
-    else
-    {
-      int duration;
-      if (!CDVDFileInfo::GetFileDuration((*m_currentStack)[i]->GetPath(), duration))
-      {
-        m_currentStack->Clear();
-        return false;
-      }
-      totalTime += duration / 1000;
-      (*m_currentStack)[i]->m_lEndOffset = totalTime;
-      times.push_back(totalTime);
-    }
-  }
+		// calculate the total time of the stack
+		CStackDirectory dir;
+		dir.GetDirectory(item.GetPath(), *m_currentStack);
+		long totalTime = 0;
+		for (int i = 0; i < m_currentStack->Size(); i++)
+		{
+			if (haveTimes)
+			(*m_currentStack)[i]->m_lEndOffset = times[i];
+			else
+			{
+				int duration;
+				if (!CDVDFileInfo::GetFileDuration((*m_currentStack)[i]->GetPath(), duration))
+				{
+					m_currentStack->Clear();
+					return false;
+				}
+				totalTime += duration / 1000;
+				(*m_currentStack)[i]->m_lEndOffset = totalTime;
+				times.push_back(totalTime);
+			}
+		}
 
-  double seconds = item.m_lStartOffset / 75.0;
+		double seconds = item.m_lStartOffset / 75.0;
 
-  if (!haveTimes || item.m_lStartOffset == STARTOFFSET_RESUME )
-  {  // have our times now, so update the dB
-    if (dbs.Open())
-    {
-      if( !haveTimes )
-        dbs.SetStackTimes(item.GetPath(), times);
+		if (!haveTimes || item.m_lStartOffset == STARTOFFSET_RESUME )
+		{  // have our times now, so update the dB
+			if (dbs.Open())
+			{
+				if( !haveTimes )
+				dbs.SetStackTimes(item.GetPath(), times);
 
-      if( item.m_lStartOffset == STARTOFFSET_RESUME )
-      {
-        // can only resume seek here, not dvdstate
-        CBookmark bookmark;
-        if( dbs.GetResumeBookMark(item.GetPath(), bookmark) )
-          seconds = bookmark.timeInSeconds;
-        else
-          seconds = 0.0f;
-      }
-      dbs.Close();
-    }
-  }
+				if( item.m_lStartOffset == STARTOFFSET_RESUME )
+				{
+					// can only resume seek here, not dvdstate
+					CBookmark bookmark;
+					if( dbs.GetResumeBookMark(item.GetPath(), bookmark) )
+					seconds = bookmark.timeInSeconds;
+					else
+					seconds = 0.0f;
+				}
+				dbs.Close();
+			}
+		}
 
-  *m_itemCurrentFile = item;
-  m_currentStackPosition = 0;
-  m_eCurrentPlayer = EPC_NONE; // must be reset on initial play otherwise last player will be used 
+		*m_itemCurrentFile = item;
+		m_currentStackPosition = 0;
+		m_eCurrentPlayer = EPC_NONE; // must be reset on initial play otherwise last player will be used 
 
-  if (seconds > 0)
-  {
-    // work out where to seek to
-    for (int i = 0; i < m_currentStack->Size(); i++)
-    {
-      if (seconds < (*m_currentStack)[i]->m_lEndOffset)
-      {
-        CFileItem item(*(*m_currentStack)[i]);
-        long start = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
-        item.m_lStartOffset = (long)(seconds - start) * 75;
-        m_currentStackPosition = i;
-        return PlayFile(item, true);
-      }
-    }
-  }
+		if (seconds > 0)
+		{
+			// work out where to seek to
+			for (int i = 0; i < m_currentStack->Size(); i++)
+			{
+				if (seconds < (*m_currentStack)[i]->m_lEndOffset)
+				{
+					CFileItem item(*(*m_currentStack)[i]);
+					long start = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
+					item.m_lStartOffset = (long)(seconds - start) * 75;
+					m_currentStackPosition = i;
+					return PlayFile(item, true);
+				}
+			}
+		}
 
-  return PlayFile(*(*m_currentStack)[0], true);
-}
+		return PlayFile(*(*m_currentStack)[0], true);
+	}
 
-bool CApplication::PlayFile(const CFileItem& item, bool bRestart)
-{
-  if (!bRestart)
-  {
-    SaveCurrentFileSettings();
+	bool CApplication::PlayFile(const CFileItem& item, bool bRestart)
+	{
+		if (!bRestart)
+		{
+			SaveCurrentFileSettings();
 
-    OutputDebugString("new file set audiostream:0\n");
-    // Switch to default options
-    g_settings.m_currentVideoSettings = g_settings.m_defaultVideoSettings;
-    // see if we have saved options in the database
+			OutputDebugString("new file set audiostream:0\n");
+			// Switch to default options
+			g_settings.m_currentVideoSettings = g_settings.m_defaultVideoSettings;
+			// see if we have saved options in the database
 
-    m_iPlaySpeed = 1;
-    *m_itemCurrentFile = item;
-    m_nextPlaylistItem = -1;
-    m_currentStackPosition = 0;
-    m_currentStack->Clear();
-   
-    if (item.IsVideo())
-      CUtil::ClearSubtitles();
-  }
+			m_iPlaySpeed = 1;
+			*m_itemCurrentFile = item;
+			m_nextPlaylistItem = -1;
+			m_currentStackPosition = 0;
+			m_currentStack->Clear();
 
-  if (item.IsPlayList())
-    return false;
+			if (item.IsVideo())
+			CUtil::ClearSubtitles();
+		}
 
-  if (item.IsPlugin())
-  { // we modify the item so that it becomes a real URL
-    CFileItem item_new(item);
-    if (XFILE::CPluginDirectory::GetPluginResult(item.GetPath(), item_new))
-      return PlayFile(item_new, false);
-    return false;
-  }
+		if (item.IsPlayList())
+		return false;
 
-  if (URIUtils::IsUPnP(item.GetPath()))
-  {
-    CFileItem item_new(item);
-    if (XFILE::CUPnPDirectory::GetResource(item.GetPath(), item_new))
-      return PlayFile(item_new, false);
-    return false;
-  }
+		if (item.IsPlugin())
+		{ // we modify the item so that it becomes a real URL
+			CFileItem item_new(item);
+			if (XFILE::CPluginDirectory::GetPluginResult(item.GetPath(), item_new))
+			return PlayFile(item_new, false);
+			return false;
+		}
 
-  // if we have a stacked set of files, we need to setup our stack routines for
-  // "seamless" seeking and total time of the movie etc.
-  // will recall with restart set to true
-  if (item.IsStack())
-    return PlayStack(item, bRestart);
+		if (URIUtils::IsUPnP(item.GetPath()))
+		{
+			CFileItem item_new(item);
+			if (XFILE::CUPnPDirectory::GetResource(item.GetPath(), item_new))
+			return PlayFile(item_new, false);
+			return false;
+		}
 
-  //Is TuxBox, this should probably be moved to CFileTuxBox
-  if(item.IsTuxBox())
-  {
-    CLog::Log(LOGDEBUG, "%s - TuxBox URL Detected %s",__FUNCTION__, item.GetPath().c_str());
+		// if we have a stacked set of files, we need to setup our stack routines for
+		// "seamless" seeking and total time of the movie etc.
+		// will recall with restart set to true
+		if (item.IsStack())
+		return PlayStack(item, bRestart);
 
-    if(g_tuxboxService.IsRunning())
-      g_tuxboxService.Stop();
+		//Is TuxBox, this should probably be moved to CFileTuxBox
+		if(item.IsTuxBox())
+		{
+			CLog::Log(LOGDEBUG, "%s - TuxBox URL Detected %s",__FUNCTION__, item.GetPath().c_str());
 
-    CFileItem item_new;
-    if(g_tuxbox.CreateNewItem(item, item_new))
-    {
+			if(g_tuxboxService.IsRunning())
+			g_tuxboxService.Stop();
 
-      // Make sure it doesn't have a player
-      // so we actually select one normally
-      m_eCurrentPlayer = EPC_NONE;
+			CFileItem item_new;
+			if(g_tuxbox.CreateNewItem(item, item_new))
+			{
 
-      // keep the tuxbox:// url as playing url
-      // and give the new url to the player
-      if(PlayFile(item_new, true))
-      {
-        if(!g_tuxboxService.IsRunning())
-          g_tuxboxService.Start();
-        return true;
-      }
-    }
-    return false;
-  }
+				// Make sure it doesn't have a player
+				// so we actually select one normally
+				m_eCurrentPlayer = EPC_NONE;
 
-  CPlayerOptions options;
-  
-  if( item.HasProperty("StartPercent") )
-  {
-    options.startpercent = item.GetPropertyDouble("StartPercent");                    
-  }
-  
-  PLAYERCOREID eNewCore = EPC_NONE;
-  if( bRestart )
-  {
-    // have to be set here due to playstack using this for starting the file
-    options.starttime = item.m_lStartOffset / 75.0;
-    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_itemCurrentFile->m_lStartOffset != 0)
-      m_itemCurrentFile->m_lStartOffset = STARTOFFSET_RESUME; // to force fullscreen switching
+				// keep the tuxbox:// url as playing url
+				// and give the new url to the player
+				if(PlayFile(item_new, true))
+				{
+					if(!g_tuxboxService.IsRunning())
+					g_tuxboxService.Start();
+					return true;
+				}
+			}
+			return false;
+		}
 
-    if( m_eForcedNextPlayer != EPC_NONE )
-      eNewCore = m_eForcedNextPlayer;
-    else if( m_eCurrentPlayer == EPC_NONE )
-      eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
-    else
-      eNewCore = m_eCurrentPlayer;
-  }
-  else
-  {
-    options.starttime = item.m_lStartOffset / 75.0;
+		CPlayerOptions options;
 
-    if (item.IsVideo())
-    {
-      // open the d/b and retrieve the bookmarks for the current movie
-      CVideoDatabase dbs;
-      dbs.Open();
-      dbs.GetVideoSettings(item.GetPath(), g_settings.m_currentVideoSettings);
+		if( item.HasProperty("StartPercent") )
+		{
+			options.startpercent = item.GetPropertyDouble("StartPercent");                    
+		}
 
-      if( item.m_lStartOffset == STARTOFFSET_RESUME )
-      {
-        options.starttime = 0.0f;
-        CBookmark bookmark;
-        if(dbs.GetResumeBookMark(item.GetPath(), bookmark))
-        {
-          options.starttime = bookmark.timeInSeconds;
-          options.state = bookmark.playerState;
-        }
-      }
-      else if (item.HasVideoInfoTag())
-      {
-        const CVideoInfoTag *tag = item.GetVideoInfoTag();
+		PLAYERCOREID eNewCore = EPC_NONE;
+		if( bRestart )
+		{
+			// have to be set here due to playstack using this for starting the file
+			options.starttime = item.m_lStartOffset / 75.0;
+			if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_itemCurrentFile->m_lStartOffset != 0)
+			m_itemCurrentFile->m_lStartOffset = STARTOFFSET_RESUME; // to force fullscreen switching
 
-        if (tag->m_iBookmarkId != -1 && tag->m_iBookmarkId != 0)
-        {
-          CBookmark bookmark;
-          dbs.GetBookMarkForEpisode(*tag, bookmark);
-          options.starttime = bookmark.timeInSeconds;
-          options.state = bookmark.playerState;
-        }
-      }
+			if( m_eForcedNextPlayer != EPC_NONE )
+			eNewCore = m_eForcedNextPlayer;
+			else if( m_eCurrentPlayer == EPC_NONE )
+			eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
+			else
+			eNewCore = m_eCurrentPlayer;
+		}
+		else
+		{
+			options.starttime = item.m_lStartOffset / 75.0;
 
-      dbs.Close();
-    }
+			if (item.IsVideo())
+			{
+				// open the d/b and retrieve the bookmarks for the current movie
+				CVideoDatabase dbs;
+				dbs.Open();
+				dbs.GetVideoSettings(item.GetPath(), g_settings.m_currentVideoSettings);
 
-    if (m_eForcedNextPlayer != EPC_NONE)
-      eNewCore = m_eForcedNextPlayer;
-    else
-      eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
-  }
+				if( item.m_lStartOffset == STARTOFFSET_RESUME )
+				{
+					options.starttime = 0.0f;
+					CBookmark bookmark;
+					if(dbs.GetResumeBookMark(item.GetPath(), bookmark))
+					{
+						options.starttime = bookmark.timeInSeconds;
+						options.state = bookmark.playerState;
+					}
+				}
+				else if (item.HasVideoInfoTag())
+				{
+					const CVideoInfoTag *tag = item.GetVideoInfoTag();
 
-  // this really aught to be inside !bRestart, but since PlayStack
-  // uses that to init playback, we have to keep it outside
-  int playlist = g_playlistPlayer.GetCurrentPlaylist();
-  if (playlist == PLAYLIST_VIDEO && g_playlistPlayer.GetPlaylist(playlist).size() > 1)
-  { // playing from a playlist by the looks
-    // don't switch to fullscreen if we are not playing the first item...
-    options.fullscreen = !g_playlistPlayer.HasPlayedFirstFile() && g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
-  }
-  else if(m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
-  {
-    // TODO - this will fail if user seeks back to first file in stack
-    if(m_currentStackPosition == 0 || m_itemCurrentFile->m_lStartOffset == STARTOFFSET_RESUME)
-      options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
-    else
-      options.fullscreen = false;
-    // reset this so we don't think we are resuming on seek
-    m_itemCurrentFile->m_lStartOffset = 0;
-  }
-  else
-    options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
+					if (tag->m_iBookmarkId != -1 && tag->m_iBookmarkId != 0)
+					{
+						CBookmark bookmark;
+						dbs.GetBookMarkForEpisode(*tag, bookmark);
+						options.starttime = bookmark.timeInSeconds;
+						options.state = bookmark.playerState;
+					}
+				}
 
-  // reset m_bStartVideoWindowed as it's a temp setting
-  g_settings.m_bStartVideoWindowed = false;
-  // reset any forced player
-  m_eForcedNextPlayer = EPC_NONE;
+				dbs.Close();
+			}
 
+			if (m_eForcedNextPlayer != EPC_NONE)
+			eNewCore = m_eForcedNextPlayer;
+			else
+			eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
+		}
+
+		// this really aught to be inside !bRestart, but since PlayStack
+		// uses that to init playback, we have to keep it outside
+		int playlist = g_playlistPlayer.GetCurrentPlaylist();
+		if (playlist == PLAYLIST_VIDEO && g_playlistPlayer.GetPlaylist(playlist).size() > 1)
+		{ // playing from a playlist by the looks
+			// don't switch to fullscreen if we are not playing the first item...
+			options.fullscreen = !g_playlistPlayer.HasPlayedFirstFile() && g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
+		}
+		else if(m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+		{
+			// TODO - this will fail if user seeks back to first file in stack
+			if(m_currentStackPosition == 0 || m_itemCurrentFile->m_lStartOffset == STARTOFFSET_RESUME)
+			options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
+			else
+			options.fullscreen = false;
+			// reset this so we don't think we are resuming on seek
+			m_itemCurrentFile->m_lStartOffset = 0;
+		}
+		else
+		options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
+
+		// reset m_bStartVideoWindowed as it's a temp setting
+		g_settings.m_bStartVideoWindowed = false;
+		// reset any forced player
+		m_eForcedNextPlayer = EPC_NONE;
+
 #ifdef HAS_KARAOKE
-  //We have to stop parsing a cdg before mplayer is deallocated
-  // WHY do we have to do this????
-  if(m_pCdgParser)
-    m_pCdgParser->Stop();
+		//We have to stop parsing a cdg before mplayer is deallocated
+		// WHY do we have to do this????
+		if(m_pCdgParser)
+		m_pCdgParser->Stop();
 #endif
 
-  // tell system we are starting a file
-  m_bPlaybackStarting = true;
+		// tell system we are starting a file
+		m_bPlaybackStarting = true;
 
-  // We should restart the player, unless the previous and next tracks are using
-  // one of the players that allows gapless playback (paplayer, dvdplayer)
-  if (m_pPlayer)
-  {
-    if ( !(m_eCurrentPlayer == eNewCore && (m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer  == EPC_PAPLAYER)) )
-    {
-      delete m_pPlayer;
-      m_pPlayer = NULL;
-    }
-  }
+		// We should restart the player, unless the previous and next tracks are using
+		// one of the players that allows gapless playback (paplayer, dvdplayer)
+		if (m_pPlayer)
+		{
+			if ( !(m_eCurrentPlayer == eNewCore && (m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer  == EPC_PAPLAYER)) )
+			{
+				delete m_pPlayer;
+				m_pPlayer = NULL;
+			}
+		}
 
-  if (!m_pPlayer)
-  {
-    m_eCurrentPlayer = eNewCore;
-    m_pPlayer = CPlayerCoreFactory::CreatePlayer(eNewCore, *this);
-  }
+		if (!m_pPlayer)
+		{
+			m_eCurrentPlayer = eNewCore;
+			m_pPlayer = CPlayerCoreFactory::CreatePlayer(eNewCore, *this);
+		}
 
-  bool bResult;
-  if (m_pPlayer)
-  {
-    // don't hold graphicscontext here since player
-    // may wait on another thread, that requires gfx
-    CSingleExit ex(g_graphicsContext);
-    bResult = m_pPlayer->OpenFile(item, options);
-  }
-  else
-  {
-    CLog::Log(LOGERROR, "Error creating player for item %s (File doesn't exist?)", item.GetPath().c_str());
-    bResult = false;
-  }
+		bool bResult;
+		if (m_pPlayer)
+		{
+			// don't hold graphicscontext here since player
+			// may wait on another thread, that requires gfx
+			CSingleExit ex(g_graphicsContext);
+			bResult = m_pPlayer->OpenFile(item, options);
+		}
+		else
+		{
+			CLog::Log(LOGERROR, "Error creating player for item %s (File doesn't exist?)", item.GetPath().c_str());
+			bResult = false;
+		}
 
-  if(bResult)
-  {
-    if (m_iPlaySpeed != 1)
-    {
-      int iSpeed = m_iPlaySpeed;
-      m_iPlaySpeed = 1;
-      SetPlaySpeed(iSpeed);
-    }
+		if(bResult)
+		{
+			if (m_iPlaySpeed != 1)
+			{
+				int iSpeed = m_iPlaySpeed;
+				m_iPlaySpeed = 1;
+				SetPlaySpeed(iSpeed);
+			}
 
-    if( IsPlayingAudio() )
-    {
-      if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
-        g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
-    }
+			if( IsPlayingAudio() )
+			{
+				if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+				g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+			}
 
 #ifdef HAS_VIDEO_PLAYBACK
-    if( IsPlayingVideo() )
-    {
-      if (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
-        g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+			if( IsPlayingVideo() )
+			{
+				if (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+				g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
 
-      // if player didn't manange to switch to fullscreen by itself do it here
-      if( options.fullscreen && g_renderManager.IsStarted()
-       && g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
-       SwitchToFullScreen();
+				// if player didn't manange to switch to fullscreen by itself do it here
+				if( options.fullscreen && g_renderManager.IsStarted()
+						&& g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
+				SwitchToFullScreen();
 
-      if (!item.IsDVDImage() && !item.IsDVDFile())
-      {
-        CVideoInfoTag *details = m_itemCurrentFile->GetVideoInfoTag();
-        // Save information about the stream if we currently have no data
-        if (!details->HasStreamDetails() ||
-             details->m_streamDetails.GetVideoDuration() <= 0)
-        {
-          if (m_pPlayer->GetStreamDetails(details->m_streamDetails) && details->HasStreamDetails())
-          {
-            CVideoDatabase dbs;
-            dbs.Open();
-            dbs.SetStreamDetailsForFileId(details->m_streamDetails, details->m_iFileId);
-            dbs.Close();
-            CUtil::DeleteVideoDatabaseDirectoryCache();
-          }
-        }
-      }
-    }
+				if (!item.IsDVDImage() && !item.IsDVDFile())
+				{
+					CVideoInfoTag *details = m_itemCurrentFile->GetVideoInfoTag();
+					// Save information about the stream if we currently have no data
+					if (!details->HasStreamDetails() ||
+							details->m_streamDetails.GetVideoDuration() <= 0)
+					{
+						if (m_pPlayer->GetStreamDetails(details->m_streamDetails) && details->HasStreamDetails())
+						{
+							CVideoDatabase dbs;
+							dbs.Open();
+							dbs.SetStreamDetailsForFileId(details->m_streamDetails, details->m_iFileId);
+							dbs.Close();
+							CUtil::DeleteVideoDatabaseDirectoryCache();
+						}
+					}
+				}
+			}
 #endif
 
-    g_audioManager.Enable(false);
-  }
-  m_bPlaybackStarting = false;
-  if(bResult)
-  {
-    // we must have started, otherwise player might send this later
-    if(IsPlaying())
-      OnPlayBackStarted();
-    else
-      OnPlayBackEnded();
-  }
-  else
-  {
-    // we send this if it isn't playlistplayer that is doing this
-    int next = g_playlistPlayer.GetNextSong();
-    int size = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist()).size();
-    if(next < 0
-    || next >= size)
-      OnPlayBackStopped();
-  }
+			g_audioManager.Enable(false);
+		}
+		m_bPlaybackStarting = false;
+		if(bResult)
+		{
+			// we must have started, otherwise player might send this later
+			if(IsPlaying())
+			OnPlayBackStarted();
+			else
+			OnPlayBackEnded();
+		}
+		else
+		{
+			// we send this if it isn't playlistplayer that is doing this
+			int next = g_playlistPlayer.GetNextSong();
+			int size = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist()).size();
+			if(next < 0
+					|| next >= size)
+			OnPlayBackStopped();
+		}
 
-  return bResult;
-}
+		return bResult;
+	}
 
-void CApplication::OnPlayBackEnded()
-{
-  if(m_bPlaybackStarting)
-    return;
+	void CApplication::OnPlayBackEnded()
+	{
+		if(m_bPlaybackStarting)
+		return;
 
-  // informs python script currently running playback has ended
-  // (does nothing if python is not loaded)
-  g_pythonParser.OnPlayBackEnded();
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-    m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackEnded;1");
-  
-  if (IsPlayingAudio())
-  {
-    CLastfmScrobbler::GetInstance()->SubmitQueue();
-    CLibrefmScrobbler::GetInstance()->SubmitQueue();
-  }
+		// informs python script currently running playback has ended
+		// (does nothing if python is not loaded)
+		g_pythonParser.OnPlayBackEnded();
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackEnded;1");
 
-  CLog::Log(LOGDEBUG, "%s - Playback has finished", __FUNCTION__);
+		// if (IsPlayingAudio())
+		// {
+			// CLastfmScrobbler::GetInstance()->SubmitQueue();
+			// CLibrefmScrobbler::GetInstance()->SubmitQueue();
+		// }
 
-  CGUIMessage msg(GUI_MSG_PLAYBACK_ENDED, 0, 0);
-  g_windowManager.SendThreadMessage(msg);
-}
+		CLog::Log(LOGDEBUG, "%s - Playback has finished", __FUNCTION__);
 
-void CApplication::OnPlayBackStarted()
-{
-  if(m_bPlaybackStarting)
-    return;
+		CGUIMessage msg(GUI_MSG_PLAYBACK_ENDED, 0, 0);
+		g_windowManager.SendThreadMessage(msg);
+	}
 
-  // informs python script currently running playback has started
-  // (does nothing if python is not loaded)
-  g_pythonParser.OnPlayBackStarted();
+	void CApplication::OnPlayBackStarted()
+	{
+		if(m_bPlaybackStarting)
+		return;
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-    m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackStarted;1");
+		// informs python script currently running playback has started
+		// (does nothing if python is not loaded)
+		g_pythonParser.OnPlayBackStarted();
 
-  CLog::Log(LOGDEBUG, "%s - Playback has started", __FUNCTION__);
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackStarted;1");
 
-  CGUIMessage msg(GUI_MSG_PLAYBACK_STARTED, 0, 0);
-  g_windowManager.SendThreadMessage(msg);
-}
+		CLog::Log(LOGDEBUG, "%s - Playback has started", __FUNCTION__);
 
-void CApplication::OnQueueNextItem()
-{
-  // informs python script currently running that we are requesting the next track
-  // (does nothing if python is not loaded)
-  g_pythonParser.OnQueueNextItem(); // currently unimplemented
+		CGUIMessage msg(GUI_MSG_PLAYBACK_STARTED, 0, 0);
+		g_windowManager.SendThreadMessage(msg);
+	}
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-  m_applicationMessenger.HttpApi("broadcastlevel; OnQueueNextItem;1");
+	void CApplication::OnQueueNextItem()
+	{
+		// informs python script currently running that we are requesting the next track
+		// (does nothing if python is not loaded)
+		g_pythonParser.OnQueueNextItem(); // currently unimplemented
 
-  CLog::Log(LOGDEBUG, "Player has asked for the next item");
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		m_applicationMessenger.HttpApi("broadcastlevel; OnQueueNextItem;1");
 
-  if(IsPlayingAudio())
-  {
-    CLastfmScrobbler::GetInstance()->SubmitQueue();
-    CLibrefmScrobbler::GetInstance()->SubmitQueue();
-  }
+		CLog::Log(LOGDEBUG, "Player has asked for the next item");
 
-  CGUIMessage msg(GUI_MSG_QUEUE_NEXT_ITEM, 0, 0);
-  g_windowManager.SendThreadMessage(msg);
-}
+		// if(IsPlayingAudio())
+		// {
+			// CLastfmScrobbler::GetInstance()->SubmitQueue();
+			// CLibrefmScrobbler::GetInstance()->SubmitQueue();
+		// }
 
-void CApplication::OnPlayBackStopped()
-{
-  if(m_bPlaybackStarting)
-    return;
+		CGUIMessage msg(GUI_MSG_QUEUE_NEXT_ITEM, 0, 0);
+		g_windowManager.SendThreadMessage(msg);
+	}
 
-  // informs python script currently running playback has ended
-  // (does nothing if python is not loaded)
-  g_pythonParser.OnPlayBackStopped();
+	void CApplication::OnPlayBackStopped()
+	{
+		if(m_bPlaybackStarting)
+		return;
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-    m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackStopped;1");
-  
-  if (IsPlayingAudio())
-  {
-    CLastfmScrobbler::GetInstance()->SubmitQueue();
-    CLibrefmScrobbler::GetInstance()->SubmitQueue();
-  }
+		// informs python script currently running playback has ended
+		// (does nothing if python is not loaded)
+		g_pythonParser.OnPlayBackStopped();
 
-  CLog::Log(LOGDEBUG, "%s - Playback was stopped", __FUNCTION__);
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackStopped;1");
 
-  CGUIMessage msg( GUI_MSG_PLAYBACK_STOPPED, 0, 0 );
-  g_windowManager.SendThreadMessage(msg);
-}
+		// if (IsPlayingAudio())
+		// {
+			// CLastfmScrobbler::GetInstance()->SubmitQueue();
+			// CLibrefmScrobbler::GetInstance()->SubmitQueue();
+		// }
 
-void CApplication::OnPlayBackPaused()
-{
-  g_pythonParser.OnPlayBackPaused();
+		CLog::Log(LOGDEBUG, "%s - Playback was stopped", __FUNCTION__);
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-    m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackPaused;1");
+		CGUIMessage msg( GUI_MSG_PLAYBACK_STOPPED, 0, 0 );
+		g_windowManager.SendThreadMessage(msg);
+	}
 
-  CLog::Log(LOGDEBUG, "%s - Playback was paused", __FUNCTION__);
-}
+	void CApplication::OnPlayBackPaused()
+	{
+		g_pythonParser.OnPlayBackPaused();
 
-void CApplication::OnPlayBackResumed()
-{
-  g_pythonParser.OnPlayBackResumed();
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackPaused;1");
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-    m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackResumed;1");
+		CLog::Log(LOGDEBUG, "%s - Playback was paused", __FUNCTION__);
+	}
 
-  CLog::Log(LOGDEBUG, "%s - Playback was resumed", __FUNCTION__);
-}
+	void CApplication::OnPlayBackResumed()
+	{
+		g_pythonParser.OnPlayBackResumed();
 
-void CApplication::OnPlayBackSpeedChanged(int iSpeed)
-{
-  g_pythonParser.OnPlayBackSpeedChanged(iSpeed);
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		m_applicationMessenger.HttpApi("broadcastlevel; OnPlayBackResumed;1");
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-  {
-    CStdString tmp;
-    tmp.Format("broadcastlevel; OnPlayBackSpeedChanged:%i;1",iSpeed);
-    m_applicationMessenger.HttpApi(tmp);
-  }
+		CLog::Log(LOGDEBUG, "%s - Playback was resumed", __FUNCTION__);
+	}
 
-  CLog::Log(LOGDEBUG, "%s - Playback speed changed", __FUNCTION__);
-}
+	void CApplication::OnPlayBackSpeedChanged(int iSpeed)
+	{
+		g_pythonParser.OnPlayBackSpeedChanged(iSpeed);
 
-void CApplication::OnPlayBackSeek(int iTime, int seekOffset)
-{
-  g_pythonParser.OnPlayBackSeek(iTime, seekOffset);
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		{
+			CStdString tmp;
+			tmp.Format("broadcastlevel; OnPlayBackSpeedChanged:%i;1",iSpeed);
+			m_applicationMessenger.HttpApi(tmp);
+		}
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-  {
-    CStdString tmp;
-    tmp.Format("broadcastlevel; OnPlayBackSeek:%i;1",iTime);
-    m_applicationMessenger.HttpApi(tmp);
-  }
+		CLog::Log(LOGDEBUG, "%s - Playback speed changed", __FUNCTION__);
+	}
 
-  CLog::Log(LOGDEBUG, "%s - Playback skip", __FUNCTION__);
-//  g_infoManager.SetDisplayAfterSeek(2500, seekOffset/1000);
-}
+	void CApplication::OnPlayBackSeek(int iTime, int seekOffset)
+	{
+		g_pythonParser.OnPlayBackSeek(iTime, seekOffset);
 
-void CApplication::OnPlayBackSeekChapter(int iChapter)
-{
-  g_pythonParser.OnPlayBackSeekChapter(iChapter);
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		{
+			CStdString tmp;
+			tmp.Format("broadcastlevel; OnPlayBackSeek:%i;1",iTime);
+			m_applicationMessenger.HttpApi(tmp);
+		}
 
-  // Let's tell the outside world as well
-  if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
-  {
-    CStdString tmp;
-    tmp.Format("broadcastlevel; OnPlayBackSkeekChapter:%i;1",iChapter);
-    m_applicationMessenger.HttpApi(tmp);
-  }
+		CLog::Log(LOGDEBUG, "%s - Playback skip", __FUNCTION__);
+		//  g_infoManager.SetDisplayAfterSeek(2500, seekOffset/1000);
+	}
 
-  CLog::Log(LOGDEBUG, "%s - Playback skip", __FUNCTION__);
-}
+	void CApplication::OnPlayBackSeekChapter(int iChapter)
+	{
+		g_pythonParser.OnPlayBackSeekChapter(iChapter);
 
-bool CApplication::IsPlaying() const
-{
-  if (!m_pPlayer)
-    return false;
-  if (!m_pPlayer->IsPlaying())
-    return false;
-  return true;
-}
+		// Let's tell the outside world as well
+		if (m_pXbmcHttp && g_settings.m_HttpApiBroadcastLevel>=1)
+		{
+			CStdString tmp;
+			tmp.Format("broadcastlevel; OnPlayBackSkeekChapter:%i;1",iChapter);
+			m_applicationMessenger.HttpApi(tmp);
+		}
 
-bool CApplication::IsPaused() const
-{
-  if (!m_pPlayer)
-    return false;
-  if (!m_pPlayer->IsPlaying())
-    return false;
-  return m_pPlayer->IsPaused();
-}
+		CLog::Log(LOGDEBUG, "%s - Playback skip", __FUNCTION__);
+	}
 
-bool CApplication::IsPlayingAudio() const
-{
-  if (!m_pPlayer)
-    return false;
-  if (!m_pPlayer->IsPlaying())
-    return false;
-  if (m_pPlayer->HasVideo())
-    return false;
-  if (m_pPlayer->HasAudio())
-    return true;
-  return false;
-}
+	bool CApplication::IsPlaying() const
+	{
+		if (!m_pPlayer)
+		return false;
+		if (!m_pPlayer->IsPlaying())
+		return false;
+		return true;
+	}
 
-bool CApplication::IsPlayingVideo() const
-{
-  if (!m_pPlayer)
-    return false;
-  if (!m_pPlayer->IsPlaying())
-    return false;
-  if (m_pPlayer->HasVideo())
-    return true;
+	bool CApplication::IsPaused() const
+	{
+		if (!m_pPlayer)
+		return false;
+		if (!m_pPlayer->IsPlaying())
+		return false;
+		return m_pPlayer->IsPaused();
+	}
 
-  return false;
-}
+	bool CApplication::IsPlayingAudio() const
+	{
+		if (!m_pPlayer)
+		return false;
+		if (!m_pPlayer->IsPlaying())
+		return false;
+		if (m_pPlayer->HasVideo())
+		return false;
+		if (m_pPlayer->HasAudio())
+		return true;
+		return false;
+	}
 
-bool CApplication::IsPlayingFullScreenVideo() const
-{
-  return IsPlayingVideo() && g_graphicsContext.IsFullScreenVideo();
-}
+	bool CApplication::IsPlayingVideo() const
+	{
+		if (!m_pPlayer)
+		return false;
+		if (!m_pPlayer->IsPlaying())
+		return false;
+		if (m_pPlayer->HasVideo())
+		return true;
 
-void CApplication::SaveFileState()
-{
-  CStdString progressTrackingFile = m_progressTrackingItem->GetPath();
+		return false;
+	}
 
-  if (progressTrackingFile != "")
-  {
-    if (m_progressTrackingItem->IsVideo())
-    {
-      CLog::Log(LOGDEBUG, "%s - Saving file state for video item %s", __FUNCTION__, progressTrackingFile.c_str());
+	bool CApplication::IsPlayingFullScreenVideo() const
+	{
+		return IsPlayingVideo() && g_graphicsContext.IsFullScreenVideo();
+	}
 
-      CVideoDatabase videodatabase;
-      if (videodatabase.Open())
-      {
-        bool updateListing = false;
-        // No resume & watched status for livetv
-        if (!m_progressTrackingItem->IsLiveTV())
-        {
-          if (m_progressTrackingPlayCountUpdate)
-          {
-            CLog::Log(LOGDEBUG, "%s - Marking video item %s as watched", __FUNCTION__, progressTrackingFile.c_str());
+	void CApplication::SaveFileState()
+	{
+		CStdString progressTrackingFile = m_progressTrackingItem->GetPath();
 
-            // consider this item as played
-            videodatabase.IncrementPlayCount(*m_progressTrackingItem);
-            m_progressTrackingItem->GetVideoInfoTag()->m_playCount++;
-            m_progressTrackingItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, true);
-            updateListing = true;
-          }
+		if (progressTrackingFile != "")
+		{
+			/*  if (m_progressTrackingItem->IsVideo())
+	{
+	CLog::Log(LOGDEBUG, "%s - Saving file state for video item %s", __FUNCTION__, progressTrackingFile.c_str());
 
-          if (m_progressTrackingVideoResumeBookmark.timeInSeconds < 0.0f)
-          {
-            videodatabase.ClearBookMarksOfFile(progressTrackingFile, CBookmark::RESUME);
-          }
-          else if (m_progressTrackingVideoResumeBookmark.timeInSeconds > 0.0f)
-          {
-            videodatabase.AddBookMarkToFile(progressTrackingFile, m_progressTrackingVideoResumeBookmark, CBookmark::RESUME);
-          }
-        }
+	CVideoDatabase videodatabase;
+	if (videodatabase.Open())
+	{
+		bool updateListing = false;
+		// No resume & watched status for livetv
+		if (!m_progressTrackingItem->IsLiveTV())
+		{
+		if (m_progressTrackingPlayCountUpdate)
+		{
+			CLog::Log(LOGDEBUG, "%s - Marking video item %s as watched", __FUNCTION__, progressTrackingFile.c_str());
 
-        if (g_settings.m_currentVideoSettings != g_settings.m_defaultVideoSettings)
-        {
-          videodatabase.SetVideoSettings(progressTrackingFile, g_settings.m_currentVideoSettings);
-        }
+			// consider this item as played
+			videodatabase.IncrementPlayCount(*m_progressTrackingItem);
+			m_progressTrackingItem->GetVideoInfoTag()->m_playCount++;
+			m_progressTrackingItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, true);
+			updateListing = true;
+		}
 
-        if ((m_progressTrackingItem->IsDVDImage() ||
-             m_progressTrackingItem->IsDVDFile()    ) &&
-             m_progressTrackingItem->HasVideoInfoTag() &&
-             m_progressTrackingItem->GetVideoInfoTag()->HasStreamDetails())
-        {
-          videodatabase.SetStreamDetailsForFile(m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails,progressTrackingFile);
-          updateListing = true;
-        }
-        videodatabase.Close();
-        
-        if (updateListing)
-        {
-          CUtil::DeleteVideoDatabaseDirectoryCache();
+		if (m_progressTrackingVideoResumeBookmark.timeInSeconds < 0.0f)
+		{
+			videodatabase.ClearBookMarksOfFile(progressTrackingFile, CBookmark::RESUME);
+		}
+		else if (m_progressTrackingVideoResumeBookmark.timeInSeconds > 0.0f)
+		{
+			videodatabase.AddBookMarkToFile(progressTrackingFile, m_progressTrackingVideoResumeBookmark, CBookmark::RESUME);
+		}
+		}
+
+		if (g_settings.m_currentVideoSettings != g_settings.m_defaultVideoSettings)
+		{
+		videodatabase.SetVideoSettings(progressTrackingFile, g_settings.m_currentVideoSettings);
+		}
+
+		if ((m_progressTrackingItem->IsDVDImage() ||
+			m_progressTrackingItem->IsDVDFile()    ) &&
+			m_progressTrackingItem->HasVideoInfoTag() &&
+			m_progressTrackingItem->GetVideoInfoTag()->HasStreamDetails())
+		{
+		videodatabase.SetStreamDetailsForFile(m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails,progressTrackingFile);
+		updateListing = true;
+		}
+		videodatabase.Close();
+		
+		if (updateListing)
+		{
+		CUtil::DeleteVideoDatabaseDirectoryCache();
 //          CFileItemPtr msgItem(new CFileItem(*m_progressTrackingItem));
 //          if (m_progressTrackingItem->HasProperty("original_listitem_url"))
 //            msgItem->SetPath(m_progressTrackingItem->GetProperty("original_listitem_url"));
-          CGUIMessage message(GUI_MSG_NOTIFY_ALL, g_windowManager.GetActiveWindow(), 0, GUI_MSG_UPDATE, 0);
+		CGUIMessage message(GUI_MSG_NOTIFY_ALL, g_windowManager.GetActiveWindow(), 0, GUI_MSG_UPDATE, 0);
 //          CGUIMessage message(GUI_MSG_NOTIFY_ALL, g_windowManager.GetActiveWindow(), 0, GUI_MSG_UPDATE_ITEM, 1, msgItem); // 1 to update the listing as well 
-          g_windowManager.SendThreadMessage(message);
-        }
-      }
-    }
+		g_windowManager.SendThreadMessage(message);
+		}
+	}
+	} */
 
-    if (m_progressTrackingItem->IsAudio())
-    {
-      CLog::Log(LOGDEBUG, "%s - Saving file state for audio item %s", __FUNCTION__, progressTrackingFile.c_str());
+			if (m_progressTrackingItem->IsAudio())
+			{
+				CLog::Log(LOGDEBUG, "%s - Saving file state for audio item %s", __FUNCTION__, progressTrackingFile.c_str());
 
-      if (m_progressTrackingPlayCountUpdate)
-      {
-        // Can't write to the musicdatabase while scanning for music info
-        CGUIDialogMusicScan *dialog = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
-        if (dialog && !dialog->IsDialogRunning())
-        {
-          // consider this item as played
-          CLog::Log(LOGDEBUG, "%s - Marking audio item %s as listened", __FUNCTION__, progressTrackingFile.c_str());
+				if (m_progressTrackingPlayCountUpdate)
+				{
+					// Can't write to the musicdatabase while scanning for music info
+					CGUIDialogMusicScan *dialog = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
+					if (dialog && !dialog->IsDialogRunning())
+					{
+						// consider this item as played
+						CLog::Log(LOGDEBUG, "%s - Marking audio item %s as listened", __FUNCTION__, progressTrackingFile.c_str());
 
-          CMusicDatabase musicdatabase;
-          if (musicdatabase.Open())
-          {
-            musicdatabase.IncrTop100CounterByFileName(progressTrackingFile);
-            musicdatabase.Close();
-          }
-        }
-      }
-    }
-  }
-}
+						CMusicDatabase musicdatabase;
+						if (musicdatabase.Open())
+						{
+							musicdatabase.IncrTop100CounterByFileName(progressTrackingFile);
+							musicdatabase.Close();
+						}
+					}
+				}
+			}
+		}
+	}
 
-void CApplication::UpdateFileState()
-{
-  // Did the file change?
-  if (m_progressTrackingItem->GetPath() != "" && m_progressTrackingItem->GetPath() != CurrentFile())
-  {
-    SaveFileState();
+	void CApplication::UpdateFileState()
+	{
+		// Did the file change?
+		if (m_progressTrackingItem->GetPath() != "" && m_progressTrackingItem->GetPath() != CurrentFile())
+		{
+			SaveFileState();
 
-    // Reset tracking item
-    m_progressTrackingItem->Reset();
-  }
-  else
-  {
-    if (IsPlayingVideo() || IsPlayingAudio())
-    {
-      if (m_progressTrackingItem->GetPath() == "")
-      {
-        // Init some stuff
-        *m_progressTrackingItem = CurrentFileItem();
-        m_progressTrackingPlayCountUpdate = false;
-      }
+			// Reset tracking item
+			m_progressTrackingItem->Reset();
+		}
+		else
+		{
+			if (IsPlayingVideo() || IsPlayingAudio())
+			{
+				if (m_progressTrackingItem->GetPath() == "")
+				{
+					// Init some stuff
+					*m_progressTrackingItem = CurrentFileItem();
+					m_progressTrackingPlayCountUpdate = false;
+				}
 
-      if ((m_progressTrackingItem->IsAudio() && g_advancedSettings.m_audioPlayCountMinimumPercent > 0 &&
-          GetPercentage() >= g_advancedSettings.m_audioPlayCountMinimumPercent) ||
-          (m_progressTrackingItem->IsVideo() && g_advancedSettings.m_videoPlayCountMinimumPercent > 0 &&
-          GetPercentage() >= g_advancedSettings.m_videoPlayCountMinimumPercent))
-      {
-        m_progressTrackingPlayCountUpdate = true;
-      }
+				if ((m_progressTrackingItem->IsAudio() && g_advancedSettings.m_audioPlayCountMinimumPercent > 0 &&
+							GetPercentage() >= g_advancedSettings.m_audioPlayCountMinimumPercent) ||
+						(m_progressTrackingItem->IsVideo() && g_advancedSettings.m_videoPlayCountMinimumPercent > 0 &&
+							GetPercentage() >= g_advancedSettings.m_videoPlayCountMinimumPercent))
+				{
+					m_progressTrackingPlayCountUpdate = true;
+				}
 
-      if (m_progressTrackingItem->IsVideo())
-      {
-        if ((m_progressTrackingItem->IsDVDImage() ||
-             m_progressTrackingItem->IsDVDFile()    ) &&
-            m_pPlayer->GetTotalTime() > 15*60)
+				if (m_progressTrackingItem->IsVideo())
+				{
+					if ((m_progressTrackingItem->IsDVDImage() ||
+								m_progressTrackingItem->IsDVDFile()    ) &&
+							m_pPlayer->GetTotalTime() > 15*60)
 
-        {
-          m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails.Reset();
-          m_pPlayer->GetStreamDetails(m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails);
-        }
-        // Update bookmark for save
-        m_progressTrackingVideoResumeBookmark.player = CPlayerCoreFactory::GetPlayerName(m_eCurrentPlayer);
-        m_progressTrackingVideoResumeBookmark.playerState = m_pPlayer->GetPlayerState();
-        m_progressTrackingVideoResumeBookmark.thumbNailImage.Empty();
+					{
+						m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails.Reset();
+						m_pPlayer->GetStreamDetails(m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails);
+					}
+					// Update bookmark for save
+					m_progressTrackingVideoResumeBookmark.player = CPlayerCoreFactory::GetPlayerName(m_eCurrentPlayer);
+					m_progressTrackingVideoResumeBookmark.playerState = m_pPlayer->GetPlayerState();
+					m_progressTrackingVideoResumeBookmark.thumbNailImage.Empty();
 
-        if (g_advancedSettings.m_videoIgnorePercentAtEnd > 0 &&
-            GetTotalTime() - GetTime() < 0.01f * g_advancedSettings.m_videoIgnorePercentAtEnd * GetTotalTime())
-        {
-          // Delete the bookmark
-          m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
-        }
-        else
-        if (GetTime() > g_advancedSettings.m_videoIgnoreSecondsAtStart)
-        {
-          // Update the bookmark
-          m_progressTrackingVideoResumeBookmark.timeInSeconds = GetTime();
-          m_progressTrackingVideoResumeBookmark.totalTimeInSeconds = GetTotalTime();
-        }
-        else
-        {
-          // Do nothing
-          m_progressTrackingVideoResumeBookmark.timeInSeconds = 0.0f;
-        }
-      }
-    }
-  }
-}
+					if (g_advancedSettings.m_videoIgnorePercentAtEnd > 0 &&
+							GetTotalTime() - GetTime() < 0.01f * g_advancedSettings.m_videoIgnorePercentAtEnd * GetTotalTime())
+					{
+						// Delete the bookmark
+						m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
+					}
+					else
+					if (GetTime() > g_advancedSettings.m_videoIgnoreSecondsAtStart)
+					{
+						// Update the bookmark
+						m_progressTrackingVideoResumeBookmark.timeInSeconds = GetTime();
+						m_progressTrackingVideoResumeBookmark.totalTimeInSeconds = GetTotalTime();
+					}
+					else
+					{
+						// Do nothing
+						m_progressTrackingVideoResumeBookmark.timeInSeconds = 0.0f;
+					}
+				}
+			}
+		}
+	}
 
-void CApplication::StopPlaying()
-{
-  int iWin = g_windowManager.GetActiveWindow();
-  if ( IsPlaying() )
-  {
+	void CApplication::StopPlaying()
+	{
+		int iWin = g_windowManager.GetActiveWindow();
+		if ( IsPlaying() )
+		{
 #ifdef HAS_KARAOKE
-    if( m_pCdgParser )
-      m_pCdgParser->Stop();
+			if( m_pCdgParser )
+			m_pCdgParser->Stop();
 #endif
 
-    if (m_pPlayer)
-      m_pPlayer->CloseFile();
+			if (m_pPlayer)
+			m_pPlayer->CloseFile();
 
-    // turn off visualisation window when stopping
-    if (iWin == WINDOW_VISUALISATION
-    ||  iWin == WINDOW_FULLSCREEN_VIDEO)
-      g_windowManager.PreviousWindow();
+			// turn off visualisation window when stopping
+			if (iWin == WINDOW_VISUALISATION
+					||  iWin == WINDOW_FULLSCREEN_VIDEO)
+			g_windowManager.PreviousWindow();
 
-    g_partyModeManager.Disable();
-  }
-}
+			g_partyModeManager.Disable();
+		}
+	}
 
-bool CApplication::NeedRenderFullScreen()
-{
-  if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
-  {
-    g_windowManager.UpdateModelessVisibility();
+	bool CApplication::NeedRenderFullScreen()
+	{
+		if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+		{
+			g_windowManager.UpdateModelessVisibility();
 
-    if (g_windowManager.HasDialogOnScreen()) return true;
-    if (g_Mouse.IsActive()) return true;
+			if (g_windowManager.HasDialogOnScreen()) return true;
+			if (g_Mouse.IsActive()) return true;
 
-    CGUIWindowFullScreen *pFSWin = (CGUIWindowFullScreen *)g_windowManager.GetWindow(WINDOW_FULLSCREEN_VIDEO);
-    if (!pFSWin)
-      return false;
-    return pFSWin->NeedRenderFullScreen();
-  }
-  return false;
-}
+			CGUIWindowFullScreen *pFSWin = (CGUIWindowFullScreen *)g_windowManager.GetWindow(WINDOW_FULLSCREEN_VIDEO);
+			if (!pFSWin)
+			return false;
+			return pFSWin->NeedRenderFullScreen();
+		}
+		return false;
+	}
 
-void CApplication::RenderFullScreen()
-{
-  g_ApplicationRenderer.Render(true);
-}
+	void CApplication::RenderFullScreen()
+	{
+		g_ApplicationRenderer.Render(true);
+	}
 
-void CApplication::DoRenderFullScreen()
-{
-  if (g_graphicsContext.IsFullScreenVideo())
-  {
-    // make sure our overlays are closed
-    CGUIDialog *overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_VIDEO_OVERLAY);
-    if (overlay) overlay->Close(true);
-    overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_MUSIC_OVERLAY);
-    if (overlay) overlay->Close(true);
+	void CApplication::DoRenderFullScreen()
+	{
+		if (g_graphicsContext.IsFullScreenVideo())
+		{
+			// make sure our overlays are closed
+			CGUIDialog *overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_VIDEO_OVERLAY);
+			if (overlay) overlay->Close(true);
+			overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_MUSIC_OVERLAY);
+			if (overlay) overlay->Close(true);
 
-    CGUIWindowFullScreen *pFSWin = (CGUIWindowFullScreen *)g_windowManager.GetWindow(WINDOW_FULLSCREEN_VIDEO);
-    if (!pFSWin)
-      return ;
-    pFSWin->RenderFullScreen();
+			CGUIWindowFullScreen *pFSWin = (CGUIWindowFullScreen *)g_windowManager.GetWindow(WINDOW_FULLSCREEN_VIDEO);
+			if (!pFSWin)
+			return ;
+			pFSWin->RenderFullScreen();
 
-    if (g_windowManager.HasDialogOnScreen())
-      g_windowManager.RenderDialogs();
-    // Render the mouse pointer, if visible...
-    if (g_Mouse.IsActive())
-      g_application.m_guiPointer.Render();
-  }
-}
+			if (g_windowManager.HasDialogOnScreen())
+			g_windowManager.RenderDialogs();
+			// Render the mouse pointer, if visible...
+			if (g_Mouse.IsActive())
+			g_application.m_guiPointer.Render();
+		}
+	}
 
-void CApplication::ResetScreenSaver()
-{
-  // reset our timers
-  m_shutdownTimer.StartZero();
+	void CApplication::ResetScreenSaver()
+	{
+		// reset our timers
+		m_shutdownTimer.StartZero();
 
-  // screen saver timer is reset only if we're not already in screensaver mode
-  if (!m_bScreenSave && m_iScreenSaveLock == 0)
-    m_screenSaverTimer.StartZero();
-}
+		// screen saver timer is reset only if we're not already in screensaver mode
+		if (!m_bScreenSave && m_iScreenSaveLock == 0)
+		m_screenSaverTimer.StartZero();
+	}
 
-bool CApplication::ResetScreenSaverWindow()
-{
-  if (m_iScreenSaveLock == 2)
-    return false;
+	bool CApplication::ResetScreenSaverWindow()
+	{
+		if (m_iScreenSaveLock == 2)
+		return false;
 
-  // if Screen saver is active
-  if (m_bScreenSave)
-  {
-    if (m_iScreenSaveLock == 0)
-      if (g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
-          (g_settings.UsingLoginScreen() || g_guiSettings.GetBool("masterlock.startuplock")) &&
-          g_settings.GetCurrentProfile().getLockMode() != LOCK_MODE_EVERYONE &&
-          m_screenSaverMode != "Dim" && m_screenSaverMode != "Black" && m_screenSaverMode != "Visualisation")
-      {
-        m_iScreenSaveLock = 2;
-        CGUIMessage msg(GUI_MSG_CHECK_LOCK,0,0);
-        g_windowManager.GetWindow(WINDOW_SCREENSAVER)->OnMessage(msg);
-      }
-    if (m_iScreenSaveLock == -1)
-    {
-      m_iScreenSaveLock = 0;
-      return true;
-    }
+		// if Screen saver is active
+		if (m_bScreenSave)
+		{
+			if (m_iScreenSaveLock == 0)
+			if (g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+					(g_settings.UsingLoginScreen() || g_guiSettings.GetBool("masterlock.startuplock")) &&
+					g_settings.GetCurrentProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+					m_screenSaverMode != "Dim" && m_screenSaverMode != "Black" && m_screenSaverMode != "Visualisation")
+			{
+				m_iScreenSaveLock = 2;
+				CGUIMessage msg(GUI_MSG_CHECK_LOCK,0,0);
+				g_windowManager.GetWindow(WINDOW_SCREENSAVER)->OnMessage(msg);
+			}
+			if (m_iScreenSaveLock == -1)
+			{
+				m_iScreenSaveLock = 0;
+				return true;
+			}
 
-    // disable screensaver
-    m_bScreenSave = false;
-    m_iScreenSaveLock = 0;
-    m_screenSaverTimer.StartZero();
+			// disable screensaver
+			m_bScreenSave = false;
+			m_iScreenSaveLock = 0;
+			m_screenSaverTimer.StartZero();
 
-    float fFadeLevel = 1.0f;
-    if (m_screenSaverMode == "Visualisation" || m_screenSaverMode == "Slideshow" || m_screenSaverMode == "Fanart Slideshow")
-    {
-      // we can just continue as usual from vis mode
-      return false;
-    }
-    else if (m_screenSaverMode == "Dim")
-    {
-      fFadeLevel = (float)g_guiSettings.GetInt("screensaver.dimlevel") / 100;
-    }
-    else if (m_screenSaverMode == "Black")
-    {
-      fFadeLevel = 0;
-    }
-    else if (m_screenSaverMode != "None")
-    { // we're in screensaver window
-      if (g_windowManager.GetActiveWindow() == WINDOW_SCREENSAVER)
-        g_windowManager.PreviousWindow();  // show the previous window
-      return true;
-    }
+			float fFadeLevel = 1.0f;
+			if (m_screenSaverMode == "Visualisation" || m_screenSaverMode == "Slideshow" || m_screenSaverMode == "Fanart Slideshow")
+			{
+				// we can just continue as usual from vis mode
+				return false;
+			}
+			else if (m_screenSaverMode == "Dim")
+			{
+				fFadeLevel = (float)g_guiSettings.GetInt("screensaver.dimlevel") / 100;
+			}
+			else if (m_screenSaverMode == "Black")
+			{
+				fFadeLevel = 0;
+			}
+			else if (m_screenSaverMode != "None")
+			{ // we're in screensaver window
+				if (g_windowManager.GetActiveWindow() == WINDOW_SCREENSAVER)
+				g_windowManager.PreviousWindow();  // show the previous window
+				return true;
+			}
 
-    // Fade to dim or black screensaver is active --> fade in
-    D3DGAMMARAMP Ramp;
-    for (float fade = fFadeLevel; fade <= 1; fade += 0.01f)
-    {
-      for (int i = 0;i < 256;i++)
-      {
-        Ramp.red[i] = (int)((float)m_OldRamp.red[i] * fade);
-        Ramp.green[i] = (int)((float)m_OldRamp.green[i] * fade);
-        Ramp.blue[i] = (int)((float)m_OldRamp.blue[i] * fade);
-      }
-      Sleep(5);
-      m_pd3dDevice->SetGammaRamp(GAMMA_RAMP_FLAG, &Ramp); // use immediate to get a smooth fade
-    }
-    m_pd3dDevice->SetGammaRamp(0, &m_OldRamp); // put the old gamma ramp back in place
-    return true;
-  }
-  else
-    return false;
-}
+			// Fade to dim or black screensaver is active --> fade in
+			D3DGAMMARAMP Ramp;
+			for (float fade = fFadeLevel; fade <= 1; fade += 0.01f)
+			{
+				for (int i = 0;i < 256;i++)
+				{
+					Ramp.red[i] = (int)((float)m_OldRamp.red[i] * fade);
+					Ramp.green[i] = (int)((float)m_OldRamp.green[i] * fade);
+					Ramp.blue[i] = (int)((float)m_OldRamp.blue[i] * fade);
+				}
+				Sleep(5);
+				m_pd3dDevice->SetGammaRamp(GAMMA_RAMP_FLAG, &Ramp); // use immediate to get a smooth fade
+			}
+			m_pd3dDevice->SetGammaRamp(0, &m_OldRamp); // put the old gamma ramp back in place
+			return true;
+		}
+		else
+		return false;
+	}
 
-void CApplication::CheckScreenSaver()
-{
-  // if the screen saver window is active, then clearly we are already active
-  if (g_windowManager.IsWindowActive(WINDOW_SCREENSAVER))
-  {
-    m_bScreenSave = true;
-    return;
-  }
+	void CApplication::CheckScreenSaver()
+	{
+		// if the screen saver window is active, then clearly we are already active
+		if (g_windowManager.IsWindowActive(WINDOW_SCREENSAVER))
+		{
+			m_bScreenSave = true;
+			return;
+		}
 
-  bool resetTimer = false;
-  if (IsPlayingVideo() && !m_pPlayer->IsPaused()) // are we playing video and it is not paused?
-    resetTimer = true;
+		bool resetTimer = false;
+		if (IsPlayingVideo() && !m_pPlayer->IsPaused()) // are we playing video and it is not paused?
+		resetTimer = true;
 
-  if (IsPlayingAudio() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION) // are we playing some music in fullscreen vis?
-    resetTimer = true;
+		if (IsPlayingAudio() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION) // are we playing some music in fullscreen vis?
+		resetTimer = true;
 
-  if (resetTimer)
-  {
-    m_screenSaverTimer.StartZero();
-    return;
-  }
+		if (resetTimer)
+		{
+			m_screenSaverTimer.StartZero();
+			return;
+		}
 
-  if (m_bScreenSave) // already running the screensaver
-    return;
+		if (m_bScreenSave) // already running the screensaver
+		return;
 
-  if ( m_screenSaverTimer.GetElapsedSeconds() > g_guiSettings.GetInt("screensaver.time") * 60 )
-    ActivateScreenSaver();
-}
+		if ( m_screenSaverTimer.GetElapsedSeconds() > g_guiSettings.GetInt("screensaver.time") * 60 )
+		ActivateScreenSaver();
+	}
 
-// activate the screensaver.
-// if forceType is true, we ignore the various conditions that can alter
-// the type of screensaver displayed
-void CApplication::ActivateScreenSaver(bool forceType /*= false */)
-{
-  D3DGAMMARAMP Ramp;
-  FLOAT fFadeLevel = 0;
+	// activate the screensaver.
+	// if forceType is true, we ignore the various conditions that can alter
+	// the type of screensaver displayed
+	void CApplication::ActivateScreenSaver(bool forceType /*= false */)
+	{
+		D3DGAMMARAMP Ramp;
+		FLOAT fFadeLevel = 0;
 
-  m_bScreenSave = true;
+		m_bScreenSave = true;
 
-  // Get Screensaver Mode
-  m_screenSaverMode = g_guiSettings.GetString("screensaver.mode");
+		// Get Screensaver Mode
+		m_screenSaverMode = g_guiSettings.GetString("screensaver.mode");
 
-  // disable screensaver lock from the login screen
-  m_iScreenSaveLock = g_windowManager.GetActiveWindow() == WINDOW_LOGIN_SCREEN ? 1 : 0;
-  if (!forceType)
-  {
-    // set to Dim in the case of a dialog on screen or playing video
-    if (g_windowManager.HasModalDialog() || (IsPlayingVideo() && g_guiSettings.GetBool("screensaver.usedimonpause")))
-      m_screenSaverMode = "Dim";
-    // Check if we are Playing Audio and Vis instead Screensaver!
-    else if (IsPlayingAudio() && g_guiSettings.GetBool("screensaver.usemusicvisinstead") && g_guiSettings.GetString("musicplayer.visualisation") != "None")
-    { // activate the visualisation
-      m_screenSaverMode = "Visualisation";
-      g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
-      return;
-    }
-  }
-  // Picture slideshow
-  if (m_screenSaverMode == "SlideShow" || m_screenSaverMode == "Fanart Slideshow")
-  {
-    // reset our codec info - don't want that on screen
-    g_infoManager.SetShowCodec(false);
-    m_applicationMessenger.PictureSlideShow(g_guiSettings.GetString("screensaver.slideshowpath"), true);
-    return;
-  }
-  else if (m_screenSaverMode == "Dim")
-  {
-    fFadeLevel = (FLOAT) g_guiSettings.GetInt("screensaver.dimlevel") / 100; // 0.07f;
-  }
-  else if (m_screenSaverMode == "Black")
-  {
-    fFadeLevel = 0;
-  }
-  else if (m_screenSaverMode != "None")
-  {
-    g_windowManager.ActivateWindow(WINDOW_SCREENSAVER);
-    return ;
-  }
-  
-  // Fade to fFadeLevel
-  m_pd3dDevice->GetGammaRamp(&m_OldRamp); // Store the old gamma ramp
-  for (float fade = 1.f; fade >= fFadeLevel; fade -= 0.01f)
-  {
-    for (int i = 0;i < 256;i++)
-    {
-      Ramp.red[i] = (int)((float)m_OldRamp.red[i] * fade);
-      Ramp.green[i] = (int)((float)m_OldRamp.green[i] * fade);
-      Ramp.blue[i] = (int)((float)m_OldRamp.blue[i] * fade);
-    }
-    Sleep(5);
-    m_pd3dDevice->SetGammaRamp(GAMMA_RAMP_FLAG, &Ramp); // use immediate to get a smooth fade
-  }
-}
+		// disable screensaver lock from the login screen
+		m_iScreenSaveLock = g_windowManager.GetActiveWindow() == WINDOW_LOGIN_SCREEN ? 1 : 0;
+		if (!forceType)
+		{
+			// set to Dim in the case of a dialog on screen or playing video
+			if (g_windowManager.HasModalDialog() || (IsPlayingVideo() && g_guiSettings.GetBool("screensaver.usedimonpause")))
+			m_screenSaverMode = "Dim";
+			// Check if we are Playing Audio and Vis instead Screensaver!
+			else if (IsPlayingAudio() && g_guiSettings.GetBool("screensaver.usemusicvisinstead") && g_guiSettings.GetString("musicplayer.visualisation") != "None")
+			{ // activate the visualisation
+				m_screenSaverMode = "Visualisation";
+				g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+				return;
+			}
+		}
+		// Picture slideshow
+		if (m_screenSaverMode == "SlideShow" || m_screenSaverMode == "Fanart Slideshow")
+		{
+			// reset our codec info - don't want that on screen
+			g_infoManager.SetShowCodec(false);
+			m_applicationMessenger.PictureSlideShow(g_guiSettings.GetString("screensaver.slideshowpath"), true);
+			return;
+		}
+		else if (m_screenSaverMode == "Dim")
+		{
+			fFadeLevel = (FLOAT) g_guiSettings.GetInt("screensaver.dimlevel") / 100; // 0.07f;
+		}
+		else if (m_screenSaverMode == "Black")
+		{
+			fFadeLevel = 0;
+		}
+		else if (m_screenSaverMode != "None")
+		{
+			g_windowManager.ActivateWindow(WINDOW_SCREENSAVER);
+			return ;
+		}
 
-void CApplication::CheckShutdown()
-{
+		// Fade to fFadeLevel
+		m_pd3dDevice->GetGammaRamp(&m_OldRamp); // Store the old gamma ramp
+		for (float fade = 1.f; fade >= fFadeLevel; fade -= 0.01f)
+		{
+			for (int i = 0;i < 256;i++)
+			{
+				Ramp.red[i] = (int)((float)m_OldRamp.red[i] * fade);
+				Ramp.green[i] = (int)((float)m_OldRamp.green[i] * fade);
+				Ramp.blue[i] = (int)((float)m_OldRamp.blue[i] * fade);
+			}
+			Sleep(5);
+			m_pd3dDevice->SetGammaRamp(GAMMA_RAMP_FLAG, &Ramp); // use immediate to get a smooth fade
+		}
+	}
+
+	void CApplication::CheckShutdown()
+	{
 #ifdef HAS_XBOX_HARDWARE
-  CGUIDialogMusicScan *pMusicScan = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
-  CGUIDialogVideoScan *pVideoScan = (CGUIDialogVideoScan *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_SCAN);
+		CGUIDialogMusicScan *pMusicScan = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
+		CGUIDialogVideoScan *pVideoScan = (CGUIDialogVideoScan *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_SCAN);
 
-  // first check if we should reset the timer
-  bool resetTimer = false;
-  if (IsPlaying()) // is something playing?
-    resetTimer = true;
+		// first check if we should reset the timer
+		bool resetTimer = false;
+		if (IsPlaying()) // is something playing?
+		resetTimer = true;
 
 #ifdef HAS_FTP_SERVER
-  if (m_pFileZilla && m_pFileZilla->GetNoConnections() != 0) // is FTP active ?
-    resetTimer = true;
+		if (m_pFileZilla && m_pFileZilla->GetNoConnections() != 0) // is FTP active ?
+		resetTimer = true;
 #endif
 
-  if (pMusicScan && pMusicScan->IsScanning()) // music scanning?
-    resetTimer = true;
+		if (pMusicScan && pMusicScan->IsScanning()) // music scanning?
+		resetTimer = true;
 
-  if (pVideoScan && pVideoScan->IsScanning()) // video scanning?
-    resetTimer = true;
+		if (pVideoScan && pVideoScan->IsScanning()) // video scanning?
+		resetTimer = true;
 
-  if (g_windowManager.IsWindowActive(WINDOW_DIALOG_PROGRESS)) // progress dialog is onscreen
-    resetTimer = true;
+		if (g_windowManager.IsWindowActive(WINDOW_DIALOG_PROGRESS)) // progress dialog is onscreen
+		resetTimer = true;
 
-  if (resetTimer)
-  {
-    m_shutdownTimer.StartZero();
-    return;
-  }
+		if (resetTimer)
+		{
+			m_shutdownTimer.StartZero();
+			return;
+		}
 
-  if ( m_shutdownTimer.GetElapsedSeconds() > g_guiSettings.GetInt("system.shutdowntime") * 60 )
-  {
-    m_applicationMessenger.Shutdown(); // Turn off the box
-  }
+		if ( m_shutdownTimer.GetElapsedSeconds() > g_guiSettings.GetInt("system.shutdowntime") * 60 )
+		{
+			m_applicationMessenger.Shutdown(); // Turn off the box
+		}
 #endif
-}
+	}
 
-//Check if hd spindown must be blocked
-bool CApplication::MustBlockHDSpinDown(bool bCheckThisForNormalSpinDown)
-{
+	//Check if hd spindown must be blocked
+	bool CApplication::MustBlockHDSpinDown(bool bCheckThisForNormalSpinDown)
+	{
 #ifdef HAS_XBOX_HARDWARE
-  if (IsPlayingVideo())
-  {
-    //block immediate spindown when playing a video non-fullscreen (videocontrol is playing)
-    if ((!bCheckThisForNormalSpinDown) && (!g_graphicsContext.IsFullScreenVideo()))
-    {
-      return true;
-    }
-    //allow normal hd spindown always if the movie is paused
-    if ((bCheckThisForNormalSpinDown) && (m_pPlayer->IsPaused()))
-    {
-      return false;
-    }
-    //don't allow hd spindown when playing files with vobsub subtitles.
-    CStdString strSubTitelExtension;
-    if (m_pPlayer->GetSubtitleExtension(strSubTitelExtension))
-    {
-      return (strSubTitelExtension == ".idx");
-    }
-  }
+		if (IsPlayingVideo())
+		{
+			//block immediate spindown when playing a video non-fullscreen (videocontrol is playing)
+			if ((!bCheckThisForNormalSpinDown) && (!g_graphicsContext.IsFullScreenVideo()))
+			{
+				return true;
+			}
+			//allow normal hd spindown always if the movie is paused
+			if ((bCheckThisForNormalSpinDown) && (m_pPlayer->IsPaused()))
+			{
+				return false;
+			}
+			//don't allow hd spindown when playing files with vobsub subtitles.
+			CStdString strSubTitelExtension;
+			if (m_pPlayer->GetSubtitleExtension(strSubTitelExtension))
+			{
+				return (strSubTitelExtension == ".idx");
+			}
+		}
 #endif
-  return false;
-}
+		return false;
+	}
 
-void CApplication::CheckNetworkHDSpinDown(bool playbackStarted)
-{
-  int iSpinDown = g_guiSettings.GetInt("harddisk.remoteplayspindown");
-  if (iSpinDown == SPIN_DOWN_NONE)
-    return ;
-  if (g_windowManager.HasModalDialog())
-    return ;
-  if (MustBlockHDSpinDown(false))
-    return ;
+	void CApplication::CheckNetworkHDSpinDown(bool playbackStarted)
+	{
+		int iSpinDown = g_guiSettings.GetInt("harddisk.remoteplayspindown");
+		if (iSpinDown == SPIN_DOWN_NONE)
+		return ;
+		if (g_windowManager.HasModalDialog())
+		return ;
+		if (MustBlockHDSpinDown(false))
+		return ;
 
-  if ((!m_bNetworkSpinDown) || playbackStarted)
-  {
-    int iDuration = 0;
-    if (IsPlayingAudio())
-    {
-      //try to get duration from current tag because mplayer doesn't calculate vbr mp3 correctly
-      if (m_itemCurrentFile->HasMusicInfoTag())
-        iDuration = m_itemCurrentFile->GetMusicInfoTag()->GetDuration();
-    }
-    if (IsPlaying() && iDuration <= 0)
-    {
-      iDuration = (int)GetTotalTime();
-    }
-    //spin down harddisk when the current file being played is not on local harddrive and
-    //duration is more then spindown timeoutsetting or duration is unknown (streams)
-    if (
-      !m_itemCurrentFile->IsHD() &&
-      (
-        (iSpinDown == SPIN_DOWN_VIDEO && IsPlayingVideo()) ||
-        (iSpinDown == SPIN_DOWN_MUSIC && IsPlayingAudio()) ||
-        (iSpinDown == SPIN_DOWN_BOTH && (IsPlayingVideo() || IsPlayingAudio()))
-      ) &&
-      (
-        (iDuration <= 0) ||
-        (iDuration > g_guiSettings.GetInt("harddisk.remoteplayspindownminduration")*60)
-      )
-    )
-    {
-      m_bNetworkSpinDown = true;
-      if (!playbackStarted)
-      { //if we got here not because of a playback start check what screen we are in
-        // get the current active window
-        int iWin = g_windowManager.GetActiveWindow();
-        if (iWin == WINDOW_FULLSCREEN_VIDEO)
-        {
-          // check if OSD is visible, if so don't do immediate spindown
-          CGUIWindowOSD *pOSD = (CGUIWindowOSD *)g_windowManager.GetWindow(WINDOW_OSD);
-          if (pOSD)
-            m_bNetworkSpinDown = !pOSD->IsDialogRunning();
-        }
-      }
-      if (m_bNetworkSpinDown)
-      {
-        //do the spindown right now + delayseconds
-        m_dwSpinDownTime = timeGetTime();
-      }
-    }
-  }
-  if (m_bNetworkSpinDown)
-  {
-    // check the elapsed time
-    DWORD dwTimeSpan = timeGetTime() - m_dwSpinDownTime;
-    if ( (m_dwSpinDownTime != 0) && (dwTimeSpan >= ((DWORD)g_guiSettings.GetInt("harddisk.remoteplayspindowndelay")*1000UL)) )
-    {
-      // time has elapsed, spin it down
+		if ((!m_bNetworkSpinDown) || playbackStarted)
+		{
+			int iDuration = 0;
+			if (IsPlayingAudio())
+			{
+				//try to get duration from current tag because mplayer doesn't calculate vbr mp3 correctly
+				if (m_itemCurrentFile->HasMusicInfoTag())
+				iDuration = m_itemCurrentFile->GetMusicInfoTag()->GetDuration();
+			}
+			if (IsPlaying() && iDuration <= 0)
+			{
+				iDuration = (int)GetTotalTime();
+			}
+			//spin down harddisk when the current file being played is not on local harddrive and
+			//duration is more then spindown timeoutsetting or duration is unknown (streams)
+			if (
+					!m_itemCurrentFile->IsHD() &&
+					(
+						(iSpinDown == SPIN_DOWN_VIDEO && IsPlayingVideo()) ||
+						(iSpinDown == SPIN_DOWN_MUSIC && IsPlayingAudio()) ||
+						(iSpinDown == SPIN_DOWN_BOTH && (IsPlayingVideo() || IsPlayingAudio()))
+						) &&
+					(
+						(iDuration <= 0) ||
+						(iDuration > g_guiSettings.GetInt("harddisk.remoteplayspindownminduration")*60)
+						)
+					)
+			{
+				m_bNetworkSpinDown = true;
+				if (!playbackStarted)
+				{ //if we got here not because of a playback start check what screen we are in
+					// get the current active window
+					int iWin = g_windowManager.GetActiveWindow();
+					if (iWin == WINDOW_FULLSCREEN_VIDEO)
+					{
+						// check if OSD is visible, if so don't do immediate spindown
+						CGUIWindowOSD *pOSD = (CGUIWindowOSD *)g_windowManager.GetWindow(WINDOW_OSD);
+						if (pOSD)
+						m_bNetworkSpinDown = !pOSD->IsDialogRunning();
+					}
+				}
+				if (m_bNetworkSpinDown)
+				{
+					//do the spindown right now + delayseconds
+					m_dwSpinDownTime = timeGetTime();
+				}
+			}
+		}
+		if (m_bNetworkSpinDown)
+		{
+			// check the elapsed time
+			DWORD dwTimeSpan = timeGetTime() - m_dwSpinDownTime;
+			if ( (m_dwSpinDownTime != 0) && (dwTimeSpan >= ((DWORD)g_guiSettings.GetInt("harddisk.remoteplayspindowndelay")*1000UL)) )
+			{
+				// time has elapsed, spin it down
 #ifdef HAS_XBOX_HARDWARE
-      XKHDD::SpindownHarddisk();
+				XKHDD::SpindownHarddisk();
 #endif
-      //stop checking until a key is pressed.
-      m_dwSpinDownTime = 0;
-      m_bNetworkSpinDown = true;
-    }
-    else if (m_dwSpinDownTime == 0 && IsPlaying())
-    {
-      // we are currently spun down - let's spin back up again if we are playing media
-      // and we're within 10 seconds (or 0.5*spindown time) of the end.  This should
-      // make returning to the GUI a bit snappier + speed up stacked item changes.
-      int iMinSpinUp = 10;
-      if (iMinSpinUp > g_guiSettings.GetInt("harddisk.remoteplayspindowndelay")*0.5f)
-        iMinSpinUp = (int)(g_guiSettings.GetInt("harddisk.remoteplayspindowndelay")*0.5f);
-      if (g_infoManager.GetPlayTimeRemaining() == iMinSpinUp)
-      { // spin back up
+				//stop checking until a key is pressed.
+				m_dwSpinDownTime = 0;
+				m_bNetworkSpinDown = true;
+			}
+			else if (m_dwSpinDownTime == 0 && IsPlaying())
+			{
+				// we are currently spun down - let's spin back up again if we are playing media
+				// and we're within 10 seconds (or 0.5*spindown time) of the end.  This should
+				// make returning to the GUI a bit snappier + speed up stacked item changes.
+				int iMinSpinUp = 10;
+				if (iMinSpinUp > g_guiSettings.GetInt("harddisk.remoteplayspindowndelay")*0.5f)
+				iMinSpinUp = (int)(g_guiSettings.GetInt("harddisk.remoteplayspindowndelay")*0.5f);
+				if (g_infoManager.GetPlayTimeRemaining() == iMinSpinUp)
+				{ // spin back up
 #ifdef HAS_XBOX_HARDWARE
-        XKHDD::SpindownHarddisk(false);
+					XKHDD::SpindownHarddisk(false);
 #endif
-      }
-    }
-  }
-}
+				}
+			}
+		}
+	}
 
-void CApplication::CheckHDSpindown()
-{
-  if (!g_guiSettings.GetInt("harddisk.spindowntime"))
-    return ;
-  if (g_windowManager.HasModalDialog())
-    return ;
-  if (MustBlockHDSpinDown())
-    return ;
+	void CApplication::CheckHDSpindown()
+	{
+		if (!g_guiSettings.GetInt("harddisk.spindowntime"))
+		return ;
+		if (g_windowManager.HasModalDialog())
+		return ;
+		if (MustBlockHDSpinDown())
+		return ;
 
-  if (!m_bSpinDown &&
-      (
-        !IsPlaying() ||
-        (IsPlaying() && !m_itemCurrentFile->IsHD())
-      )
-     )
-  {
-    m_bSpinDown = true;
-    m_bNetworkSpinDown = false; // let networkspindown override normal spindown
-    m_dwSpinDownTime = timeGetTime();
-  }
+		if (!m_bSpinDown &&
+				(
+					!IsPlaying() ||
+					(IsPlaying() && !m_itemCurrentFile->IsHD())
+					)
+				)
+		{
+			m_bSpinDown = true;
+			m_bNetworkSpinDown = false; // let networkspindown override normal spindown
+			m_dwSpinDownTime = timeGetTime();
+		}
 
-  //Can we do a spindown right now?
-  if (m_bSpinDown)
-  {
-    // yes, then check the elapsed time
-    DWORD dwTimeSpan = timeGetTime() - m_dwSpinDownTime;
-    if ( (m_dwSpinDownTime != 0) && (dwTimeSpan >= ((DWORD)g_guiSettings.GetInt("harddisk.spindowntime")*60UL*1000UL)) )
-    {
-      // time has elapsed, spin it down
+		//Can we do a spindown right now?
+		if (m_bSpinDown)
+		{
+			// yes, then check the elapsed time
+			DWORD dwTimeSpan = timeGetTime() - m_dwSpinDownTime;
+			if ( (m_dwSpinDownTime != 0) && (dwTimeSpan >= ((DWORD)g_guiSettings.GetInt("harddisk.spindowntime")*60UL*1000UL)) )
+			{
+				// time has elapsed, spin it down
 #ifdef HAS_XBOX_HARDWARE
-      XKHDD::SpindownHarddisk();
+				XKHDD::SpindownHarddisk();
 #endif
-      //stop checking until a key is pressed.
-      m_dwSpinDownTime = 0;
-      m_bSpinDown = true;
-    }
-  }
-}
+				//stop checking until a key is pressed.
+				m_dwSpinDownTime = 0;
+				m_bSpinDown = true;
+			}
+		}
+	}
 
-bool CApplication::OnMessage(CGUIMessage& message)
-{
-  switch ( message.GetMessage() )
-  {
-  case GUI_MSG_NOTIFY_ALL:
-    {
-      if (message.GetParam1()==GUI_MSG_REMOVED_MEDIA)
-      {
-        // Update general playlist: Remove DVD playlist items
-        int nRemoved = g_playlistPlayer.RemoveDVDItems();
-        if ( nRemoved > 0 )
-        {
-          CGUIMessage msg( GUI_MSG_PLAYLIST_CHANGED, 0, 0 );
-          g_windowManager.SendMessage( msg );
-        }
-        // stop the file if it's on dvd (will set the resume point etc)
-        if (m_itemCurrentFile->IsOnDVD())
-          StopPlaying();
-      }
-    }
-    break;
+	bool CApplication::OnMessage(CGUIMessage& message)
+	{
+		switch ( message.GetMessage() )
+		{
+		case GUI_MSG_NOTIFY_ALL:
+			{
+				if (message.GetParam1()==GUI_MSG_REMOVED_MEDIA)
+				{
+					// Update general playlist: Remove DVD playlist items
+					int nRemoved = g_playlistPlayer.RemoveDVDItems();
+					if ( nRemoved > 0 )
+					{
+						CGUIMessage msg( GUI_MSG_PLAYLIST_CHANGED, 0, 0 );
+						g_windowManager.SendMessage( msg );
+					}
+					// stop the file if it's on dvd (will set the resume point etc)
+					if (m_itemCurrentFile->IsOnDVD())
+					StopPlaying();
+				}
+			}
+			break;
 
-  case GUI_MSG_PLAYBACK_STARTED:
-    {
-      // Update our infoManager with the new details etc.
-      if (m_nextPlaylistItem >= 0)
-      { // we've started a previously queued item
-        CFileItemPtr item = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist())[m_nextPlaylistItem];
-        // update the playlist manager
-        int currentSong = g_playlistPlayer.GetCurrentSong();
-        int param = ((currentSong & 0xffff) << 16) | (m_nextPlaylistItem & 0xffff);
-        CGUIMessage msg(GUI_MSG_PLAYLISTPLAYER_CHANGED, 0, 0, g_playlistPlayer.GetCurrentPlaylist(), param, item);
-        g_windowManager.SendThreadMessage(msg);
-        g_playlistPlayer.SetCurrentSong(m_nextPlaylistItem);
-        *m_itemCurrentFile = *item;
-      }
-      g_infoManager.SetCurrentItem(*m_itemCurrentFile);
-      CLastFmManager::GetInstance()->OnSongChange(*m_itemCurrentFile);
-      g_partyModeManager.OnSongChange(true);
+		case GUI_MSG_PLAYBACK_STARTED:
+			{
+				// Update our infoManager with the new details etc.
+				if (m_nextPlaylistItem >= 0)
+				{ // we've started a previously queued item
+					CFileItemPtr item = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist())[m_nextPlaylistItem];
+					// update the playlist manager
+					int currentSong = g_playlistPlayer.GetCurrentSong();
+					int param = ((currentSong & 0xffff) << 16) | (m_nextPlaylistItem & 0xffff);
+					CGUIMessage msg(GUI_MSG_PLAYLISTPLAYER_CHANGED, 0, 0, g_playlistPlayer.GetCurrentPlaylist(), param, item);
+					g_windowManager.SendThreadMessage(msg);
+					g_playlistPlayer.SetCurrentSong(m_nextPlaylistItem);
+					*m_itemCurrentFile = *item;
+				}
+				g_infoManager.SetCurrentItem(*m_itemCurrentFile);
+				CLastFmManager::GetInstance()->OnSongChange(*m_itemCurrentFile);
+				g_partyModeManager.OnSongChange(true);
 
-      CheckNetworkHDSpinDown(true);
-      StartLEDControl(true);
-      DimLCDOnPlayback(true);
+				CheckNetworkHDSpinDown(true);
+				StartLEDControl(true);
+				DimLCDOnPlayback(true);
 
-      if (IsPlayingAudio())
-      {
-        // Start our cdg parser as appropriate
+				if (IsPlayingAudio())
+				{
+					// Start our cdg parser as appropriate
 #ifdef HAS_KARAOKE
-        if (m_pCdgParser && g_guiSettings.GetBool("karaoke.enabled") && !m_itemCurrentFile->IsInternetStream())
-        {
-          if (m_pCdgParser->IsRunning())
-            m_pCdgParser->Stop();
-          if (m_itemCurrentFile->IsMusicDb())
-          {
-            if (!m_itemCurrentFile->HasMusicInfoTag() || !m_itemCurrentFile->GetMusicInfoTag()->Loaded())
-            {
-              IMusicInfoTagLoader* tagloader = CMusicInfoTagLoaderFactory::CreateLoader(m_itemCurrentFile->GetPath());
-              tagloader->Load(m_itemCurrentFile->GetPath(),*m_itemCurrentFile->GetMusicInfoTag());
-              delete tagloader;
-            }
-            m_pCdgParser->Start(m_itemCurrentFile->GetMusicInfoTag()->GetURL());
-          }
-          else
-            m_pCdgParser->Start(m_itemCurrentFile->GetPath());
-        }
+					if (m_pCdgParser && g_guiSettings.GetBool("karaoke.enabled") && !m_itemCurrentFile->IsInternetStream())
+					{
+						if (m_pCdgParser->IsRunning())
+						m_pCdgParser->Stop();
+						if (m_itemCurrentFile->IsMusicDb())
+						{
+							if (!m_itemCurrentFile->HasMusicInfoTag() || !m_itemCurrentFile->GetMusicInfoTag()->Loaded())
+							{
+								IMusicInfoTagLoader* tagloader = CMusicInfoTagLoaderFactory::CreateLoader(m_itemCurrentFile->GetPath());
+								tagloader->Load(m_itemCurrentFile->GetPath(),*m_itemCurrentFile->GetMusicInfoTag());
+								delete tagloader;
+							}
+							m_pCdgParser->Start(m_itemCurrentFile->GetMusicInfoTag()->GetURL());
+						}
+						else
+						m_pCdgParser->Start(m_itemCurrentFile->GetPath());
+					}
 #endif
-        // Let scrobbler know about the track
-        const CMusicInfoTag* tag=g_infoManager.GetCurrentSongTag();
-        if (tag)
-        {
-          CLastfmScrobbler::GetInstance()->AddSong(*tag, CLastFmManager::GetInstance()->IsRadioEnabled());
-          CLibrefmScrobbler::GetInstance()->AddSong(*tag, CLastFmManager::GetInstance()->IsRadioEnabled());
-        }
-      }
-      
-      return true;
-    }
-    break;
+					// Let scrobbler know about the track
+					// const CMusicInfoTag* tag=g_infoManager.GetCurrentSongTag();
+					// if (tag)
+					// {
+						// CLastfmScrobbler::GetInstance()->AddSong(*tag, CLastFmManager::GetInstance()->IsRadioEnabled());
+						// CLibrefmScrobbler::GetInstance()->AddSong(*tag, CLastFmManager::GetInstance()->IsRadioEnabled());
+					// }
+				}
+				
+				return true;
+			}
+			break;
 
-  case GUI_MSG_QUEUE_NEXT_ITEM:
-    {
-      // Check to see if our playlist player has a new item for us,
-      // and if so, we check whether our current player wants the file
-      int iNext = g_playlistPlayer.GetNextSong();
-      CPlayList& playlist = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist());
-      if (iNext < 0 || iNext >= playlist.size())
-      {
-        if (m_pPlayer) m_pPlayer->OnNothingToQueueNotify();
-        return true; // nothing to do
-      }
-      // ok, grab the next song
-      CFileItemPtr item = playlist[iNext];
-      // ok - send the file to the player if it wants it
-      if (m_pPlayer && m_pPlayer->QueueNextFile(*item))
-      { // player wants the next file
-        m_nextPlaylistItem = iNext;
-      }
-      return true;
-    }
-    break;
+		case GUI_MSG_QUEUE_NEXT_ITEM:
+			{
+				// Check to see if our playlist player has a new item for us,
+				// and if so, we check whether our current player wants the file
+				int iNext = g_playlistPlayer.GetNextSong();
+				CPlayList& playlist = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist());
+				if (iNext < 0 || iNext >= playlist.size())
+				{
+					if (m_pPlayer) m_pPlayer->OnNothingToQueueNotify();
+					return true; // nothing to do
+				}
+				// ok, grab the next song
+				CFileItemPtr item = playlist[iNext];
+				// ok - send the file to the player if it wants it
+				if (m_pPlayer && m_pPlayer->QueueNextFile(*item))
+				{ // player wants the next file
+					m_nextPlaylistItem = iNext;
+				}
+				return true;
+			}
+			break;
 
-  case GUI_MSG_PLAYBACK_STOPPED:
-  case GUI_MSG_PLAYBACK_ENDED:
-  case GUI_MSG_PLAYLISTPLAYER_STOPPED:
-    {
-      // first check if we still have items in the stack to play
-      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
-      {
-        if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_currentStackPosition < m_currentStack->Size() - 1)
-        { // just play the next item in the stack
-          PlayFile(*(*m_currentStack)[++m_currentStackPosition], true);
-          return true;
-        }
-      }
-      
-      // In case playback ended due to user eg. skipping over the end, clear
-      // our resume bookmark here
-      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED && m_progressTrackingPlayCountUpdate && g_advancedSettings.m_videoIgnorePercentAtEnd > 0)
-      {
-        // Delete the bookmark
-        m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
-      }
+		case GUI_MSG_PLAYBACK_STOPPED:
+		case GUI_MSG_PLAYBACK_ENDED:
+		case GUI_MSG_PLAYLISTPLAYER_STOPPED:
+			{
+				// first check if we still have items in the stack to play
+				if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
+				{
+					if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_currentStackPosition < m_currentStack->Size() - 1)
+					{ // just play the next item in the stack
+						PlayFile(*(*m_currentStack)[++m_currentStackPosition], true);
+						return true;
+					}
+				}
+				
+				// In case playback ended due to user eg. skipping over the end, clear
+				// our resume bookmark here
+				if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED && m_progressTrackingPlayCountUpdate && g_advancedSettings.m_videoIgnorePercentAtEnd > 0)
+				{
+					// Delete the bookmark
+					m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
+				}
 
-      // reset our spindown
-      m_bNetworkSpinDown = false;
-      m_bSpinDown = false;
+				// reset our spindown
+				m_bNetworkSpinDown = false;
+				m_bSpinDown = false;
 
-      // reset the current playing file
-      m_itemCurrentFile->Reset();
-      g_infoManager.ResetCurrentItem();
-      m_currentStack->Clear();
+				// reset the current playing file
+				m_itemCurrentFile->Reset();
+				g_infoManager.ResetCurrentItem();
+				m_currentStack->Clear();
 
-      // stop lastfm
-      if (CLastFmManager::GetInstance()->IsRadioEnabled())
-        CLastFmManager::GetInstance()->StopRadio();
+				// stop lastfm
+				if (CLastFmManager::GetInstance()->IsRadioEnabled())
+				CLastFmManager::GetInstance()->StopRadio();
 
-      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
-      {
-        // sending true to PlayNext() effectively passes bRestart to PlayFile()
-        // which is not generally what we want (except for stacks, which are
-        // handled above)
-        g_playlistPlayer.PlayNext();
-      }
-      else
-      {
-        delete m_pPlayer;
-        m_pPlayer = 0;
-      }
+				if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
+				{
+					// sending true to PlayNext() effectively passes bRestart to PlayFile()
+					// which is not generally what we want (except for stacks, which are
+					// handled above)
+					g_playlistPlayer.PlayNext();
+				}
+				else
+				{
+					delete m_pPlayer;
+					m_pPlayer = 0;
+				}
 
-      if (!IsPlaying())
-      {
-        g_audioManager.Enable(true);
-        StartLEDControl(false);
-        DimLCDOnPlayback(false);
+				if (!IsPlaying())
+				{
+					g_audioManager.Enable(true);
+					StartLEDControl(false);
+					DimLCDOnPlayback(false);
 
 #ifdef HAS_KARAOKE
-        if(m_pCdgParser)
-          m_pCdgParser->Free();
+					if(m_pCdgParser)
+					m_pCdgParser->Free();
 #endif
-      }
+				}
 
-      if (!IsPlayingVideo() && g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
-      {
-        g_windowManager.PreviousWindow();
-      }
+				if (!IsPlayingVideo() && g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+				{
+					g_windowManager.PreviousWindow();
+				}
 
-      if (!IsPlayingAudio() && g_playlistPlayer.GetCurrentPlaylist() == PLAYLIST_NONE && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
-      {
-        g_settings.Save();  // save vis settings
-        ResetScreenSaverWindow();
-        g_windowManager.PreviousWindow();
-      }
+				if (!IsPlayingAudio() && g_playlistPlayer.GetCurrentPlaylist() == PLAYLIST_NONE && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+				{
+					g_settings.Save();  // save vis settings
+					ResetScreenSaverWindow();
+					g_windowManager.PreviousWindow();
+				}
 
-      // DVD ejected while playing in vis ?
-      if (!IsPlayingAudio() && (m_itemCurrentFile->IsCDDA() || m_itemCurrentFile->IsOnDVD()) && !CDetectDVDMedia::IsDiscInDrive() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
-      {
-        // yes, disable vis
-        g_settings.Save();    // save vis settings
-        ResetScreenSaverWindow();
-        g_windowManager.PreviousWindow();
-      }
-      
-      return true;
-    }
-    break;
+				// DVD ejected while playing in vis ?
+				if (!IsPlayingAudio() && (m_itemCurrentFile->IsCDDA() || m_itemCurrentFile->IsOnDVD()) && !CDetectDVDMedia::IsDiscInDrive() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+				{
+					// yes, disable vis
+					g_settings.Save();    // save vis settings
+					ResetScreenSaverWindow();
+					g_windowManager.PreviousWindow();
+				}
+				
+				return true;
+			}
+			break;
 
-  case GUI_MSG_PLAYLISTPLAYER_STARTED:
-  case GUI_MSG_PLAYLISTPLAYER_CHANGED:
-    {
-      return true;
-    }
-    break;
-  case GUI_MSG_FULLSCREEN:
-    { // Switch to fullscreen, if we can
-      SwitchToFullScreen();
-      return true;
-    }
-    break;
-  case GUI_MSG_EXECUTE:
-    if (message.GetStringParam().length() > 0)
-      return ExecuteXBMCAction(message.GetStringParam());
+		case GUI_MSG_PLAYLISTPLAYER_STARTED:
+		case GUI_MSG_PLAYLISTPLAYER_CHANGED:
+			{
+				return true;
+			}
+			break;
+		case GUI_MSG_FULLSCREEN:
+			{ // Switch to fullscreen, if we can
+				SwitchToFullScreen();
+				return true;
+			}
+			break;
+		case GUI_MSG_EXECUTE:
+			if (message.GetStringParam().length() > 0)
+			return ExecuteXBMCAction(message.GetStringParam());
 
-    break;
-  }
-  return false;
-}
+			break;
+		}
+		return false;
+	}
 
-bool CApplication::ExecuteXBMCAction(std::string actionStr)
-    {
-      // see if it is a user set string
-      CLog::Log(LOGDEBUG,"%s : Translating %s", __FUNCTION__, actionStr.c_str());
-      CGUIInfoLabel info(actionStr, "");
-      actionStr = info.GetLabel(0);
-      CLog::Log(LOGDEBUG,"%s : To %s", __FUNCTION__, actionStr.c_str());
+	bool CApplication::ExecuteXBMCAction(std::string actionStr)
+	{
+		// see if it is a user set string
+		CLog::Log(LOGDEBUG,"%s : Translating %s", __FUNCTION__, actionStr.c_str());
+		CGUIInfoLabel info(actionStr, "");
+		actionStr = info.GetLabel(0);
+		CLog::Log(LOGDEBUG,"%s : To %s", __FUNCTION__, actionStr.c_str());
 
-      // user has asked for something to be executed
-      if (CBuiltins::HasCommand(actionStr))
-        CBuiltins::Execute(actionStr);
-      else
-      {
-        // try translating the action from our ButtonTranslator
-        int actionID;
-        if (CButtonTranslator::TranslateActionString(actionStr.c_str(), actionID))
-        {
-          OnAction(CAction(actionID));
-          return true;
-        }
-        CFileItem item(actionStr, false);
-        if (item.IsPythonScript())
-        { // a python script
-          unsigned int argc = 1;
-          char ** argv = new char*[argc];
-          argv[0] = (char*)item.GetPath().c_str();
-          g_pythonParser.evalFile(argv[0], argc, (const char**)argv);
-          delete [] argv;
-        }
-        else if (item.IsXBE())
-        { // an XBE
-          int iRegion;
-          if (g_guiSettings.GetBool("myprograms.gameautoregion"))
-          {
-            CXBE xbe;
-            iRegion = xbe.ExtractGameRegion(item.GetPath());
-            if (iRegion < 1 || iRegion > 7)
-              iRegion = 0;
-            iRegion = xbe.FilterRegion(iRegion);
-          }
-          else
-            iRegion = 0;
-          CUtil::RunXBE(item.GetPath().c_str(),NULL,F_VIDEO(iRegion));
-        }
-        else if (item.IsAudio() || item.IsVideo())
-        { // an audio or video file
-          PlayFile(item);
-        }
-        else
-          return false;
-      }
-      return true;
-    }
+		// user has asked for something to be executed
+		if (CBuiltins::HasCommand(actionStr))
+		CBuiltins::Execute(actionStr);
+		else
+		{
+			// try translating the action from our ButtonTranslator
+			int actionID;
+			if (CButtonTranslator::TranslateActionString(actionStr.c_str(), actionID))
+			{
+				OnAction(CAction(actionID));
+				return true;
+			}
+			CFileItem item(actionStr, false);
+			if (item.IsPythonScript())
+			{ // a python script
+				unsigned int argc = 1;
+				char ** argv = new char*[argc];
+				argv[0] = (char*)item.GetPath().c_str();
+				g_pythonParser.evalFile(argv[0], argc, (const char**)argv);
+				delete [] argv;
+			}
+			else if (item.IsXBE())
+			{ // an XBE
+				int iRegion;
+				if (g_guiSettings.GetBool("myprograms.gameautoregion"))
+				{
+					CXBE xbe;
+					iRegion = xbe.ExtractGameRegion(item.GetPath());
+					if (iRegion < 1 || iRegion > 7)
+					iRegion = 0;
+					iRegion = xbe.FilterRegion(iRegion);
+				}
+				else
+				iRegion = 0;
+				CUtil::RunXBE(item.GetPath().c_str(),NULL,F_VIDEO(iRegion));
+			}
+			else if (item.IsAudio() || item.IsVideo())
+			{ // an audio or video file
+				PlayFile(item);
+			}
+			else
+			return false;
+		}
+		return true;
+	}
 
-void CApplication::Process()
-{
-  // check if we need to load a new skin
-  if (m_skinReloadTime && CTimeUtils::GetFrameTime() >= m_skinReloadTime)
-  {
-    ReloadSkin();
-  }
+	void CApplication::Process()
+	{
+		// check if we need to load a new skin
+		if (m_skinReloadTime && CTimeUtils::GetFrameTime() >= m_skinReloadTime)
+		{
+			CBuiltins::Execute("RunScript(special://xbmc/emustation/scripts/home_themer.py)");
+			// Set current theme for special://theme/
+			CSpecialProtocol::SetCurrentThemePath("Q:\\emustation\\themes\\"+URIUtils::ReplaceExtension(g_guiSettings.GetString("lookandfeel.skintheme"), ""));
+			ReloadSkin();
+		}
 
-  // dispatch the messages generated by python or other threads to the current window
-  g_windowManager.DispatchThreadMessages();
+		// dispatch the messages generated by python or other threads to the current window
+		g_windowManager.DispatchThreadMessages();
 
-  // process messages which have to be send to the gui
-  // (this can only be done after g_windowManager.Render())
-  m_applicationMessenger.ProcessWindowMessages();
+		// process messages which have to be send to the gui
+		// (this can only be done after g_windowManager.Render())
+		m_applicationMessenger.ProcessWindowMessages();
 
-  // process any Python scripts
-  g_pythonParser.Process();
+		// process any Python scripts
+		g_pythonParser.Process();
 
-  // process messages, even if a movie is playing
-  m_applicationMessenger.ProcessMessages();
+		// process messages, even if a movie is playing
+		m_applicationMessenger.ProcessMessages();
 
-  // check for memory unit changes
+		// check for memory unit changes
 #ifdef HAS_XBOX_HARDWARE
-  if (g_memoryUnitManager.Update())
-  { // changes have occured - update our shares
-    CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_REMOVED_MEDIA);
-    g_windowManager.SendThreadMessage(msg);
-  }
+		if (g_memoryUnitManager.Update())
+		{ // changes have occured - update our shares
+			CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_REMOVED_MEDIA);
+			g_windowManager.SendThreadMessage(msg);
+		}
 #endif
 
-  // check if we can free unused memory
-  g_audioManager.FreeUnused();
+		// check if we can free unused memory
+		g_audioManager.FreeUnused();
 
-  // check how far we are through playing the current item
-  // and do anything that needs doing (lastfm submission, playcount updates etc)
-  CheckPlayingProgress();
+		// check how far we are through playing the current item
+		// and do anything that needs doing (lastfm submission, playcount updates etc)
+		CheckPlayingProgress();
 
-  // update sound
-  if (m_pPlayer)
-    m_pPlayer->DoAudioWork();
+		// update sound
+		if (m_pPlayer)
+		m_pPlayer->DoAudioWork();
 
-  // process karaoke
+		// process karaoke
 #ifdef HAS_KARAOKE
-  if (m_pCdgParser)
-    m_pCdgParser->ProcessVoice();
+		if (m_pCdgParser)
+		m_pCdgParser->ProcessVoice();
 #endif
 
-  // do any processing that isn't needed on each run
-  if( m_slowTimer.GetElapsedMilliseconds() > 500 )
-  {
-    m_slowTimer.Reset();
-    ProcessSlow();
-  }
-}
+		// do any processing that isn't needed on each run
+		if( m_slowTimer.GetElapsedMilliseconds() > 500 )
+		{
+			m_slowTimer.Reset();
+			ProcessSlow();
+		}
+	}
 
-// We get called every 500ms
-void CApplication::ProcessSlow()
-{
-  // check our network state every 15 seconds or when net status changes
-  m_network.CheckNetwork(30);
-  
-  // check if we need 2 spin down the harddisk
-  CheckNetworkHDSpinDown();
-  if (!m_bNetworkSpinDown)
-    CheckHDSpindown();
+	// We get called every 500ms
+	void CApplication::ProcessSlow()
+	{
+		// check our network state every 30 seconds or when net status changes
+		m_network.CheckNetwork(10);
 
-  // Store our file state for use on close()
-  UpdateFileState();
+		// check if we need 2 spin down the harddisk
+		CheckNetworkHDSpinDown();
+		if (!m_bNetworkSpinDown)
+		CheckHDSpindown();
 
-  if (IsPlayingAudio())
-  {
-    CLastfmScrobbler::GetInstance()->UpdateStatus();
-    CLibrefmScrobbler::GetInstance()->UpdateStatus();
-  }
+		// Store our file state for use on close()
+		UpdateFileState();
 
-  // Check if we need to activate the screensaver (if enabled).
-  if (g_guiSettings.GetString("screensaver.mode") != "None")
-    CheckScreenSaver();
+		// if (IsPlayingAudio())
+		// {
+			// CLastfmScrobbler::GetInstance()->UpdateStatus();
+			// CLibrefmScrobbler::GetInstance()->UpdateStatus();
+		// }
 
-  // check if we need to shutdown (if enabled)
-  if (g_guiSettings.GetInt("system.shutdowntime"))
-    CheckShutdown();
+		// Check if we need to activate the screensaver (if enabled).
+		if (g_guiSettings.GetString("screensaver.mode") != "None")
+		CheckScreenSaver();
 
-  // check if we should restart the player
-  CheckDelayedPlayerRestart();
+		// check if we need to shutdown (if enabled)
+		if (g_guiSettings.GetInt("system.shutdowntime"))
+		CheckShutdown();
 
-  //  check if we can unload any unreferenced dlls or sections
-  if (!IsPlayingVideo())
-    CSectionLoader::UnloadDelayed();
+		// check if we should restart the player
+		CheckDelayedPlayerRestart();
 
-  // Xbox Autodetection - Send in X sec PingTime Interval
-  if (g_windowManager.GetActiveWindow() != WINDOW_LOGIN_SCREEN) // sorry jm ;D
-    CUtil::AutoDetection();
+		//  check if we can unload any unreferenced dlls or sections
+		if (!IsPlayingVideo())
+		CSectionLoader::UnloadDelayed();
 
-  // check for any idle curl connections
-  g_curlInterface.CheckIdle();
+		// Xbox Autodetection - Send in X sec PingTime Interval
+		if (g_windowManager.GetActiveWindow() != WINDOW_LOGIN_SCREEN) // sorry jm ;D
+		CUtil::AutoDetection();
 
-  // check for any idle myth sessions
-  CMythSession::CheckIdle();
+		// check for any idle curl connections
+		g_curlInterface.CheckIdle();
+
+		// check for any idle myth sessions
+		CMythSession::CheckIdle();
 #ifdef HAS_FILESYSTEM
-  // check for any idle htsp sessions
-  HTSP::CHTSPDirectorySession::CheckIdle();
+		// check for any idle htsp sessions
+		HTSP::CHTSPDirectorySession::CheckIdle();
 #endif
 #ifdef HAS_TIME_SERVER
-  // check for any needed sntp update
-  if(m_psntpClient && m_psntpClient->UpdateNeeded())
-    m_psntpClient->Update();
+		// check for any needed sntp update
+		if(m_psntpClient && m_psntpClient->UpdateNeeded())
+		m_psntpClient->Update();
 #endif
 
-  // LED - LCD SwitchOn On Paused! m_bIsPaused=TRUE -> LED/LCD is ON!
-  if(IsPaused() != m_bIsPaused)
-  {
-    if(g_guiSettings.GetBool("system.ledenableonpaused"))
-      StartLEDControl(m_bIsPaused);
-    if(g_guiSettings.GetBool("lcd.enableonpaused"))
-      DimLCDOnPlayback(m_bIsPaused);
-    m_bIsPaused = IsPaused();
-  }
+		// LED - LCD SwitchOn On Paused! m_bIsPaused=TRUE -> LED/LCD is ON!
+		if(IsPaused() != m_bIsPaused)
+		{
+			if(g_guiSettings.GetBool("system.ledenableonpaused"))
+			StartLEDControl(m_bIsPaused);
+			if(g_guiSettings.GetBool("lcd.enableonpaused"))
+			DimLCDOnPlayback(m_bIsPaused);
+			m_bIsPaused = IsPaused();
+		}
 
-  if (!IsPlayingVideo())
-    g_largeTextureManager.CleanupUnusedImages();
+		if (!IsPlayingVideo())
+		g_largeTextureManager.CleanupUnusedImages();
 
-  // checks whats in the DVD drive and tries to autostart the content (xbox games, dvd, cdda, avi files...)
-  if (!IsPlayingVideo())
-    m_Autorun.HandleAutorun();
+		// checks whats in the DVD drive and tries to autostart the content (xbox games, dvd, cdda, avi files...)
+		if (!IsPlayingVideo())
+		m_Autorun.HandleAutorun();
 
-  // update upnp server/renderer states
-  if(CUPnP::IsInstantiated())
-    CUPnP::GetInstance()->UpdateState();
+		// update upnp server/renderer states
+		if(CUPnP::IsInstantiated())
+		CUPnP::GetInstance()->UpdateState();
 
-  //Check to see if current playing Title has changed and whether we should broadcast the fact
-  CheckForTitleChange();
-}
+		//Check to see if current playing Title has changed and whether we should broadcast the fact
+		CheckForTitleChange();
+	}
 
-// Global Idle Time in Seconds
-// idle time will be resetet if on any OnKey()
-// int return: system Idle time in seconds! 0 is no idle!
-int CApplication::GlobalIdleTime()
-{
-  if(!m_idleTimer.IsRunning())
-  {
-    m_idleTimer.Stop();
-    m_idleTimer.StartZero();
-  }
-  return (int)m_idleTimer.GetElapsedSeconds();
-}
+	// Global Idle Time in Seconds
+	// idle time will be resetet if on any OnKey()
+	// int return: system Idle time in seconds! 0 is no idle!
+	int CApplication::GlobalIdleTime()
+	{
+		if(!m_idleTimer.IsRunning())
+		{
+			m_idleTimer.Stop();
+			m_idleTimer.StartZero();
+		}
+		return (int)m_idleTimer.GetElapsedSeconds();
+	}
 
-float CApplication::NavigationIdleTime()
-{
-  if (!m_navigationTimer.IsRunning())
-  {
-    m_navigationTimer.Stop();
-    m_navigationTimer.StartZero();
-  }
-  return m_navigationTimer.GetElapsedSeconds();
-}
+	float CApplication::NavigationIdleTime()
+	{
+		if (!m_navigationTimer.IsRunning())
+		{
+			m_navigationTimer.Stop();
+			m_navigationTimer.StartZero();
+		}
+		return m_navigationTimer.GetElapsedSeconds();
+	}
 
-void CApplication::DelayedPlayerRestart()
-{
-  m_restartPlayerTimer.StartZero();
-}
+	void CApplication::DelayedPlayerRestart()
+	{
+		m_restartPlayerTimer.StartZero();
+	}
 
-void CApplication::CheckDelayedPlayerRestart()
-{
-  if (m_restartPlayerTimer.GetElapsedSeconds() > 3)
-  {
-    m_restartPlayerTimer.Stop();
-    m_restartPlayerTimer.Reset();
-    Restart(true);
-  }
-}
+	void CApplication::CheckDelayedPlayerRestart()
+	{
+		if (m_restartPlayerTimer.GetElapsedSeconds() > 3)
+		{
+			m_restartPlayerTimer.Stop();
+			m_restartPlayerTimer.Reset();
+			Restart(true);
+		}
+	}
 
-void CApplication::Restart(bool bSamePosition)
-{
-  // this function gets called when the user changes a setting (like noninterleaved)
-  // and which means we gotta close & reopen the current playing file
+	void CApplication::Restart(bool bSamePosition)
+	{
+		// this function gets called when the user changes a setting (like noninterleaved)
+		// and which means we gotta close & reopen the current playing file
 
-  // first check if we're playing a file
-  if ( !IsPlayingVideo() && !IsPlayingAudio())
-    return ;
+		// first check if we're playing a file
+		if ( !IsPlayingVideo() && !IsPlayingAudio())
+		return ;
 
-  if( !m_pPlayer )
-    return ;
+		if( !m_pPlayer )
+		return ;
 
-  SaveFileState();
+		SaveFileState();
 
-  // do we want to return to the current position in the file
-  if (false == bSamePosition)
-  {
-    // no, then just reopen the file and start at the beginning
-    PlayFile(*m_itemCurrentFile, true);
-    return ;
-  }
+		// do we want to return to the current position in the file
+		if (false == bSamePosition)
+		{
+			// no, then just reopen the file and start at the beginning
+			PlayFile(*m_itemCurrentFile, true);
+			return ;
+		}
 
-  // else get current position
-  double time = GetTime();
+		// else get current position
+		double time = GetTime();
 
-  // get player state, needed for dvd's
-  CStdString state = m_pPlayer->GetPlayerState();
+		// get player state, needed for dvd's
+		CStdString state = m_pPlayer->GetPlayerState();
 
-  // set the requested starttime
-  m_itemCurrentFile->m_lStartOffset = (long)(time * 75.0);
+		// set the requested starttime
+		m_itemCurrentFile->m_lStartOffset = (long)(time * 75.0);
 
-  // reopen the file
-  if ( PlayFile(*m_itemCurrentFile, true) && m_pPlayer )
-    m_pPlayer->SetPlayerState(state);
-}
+		// reopen the file
+		if ( PlayFile(*m_itemCurrentFile, true) && m_pPlayer )
+		m_pPlayer->SetPlayerState(state);
+	}
 
-const CStdString& CApplication::CurrentFile()
-{
-  return m_itemCurrentFile->GetPath();
-}
+	const CStdString& CApplication::CurrentFile()
+	{
+		return m_itemCurrentFile->GetPath();
+	}
 
-CFileItem& CApplication::CurrentFileItem()
-{
-  return *m_itemCurrentFile;
-}
+	CFileItem& CApplication::CurrentFileItem()
+	{
+		return *m_itemCurrentFile;
+	}
 
-void CApplication::Mute(void)
-{
-  if (g_settings.m_bMute)
-  { // muted - unmute.
-    // In case our premutevolume is 0, return to 100% volume
-    if( g_settings.m_iPreMuteVolumeLevel == 0 )
-    {
-      SetVolume(100);
-    }
-    else
-    {
-      SetVolume(g_settings.m_iPreMuteVolumeLevel);
-      g_settings.m_iPreMuteVolumeLevel = 0;
-    }
-    m_guiDialogVolumeBar.Show();
-  }
-  else
-  { // mute
-    g_settings.m_iPreMuteVolumeLevel = GetVolume();
-    SetVolume(0);
-  }
-}
+	void CApplication::Mute(void)
+	{
+		if (g_settings.m_bMute)
+		{ // muted - unmute.
+			// In case our premutevolume is 0, return to 100% volume
+			if( g_settings.m_iPreMuteVolumeLevel == 0 )
+			{
+				SetVolume(100);
+			}
+			else
+			{
+				SetVolume(g_settings.m_iPreMuteVolumeLevel);
+				g_settings.m_iPreMuteVolumeLevel = 0;
+			}
+			m_guiDialogVolumeBar.Show();
+		}
+		else
+		{ // mute
+			g_settings.m_iPreMuteVolumeLevel = GetVolume();
+			SetVolume(0);
+		}
+	}
 
-void CApplication::SetVolume(int iPercent)
-{
-  // convert the percentage to a mB (milliBell) value (*100 for dB)
-  long hardwareVolume = (long)((float)iPercent * 0.01f * (VOLUME_MAXIMUM - VOLUME_MINIMUM) + VOLUME_MINIMUM);
-  SetHardwareVolume(hardwareVolume);
-  g_audioManager.SetVolume(g_settings.m_nVolumeLevel);
-}
+	void CApplication::SetVolume(int iPercent)
+	{
+		// convert the percentage to a mB (milliBell) value (*100 for dB)
+		long hardwareVolume = (long)((float)iPercent * 0.01f * (VOLUME_MAXIMUM - VOLUME_MINIMUM) + VOLUME_MINIMUM);
+		SetHardwareVolume(hardwareVolume);
+		g_audioManager.SetVolume(g_settings.m_nVolumeLevel);
+	}
 
-void CApplication::SetHardwareVolume(long hardwareVolume)
-{
-  // TODO DRC
-  if (hardwareVolume >= VOLUME_MAXIMUM) // + VOLUME_DRC_MAXIMUM
-    hardwareVolume = VOLUME_MAXIMUM;// + VOLUME_DRC_MAXIMUM;
-  if (hardwareVolume <= VOLUME_MINIMUM)
-  {
-    hardwareVolume = VOLUME_MINIMUM;
-  }
-  // update our settings
-  if (hardwareVolume > VOLUME_MAXIMUM)
-  {
-    g_settings.m_dynamicRangeCompressionLevel = hardwareVolume - VOLUME_MAXIMUM;
-    g_settings.m_nVolumeLevel = VOLUME_MAXIMUM;
-  }
-  else
-  {
-    g_settings.m_dynamicRangeCompressionLevel = 0;
-    g_settings.m_nVolumeLevel = hardwareVolume;
-  }
+	void CApplication::SetHardwareVolume(long hardwareVolume)
+	{
+		// TODO DRC
+		if (hardwareVolume >= VOLUME_MAXIMUM) // + VOLUME_DRC_MAXIMUM
+		hardwareVolume = VOLUME_MAXIMUM;// + VOLUME_DRC_MAXIMUM;
+		if (hardwareVolume <= VOLUME_MINIMUM)
+		{
+			hardwareVolume = VOLUME_MINIMUM;
+		}
+		// update our settings
+		if (hardwareVolume > VOLUME_MAXIMUM)
+		{
+			g_settings.m_dynamicRangeCompressionLevel = hardwareVolume - VOLUME_MAXIMUM;
+			g_settings.m_nVolumeLevel = VOLUME_MAXIMUM;
+		}
+		else
+		{
+			g_settings.m_dynamicRangeCompressionLevel = 0;
+			g_settings.m_nVolumeLevel = hardwareVolume;
+		}
 
-  // update mute state
-  if(!g_settings.m_bMute && hardwareVolume <= VOLUME_MINIMUM)
-  {
-    g_settings.m_bMute = true;
-    if (!m_guiDialogMuteBug.IsDialogRunning())
-      m_guiDialogMuteBug.Show();
-  }
-  else if(g_settings.m_bMute && hardwareVolume > VOLUME_MINIMUM)
-  {
-    g_settings.m_bMute = false;
-    if (m_guiDialogMuteBug.IsDialogRunning())
-      m_guiDialogMuteBug.Close();
-  }
+		// update mute state
+		if(!g_settings.m_bMute && hardwareVolume <= VOLUME_MINIMUM)
+		{
+			g_settings.m_bMute = true;
+			if (!m_guiDialogMuteBug.IsDialogRunning())
+			m_guiDialogMuteBug.Show();
+		}
+		else if(g_settings.m_bMute && hardwareVolume > VOLUME_MINIMUM)
+		{
+			g_settings.m_bMute = false;
+			if (m_guiDialogMuteBug.IsDialogRunning())
+			m_guiDialogMuteBug.Close();
+		}
 
-  // and tell our player to update the volume
-  if (m_pPlayer)
-  {
-    m_pPlayer->SetVolume(g_settings.m_nVolumeLevel);
-    // TODO DRC
-//    m_pPlayer->SetDynamicRangeCompression(g_settings.m_dynamicRangeCompressionLevel);
-  }
-}
+		// and tell our player to update the volume
+		if (m_pPlayer)
+		{
+			m_pPlayer->SetVolume(g_settings.m_nVolumeLevel);
+			// TODO DRC
+			//    m_pPlayer->SetDynamicRangeCompression(g_settings.m_dynamicRangeCompressionLevel);
+		}
+	}
 
-int CApplication::GetVolume() const
-{
-  // converts the hardware volume (in mB) to a percentage
-  return int(((float)(g_settings.m_nVolumeLevel + g_settings.m_dynamicRangeCompressionLevel - VOLUME_MINIMUM)) / (VOLUME_MAXIMUM - VOLUME_MINIMUM)*100.0f + 0.5f);
-}
+	int CApplication::GetVolume() const
+	{
+		// converts the hardware volume (in mB) to a percentage
+		return int(((float)(g_settings.m_nVolumeLevel + g_settings.m_dynamicRangeCompressionLevel - VOLUME_MINIMUM)) / (VOLUME_MAXIMUM - VOLUME_MINIMUM)*100.0f + 0.5f);
+	}
 
-int CApplication::GetSubtitleDelay() const
-{
-  // converts subtitle delay to a percentage
-  return int(((float)(g_settings.m_currentVideoSettings.m_SubtitleDelay + g_advancedSettings.m_videoSubsDelayRange)) / (2 * g_advancedSettings.m_videoSubsDelayRange)*100.0f + 0.5f);
-}
+	int CApplication::GetSubtitleDelay() const
+	{
+		// converts subtitle delay to a percentage
+		return int(((float)(g_settings.m_currentVideoSettings.m_SubtitleDelay + g_advancedSettings.m_videoSubsDelayRange)) / (2 * g_advancedSettings.m_videoSubsDelayRange)*100.0f + 0.5f);
+	}
 
-int CApplication::GetAudioDelay() const
-{
-  // converts subtitle delay to a percentage
-  return int(((float)(g_settings.m_currentVideoSettings.m_AudioDelay + g_advancedSettings.m_videoAudioDelayRange)) / (2 * g_advancedSettings.m_videoAudioDelayRange)*100.0f + 0.5f);
-}
+	int CApplication::GetAudioDelay() const
+	{
+		// converts subtitle delay to a percentage
+		return int(((float)(g_settings.m_currentVideoSettings.m_AudioDelay + g_advancedSettings.m_videoAudioDelayRange)) / (2 * g_advancedSettings.m_videoAudioDelayRange)*100.0f + 0.5f);
+	}
 
-void CApplication::SetPlaySpeed(int iSpeed)
-{
-  if (!IsPlayingAudio() && !IsPlayingVideo())
-    return ;
-  if (m_iPlaySpeed == iSpeed)
-    return ;
-  if (!m_pPlayer->CanSeek())
-    return;
-  if (m_pPlayer->IsPaused())
-  {
-    if (
-      ((m_iPlaySpeed > 1) && (iSpeed > m_iPlaySpeed)) ||
-      ((m_iPlaySpeed < -1) && (iSpeed < m_iPlaySpeed))
-    )
-    {
-      iSpeed = m_iPlaySpeed; // from pause to ff/rw, do previous ff/rw speed
-    }
-    m_pPlayer->Pause();
-  }
-  m_iPlaySpeed = iSpeed;
+	void CApplication::SetPlaySpeed(int iSpeed)
+	{
+		if (!IsPlayingAudio() && !IsPlayingVideo())
+		return ;
+		if (m_iPlaySpeed == iSpeed)
+		return ;
+		if (!m_pPlayer->CanSeek())
+		return;
+		if (m_pPlayer->IsPaused())
+		{
+			if (
+					((m_iPlaySpeed > 1) && (iSpeed > m_iPlaySpeed)) ||
+					((m_iPlaySpeed < -1) && (iSpeed < m_iPlaySpeed))
+					)
+			{
+				iSpeed = m_iPlaySpeed; // from pause to ff/rw, do previous ff/rw speed
+			}
+			m_pPlayer->Pause();
+		}
+		m_iPlaySpeed = iSpeed;
 
-  m_pPlayer->ToFFRW(m_iPlaySpeed);
-  if (m_iPlaySpeed == 1)
-  { // restore volume
-    m_pPlayer->SetVolume(g_settings.m_nVolumeLevel);
-  }
-  else
-  { // mute volume
-    m_pPlayer->SetVolume(VOLUME_MINIMUM);
-  }
-}
+		m_pPlayer->ToFFRW(m_iPlaySpeed);
+		if (m_iPlaySpeed == 1)
+		{ // restore volume
+			m_pPlayer->SetVolume(g_settings.m_nVolumeLevel);
+		}
+		else
+		{ // mute volume
+			m_pPlayer->SetVolume(VOLUME_MINIMUM);
+		}
+	}
 
-int CApplication::GetPlaySpeed() const
-{
-  return m_iPlaySpeed;
-}
+	int CApplication::GetPlaySpeed() const
+	{
+		return m_iPlaySpeed;
+	}
 
-// Returns the total time in seconds of the current media.  Fractional
-// portions of a second are possible - but not necessarily supported by the
-// player class.  This returns a double to be consistent with GetTime() and
-// SeekTime().
-double CApplication::GetTotalTime() const
-{
-  double rc = 0.0;
+	// Returns the total time in seconds of the current media.  Fractional
+	// portions of a second are possible - but not necessarily supported by the
+	// player class.  This returns a double to be consistent with GetTime() and
+	// SeekTime().
+	double CApplication::GetTotalTime() const
+	{
+		double rc = 0.0;
 
-  if (IsPlaying() && m_pPlayer)
-  {
-    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
-      rc = (*m_currentStack)[m_currentStack->Size() - 1]->m_lEndOffset;
-    else
-      rc = m_pPlayer->GetTotalTime();
-  }
+		if (IsPlaying() && m_pPlayer)
+		{
+			if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+			rc = (*m_currentStack)[m_currentStack->Size() - 1]->m_lEndOffset;
+			else
+			rc = m_pPlayer->GetTotalTime();
+		}
 
-  return rc;
-}
+		return rc;
+	}
 
-void CApplication::ResetPlayTime()
-{
-  if (IsPlaying() && m_pPlayer)
-    m_pPlayer->ResetTime();
-}
+	void CApplication::ResetPlayTime()
+	{
+		if (IsPlaying() && m_pPlayer)
+		m_pPlayer->ResetTime();
+	}
 
-// Returns the current time in seconds of the currently playing media.
-// Fractional portions of a second are possible.  This returns a double to
-// be consistent with GetTotalTime() and SeekTime().
-double CApplication::GetTime() const
-{
-  double rc = 0.0;
+	// Returns the current time in seconds of the currently playing media.
+	// Fractional portions of a second are possible.  This returns a double to
+	// be consistent with GetTotalTime() and SeekTime().
+	double CApplication::GetTime() const
+	{
+		double rc = 0.0;
 
-  if (IsPlaying() && m_pPlayer)
-  {
-    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
-    {
-      long startOfCurrentFile = (m_currentStackPosition > 0) ? (*m_currentStack)[m_currentStackPosition-1]->m_lEndOffset : 0;
-      rc = (double)startOfCurrentFile + m_pPlayer->GetTime() * 0.001;
-    }
-    else
-      rc = static_cast<double>(m_pPlayer->GetTime() * 0.001f);
-  }
+		if (IsPlaying() && m_pPlayer)
+		{
+			if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+			{
+				long startOfCurrentFile = (m_currentStackPosition > 0) ? (*m_currentStack)[m_currentStackPosition-1]->m_lEndOffset : 0;
+				rc = (double)startOfCurrentFile + m_pPlayer->GetTime() * 0.001;
+			}
+			else
+			rc = static_cast<double>(m_pPlayer->GetTime() * 0.001f);
+		}
 
-  return rc;
-}
+		return rc;
+	}
 
-// Sets the current position of the currently playing media to the specified
-// time in seconds.  Fractional portions of a second are valid.  The passed
-// time is the time offset from the beginning of the file as opposed to a
-// delta from the current position.  This method accepts a double to be
-// consistent with GetTime() and GetTotalTime().
-void CApplication::SeekTime( double dTime )
-{
-  if (IsPlaying() && m_pPlayer && (dTime >= 0.0))
-  {
-    if (!m_pPlayer->CanSeek()) return;
-    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
-    {
-      // find the item in the stack we are seeking to, and load the new
-      // file if necessary, and calculate the correct seek within the new
-      // file.  Otherwise, just fall through to the usual routine if the
-      // time is higher than our total time.
-      for (int i = 0; i < m_currentStack->Size(); i++)
-      {
-        if ((*m_currentStack)[i]->m_lEndOffset > dTime)
-        {
-          long startOfNewFile = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
-          if (m_currentStackPosition == i)
-            m_pPlayer->SeekTime((__int64)((dTime - startOfNewFile) * 1000.0));
-          else
-          { // seeking to a new file
-            m_currentStackPosition = i;
-            CFileItem item(*(*m_currentStack)[i]);
-            item.m_lStartOffset = (long)((dTime - startOfNewFile) * 75.0);
-            // don't just call "PlayFile" here, as we are quite likely called from the
-            // player thread, so we won't be able to delete ourselves.
-            m_applicationMessenger.PlayFile(item, true);
-          }
-          return;
-        }
-      }
-    }
-    // convert to milliseconds and perform seek
-    m_pPlayer->SeekTime( static_cast<__int64>( dTime * 1000.0 ) );
-  }
-}
+	// Sets the current position of the currently playing media to the specified
+	// time in seconds.  Fractional portions of a second are valid.  The passed
+	// time is the time offset from the beginning of the file as opposed to a
+	// delta from the current position.  This method accepts a double to be
+	// consistent with GetTime() and GetTotalTime().
+	void CApplication::SeekTime( double dTime )
+	{
+		if (IsPlaying() && m_pPlayer && (dTime >= 0.0))
+		{
+			if (!m_pPlayer->CanSeek()) return;
+			if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+			{
+				// find the item in the stack we are seeking to, and load the new
+				// file if necessary, and calculate the correct seek within the new
+				// file.  Otherwise, just fall through to the usual routine if the
+				// time is higher than our total time.
+				for (int i = 0; i < m_currentStack->Size(); i++)
+				{
+					if ((*m_currentStack)[i]->m_lEndOffset > dTime)
+					{
+						long startOfNewFile = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
+						if (m_currentStackPosition == i)
+						m_pPlayer->SeekTime((__int64)((dTime - startOfNewFile) * 1000.0));
+						else
+						{ // seeking to a new file
+							m_currentStackPosition = i;
+							CFileItem item(*(*m_currentStack)[i]);
+							item.m_lStartOffset = (long)((dTime - startOfNewFile) * 75.0);
+							// don't just call "PlayFile" here, as we are quite likely called from the
+							// player thread, so we won't be able to delete ourselves.
+							m_applicationMessenger.PlayFile(item, true);
+						}
+						return;
+					}
+				}
+			}
+			// convert to milliseconds and perform seek
+			m_pPlayer->SeekTime( static_cast<__int64>( dTime * 1000.0 ) );
+		}
+	}
 
-float CApplication::GetPercentage() const
-{
-  if (IsPlaying() && m_pPlayer)
-  {
-    if (IsPlayingAudio() && m_itemCurrentFile->HasMusicInfoTag())
-    {
-      const CMusicInfoTag& tag = *m_itemCurrentFile->GetMusicInfoTag();
-      if (tag.GetDuration() > 0)
-        return (float)(GetTime() / tag.GetDuration() * 100);
-    } 
-    
-    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
-      return (float)(GetTime() / GetTotalTime() * 100);
-    else
-      return m_pPlayer->GetPercentage();
-  }
-  return 0.0f;
-}
+	float CApplication::GetPercentage() const
+	{
+		if (IsPlaying() && m_pPlayer)
+		{
+			if (IsPlayingAudio() && m_itemCurrentFile->HasMusicInfoTag())
+			{
+				const CMusicInfoTag& tag = *m_itemCurrentFile->GetMusicInfoTag();
+				if (tag.GetDuration() > 0)
+				return (float)(GetTime() / tag.GetDuration() * 100);
+			} 
+			
+			if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+			return (float)(GetTime() / GetTotalTime() * 100);
+			else
+			return m_pPlayer->GetPercentage();
+		}
+		return 0.0f;
+	}
 
-float CApplication::GetCachePercentage() const
-{
-  if (IsPlaying() && m_pPlayer)
-  {
-    // Note that the player returns a relative cache percentage and we want an absolute percentage
-    // We also need to take into account the stack's total time vs. currently playing file's total time
-    float stackedTotalTime = (float) GetTotalTime();
-    if (stackedTotalTime > 0.0f)
-      return min( 100.0f, GetPercentage() + (m_pPlayer->GetCachePercentage() * m_pPlayer->GetTotalTime() / stackedTotalTime ) );
-  }
-  return 0.0f;
-}
+	float CApplication::GetCachePercentage() const
+	{
+		if (IsPlaying() && m_pPlayer)
+		{
+			// Note that the player returns a relative cache percentage and we want an absolute percentage
+			// We also need to take into account the stack's total time vs. currently playing file's total time
+			float stackedTotalTime = (float) GetTotalTime();
+			if (stackedTotalTime > 0.0f)
+			return min( 100.0f, GetPercentage() + (m_pPlayer->GetCachePercentage() * m_pPlayer->GetTotalTime() / stackedTotalTime ) );
+		}
+		return 0.0f;
+	}
 
-void CApplication::SeekPercentage(float percent)
-{
-  if (IsPlaying() && m_pPlayer && (percent >= 0.0))
-  {
-    if (!m_pPlayer->CanSeek()) return;
-    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
-      SeekTime(percent * 0.01 * GetTotalTime());
-    else
-      m_pPlayer->SeekPercentage(percent);
-  }
-}
+	void CApplication::SeekPercentage(float percent)
+	{
+		if (IsPlaying() && m_pPlayer && (percent >= 0.0))
+		{
+			if (!m_pPlayer->CanSeek()) return;
+			if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+			SeekTime(percent * 0.01 * GetTotalTime());
+			else
+			m_pPlayer->SeekPercentage(percent);
+		}
+	}
 
-// SwitchToFullScreen() returns true if a switch is made, else returns false
-bool CApplication::SwitchToFullScreen()
-{
-  // if playing from the video info window, close it first!
-  if (g_windowManager.HasModalDialog() && g_windowManager.GetTopMostModalDialogID() == WINDOW_VIDEO_INFO)
-  {
-    CGUIWindowVideoInfo* pDialog = (CGUIWindowVideoInfo*)g_windowManager.GetWindow(WINDOW_VIDEO_INFO);
-    if (pDialog) pDialog->Close(true);
-  }
+	// SwitchToFullScreen() returns true if a switch is made, else returns false
+	bool CApplication::SwitchToFullScreen()
+	{
+		// if playing from the video info window, close it first!
+		if (g_windowManager.HasModalDialog() && g_windowManager.GetTopMostModalDialogID() == WINDOW_VIDEO_INFO)
+		{
+			CGUIWindowVideoInfo* pDialog = (CGUIWindowVideoInfo*)g_windowManager.GetWindow(WINDOW_VIDEO_INFO);
+			if (pDialog) pDialog->Close(true);
+		}
 
-  // don't switch if there is a dialog on screen or the slideshow is active
-  if (g_windowManager.HasModalDialog() || g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW)
-    return false;
+		// don't switch if there is a dialog on screen or the slideshow is active
+		if (g_windowManager.HasModalDialog() || g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW)
+		return false;
 
-  // See if we're playing a video, and are in GUI mode
-  if ( IsPlayingVideo() && g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO)
-  {
-    // then switch to fullscreen mode
-    g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
-    g_TextureManager.Flush();
-    return true;
-  }
-  // special case for switching between GUI & visualisation mode. (only if we're playing an audio song)
-  if (IsPlayingAudio() && g_windowManager.GetActiveWindow() != WINDOW_VISUALISATION)
-  { // then switch to visualisation
-    g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
-    g_TextureManager.Flush();
-    return true;
-  }
-  return false;
-}
+		// See if we're playing a video, and are in GUI mode
+		if ( IsPlayingVideo() && g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO)
+		{
+			// then switch to fullscreen mode
+			g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+			g_TextureManager.Flush();
+			return true;
+		}
+		// special case for switching between GUI & visualisation mode. (only if we're playing an audio song)
+		if (IsPlayingAudio() && g_windowManager.GetActiveWindow() != WINDOW_VISUALISATION)
+		{ // then switch to visualisation
+			g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+			g_TextureManager.Flush();
+			return true;
+		}
+		return false;
+	}
 
-PLAYERCOREID CApplication::GetCurrentPlayer()
-{
-  return m_eCurrentPlayer;
-}
+	PLAYERCOREID CApplication::GetCurrentPlayer()
+	{
+		return m_eCurrentPlayer;
+	}
 
-// when a scan is initiated, save current settings
-// and enable tag reading and remote thums
-void CApplication::SaveMusicScanSettings()
-{
-  CLog::Log(LOGINFO,"Music scan has started... Enabling tag reading, and remote thumbs");
-  g_settings.m_bMyMusicIsScanning = true;
-  g_settings.Save();
-}
+	// when a scan is initiated, save current settings
+	// and enable tag reading and remote thums
+	void CApplication::SaveMusicScanSettings()
+	{
+		CLog::Log(LOGINFO,"Music scan has started... Enabling tag reading, and remote thumbs");
+		g_settings.m_bMyMusicIsScanning = true;
+		g_settings.Save();
+	}
 
-void CApplication::RestoreMusicScanSettings()
-{
-  g_settings.m_bMyMusicIsScanning = false;
-  g_settings.Save();
-}
+	void CApplication::RestoreMusicScanSettings()
+	{
+		g_settings.m_bMyMusicIsScanning = false;
+		g_settings.Save();
+	}
 
-void CApplication::UpdateLibraries()
-{
-  if (g_guiSettings.GetBool("videolibrary.updateonstartup"))
-  {
-    CLog::Log(LOGNOTICE, "%s - Starting video library startup scan", __FUNCTION__);
-    CGUIDialogVideoScan *scanner = (CGUIDialogVideoScan *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_SCAN);
-    SScraperInfo info;
-    VIDEO::SScanSettings settings;
-    if (scanner && !scanner->IsScanning())
-      scanner->StartScanning("",info,settings,false);
-  }
- 
-  if (g_guiSettings.GetBool("musiclibrary.updateonstartup"))
-  {
-    CLog::Log(LOGNOTICE, "%s - Starting music library startup scan", __FUNCTION__);
-    CGUIDialogMusicScan *scanner = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
-    if (scanner && !scanner->IsScanning())
-      scanner->StartScanning("");
-  }
-}
+	void CApplication::UpdateLibraries()
+	{
+		if (g_guiSettings.GetBool("videolibrary.updateonstartup"))
+		{
+			CLog::Log(LOGNOTICE, "%s - Starting video library startup scan", __FUNCTION__);
+			CGUIDialogVideoScan *scanner = (CGUIDialogVideoScan *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_SCAN);
+			SScraperInfo info;
+			VIDEO::SScanSettings settings;
+			if (scanner && !scanner->IsScanning())
+			scanner->StartScanning("",info,settings,false);
+		}
 
-void CApplication::CheckPlayingProgress()
-{
-  // check if we haven't rewound past the start of the file
-  if (IsPlaying())
-  {
-    int iSpeed = g_application.GetPlaySpeed();
-    if (iSpeed < 1)
-    {
-      iSpeed *= -1;
-      int iPower = 0;
-      while (iSpeed != 1)
-      {
-        iSpeed >>= 1;
-        iPower++;
-      }
-      if (g_infoManager.GetPlayTime() / 1000 < iPower)
-      {
-        g_application.SetPlaySpeed(1);
-        g_application.SeekTime(0);
-      }
-    }
-  }
-}
+		if (g_guiSettings.GetBool("musiclibrary.updateonstartup"))
+		{
+			CLog::Log(LOGNOTICE, "%s - Starting music library startup scan", __FUNCTION__);
+			CGUIDialogMusicScan *scanner = (CGUIDialogMusicScan *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_SCAN);
+			if (scanner && !scanner->IsScanning())
+			scanner->StartScanning("");
+		}
+	}
 
-bool CApplication::ProcessAndStartPlaylist(const CStdString& strPlayList, CPlayList& playlist, int iPlaylist, int track)
-{
-  CLog::Log(LOGDEBUG,"CApplication::ProcessAndStartPlaylist(%s, %i)",strPlayList.c_str(), iPlaylist);
+	void CApplication::CheckPlayingProgress()
+	{
+		// check if we haven't rewound past the start of the file
+		if (IsPlaying())
+		{
+			int iSpeed = g_application.GetPlaySpeed();
+			if (iSpeed < 1)
+			{
+				iSpeed *= -1;
+				int iPower = 0;
+				while (iSpeed != 1)
+				{
+					iSpeed >>= 1;
+					iPower++;
+				}
+				if (g_infoManager.GetPlayTime() / 1000 < iPower)
+				{
+					g_application.SetPlaySpeed(1);
+					g_application.SeekTime(0);
+				}
+			}
+		}
+	}
 
-  // initial exit conditions
-  // no songs in playlist just return
-  if (playlist.size() == 0)
-    return false;
+	bool CApplication::ProcessAndStartPlaylist(const CStdString& strPlayList, CPlayList& playlist, int iPlaylist, int track)
+	{
+		CLog::Log(LOGDEBUG,"CApplication::ProcessAndStartPlaylist(%s, %i)",strPlayList.c_str(), iPlaylist);
 
-  // illegal playlist
-  if (iPlaylist < PLAYLIST_MUSIC || iPlaylist > PLAYLIST_VIDEO)
-    return false;
+		// initial exit conditions
+		// no songs in playlist just return
+		if (playlist.size() == 0)
+		return false;
 
-  // setup correct playlist
-  g_playlistPlayer.ClearPlaylist(iPlaylist);
+		// illegal playlist
+		if (iPlaylist < PLAYLIST_MUSIC || iPlaylist > PLAYLIST_VIDEO)
+		return false;
 
-  // if the playlist contains an internet stream, this file will be used
-  // to generate a thumbnail for musicplayer.cover
-  g_application.m_strPlayListFile = strPlayList;
+		// setup correct playlist
+		g_playlistPlayer.ClearPlaylist(iPlaylist);
 
-  // add the items to the playlist player
-  g_playlistPlayer.Add(iPlaylist, playlist);
+		// if the playlist contains an internet stream, this file will be used
+		// to generate a thumbnail for musicplayer.cover
+		g_application.m_strPlayListFile = strPlayList;
 
-  // if we have a playlist
-  if (g_playlistPlayer.GetPlaylist(iPlaylist).size())
-  {
-    // start playing it
-    g_playlistPlayer.SetCurrentPlaylist(iPlaylist);
-    g_playlistPlayer.Reset();
-    g_playlistPlayer.Play(track);
-    return true;
-  }
-  return false;
-}
+		// add the items to the playlist player
+		g_playlistPlayer.Add(iPlaylist, playlist);
 
-void CApplication::CheckForDebugButtonCombo()
-{
+		// if we have a playlist
+		if (g_playlistPlayer.GetPlaylist(iPlaylist).size())
+		{
+			// start playing it
+			g_playlistPlayer.SetCurrentPlaylist(iPlaylist);
+			g_playlistPlayer.Reset();
+			g_playlistPlayer.Play(track);
+			return true;
+		}
+		return false;
+	}
+
+	void CApplication::CheckForDebugButtonCombo()
+	{
 #ifdef HAS_GAMEPAD
-  ReadInput();
-  if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_X] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y])
-  {
-    g_advancedSettings.m_logLevel = LOG_LEVEL_DEBUG_FREEMEM;
-    CLog::SetLogLevel(g_advancedSettings.m_logLevel);
-    CLog::Log(LOGINFO, "Key combination detected for full debug logging (X+Y)");
-  }
+		ReadInput();
+		if (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_X] && m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_Y])
+		{
+			g_advancedSettings.m_logLevel = LOG_LEVEL_DEBUG_FREEMEM;
+			CLog::SetLogLevel(g_advancedSettings.m_logLevel);
+			CLog::Log(LOGINFO, "Key combination detected for full debug logging (X+Y)");
+		}
 #ifdef _DEBUG
-  g_advancedSettings.m_logLevel = LOG_LEVEL_DEBUG_FREEMEM;
+		g_advancedSettings.m_logLevel = LOG_LEVEL_DEBUG_FREEMEM;
 #endif
 #endif
-}
+	}
 
-void CApplication::StartFtpEmergencyRecoveryMode()
-{
+	void CApplication::StartFtpEmergencyRecoveryMode()
+	{
 #ifdef HAS_FTP_SERVER
-  m_pFileZilla = new CXBFileZilla(NULL);
-  m_pFileZilla->Start();
+		m_pFileZilla = new CXBFileZilla(NULL);
+		m_pFileZilla->Start();
 
-  // Default settings
-  m_pFileZilla->mSettings.SetMaxUsers(0);
-  m_pFileZilla->mSettings.SetWelcomeMessage("XBMC emergency recovery console FTP.");
+		// Default settings
+		m_pFileZilla->mSettings.SetMaxUsers(8);
+		m_pFileZilla->mSettings.SetWelcomeMessage("XBMC internal console FTP.");
 
-  // default user
-  CXFUser* pUser;
-  m_pFileZilla->AddUser("xbox", pUser);
-  pUser->SetPassword("xbox");
-  pUser->SetShortcutsEnabled(false);
-  pUser->SetUseRelativePaths(false);
-  pUser->SetBypassUserLimit(false);
-  pUser->SetUserLimit(0);
-  pUser->SetIPLimit(0);
-  pUser->AddDirectory("/", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS | XBDIR_HOME);
-  pUser->AddDirectory("C:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  pUser->AddDirectory("D:\\", XBFILE_READ | XBDIR_LIST | XBDIR_SUBDIRS);
-  pUser->AddDirectory("E:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  pUser->AddDirectory("Q:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  //Add existing extended partitions
-  if (CIoSupport::DriveExists('F')){
-    pUser->AddDirectory("F:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  if (CIoSupport::DriveExists('G')){
-    pUser->AddDirectory("G:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  if (CIoSupport::DriveExists('R')){
-    pUser->AddDirectory("R:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  if (CIoSupport::DriveExists('S')){
-    pUser->AddDirectory("S:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  if (CIoSupport::DriveExists('V')){
-    pUser->AddDirectory("V:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  if (CIoSupport::DriveExists('W')){
-    pUser->AddDirectory("W:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  if (CIoSupport::DriveExists('A')){
-    pUser->AddDirectory("A:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  if (CIoSupport::DriveExists('B')){
-    pUser->AddDirectory("B:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
-  }
-  pUser->CommitChanges();
+		// default user
+		CXFUser* pUser;
+		m_pFileZilla->AddUser("xbox", pUser);
+		pUser->SetPassword("xbox");
+		pUser->SetShortcutsEnabled(false);
+		pUser->SetUseRelativePaths(false);
+		pUser->SetBypassUserLimit(false);
+		pUser->SetUserLimit(7);
+		pUser->SetIPLimit(0);
+		pUser->AddDirectory("/", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS | XBDIR_HOME);
+		pUser->AddDirectory("C:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		pUser->AddDirectory("D:\\", XBFILE_READ | XBDIR_LIST | XBDIR_SUBDIRS);
+		pUser->AddDirectory("E:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		pUser->AddDirectory("Q:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		pUser->AddDirectory("X:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		pUser->AddDirectory("Y:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		pUser->AddDirectory("Z:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		pUser->AddDirectory("P:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		//Add existing extended partitions
+		if (CIoSupport::DriveExists('F')){
+			pUser->AddDirectory("F:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		if (CIoSupport::DriveExists('G')){
+			pUser->AddDirectory("G:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		if (CIoSupport::DriveExists('R')){
+			pUser->AddDirectory("R:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		if (CIoSupport::DriveExists('S')){
+			pUser->AddDirectory("S:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		if (CIoSupport::DriveExists('V')){
+			pUser->AddDirectory("V:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		if (CIoSupport::DriveExists('W')){
+			pUser->AddDirectory("W:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		if (CIoSupport::DriveExists('A')){
+			pUser->AddDirectory("A:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		if (CIoSupport::DriveExists('B')){
+			pUser->AddDirectory("B:\\", XBFILE_READ | XBFILE_WRITE | XBFILE_DELETE | XBFILE_APPEND | XBDIR_DELETE | XBDIR_CREATE | XBDIR_LIST | XBDIR_SUBDIRS);
+		}
+		pUser->CommitChanges();
 #endif
-}
+	}
 
-void CApplication::SaveCurrentFileSettings()
-{
-  if (m_itemCurrentFile->IsVideo())
-  {
-    // save video settings
-    if (g_settings.m_currentVideoSettings != g_settings.m_defaultVideoSettings)
-    {
-      CVideoDatabase dbs;
-      dbs.Open();
-      dbs.SetVideoSettings(m_itemCurrentFile->GetPath(), g_settings.m_currentVideoSettings);
-      dbs.Close();
-    }
-  }
-}
+	void CApplication::SaveCurrentFileSettings()
+	{
+		if (m_itemCurrentFile->IsVideo())
+		{
+			// save video settings
+			if (g_settings.m_currentVideoSettings != g_settings.m_defaultVideoSettings)
+			{
+				CVideoDatabase dbs;
+				dbs.Open();
+				dbs.SetVideoSettings(m_itemCurrentFile->GetPath(), g_settings.m_currentVideoSettings);
+				dbs.Close();
+			}
+		}
+	}
 
-CApplicationMessenger& CApplication::getApplicationMessenger()
-{
-   return m_applicationMessenger;
-}
+	CApplicationMessenger& CApplication::getApplicationMessenger()
+	{
+		return m_applicationMessenger;
+	}
 
-CNetwork& CApplication::getNetwork()
-{
-   return m_network;
-}
+	CNetwork& CApplication::getNetwork()
+	{
+		return m_network;
+	}
 
-bool CApplication::IsCurrentThread() const
-{
-  return CThread::IsCurrentThread(m_threadID);
-}
+	bool CApplication::IsCurrentThread() const
+	{
+		return CThread::IsCurrentThread(m_threadID);
+	}
 
-void CApplication::InitDirectoriesXbox()
-{  
-  // Set installation path. Use Q as ie. F doesn't exist yet!!!
-  CStdString install_path = "Q:\\";
+	void CApplication::InitDirectoriesXbox()
+	{  
+		// Set installation path. Use Q as ie. F doesn't exist yet!!!
+		CStdString install_path = "Q:\\";
+		// Get absolute path for XBMC
+		CStdString strABPath;
+		CUtil::GetHomePath(strABPath);
+		if (!XFILE::CFile::Cache("Q:/system/backups/filezilla server.xml","Q:/system/filezilla server.xml"))
+		{
+			CLog::Log(LOGERROR, "Q:/system/backups/filezilla server.xml is missing.");
+		}
 
-  // check logpath
-  CStdString strLogFile, strLogFileOld;
-  g_settings.m_logFolder = install_path;
-  URIUtils::AddSlashAtEnd(g_settings.m_logFolder);
-  strLogFile.Format("%sxbmc.log", g_settings.m_logFolder);
-  strLogFileOld.Format("%sxbmc.old.log", g_settings.m_logFolder);
+		// check logpath
+		CStdString strLogFile, strLogFileOld;
+		g_settings.m_logFolder = "Q:\\system";
+		URIUtils::AddSlashAtEnd(g_settings.m_logFolder);
+		strLogFile.Format("%sxbmc.log", g_settings.m_logFolder);
+		strLogFileOld.Format("%sxbmc.old.log", g_settings.m_logFolder);
 
-  // Rotate the log (xbmc.log -> xbmc.old.log)
-  ::DeleteFile(strLogFileOld.c_str());
-  ::MoveFile(strLogFile.c_str(), strLogFileOld.c_str());
+		// Rotate the log (xbmc.log -> xbmc.old.log)
+		XFILE::CFile::Cache(strLogFile.c_str(), strLogFileOld.c_str());
+		DeleteFile(strLogFile.c_str());
 
-  // map our special drives to the correct drive letter
-  CSpecialProtocol::SetXBMCPath(install_path);
-  CSpecialProtocol::SetHomePath(install_path);
-  CSpecialProtocol::SetTempPath("Z:\\");
+		// map our special drives to the correct drive letter
+		CSpecialProtocol::SetXBMCPath(install_path);
+		CSpecialProtocol::SetHomePath(install_path);
+		CSpecialProtocol::SetRootPath(strABPath);
+		CSpecialProtocol::SetThemePath("Q:\\emustation\\themes\\");
+		CSpecialProtocol::SetURLDownloaderPath("Q:\\emustation\\scripts\\urldownloader\\");
+		CSpecialProtocol::SetEmustationScriptsPath("Q:\\emustation\\scripts\\");
+		CSpecialProtocol::SetTempPath("Z:\\");
 
-  // First profile is always the Master Profile
-  CSpecialProtocol::SetMasterProfilePath("Q:\\UserData");
+		// First profile is always the Master Profile
+		CSpecialProtocol::SetMasterProfilePath("Q:\\system\\UserData");
 
-  g_settings.LoadProfiles(PROFILES_FILE);
-}
+		g_settings.LoadProfiles(PROFILES_FILE);
+	}
Index: xbmc/Application.h
===================================================================
--- xbmc/Application.h	(revision 33042)
+++ xbmc/Application.h	(working copy)
@@ -100,6 +100,7 @@
   void LoadSkin(const CStdString& strSkin);
   void UnloadSkin();
   bool LoadUserWindows();
+  bool LoadUserWindowsalt();
   void DelayLoadSkin();
   void CancelDelayLoadSkin();
   void ReloadSkin();
Index: xbmc/ApplicationMessenger.cpp
===================================================================
--- xbmc/ApplicationMessenger.cpp	(revision 33042)
+++ xbmc/ApplicationMessenger.cpp	(working copy)
@@ -382,8 +382,8 @@
         if (pMsg->dwMessage == TMSG_SLIDESHOW_SCREENSAVER &&
             g_guiSettings.GetString("screensaver.mode").Equals("Fanart Slideshow"))
         {
-          CUtil::GetRecursiveListing(g_settings.GetVideoFanartFolder(), items, ".tbn");
-          CUtil::GetRecursiveListing(g_settings.GetMusicFanartFolder(), items, ".tbn");
+          CUtil::GetRecursiveListing("Q:\\system\\screensavers\\Fanart\\", items, ".jpg");
+          CUtil::GetRecursiveListing("Q:\\system\\screensavers\\Fanart\\", items, ".png");
         }
         else
           CUtil::GetRecursiveListing(strPath, items, g_settings.m_pictureExtensions);
Index: xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
===================================================================
--- xbmc/cores/DllLoader/exports/emu_msvcrt.cpp	(revision 33042)
+++ xbmc/cores/DllLoader/exports/emu_msvcrt.cpp	(working copy)
@@ -531,7 +531,7 @@
       // it might be something else than a file, or the file is not emulated
       // let the operating system handle it
       // not supported: return lseeki64(fd, lPos, iWhence);
-      CLog::Log(LOGWARNING, "msvcrt.dll: dll_lseeki64 called, TODO: add 'int64 -> long' type checking");      //warning
+      CLog::Log(LOGDEBUG, "msvcrt.dll: dll_lseeki64 called, TODO: add 'int64 -> long' type checking");      //warning
       return (__int64)lseek(fd, (long)lPos, iWhence);
     }
     CLog::Log(LOGERROR, "%s emulated function failed",  __FUNCTION__);
@@ -1010,7 +1010,7 @@
       // it might be something else than a file, or the file is not emulated
       // let the operating system handle it
       // not supported return telli64(fd);
-      CLog::Log(LOGWARNING, "msvcrt.dll: dll_telli64 called, TODO: add 'int64 -> long' type checking");      //warning
+      CLog::Log(LOGDEBUG, "msvcrt.dll: dll_telli64 called, TODO: add 'int64 -> long' type checking");      //warning
       return (__int64)tell(fd);
     }
     CLog::Log(LOGERROR, "%s emulated function failed",  __FUNCTION__);
@@ -1447,7 +1447,7 @@
     }
     else if (!IS_STD_DESCRIPTOR(fd))
     {
-      CLog::Log(LOGWARNING, "msvcrt.dll: dll_fstati64 called, TODO: add 'int64 <-> long' type checking");      //warning
+      CLog::Log(LOGDEBUG, "msvcrt.dll: dll_fstati64 called, TODO: add 'int64 <-> long' type checking");      //warning
       // need to use fstat and convert everything
       struct stat temp;
       int res = fstat(fd, &temp);
@@ -1575,7 +1575,7 @@
   {
     // some libs in the solution linked to getenv which was exported in python.lib
     // now python is in a dll this needs the be fixed, or not 
-    CLog::Log(LOGWARNING, "old getenv from python.lib called, library check needed");
+    CLog::Log(LOGDEBUG, "old getenv from python.lib called, library check needed");
     return NULL;
   }
 #endif
Index: xbmc/cores/dvdplayer/Codecs/ffmpeg/libavformat/xmv.c
===================================================================
--- xbmc/cores/dvdplayer/Codecs/ffmpeg/libavformat/xmv.c	(revision 33042)
+++ xbmc/cores/dvdplayer/Codecs/ffmpeg/libavformat/xmv.c	(working copy)
@@ -19,24 +19,18 @@
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-
 /**
  * @file
  * Microsoft XMV demuxer
  */
-
 #include <stdint.h>
-
 #include "libavutil/intreadwrite.h"
-
 #include "avformat.h"
 #include "internal.h"
 #include "riff.h"
 #include "libavutil/avassert.h"
-
 /** The min size of an XMV header. */
 #define XMV_MIN_HEADER_SIZE 36
-
 /** Audio flag: ADPCM'd 5.1 stream, front left / right channels */
 #define XMV_AUDIO_ADPCM51_FRONTLEFTRIGHT 1
 /** Audio flag: ADPCM'd 5.1 stream, front center / low frequency channels */
@@ -43,33 +37,25 @@
 #define XMV_AUDIO_ADPCM51_FRONTCENTERLOW 2
 /** Audio flag: ADPCM'd 5.1 stream, rear left / right channels */
 #define XMV_AUDIO_ADPCM51_REARLEFTRIGHT  4
-
 /** Audio flag: Any of the ADPCM'd 5.1 stream flags. */
 #define XMV_AUDIO_ADPCM51 (XMV_AUDIO_ADPCM51_FRONTLEFTRIGHT | \
                            XMV_AUDIO_ADPCM51_FRONTCENTERLOW | \
                            XMV_AUDIO_ADPCM51_REARLEFTRIGHT)
-
 /** A video packet with an XMV file. */
 typedef struct XMVVideoPacket {
     int stream_index; ///< The decoder stream index for this video packet.
-
     uint32_t data_size;   ///< The size of the remaining video data.
     uint64_t data_offset; ///< The offset of the video data within the file.
-
     uint32_t current_frame; ///< The current frame within this video packet.
     uint32_t frame_count;   ///< The amount of frames within this video packet.
-
     int     has_extradata; ///< Does the video packet contain extra data?
     uint8_t extradata[4];  ///< The extra data
-
     int64_t last_pts; ///< PTS of the last video frame.
     int64_t pts;      ///< PTS of the most current video frame.
 } XMVVideoPacket;
-
 /** An audio packet with an XMV file. */
 typedef struct XMVAudioPacket {
     int stream_index; ///< The decoder stream index for this audio packet.
-
     /* Stream format properties. */
     uint16_t compression;     ///< The type of compression.
     uint16_t channels;        ///< Number of channels.
@@ -79,116 +65,81 @@
     uint16_t flags;           ///< Flags
     unsigned block_align;     ///< Bytes per compressed block.
     uint16_t block_samples;   ///< Decompressed samples per compressed block.
-
     enum AVCodecID codec_id; ///< The codec ID of the compression scheme.
-
     uint32_t data_size;   ///< The size of the remaining audio data.
     uint64_t data_offset; ///< The offset of the audio data within the file.
-
     uint32_t frame_size; ///< Number of bytes to put into an audio frame.
-
     uint64_t block_count; ///< Running counter of decompressed audio block.
 } XMVAudioPacket;
-
 /** Context for demuxing an XMV file. */
 typedef struct XMVDemuxContext {
     uint16_t audio_track_count; ///< Number of audio track in this file.
-
     uint32_t this_packet_size; ///< Size of the current packet.
     uint32_t next_packet_size; ///< Size of the next packet.
-
     uint64_t this_packet_offset; ///< Offset of the current packet.
     uint64_t next_packet_offset; ///< Offset of the next packet.
-
     uint16_t current_stream; ///< The index of the stream currently handling.
     uint16_t stream_count;   ///< The number of streams in this file.
-
     XMVVideoPacket  video; ///< The video packet contained in each packet.
     XMVAudioPacket *audio; ///< The audio packets contained in each packet.
 } XMVDemuxContext;
-
 static int xmv_probe(AVProbeData *p)
 {
     uint32_t file_version;
-
     if (p->buf_size < XMV_MIN_HEADER_SIZE)
         return 0;
-
     file_version = AV_RL32(p->buf + 16);
     if ((file_version == 0) || (file_version > 4))
         return 0;
-
     if (!memcmp(p->buf + 12, "xobX", 4))
         return AVPROBE_SCORE_MAX;
-
     return 0;
 }
-
 static int xmv_read_header(AVFormatContext *s)
 {
     XMVDemuxContext *xmv = s->priv_data;
     AVIOContext     *pb  = s->pb;
     AVStream        *vst = NULL;
-
     uint32_t file_version;
     uint32_t this_packet_size;
     uint16_t audio_track;
-
     avio_skip(pb, 4); /* Next packet size */
-
     this_packet_size = avio_rl32(pb);
-
     avio_skip(pb, 4); /* Max packet size */
     avio_skip(pb, 4); /* "xobX" */
-
     file_version = avio_rl32(pb);
     if ((file_version != 4) && (file_version != 2))
         av_log_ask_for_sample(s, "Found uncommon version %d\n", file_version);
-
-
     /* Video track */
-
     vst = avformat_new_stream(s, NULL);
     if (!vst)
         return AVERROR(ENOMEM);
-
     avpriv_set_pts_info(vst, 32, 1, 1000);
-
     vst->codec->codec_type = AVMEDIA_TYPE_VIDEO;
     vst->codec->codec_id   = AV_CODEC_ID_WMV2;
     vst->codec->codec_tag  = MKBETAG('W', 'M', 'V', '2');
     vst->codec->width      = avio_rl32(pb);
     vst->codec->height     = avio_rl32(pb);
-
     vst->duration          = avio_rl32(pb);
-
     xmv->video.stream_index = vst->index;
-
     /* Audio tracks */
-
     xmv->audio_track_count = avio_rl16(pb);
-
     avio_skip(pb, 2); /* Unknown (padding?) */
-
     xmv->audio = av_malloc(xmv->audio_track_count * sizeof(XMVAudioPacket));
     if (!xmv->audio)
         return AVERROR(ENOMEM);
-
     for (audio_track = 0; audio_track < xmv->audio_track_count; audio_track++) {
         XMVAudioPacket *packet = &xmv->audio[audio_track];
         AVStream *ast = NULL;
-
         packet->compression     = avio_rl16(pb);
         packet->channels        = avio_rl16(pb);
         packet->sample_rate     = avio_rl32(pb);
         packet->bits_per_sample = avio_rl16(pb);
         packet->flags           = avio_rl16(pb);
-
         if (!packet->channels) {
             av_log(s, AV_LOG_ERROR, "0 channels\n");
             return AVERROR(EINVAL);
         }
-
         packet->bit_rate      = packet->bits_per_sample *
                                 packet->sample_rate *
                                 packet->channels;
@@ -196,22 +147,17 @@
         packet->block_samples = 64;
         packet->codec_id      = ff_wav_codec_get_id(packet->compression,
                                                     packet->bits_per_sample);
-
         packet->stream_index = -1;
-
         packet->frame_size  = 0;
         packet->block_count = 0;
-
         /* TODO: ADPCM'd 5.1 sound is encoded in three separate streams.
          *       Those need to be interleaved to a proper 5.1 stream. */
         if (packet->flags & XMV_AUDIO_ADPCM51)
             av_log(s, AV_LOG_WARNING, "Unsupported 5.1 ADPCM audio stream "
                                       "(0x%04X)\n", packet->flags);
-
         ast = avformat_new_stream(s, NULL);
         if (!ast)
             return AVERROR(ENOMEM);
-
         ast->codec->codec_type            = AVMEDIA_TYPE_AUDIO;
         ast->codec->codec_id              = packet->codec_id;
         ast->codec->codec_tag             = packet->compression;
@@ -220,30 +166,20 @@
         ast->codec->bits_per_coded_sample = packet->bits_per_sample;
         ast->codec->bit_rate              = packet->bit_rate;
         ast->codec->block_align           = 36 * packet->channels;
-
         avpriv_set_pts_info(ast, 32, packet->block_samples, packet->sample_rate);
-
         packet->stream_index = ast->index;
-
         ast->duration = vst->duration;
     }
-
-
     /* Initialize the packet context */
-
     xmv->next_packet_offset = avio_tell(pb);
     xmv->next_packet_size   = this_packet_size - xmv->next_packet_offset;
     xmv->stream_count       = xmv->audio_track_count + 1;
-
     return 0;
 }
-
 static void xmv_read_extradata(uint8_t *extradata, AVIOContext *pb)
 {
     /* Read the XMV extradata */
-
     uint32_t data = avio_rl32(pb);
-
     int mspel_bit        = !!(data & 0x01);
     int loop_filter      = !!(data & 0x02);
     int abt_flag         = !!(data & 0x04);
@@ -251,11 +187,8 @@
     int top_left_mv_flag = !!(data & 0x10);
     int per_mb_rl_bit    = !!(data & 0x20);
     int slice_count      = (data >> 6) & 7;
-
     /* Write it back as standard WMV2 extradata */
-
     data = 0;
-
     data |= mspel_bit        << 15;
     data |= loop_filter      << 14;
     data |= abt_flag         << 13;
@@ -263,34 +196,24 @@
     data |= top_left_mv_flag << 11;
     data |= per_mb_rl_bit    << 10;
     data |= slice_count      <<  7;
-
     AV_WB32(extradata, data);
 }
-
 static int xmv_process_packet_header(AVFormatContext *s)
 {
     XMVDemuxContext *xmv = s->priv_data;
     AVIOContext     *pb  = s->pb;
-
     uint8_t  data[8];
     uint16_t audio_track;
     uint64_t data_offset;
-
     /* Next packet size */
     xmv->next_packet_size = avio_rl32(pb);
-
     /* Packet video header */
-
     if (avio_read(pb, data, 8) != 8)
         return AVERROR(EIO);
-
     xmv->video.data_size     = AV_RL32(data) & 0x007FFFFF;
-
     xmv->video.current_frame = 0;
     xmv->video.frame_count   = (AV_RL32(data) >> 23) & 0xFF;
-
     xmv->video.has_extradata = (data[3] & 0x80) != 0;
-
     /* Adding the audio data sizes and the video data size keeps you 4 bytes
      * short for every audio track. But as playing around with XMV files with
      * ADPCM audio showed, taking the extra 4 bytes from the audio data gives
@@ -301,21 +224,16 @@
      * The video data has (always?) lots of padding, so it should work out...
      */
     xmv->video.data_size -= xmv->audio_track_count * 4;
-
     xmv->current_stream = 0;
     if (!xmv->video.frame_count) {
         xmv->video.frame_count = 1;
         xmv->current_stream    = xmv->stream_count > 1;
     }
-
     /* Packet audio header */
-
     for (audio_track = 0; audio_track < xmv->audio_track_count; audio_track++) {
         XMVAudioPacket *packet = &xmv->audio[audio_track];
-
         if (avio_read(pb, data, 4) != 4)
             return AVERROR(EIO);
-
         packet->data_size = AV_RL32(data) & 0x007FFFFF;
         if ((packet->data_size == 0) && (audio_track != 0))
             /* This happens when I create an XMV with several identical audio
@@ -324,85 +242,63 @@
              * Maybe this should also redirect the offset to the previous track?
              */
             packet->data_size = xmv->audio[audio_track - 1].data_size;
-
         /* Carve up the audio data in frame_count slices */
         packet->frame_size  = packet->data_size  / xmv->video.frame_count;
         packet->frame_size -= packet->frame_size % packet->block_align;
     }
-
     /* Packet data offsets */
-
     data_offset = avio_tell(pb);
-
     xmv->video.data_offset = data_offset;
     data_offset += xmv->video.data_size;
-
     for (audio_track = 0; audio_track < xmv->audio_track_count; audio_track++) {
         xmv->audio[audio_track].data_offset = data_offset;
         data_offset += xmv->audio[audio_track].data_size;
     }
-
     /* Video frames header */
-
     /* Read new video extra data */
     if (xmv->video.data_size > 0) {
         if (xmv->video.has_extradata) {
             xmv_read_extradata(xmv->video.extradata, pb);
-
             xmv->video.data_size   -= 4;
             xmv->video.data_offset += 4;
-
             if (xmv->video.stream_index >= 0) {
                 AVStream *vst = s->streams[xmv->video.stream_index];
-
                 av_assert0(xmv->video.stream_index < s->nb_streams);
-
                 if (vst->codec->extradata_size < 4) {
                     av_free(vst->codec->extradata);
-
                     vst->codec->extradata =
                         av_malloc(4 + FF_INPUT_BUFFER_PADDING_SIZE);
                     vst->codec->extradata_size = 4;
                 }
-
                 memcpy(vst->codec->extradata, xmv->video.extradata, 4);
             }
         }
     }
-
     return 0;
 }
-
 static int xmv_fetch_new_packet(AVFormatContext *s)
 {
     XMVDemuxContext *xmv = s->priv_data;
     AVIOContext     *pb  = s->pb;
     int result;
-
     if (xmv->this_packet_offset == xmv->next_packet_offset)
         return AVERROR_EOF;
-
     /* Seek to it */
     xmv->this_packet_offset = xmv->next_packet_offset;
     if (avio_seek(pb, xmv->this_packet_offset, SEEK_SET) != xmv->this_packet_offset)
         return AVERROR(EIO);
-
     /* Update the size */
     xmv->this_packet_size = xmv->next_packet_size;
     if (xmv->this_packet_size < (12 + xmv->audio_track_count * 4))
         return AVERROR(EIO);
-
     /* Process the header */
     result = xmv_process_packet_header(s);
     if (result)
         return result;
-
     /* Update the offset */
     xmv->next_packet_offset = xmv->this_packet_offset + xmv->this_packet_size;
-
     return 0;
 }
-
 static int xmv_fetch_audio_packet(AVFormatContext *s,
                                   AVPacket *pkt, uint32_t stream)
 {
@@ -409,15 +305,12 @@
     XMVDemuxContext *xmv   = s->priv_data;
     AVIOContext     *pb    = s->pb;
     XMVAudioPacket  *audio = &xmv->audio[stream];
-
     uint32_t data_size;
     uint32_t block_count;
     int result;
-
     /* Seek to it */
     if (avio_seek(pb, audio->data_offset, SEEK_SET) != audio->data_offset)
         return AVERROR(EIO);
-
     if ((xmv->video.current_frame + 1) < xmv->video.frame_count)
         /* Not the last frame, get at most frame_size bytes. */
         data_size = FFMIN(audio->frame_size, audio->data_size);
@@ -424,31 +317,22 @@
     else
         /* Last frame, get the rest. */
         data_size = audio->data_size;
-
     /* Read the packet */
     result = av_get_packet(pb, pkt, data_size);
     if (result <= 0)
         return result;
-
     pkt->stream_index = audio->stream_index;
-
     /* Calculate the PTS */
-
     block_count = data_size / audio->block_align;
-
     pkt->duration = block_count;
     pkt->pts      = audio->block_count;
     pkt->dts      = AV_NOPTS_VALUE;
-
     audio->block_count += block_count;
-
     /* Advance offset */
     audio->data_size   -= data_size;
     audio->data_offset += data_size;
-
     return 0;
 }
-
 static int xmv_fetch_video_packet(AVFormatContext *s,
                                   AVPacket *pkt)
 {
@@ -455,30 +339,23 @@
     XMVDemuxContext *xmv   = s->priv_data;
     AVIOContext     *pb    = s->pb;
     XMVVideoPacket  *video = &xmv->video;
-
     int result;
     uint32_t frame_header;
     uint32_t frame_size, frame_timestamp;
     uint8_t *data, *end;
-
     /* Seek to it */
     if (avio_seek(pb, video->data_offset, SEEK_SET) != video->data_offset)
         return AVERROR(EIO);
-
     /* Read the frame header */
     frame_header = avio_rl32(pb);
-
     frame_size      = (frame_header & 0x1FFFF) * 4 + 4;
     frame_timestamp = (frame_header >> 17);
-
     if ((frame_size + 4) > video->data_size)
         return AVERROR(EIO);
-
     /* Get the packet data */
     result = av_get_packet(pb, pkt, frame_size);
     if (result != frame_size)
         return result;
-
     /* Contrary to normal WMV2 video, the bit stream in XMV's
      * WMV2 is little-endian.
      * TODO: This manual swap is of course suboptimal.
@@ -485,76 +362,55 @@
      */
     for (data = pkt->data, end = pkt->data + frame_size; data < end; data += 4)
         AV_WB32(data, AV_RL32(data));
-
     pkt->stream_index = video->stream_index;
-
     /* Calculate the PTS */
-
     video->last_pts = frame_timestamp + video->pts;
-
     pkt->duration = 0;
     pkt->pts      = video->last_pts;
     pkt->dts      = AV_NOPTS_VALUE;
-
     video->pts += frame_timestamp;
-
     /* Keyframe? */
     pkt->flags = (pkt->data[0] & 0x80) ? 0 : AV_PKT_FLAG_KEY;
-
     /* Advance offset */
     video->data_size   -= frame_size + 4;
     video->data_offset += frame_size + 4;
-
     return 0;
 }
-
 static int xmv_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
 {
     XMVDemuxContext *xmv = s->priv_data;
     int result;
-
     if (xmv->video.current_frame == xmv->video.frame_count) {
         /* No frames left in this packet, so we fetch a new one */
-
         result = xmv_fetch_new_packet(s);
         if (result)
             return result;
     }
-
     if (xmv->current_stream == 0) {
         /* Fetch a video frame */
-
         result = xmv_fetch_video_packet(s, pkt);
         if (result)
             return result;
-
     } else {
         /* Fetch an audio frame */
-
         result = xmv_fetch_audio_packet(s, pkt, xmv->current_stream - 1);
         if (result)
             return result;
     }
-
     /* Increase our counters */
     if (++xmv->current_stream >= xmv->stream_count) {
         xmv->current_stream       = 0;
         xmv->video.current_frame += 1;
     }
-
     return 0;
 }
-
 static int xmv_read_close(AVFormatContext *s)
 {
     XMVDemuxContext *xmv = s->priv_data;
-
     av_freep(&xmv->audio);
-
     return 0;
 }
-
 AVInputFormat ff_xmv_demuxer = {
     .name           = "xmv",
     .long_name      = NULL_IF_CONFIG_SMALL("Microsoft XMV"),
@@ -563,4 +419,4 @@
     .read_header    = xmv_read_header,
     .read_packet    = xmv_read_packet,
     .read_close     = xmv_read_close,
-};
+};
\ No newline at end of file
Index: xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.cpp
===================================================================
--- xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.cpp	(revision 33042)
+++ xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitlesLibass.cpp	(working copy)
@@ -41,7 +41,7 @@
   }
 
 #ifdef _XBOX
-  CStdString strPath = "special://xbmc/media/Fonts/";
+  CStdString strPath = "special://xbmc/system/media/Fonts/";
 #else
   //Setting the font directory to the temp dir(where mkv fonts are extracted to)
   CStdString strPath = "special://temp/fonts/";
@@ -66,7 +66,7 @@
     return;
 
   //Setting default font to the Arial in \media\fonts (used if FontConfig fails)
-  strPath = "special://xbmc/media/Fonts/arial.ttf";
+  strPath = "special://xbmc/system/media/Fonts/arial.ttf";
 
   m_dll.ass_set_margins(m_renderer, 0, 0, 0, 0);
   m_dll.ass_set_use_margins(m_renderer, 0);
Index: xbmc/Credits.cpp
===================================================================
--- xbmc/Credits.cpp	(revision 33042)
+++ xbmc/Credits.cpp	(working copy)
@@ -1085,7 +1085,7 @@
     if (Fonts.find(Credits[i].Font) == Fonts.end())
     {
       // first try loading it
-      CStdString fontPath = "special://xbmc/media/Fonts/Arial.ttf";
+      CStdString fontPath = "special://xbmc/system/media/Fonts/Arial.ttf";
       CStdString strFont;
       strFont.Fmt("__credits%d__", Credits[i].Font);
       CGUIFont *font = g_fontManager.LoadTTF(strFont, fontPath, 0xFFdadada, 0, Credits[i].Font, FONT_STYLE_BOLD);
Index: xbmc/dialogs/GUIDialogContextMenu.h
===================================================================
--- xbmc/dialogs/GUIDialogContextMenu.h	(revision 33042)
+++ xbmc/dialogs/GUIDialogContextMenu.h	(working copy)
@@ -28,6 +28,12 @@
                       CONTEXT_BUTTON_LAUNCH,
                       CONTEXT_BUTTON_LAUNCH_IN,
                       CONTEXT_BUTTON_GAMESAVES,
+                      CONTEXT_BUTTON_SYNOPSIS,
+                      CONTEXT_BUTTON_PATCHEDXBE,
+                      CONTEXT_BUTTON_PATCHEDXHDXBE,
+                      CONTEXT_BUTTON_PATCHED720XBE,
+                      CONTEXT_BUTTON_PATCHEDWSXBE,
+                      CONTEXT_BUTTON_XRESIZERXBE,
                       CONTEXT_BUTTON_RENAME,
                       CONTEXT_BUTTON_DELETE,
                       CONTEXT_BUTTON_COPY,
Index: xbmc/dialogs/GUIDialogFavourites.cpp
===================================================================
--- xbmc/dialogs/GUIDialogFavourites.cpp	(revision 33042)
+++ xbmc/dialogs/GUIDialogFavourites.cpp	(working copy)
@@ -25,7 +25,11 @@
 #include "GUIDialogKeyboard.h"
 #include "FileItem.h"
 #include "LocalizeStrings.h"
+#include "interfaces/Builtins.h"
+#include "FileSystem/File.h"
 
+using namespace XFILE;
+
 #define FAVOURITES_LIST 450
 
 CGUIDialogFavourites::CGUIDialogFavourites(void)
@@ -49,6 +53,10 @@
       int action = message.GetParam1();
       if (action == ACTION_SELECT_ITEM || action == ACTION_MOUSE_LEFT_CLICK)
         OnClick(item);
+      else if (action == ACTION_SELECT_ITEM || action == ACTION_MOUSE_LEFT_CLICK)
+        OnClick(item);
+      else if (action == ACTION_SELECT_ITEM || action == ACTION_MOUSE_LEFT_CLICK)
+        OnClick(item);
       else if (action == ACTION_MOVE_ITEM_UP)
         OnMoveItem(item, -1);
       else if (action == ACTION_MOVE_ITEM_DOWN)
@@ -97,7 +105,7 @@
   CFileItemPtr pItem = (*m_favourites)[item];
   CStdString execute(pItem->GetPath());
 
-  Close();
+  //Close();
 
   CGUIMessage message(GUI_MSG_EXECUTE, 0, GetID());
   message.SetStringParam(execute);
@@ -113,13 +121,18 @@
   (*m_favourites)[item]->Select(true);
 
   CContextButtons choices;
+  if (CFile::Exists("special://xbmc/emustation/scripts/sort_favourites.py"))
+  {
+    choices.Add(1, "Sort by Name");
+    choices.Add(2, "Sort by System");
+  }
   if (m_favourites->Size() > 1)
   {
-    choices.Add(1, 13332);
-    choices.Add(2, 13333);
+    choices.Add(3, 13332);
+    choices.Add(4, 13333);
   }
-  choices.Add(3, 15015);
-  choices.Add(4, 118);
+  choices.Add(5, 15015);
+  choices.Add(6, 118);
   
   int button = CGUIDialogContextMenu::ShowAndGetChoice(choices);
 
@@ -127,15 +140,29 @@
   (*m_favourites)[item]->Select(false);
 
   if (button == 1)
+	  SortA();
+  else if (button == 2)
+	  SortSA();
+  else if (button == 3)
     OnMoveItem(item, -1);
-  else if (button == 2)
+  else if (button == 4)
     OnMoveItem(item, 1);
-  else if (button == 3)
+  else if (button == 5)
     OnDelete(item);
-  else if (button == 4)
+  else if (button == 6)
     OnRename(item);
 }
 
+void CGUIDialogFavourites::SortSA()
+{
+  CBuiltins::Execute("RunScript(special://xbmc/emustation/scripts/sort_favourites.py,1)");
+}
+
+void CGUIDialogFavourites::SortA()
+{
+  CBuiltins::Execute("RunScript(special://xbmc/emustation/scripts/sort_favourites.py)");
+}
+
 void CGUIDialogFavourites::OnMoveItem(int item, int amount)
 {
   if (item < 0 || item >= m_favourites->Size() || m_favourites->Size() <= 1 || 0 == amount) return;
@@ -161,7 +188,7 @@
 
   CGUIMessage message(GUI_MSG_ITEM_SELECT, GetID(), FAVOURITES_LIST, item < m_favourites->Size() ? item : item - 1);
   OnMessage(message);
-
+  CBuiltins::Execute("RunScript(special://xbmc/emustation/scripts/update_favs_counter.py,1)");
   UpdateList();
 }
 
@@ -172,11 +199,11 @@
 
   CStdString label((*m_favourites)[item]->GetLabel());
   if (CGUIDialogKeyboard::ShowAndGetInput(label, g_localizeStrings.Get(16008), false))
-    (*m_favourites)[item]->SetLabel(label);
-
-  CFavourites::Save(*m_favourites);
-
-  UpdateList();
+  {
+	  (*m_favourites)[item]->SetLabel(label);
+	  CFavourites::Save(*m_favourites);
+	  UpdateList();
+  }
 }
 
 void CGUIDialogFavourites::UpdateList()
Index: xbmc/dialogs/GUIDialogFavourites.h
===================================================================
--- xbmc/dialogs/GUIDialogFavourites.h	(revision 33042)
+++ xbmc/dialogs/GUIDialogFavourites.h	(working copy)
@@ -45,6 +45,8 @@
   void OnMoveItem(int item, int amount);
   void OnDelete(int item);
   void OnRename(int item);
+  void SortSA();
+  void SortA();
   void UpdateList();
 
   CFileItemList* m_favourites;
Index: xbmc/dialogs/GUIDialogMediaSource.cpp
===================================================================
--- xbmc/dialogs/GUIDialogMediaSource.cpp	(revision 33042)
+++ xbmc/dialogs/GUIDialogMediaSource.cpp	(working copy)
@@ -408,7 +408,7 @@
     if (share.strPath.Left(9).Equals("plugin://"))
     {
       CStdString strPath=share.strPath;
-      strPath.Replace("plugin://","special://home/plugins/");
+      strPath.Replace("plugin://","special://home/system/plugins/");
       CFileItem item(strPath,true);
       item.SetCachedProgramThumb();
       if (!item.HasThumbnail())
Index: xbmc/dialogs/GUIDialogPluginSettings.cpp
===================================================================
--- xbmc/dialogs/GUIDialogPluginSettings.cpp	(revision 33042)
+++ xbmc/dialogs/GUIDialogPluginSettings.cpp	(working copy)
@@ -881,7 +881,7 @@
   {
     CStdString url = m_url.Get();
     // replace plugin:// with the plugins root path
-    url.Replace("plugin://", "special://home/plugins/");
+    url.Replace("plugin://", "special://home/system/plugins/");
     fullPath = CUtil::ValidatePath(URIUtils::AddFileToFolder(url, path));
   }
 
Index: xbmc/dialogs/GUIDialogYesNo.cpp
===================================================================
--- xbmc/dialogs/GUIDialogYesNo.cpp	(revision 33042)
+++ xbmc/dialogs/GUIDialogYesNo.cpp	(working copy)
@@ -120,3 +120,17 @@
   return (dialog->IsConfirmed()) ? true : false;
 }
 
+bool CGUIDialogYesNo::ShowAndGetInput(const CStdString& heading, const CStdString& line0, const CStdString& line1, const CStdString& line2, const CStdString& iNoLabel, const CStdString& iYesLabel)
+{
+  CGUIDialogYesNo *dialog = (CGUIDialogYesNo *)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+  if (!dialog) return false;
+  dialog->SetHeading(heading);
+  dialog->SetLine(0, line0);
+  dialog->SetLine(1, line1);
+  dialog->SetLine(2, line2);
+  dialog->SetChoice(0,iNoLabel);
+  dialog->SetChoice(1,iYesLabel);
+  dialog->DoModal();
+  return (dialog->IsConfirmed()) ? true : false;
+}
+
Index: xbmc/dialogs/GUIDialogYesNo.h
===================================================================
--- xbmc/dialogs/GUIDialogYesNo.h	(revision 33042)
+++ xbmc/dialogs/GUIDialogYesNo.h	(working copy)
@@ -36,6 +36,7 @@
   static bool ShowAndGetInput(int heading, int line0, int line1, int line2, int iNoLabel, int iYesLabel, bool& bCanceled, unsigned int autoCloseTime = 0);
   static bool ShowAndGetInput(const CStdString& heading, const CStdString& line0, const CStdString& line1, const CStdString& line2);
   static bool ShowAndGetInput(const CStdString& heading, const CStdString& line0, const CStdString& line1, const CStdString& line2, bool &bCanceled);
+  static bool ShowAndGetInput(const CStdString& heading, const CStdString& line0, const CStdString& line1, const CStdString& line2, const CStdString& iNoLabel, const CStdString& iYesLabel);
 protected:
   bool m_bCanceled;
 };
Index: xbmc/Favourites.cpp
===================================================================
--- xbmc/Favourites.cpp	(revision 33042)
+++ xbmc/Favourites.cpp	(working copy)
@@ -128,7 +128,7 @@
   }
   else
   { // create our new favourite item
-    CFileItemPtr favourite(new CFileItem(item->GetLabel()));
+    CFileItemPtr favourite(new CFileItem(item->GetLabel()+" [xbox]"));
     if (item->GetLabel().IsEmpty())
       favourite->SetLabel(CUtil::GetTitleFromPath(item->GetPath(), item->m_bIsFolder));
     favourite->SetThumbnailImage(item->GetThumbnailImage());
Index: xbmc/FileSystem/PluginDirectory.cpp
===================================================================
--- xbmc/FileSystem/PluginDirectory.cpp	(revision 33042)
+++ xbmc/FileSystem/PluginDirectory.cpp	(working copy)
@@ -76,8 +76,8 @@
 
   CStdString fileName;
   
-  // path is special://home/plugins/<path from here>
-  CStdString pathToScript = "special://home/plugins/";
+  // path is special://home/system/plugins/<path from here>
+  CStdString pathToScript = "special://home/system/plugins/";
   URIUtils::AddFileToFolder(pathToScript, url.GetHostName(), pathToScript);
   URIUtils::AddFileToFolder(pathToScript, url.GetFileName(), pathToScript);
   URIUtils::AddFileToFolder(pathToScript, "default.py", pathToScript);
@@ -421,8 +421,8 @@
   // Load language strings
   LoadPluginStrings(url);
 
-  // path is special://home/plugins/<path from here>
-  CStdString pathToScript = "special://home/plugins/";
+  // path is special://home/system/plugins/<path from here>
+  CStdString pathToScript = "special://home/system/plugins/";
   URIUtils::AddFileToFolder(pathToScript, url.GetHostName(), pathToScript);
   URIUtils::AddFileToFolder(pathToScript, url.GetFileName(), pathToScript);
   URIUtils::AddFileToFolder(pathToScript, "default.py", pathToScript);
@@ -458,7 +458,7 @@
 
 bool CPluginDirectory::HasPlugins(const CStdString &type)
 {
-  CStdString path = "special://home/plugins/";
+  CStdString path = "special://home/system/plugins/";
   URIUtils::AddFileToFolder(path, type, path);
   CFileItemList items;
   if (CDirectory::GetDirectory(path, items, "/", false))
@@ -481,7 +481,7 @@
 bool CPluginDirectory::GetPluginsDirectory(const CStdString &type, CFileItemList &items)
 {
   // retrieve our folder
-  CStdString pluginsFolder = "special://home/plugins";
+  CStdString pluginsFolder = "special://home/system/plugins";
   URIUtils::AddFileToFolder(pluginsFolder, type, pluginsFolder);
   URIUtils::AddSlashAtEnd(pluginsFolder);
 
@@ -489,7 +489,7 @@
     return false;
 
   CStdString path = items.GetPath();
-  path.Replace("special://home/plugins/", "plugin://");
+  path.Replace("special://home/system/plugins/", "plugin://");
   items.SetPath(path);
 
   // flatten any folders - TODO: Assigning of thumbs
@@ -515,7 +515,7 @@
       }
     }
     path = item->GetPath();
-    path.Replace("special://home/plugins/", "plugin://");
+    path.Replace("special://home/system/plugins/", "plugin://");
     path.Replace("\\", "/");
     item->SetPath(path);
   }
@@ -664,7 +664,7 @@
 void CPluginDirectory::LoadPluginStrings(const CURL &url)
 {
   // Path where the plugin resides
-  CStdString pathToPlugin = "special://home/plugins/";
+  CStdString pathToPlugin = "special://home/system/plugins/";
   URIUtils::AddFileToFolder(pathToPlugin, url.GetHostName(), pathToPlugin);
   URIUtils::AddFileToFolder(pathToPlugin, url.GetFileName(), pathToPlugin);
 
Index: xbmc/FileSystem/SpecialProtocol.cpp
===================================================================
--- xbmc/FileSystem/SpecialProtocol.cpp	(revision 33042)
+++ xbmc/FileSystem/SpecialProtocol.cpp	(working copy)
@@ -26,6 +26,7 @@
 #include "settings/GUISettings.h"
 #include "settings/Settings.h"
 #include "utils/URIUtils.h"
+#include "xbox/IoSupport.h"
 
 #ifdef _LINUX
 #include <dirent.h>
@@ -51,6 +52,31 @@
   SetPath("home", dir);
 }
 
+void CSpecialProtocol::SetRootPath(const CStdString &dir)
+{
+  SetPath("root", dir);
+}
+
+void CSpecialProtocol::SetThemePath(const CStdString &dir)
+{
+  SetPath("themes_root", dir);
+}
+
+void CSpecialProtocol::SetCurrentThemePath(const CStdString &dir)
+{
+  SetPath("theme", dir);
+}
+
+void CSpecialProtocol::SetEmustationScriptsPath(const CStdString &dir)
+{
+  SetPath("emustation_scripts", dir);
+}
+
+void CSpecialProtocol::SetURLDownloaderPath(const CStdString &dir)
+{
+  SetPath("urldownloader", dir);
+}
+
 void CSpecialProtocol::SetUserHomePath(const CStdString &dir)
 {
   SetPath("userhome", dir);
@@ -137,6 +163,16 @@
     URIUtils::AddFileToFolder(GetPath("xbmc"), FileName, translatedPath);
   else if (RootDir.Equals("home"))
     URIUtils::AddFileToFolder(GetPath("home"), FileName, translatedPath);
+  else if (RootDir.Equals("root"))
+    URIUtils::AddFileToFolder(GetPath("root"), FileName, translatedPath);
+  else if (RootDir.Equals("themes_root"))
+    URIUtils::AddFileToFolder(GetPath("themes_root"), FileName, translatedPath);
+  else if (RootDir.Equals("theme"))
+    URIUtils::AddFileToFolder(GetPath("theme"), FileName, translatedPath);
+  else if (RootDir.Equals("emustation_scripts"))
+    URIUtils::AddFileToFolder(GetPath("emustation_scripts"), FileName, translatedPath);
+  else if (RootDir.Equals("urldownloader"))
+    URIUtils::AddFileToFolder(GetPath("urldownloader"), FileName, translatedPath);
   else if (RootDir.Equals("userhome"))
     URIUtils::AddFileToFolder(GetPath("userhome"), FileName, translatedPath);
   else if (RootDir.Equals("temp"))
@@ -231,6 +267,8 @@
       return URIUtils::AddFileToFolder("special://masterprofile/", oldPath.Mid(2));
     else if (oldPath.Left(2).CompareNoCase("U:") == 0)
       return URIUtils::AddFileToFolder("special://home/", oldPath.Mid(2));
+    else if (oldPath.Left(2).CompareNoCase("R:") == 0)
+      return URIUtils::AddFileToFolder("special://root/", oldPath.Mid(2));
     else if (oldPath.Left(2).CompareNoCase("Z:") == 0)
       return URIUtils::AddFileToFolder("special://temp/", oldPath.Mid(2));
   }
@@ -242,6 +280,11 @@
   CLog::Log(LOGNOTICE, "special://xbmc/ is mapped to: %s", GetPath("xbmc").c_str());
   CLog::Log(LOGNOTICE, "special://masterprofile/ is mapped to: %s", GetPath("masterprofile").c_str());
   CLog::Log(LOGNOTICE, "special://home/ is mapped to: %s", GetPath("home").c_str());
+  CLog::Log(LOGNOTICE, "special://root/ is mapped to: %s", GetPath("root").c_str());
+  CLog::Log(LOGNOTICE, "special://emustation_scripts/ is mapped to: %s", GetPath("emustation_scripts").c_str());
+  CLog::Log(LOGNOTICE, "special://themes_root/ is mapped to: %s", GetPath("themes_root").c_str());
+  CLog::Log(LOGNOTICE, "special://theme/ is mapped to: the currently loaded theme");
+  CLog::Log(LOGNOTICE, "special://urldownloader/ is mapped to: %s", GetPath("urldownloader").c_str());
   CLog::Log(LOGNOTICE, "special://temp/ is mapped to: %s", GetPath("temp").c_str());
   //CLog::Log(LOGNOTICE, "special://userhome/ is mapped to: %s", GetPath("userhome").c_str());
 }
Index: xbmc/FileSystem/SpecialProtocol.h
===================================================================
--- xbmc/FileSystem/SpecialProtocol.h	(revision 33042)
+++ xbmc/FileSystem/SpecialProtocol.h	(working copy)
@@ -55,6 +55,11 @@
   static void SetProfilePath(const CStdString &path);
   static void SetXBMCPath(const CStdString &path);
   static void SetHomePath(const CStdString &path);
+  static void SetRootPath(const CStdString &path);
+  static void SetThemePath(const CStdString &path);
+  static void SetCurrentThemePath(const CStdString &path);
+  static void SetURLDownloaderPath(const CStdString &path);
+  static void SetEmustationScriptsPath(const CStdString &path);
   static void SetUserHomePath(const CStdString &path);
   static void SetMasterProfilePath(const CStdString &path);
   static void SetTempPath(const CStdString &path);
Index: xbmc/GUIInfoManager.cpp
===================================================================
--- xbmc/GUIInfoManager.cpp	(revision 33042)
+++ xbmc/GUIInfoManager.cpp	(working copy)
@@ -362,6 +362,7 @@
     else if (strTest.Equals("system.dvdready")) ret = SYSTEM_DVDREADY;
     else if (strTest.Equals("system.trayopen")) ret = SYSTEM_TRAYOPEN;
     else if (strTest.Equals("system.dvdtraystate")) ret = SYSTEM_DVD_TRAY_STATE;
+    else if (strTest.Equals("system.screensaveractive")) ret = SYSTEM_SCREENSAVER_ACTIV;
     
     else if (strTest.Equals("system.memory(free)") || strTest.Equals("system.freememory")) ret = SYSTEM_FREE_MEMORY;
     else if (strTest.Equals("system.memory(free.percent)")) ret = SYSTEM_FREE_MEMORY_PERCENT;
@@ -378,6 +379,7 @@
     else if (strTest.Equals("system.currentcontrol")) ret = SYSTEM_CURRENT_CONTROL;
     else if (strTest.Equals("system.xboxnickname")) ret = SYSTEM_XBOX_NICKNAME;
     else if (strTest.Equals("system.dvdlabel")) ret = SYSTEM_DVD_LABEL;
+    else if (strTest.Equals("system.dvdtitleid")) ret = SYSTEM_DVD_TITLEID;
     else if (strTest.Equals("system.haslocks")) ret = SYSTEM_HASLOCKS;
     else if (strTest.Equals("system.hasloginscreen")) ret = SYSTEM_HAS_LOGINSCREEN;
     else if (strTest.Equals("system.ismaster")) ret = SYSTEM_ISMASTER;
@@ -404,6 +406,7 @@
     else if (strTest.Equals("system.xboxversion")) ret = SYSTEM_XBOX_VERSION;
     else if (strTest.Equals("system.avpackinfo")) ret = SYSTEM_AV_PACK_INFO;
     else if (strTest.Equals("system.screenresolution")) ret = SYSTEM_SCREEN_RESOLUTION;
+    else if (strTest.Equals("system.screenwidthxheight")) ret = SYSTEM_SCREEN_RESOLUTION_ONLY;
     else if (strTest.Equals("system.videoencoderinfo")) ret = SYSTEM_VIDEO_ENCODER_INFO;
     else if (strTest.Equals("system.xboxproduceinfo")) ret = SYSTEM_XBOX_PRODUCE_INFO;
     else if (strTest.Equals("system.xboxserial")) ret = SYSTEM_XBOX_SERIAL;
@@ -1347,6 +1350,12 @@
       g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].strMode,GetFPS());
     return strLabel;
     break;
+  case SYSTEM_SCREEN_RESOLUTION_ONLY:
+    strLabel.Format("%ix%i",
+      g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].iWidth,
+      g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].iHeight);
+    return strLabel;
+    break;
 #ifdef HAS_XBOX_HARDWARE
   case SYSTEM_CONTROLLER_PORT_1:
     return g_sysinfo.GetUnits(1);
@@ -1503,6 +1512,9 @@
   case SYSTEM_DVD_LABEL:
     strLabel = CDetectDVDMedia::GetDVDLabel();
     break;
+  case SYSTEM_DVD_TITLEID:
+    strLabel = CDetectDVDMedia::GetDVDTitleID();
+    break;
   case SYSTEM_ALARM_POS:
     if (g_alarmClock.GetRemaining("shutdowntimer") == 0.f)
       strLabel = "";
@@ -1562,6 +1574,7 @@
       strLabel = "skindefault";
     else
       strLabel = g_guiSettings.GetString("lookandfeel.skintheme");
+      URIUtils::RemoveExtension(strLabel);
     break;
   case SKIN_COLOUR_THEME:
     if (g_guiSettings.GetString("lookandfeel.skincolors").Equals("skindefault"))
@@ -1959,6 +1972,8 @@
     bReturn = CDetectDVDMedia::DriveReady() != DRIVE_NOT_READY;
   else if (condition == SYSTEM_TRAYOPEN)
     bReturn = CDetectDVDMedia::DriveReady() == DRIVE_OPEN;
+  else if (condition == SYSTEM_SCREENSAVER_ACTIV)
+    bReturn = g_application.IsInScreenSaver();
   else if (condition == PLAYER_SHOWINFO)
     bReturn = m_playerShowInfo;
   else if (condition == PLAYER_SHOWCODEC)
@@ -4155,8 +4170,8 @@
     break;
   case LISTITEM_SORT_LETTER:
     {
-      CStdString letter = g_charsetConverter.utf8Left(item->GetSortLabel(), 1);
-      letter.ToUpper();
+      CStdString letter = g_charsetConverter.utf8Left(item->GetSortLabel(), 50);
+      //letter.ToUpper();
       return letter;
     }
     break;
Index: xbmc/GUIInfoManager.h
===================================================================
--- xbmc/GUIInfoManager.h	(revision 33042)
+++ xbmc/GUIInfoManager.h	(working copy)
@@ -142,6 +142,7 @@
 #define SYSTEM_CURRENT_CONTROL      136
 #define SYSTEM_XBOX_NICKNAME        137
 #define SYSTEM_DVD_LABEL            138
+#define SYSTEM_DVD_TITLEID          1004
 #define SYSTEM_HAS_DRIVE_F          139
 #define SYSTEM_HASLOCKS             140
 #define SYSTEM_ISMASTER             141
@@ -359,6 +360,7 @@
 #define SYSTEM_XBOX_VERSION         657
 #define SYSTEM_AV_PACK_INFO         658
 #define SYSTEM_SCREEN_RESOLUTION    659
+#define SYSTEM_SCREEN_RESOLUTION_ONLY    1005
 #define SYSTEM_VIDEO_ENCODER_INFO   660
 #define SYSTEM_XBOX_SERIAL          661
 #define SYSTEM_CONTROLLER_PORT_1    662
@@ -409,6 +411,7 @@
 #define SYSTEM_OPENGL_VERSION       709
 #define SYSTEM_SETTING              710
 #define SYSTEM_HAS_ADDON            711
+#define SYSTEM_SCREENSAVER_ACTIV    717
 
 #define LIBRARY_HAS_MUSIC           720
 #define LIBRARY_HAS_VIDEO           721
Index: xbmc/guilib
===================================================================
--- xbmc/guilib	(revision 33042)
+++ xbmc/guilib	(working copy)

Property changes on: xbmc/guilib
___________________________________________________________________
Modified: svn:ignore
## -10,3 +10,4 ##
 Debug
 Profile
 Profile_FastCap
+GUIControlFactory.cpp left right
Index: xbmc/guilib/GUIAudioManager.cpp
===================================================================
--- xbmc/guilib/GUIAudioManager.cpp	(revision 33042)
+++ xbmc/guilib/GUIAudioManager.cpp	(working copy)
@@ -1,22 +1,22 @@
 /*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
 
 #include "include.h"
 #include "GUIAudioManager.h"
@@ -28,6 +28,7 @@
 #include "utils/SingleLock.h"
 #include "../xbmc/utils/URIUtils.h"
 #include "../xbmc/FileSystem/Directory.h"
+#include "FileSystem/File.h"
 
 using namespace std;
 using namespace XFILE;
@@ -36,8 +37,8 @@
 
 CGUIAudioManager::CGUIAudioManager()
 {
-  m_actionSound=NULL;
-  m_bEnabled=true;
+	m_actionSound=NULL;
+	m_bEnabled=true;
 }
 
 CGUIAudioManager::~CGUIAudioManager()
@@ -47,124 +48,124 @@
 
 void CGUIAudioManager::Initialize(int iDevice)
 {
-  CSingleLock lock(m_cs);
+	CSingleLock lock(m_cs);
 
-  if (iDevice==CAudioContext::DEFAULT_DEVICE)
-  {
-    bool bAudioOnAllSpeakers=false;
-    g_audioContext.SetupSpeakerConfig(2, bAudioOnAllSpeakers);
-    g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
-  }
+	if (iDevice==CAudioContext::DEFAULT_DEVICE)
+	{
+		bool bAudioOnAllSpeakers=false;
+		g_audioContext.SetupSpeakerConfig(2, bAudioOnAllSpeakers);
+		g_audioContext.SetActiveDevice(CAudioContext::DIRECTSOUND_DEVICE);
+	}
 }
 
 void CGUIAudioManager::DeInitialize(int iDevice)
 {
-  if (!(iDevice == CAudioContext::DIRECTSOUND_DEVICE || iDevice == CAudioContext::DEFAULT_DEVICE)) return;
+	if (!(iDevice == CAudioContext::DIRECTSOUND_DEVICE || iDevice == CAudioContext::DEFAULT_DEVICE)) return;
 
-  CSingleLock lock(m_cs);
-  if (m_actionSound) //  Wait for finish when an action sound is playing
-    while(m_actionSound->IsPlaying()) {}
+	CSingleLock lock(m_cs);
+	if (m_actionSound) //  Wait for finish when an action sound is playing
+	while(m_actionSound->IsPlaying()) {}
 
-  Stop();
+	Stop();
 }
 
 void CGUIAudioManager::Stop()
 {
-  CSingleLock lock(m_cs);
-  if (m_actionSound)
-  {
-    delete m_actionSound;
-    m_actionSound=NULL;
-  }
+	CSingleLock lock(m_cs);
+	if (m_actionSound)
+	{
+		delete m_actionSound;
+		m_actionSound=NULL;
+	}
 
-  for (windowSoundsMap::iterator it=m_windowSounds.begin();it!=m_windowSounds.end();it++)
-  {
-    CGUISound* sound=it->second;
-    if (sound->IsPlaying())
-      sound->Stop();
+	for (windowSoundsMap::iterator it=m_windowSounds.begin();it!=m_windowSounds.end();it++)
+	{
+		CGUISound* sound=it->second;
+		if (sound->IsPlaying())
+		sound->Stop();
 
-    delete sound;
-  }
-  m_windowSounds.clear();
+		delete sound;
+	}
+	m_windowSounds.clear();
 
-  for (pythonSoundsMap::iterator it1=m_pythonSounds.begin();it1!=m_pythonSounds.end();it1++)
-  {
-    CGUISound* sound=it1->second;
-    if (sound->IsPlaying())
-      sound->Stop();
+	for (pythonSoundsMap::iterator it1=m_pythonSounds.begin();it1!=m_pythonSounds.end();it1++)
+	{
+		CGUISound* sound=it1->second;
+		if (sound->IsPlaying())
+		sound->Stop();
 
-    delete sound;
-  }
-  m_pythonSounds.clear();
+		delete sound;
+	}
+	m_pythonSounds.clear();
 }
 
 // \brief Clear any unused audio buffers
 void CGUIAudioManager::FreeUnused()
 {
-  CSingleLock lock(m_cs);
+	CSingleLock lock(m_cs);
 
-  //  Free the sound from the last action
-  if (m_actionSound && !m_actionSound->IsPlaying())
-  {
-    delete m_actionSound;
-    m_actionSound=NULL;
-  }
+	//  Free the sound from the last action
+	if (m_actionSound && !m_actionSound->IsPlaying())
+	{
+		delete m_actionSound;
+		m_actionSound=NULL;
+	}
 
-  //  Free sounds from windows
-  windowSoundsMap::iterator it=m_windowSounds.begin();
-  while (it!=m_windowSounds.end())
-  {
-    CGUISound* sound=it->second;
-    if (!sound->IsPlaying())
-    {
-      delete sound;
-      m_windowSounds.erase(it++);
-    }
-    else ++it;
-  }
+	//  Free sounds from windows
+	windowSoundsMap::iterator it=m_windowSounds.begin();
+	while (it!=m_windowSounds.end())
+	{
+		CGUISound* sound=it->second;
+		if (!sound->IsPlaying())
+		{
+			delete sound;
+			m_windowSounds.erase(it++);
+		}
+		else ++it;
+	}
 
-  // Free sounds from python
-  pythonSoundsMap::iterator it1=m_pythonSounds.begin();
-  while (it1!=m_pythonSounds.end())
-  {
-    CGUISound* sound=it1->second;
-    if (!sound->IsPlaying())
-    {
-      delete sound;
-      m_pythonSounds.erase(it1++);
-    }
-    else ++it1;
-  }
+	// Free sounds from python
+	pythonSoundsMap::iterator it1=m_pythonSounds.begin();
+	while (it1!=m_pythonSounds.end())
+	{
+		CGUISound* sound=it1->second;
+		if (!sound->IsPlaying())
+		{
+			delete sound;
+			m_pythonSounds.erase(it1++);
+		}
+		else ++it1;
+	}
 }
 
 // \brief Play a sound associated with a CAction
 void CGUIAudioManager::PlayActionSound(const CAction& action)
 {
-  // it's not possible to play gui sounds when passthrough is active
-  if (!m_bEnabled || g_audioContext.IsPassthroughActive())
-    return;
+	// it's not possible to play gui sounds when passthrough is active
+	if (!m_bEnabled || g_audioContext.IsPassthroughActive())
+	return;
 
-  CSingleLock lock(m_cs);
+	CSingleLock lock(m_cs);
 
-  actionSoundMap::iterator it=m_actionSoundMap.find(action.GetID());
-  if (it==m_actionSoundMap.end())
-    return;
+	actionSoundMap::iterator it=m_actionSoundMap.find(action.GetID());
+	if (it==m_actionSoundMap.end())
+	return;
 
-  if (m_actionSound)
-  {
-    delete m_actionSound;
-    m_actionSound=NULL;
-  }
+	if (m_actionSound)
+	{
+		delete m_actionSound;
+		m_actionSound=NULL;
+	}
 
-  m_actionSound=new CGUISound();
-  if (!m_actionSound->Load(URIUtils::AddFileToFolder(m_strMediaDir, it->second)))
-  {
-    delete m_actionSound;
-    m_actionSound=NULL;
-    return;
-  }
+	m_actionSound=new CGUISound();
+	if (!m_actionSound->Load(URIUtils::AddFileToFolder(m_strMediaDir, it->second)))
+	{
+		delete m_actionSound;
+		m_actionSound=NULL;
+		return;
+	}
 
-  m_actionSound->Play();
+	m_actionSound->Play();
 }
 
 // \brief Play a sound associated with a window and its event
@@ -171,84 +172,84 @@
 // Events: SOUND_INIT, SOUND_DEINIT
 void CGUIAudioManager::PlayWindowSound(int id, WINDOW_SOUND event)
 {
-  // it's not possible to play gui sounds when passthrough is active
-  if (!m_bEnabled || g_audioContext.IsPassthroughActive())
-    return;
+	// it's not possible to play gui sounds when passthrough is active
+	if (!m_bEnabled || g_audioContext.IsPassthroughActive())
+	return;
 
-  CSingleLock lock(m_cs);
+	CSingleLock lock(m_cs);
 
-  windowSoundMap::iterator it=m_windowSoundMap.find(id);
-  if (it==m_windowSoundMap.end())
-    return;
+	windowSoundMap::iterator it=m_windowSoundMap.find(id);
+	if (it==m_windowSoundMap.end())
+	return;
 
-  CWindowSounds sounds=it->second;
-  CStdString strFile;
-  switch (event)
-  {
-  case SOUND_INIT:
-    strFile=sounds.strInitFile;
-    break;
-  case SOUND_DEINIT:
-    strFile=sounds.strDeInitFile;
-    break;
-  }
+	CWindowSounds sounds=it->second;
+	CStdString strFile;
+	switch (event)
+	{
+	case SOUND_INIT:
+		strFile=sounds.strInitFile;
+		break;
+	case SOUND_DEINIT:
+		strFile=sounds.strDeInitFile;
+		break;
+	}
 
-  if (strFile.IsEmpty())
-    return;
+	if (strFile.IsEmpty())
+	return;
 
-  //  One sound buffer for each window
-  windowSoundsMap::iterator itsb=m_windowSounds.find(id);
-  if (itsb!=m_windowSounds.end())
-  {
-    CGUISound* sound=itsb->second;
-    if (sound->IsPlaying())
-      sound->Stop();
-    delete sound;
-    m_windowSounds.erase(itsb++);
-  }
+	//  One sound buffer for each window
+	windowSoundsMap::iterator itsb=m_windowSounds.find(id);
+	if (itsb!=m_windowSounds.end())
+	{
+		CGUISound* sound=itsb->second;
+		if (sound->IsPlaying())
+		sound->Stop();
+		delete sound;
+		m_windowSounds.erase(itsb++);
+	}
 
-  CGUISound* sound=new CGUISound();
-  if (!sound->Load(URIUtils::AddFileToFolder(m_strMediaDir, strFile)))
-  {
-    delete sound;
-    return;
-  }
+	CGUISound* sound=new CGUISound();
+	if (!sound->Load(URIUtils::AddFileToFolder(m_strMediaDir, strFile)))
+	{
+		delete sound;
+		return;
+	}
 
-  m_windowSounds.insert(pair<int, CGUISound*>(id, sound));
-  sound->Play();
+	m_windowSounds.insert(pair<int, CGUISound*>(id, sound));
+	sound->Play();
 }
 
 // \brief Play a sound given by filename
 void CGUIAudioManager::PlayPythonSound(const CStdString& strFileName)
 {
-  // it's not possible to play gui sounds when passthrough is active
-  if (g_audioContext.IsPassthroughActive())
-    return;
+	// it's not possible to play gui sounds when passthrough is active
+	if (g_audioContext.IsPassthroughActive())
+	return;
 
-  CSingleLock lock(m_cs);
+	CSingleLock lock(m_cs);
 
-  // If we already loaded the sound, just play it
-  pythonSoundsMap::iterator itsb=m_pythonSounds.find(strFileName);
-  if (itsb!=m_pythonSounds.end())
-  {
-    CGUISound* sound=itsb->second;
-    if (sound->IsPlaying())
-      sound->Stop();
+	// If we already loaded the sound, just play it
+	pythonSoundsMap::iterator itsb=m_pythonSounds.find(strFileName);
+	if (itsb!=m_pythonSounds.end())
+	{
+		CGUISound* sound=itsb->second;
+		if (sound->IsPlaying())
+		sound->Stop();
 
-    sound->Play();
+		sound->Play();
 
-    return;
-  }
+		return;
+	}
 
-  CGUISound* sound=new CGUISound();
-  if (!sound->Load(strFileName))
-  {
-    delete sound;
-    return;
-  }
+	CGUISound* sound=new CGUISound();
+	if (!sound->Load(strFileName))
+	{
+		delete sound;
+		return;
+	}
 
-  m_pythonSounds.insert(pair<CStdString, CGUISound*>(strFileName, sound));
-  sound->Play();
+	m_pythonSounds.insert(pair<CStdString, CGUISound*>(strFileName, sound));
+	sound->Play();
 }
 
 // \brief Load the config file (sounds.xml) for nav sounds
@@ -257,153 +258,151 @@
 // xbmc
 bool CGUIAudioManager::Load()
 {
-  m_actionSoundMap.clear();
-  m_windowSoundMap.clear();
+	m_actionSoundMap.clear();
+	m_windowSoundMap.clear();
+	CStdString ThemeName(URIUtils::ReplaceExtension(g_guiSettings.GetString("lookandfeel.skintheme"), ""));
 
-  if (g_guiSettings.GetString("lookandfeel.soundskin")=="OFF")
-    return true;
+	if (g_guiSettings.GetString("lookandfeel.soundskin")=="OFF")
+		return true;
 
-  if (g_guiSettings.GetString("lookandfeel.soundskin")=="SKINDEFAULT")
-  {
-    m_strMediaDir="special://home/skin/" + g_guiSettings.GetString("lookandfeel.skin") + "/sounds";
-    if ( ! CDirectory::Exists( m_strMediaDir ) )
-    {
-      m_strMediaDir = URIUtils::AddFileToFolder("special://xbmc/skin", g_guiSettings.GetString("lookandfeel.skin"));
-      m_strMediaDir = URIUtils::AddFileToFolder(m_strMediaDir, "sounds");
-    }
-  }
-  else
-    m_strMediaDir = URIUtils::AddFileToFolder("special://xbmc/sounds", g_guiSettings.GetString("lookandfeel.soundskin"));
+	if (CFile::Exists("special://xbmc/emustation/themes/" + ThemeName + "/sounds/sounds.xml"))
+	{
+		m_strMediaDir="special://xbmc/emustation/themes/" + ThemeName + "/sounds";
+	}
+	else
+	{
+		m_strMediaDir="special://xbmc/emustation/themes/SIMPLE/sounds";
+	}
 
-  CStdString strSoundsXml = URIUtils::AddFileToFolder(m_strMediaDir, "sounds.xml");
+	CStdString strSoundsXml = URIUtils::AddFileToFolder(m_strMediaDir, "sounds.xml");
 
-  //  Load our xml file
-  TiXmlDocument xmlDoc;
+	//  Load our xml file
+	TiXmlDocument xmlDoc;
 
-  CLog::Log(LOGINFO, "Loading %s", strSoundsXml.c_str());
+	CLog::Log(LOGINFO, "Loading %s", strSoundsXml.c_str());
 
-  //  Load the config file
-  if (!xmlDoc.LoadFile(strSoundsXml))
-  {
-    CLog::Log(LOGNOTICE, "%s, Line %d\n%s", strSoundsXml.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
-    return false;
-  }
+	//  Load the config file
+	if (!xmlDoc.LoadFile(strSoundsXml))
+	{
+		CLog::Log(LOGNOTICE, "%s, Line %d\n%s", strSoundsXml.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+		return false;
+	}
 
-  TiXmlElement* pRoot = xmlDoc.RootElement();
-  CStdString strValue = pRoot->Value();
-  if ( strValue != "sounds")
-  {
-    CLog::Log(LOGNOTICE, "%s Doesn't contain <sounds>", strSoundsXml.c_str());
-    return false;
-  }
+	TiXmlElement* pRoot = xmlDoc.RootElement();
+	CStdString strValue = pRoot->Value();
+	if ( strValue != "sounds")
+	{
+		CLog::Log(LOGNOTICE, "%s Doesn't contain <sounds>", strSoundsXml.c_str());
+		return false;
+	}
 
-  //  Load sounds for actions
-  TiXmlElement* pActions = pRoot->FirstChildElement("actions");
-  if (pActions)
-  {
-    TiXmlNode* pAction = pActions->FirstChild("action");
+	//  Load sounds for actions
+	TiXmlElement* pActions = pRoot->FirstChildElement("actions");
+	if (pActions)
+	{
+		TiXmlNode* pAction = pActions->FirstChild("action");
 
-    while (pAction)
-    {
-      TiXmlNode* pIdNode = pAction->FirstChild("name");
-      int id = 0;    // action identity
-      if (pIdNode && pIdNode->FirstChild())
-      {
-        CButtonTranslator::TranslateActionString(pIdNode->FirstChild()->Value(), id);
-      }
+		while (pAction)
+		{
+			TiXmlNode* pIdNode = pAction->FirstChild("name");
+			int id = 0;    // action identity
+			if (pIdNode && pIdNode->FirstChild())
+			{
+				CButtonTranslator::TranslateActionString(pIdNode->FirstChild()->Value(), id);
+			}
 
-      TiXmlNode* pFileNode = pAction->FirstChild("file");
-      CStdString strFile;
-      if (pFileNode && pFileNode->FirstChild())
-        strFile+=pFileNode->FirstChild()->Value();
+			TiXmlNode* pFileNode = pAction->FirstChild("file");
+			CStdString strFile;
+			if (pFileNode && pFileNode->FirstChild())
+			strFile+=pFileNode->FirstChild()->Value();
 
-      if (id > 0 && !strFile.IsEmpty())
-        m_actionSoundMap.insert(pair<int, CStdString>(id, strFile));
+			if (id > 0 && !strFile.IsEmpty())
+			m_actionSoundMap.insert(pair<int, CStdString>(id, strFile));
 
-      pAction = pAction->NextSibling();
-    }
-  }
+			pAction = pAction->NextSibling();
+		}
+	}
 
-  //  Load window specific sounds
-  TiXmlElement* pWindows = pRoot->FirstChildElement("windows");
-  if (pWindows)
-  {
-    TiXmlNode* pWindow = pWindows->FirstChild("window");
+	//  Load window specific sounds
+	TiXmlElement* pWindows = pRoot->FirstChildElement("windows");
+	if (pWindows)
+	{
+		TiXmlNode* pWindow = pWindows->FirstChild("window");
 
-    while (pWindow)
-    {
-      int id = 0;
+		while (pWindow)
+		{
+			int id = 0;
 
-      TiXmlNode* pIdNode = pWindow->FirstChild("name");
-      if (pIdNode)
-      {
-        if (pIdNode->FirstChild())
-          id = CButtonTranslator::TranslateWindow(pIdNode->FirstChild()->Value());
-      }
+			TiXmlNode* pIdNode = pWindow->FirstChild("name");
+			if (pIdNode)
+			{
+				if (pIdNode->FirstChild())
+				id = CButtonTranslator::TranslateWindow(pIdNode->FirstChild()->Value());
+			}
 
-      CWindowSounds sounds;
-      LoadWindowSound(pWindow, "activate", sounds.strInitFile);
-      LoadWindowSound(pWindow, "deactivate", sounds.strDeInitFile);
+			CWindowSounds sounds;
+			LoadWindowSound(pWindow, "activate", sounds.strInitFile);
+			LoadWindowSound(pWindow, "deactivate", sounds.strDeInitFile);
 
-      if (id > 0)
-        m_windowSoundMap.insert(pair<int, CWindowSounds>(id, sounds));
+			if (id > 0)
+			m_windowSoundMap.insert(pair<int, CWindowSounds>(id, sounds));
 
-      pWindow = pWindow->NextSibling();
-    }
-  }
+			pWindow = pWindow->NextSibling();
+		}
+	}
 
-  return true;
+	return true;
 }
 
 // \brief Load a window node of the config file (sounds.xml)
 bool CGUIAudioManager::LoadWindowSound(TiXmlNode* pWindowNode, const CStdString& strIdentifier, CStdString& strFile)
 {
-  if (!pWindowNode)
-    return false;
+	if (!pWindowNode)
+	return false;
 
-  TiXmlNode* pFileNode = pWindowNode->FirstChild(strIdentifier);
-  if (pFileNode && pFileNode->FirstChild())
-  {
-    strFile = pFileNode->FirstChild()->Value();
-    return true;
-  }
+	TiXmlNode* pFileNode = pWindowNode->FirstChild(strIdentifier);
+	if (pFileNode && pFileNode->FirstChild())
+	{
+		strFile = pFileNode->FirstChild()->Value();
+		return true;
+	}
 
-  return false;
+	return false;
 }
 
 // \brief Enable/Disable nav sounds
 void CGUIAudioManager::Enable(bool bEnable)
 {
-  // Enable/Disable has no effect if nav sounds are turned off
-  if (g_guiSettings.GetString("lookandfeel.soundskin")=="OFF")
-    return;
+	// Enable/Disable has no effect if nav sounds are turned off
+	if (g_guiSettings.GetString("lookandfeel.soundskin")=="OFF")
+	return;
 
-  m_bEnabled=bEnable;
+	m_bEnabled=bEnable;
 }
 
 // \brief Sets the volume of all playing sounds
 void CGUIAudioManager::SetVolume(int iLevel)
 {
-  CSingleLock lock(m_cs);
+	CSingleLock lock(m_cs);
 
-  if (m_actionSound)
-    m_actionSound->SetVolume(iLevel);
+	if (m_actionSound)
+	m_actionSound->SetVolume(iLevel);
 
-  windowSoundsMap::iterator it=m_windowSounds.begin();
-  while (it!=m_windowSounds.end())
-  {
-    if (it->second)
-      it->second->SetVolume(iLevel);
+	windowSoundsMap::iterator it=m_windowSounds.begin();
+	while (it!=m_windowSounds.end())
+	{
+		if (it->second)
+		it->second->SetVolume(iLevel);
 
-    ++it;
-  }
+		++it;
+	}
 
-  pythonSoundsMap::iterator it1=m_pythonSounds.begin();
-  while (it1!=m_pythonSounds.end())
-  {
-    if (it1->second)
-      it1->second->SetVolume(iLevel);
+	pythonSoundsMap::iterator it1=m_pythonSounds.begin();
+	while (it1!=m_pythonSounds.end())
+	{
+		if (it1->second)
+		it1->second->SetVolume(iLevel);
 
-    ++it1;
-  }
+		++it1;
+	}
 }
Index: xbmc/guilib/GUIBaseContainer.cpp
===================================================================
--- xbmc/guilib/GUIBaseContainer.cpp	(revision 33042)
+++ xbmc/guilib/GUIBaseContainer.cpp	(working copy)
@@ -330,6 +330,17 @@
       SelectItem(message.GetParam1());
       return true;
     }
+	else if (message.GetMessage() == GUI_MSG_SETFOCUS)
+    {
+      if (message.GetParam1()) // subfocus item is specified, so set the offset appropriately
+      {
+        int offset = GetOffset();
+        if (message.GetParam2() && message.GetParam2() == 1)
+          offset = 0;
+        int item = min(offset + (int)message.GetParam1() - 1, (int)m_items.size() - 1);
+        SelectItem(item);
+	  }
+	}
     else if (message.GetMessage() == GUI_MSG_ITEM_SELECTED)
     {
       message.SetParam1(GetSelectedItem());
Index: xbmc/guilib/GUIBaseContainer.h
===================================================================
--- xbmc/guilib/GUIBaseContainer.h	(revision 33042)
+++ xbmc/guilib/GUIBaseContainer.h	(working copy)
@@ -184,6 +184,13 @@
   float m_scrollItemsPerFrame;
 
   static const int letter_match_timeout = 1000;
+  
+  inline int GetOffset() const { return m_offset; };
+  /*! \brief Returns the index of the first visible item
+   returns the first visible item. This will always be in the range of available items. Use GetOffset() to retrieve the first visible row in the list.
+   \sa GetOffset
+  */
+  inline int GetItemOffset() const { return CorrectOffset(GetOffset(), 0); }
 };
 
 
Index: xbmc/guilib/GUIColorManager.cpp
===================================================================
--- xbmc/guilib/GUIColorManager.cpp	(revision 33042)
+++ xbmc/guilib/GUIColorManager.cpp	(working copy)
@@ -23,7 +23,11 @@
 #include "utils/URIUtils.h"
 #include "FileSystem/SpecialProtocol.h"
 #include "SkinInfo.h"
+#include "settings/GUIWindowSettingsCategory.h"
+#include "FileSystem/File.h"
 
+using namespace XFILE;
+
 CGUIColorManager g_colorManager;
 
 CGUIColorManager::CGUIColorManager(void)
@@ -47,9 +51,19 @@
 
   // load the global color map if it exists
   TiXmlDocument xmlDoc;
-  if (xmlDoc.LoadFile(PTH_IC("special://xbmc/system/colors.xml")))
-    LoadXML(xmlDoc);
+  CStdString ThemeName(URIUtils::ReplaceExtension(g_guiSettings.GetString("lookandfeel.skintheme"), ""));
+	if (CFile::Exists("special://xbmc/emustation/themes/" + ThemeName + "/colors.xml"))
+		{
+			if (xmlDoc.LoadFile(PTH_IC("special://xbmc/emustation/themes/" + ThemeName + "/colors.xml")))
+				LoadXML(xmlDoc);
+		}
+		else
+		{
+			if (xmlDoc.LoadFile(PTH_IC("special://xbmc/emustation/themes/SIMPLE/colors.xml")))
+				LoadXML(xmlDoc);
+		}
 
+
   // first load the default color map if it exists
   CStdString path, basePath;
   URIUtils::AddFileToFolder(g_SkinInfo.GetBaseDir(), "colors", basePath);
@@ -59,7 +73,7 @@
     LoadXML(xmlDoc);
 
   // now the color map requested
-  if (colorFile.CompareNoCase("SKINDEFAULT") == 0)
+  if (colorFile.CompareNoCase("SIMPLE") == 0)
     return; // nothing to do
 
   URIUtils::AddFileToFolder(basePath, colorFile, path);
Index: xbmc/guilib/GUIControlFactory left right.cpp
===================================================================
--- xbmc/guilib/GUIControlFactory left right.cpp	(nonexistent)
+++ xbmc/guilib/GUIControlFactory left right.cpp	(working copy)
@@ -0,0 +1,1423 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "include.h"
+#include "GUIControlFactory.h"
+#include "LocalizeStrings.h"
+#include "GUIButtonControl.h"
+#include "GUIRadioButtonControl.h"
+#include "GUISpinControl.h"
+#include "GUIRSSControl.h"
+#include "GUIImage.h"
+#include "GUIBorderedImage.h"
+#include "GUILabelControl.h"
+#include "GUIEditControl.h"
+#include "GUIFadeLabelControl.h"
+#include "GUICheckMarkControl.h"
+#include "GUIToggleButtonControl.h"
+#include "GUITextBox.h"
+#include "GUIVideoControl.h"
+#include "GUIProgressControl.h"
+#include "GUISliderControl.h"
+#include "GUISelectButtonControl.h"
+#include "GUIMoverControl.h"
+#include "GUIResizeControl.h"
+#include "GUIButtonScroller.h"
+#include "GUISpinControlEx.h"
+#include "GUIVisualisationControl.h"
+#include "GUISettingsSliderControl.h"
+#include "GUIMultiImage.h"
+#include "GUIControlGroup.h"
+#include "GUIControlGroupList.h"
+#include "GUIScrollBarControl.h"
+#include "GUIListContainer.h"
+#include "GUIFixedListContainer.h"
+#include "GUIWrappingListContainer.h"
+#include "GUIPanelContainer.h"
+#include "GUIMultiSelectText.h"
+#include "GUIListLabel.h"
+#include "GUIListGroup.h"
+#include "GUIInfoManager.h"
+#include "utils/CharsetConverter.h"
+#include "input/ButtonTranslator.h"
+#include "XMLUtils.h"
+#include "GUIFontManager.h"
+#include "GUIColorManager.h"
+#include "SkinInfo.h"
+#include "settings/Settings.h"
+
+using namespace std;
+
+typedef struct
+{
+  const char* name;
+  CGUIControl::GUICONTROLTYPES type;
+} ControlMapping;
+
+static const ControlMapping controls[] =
+   {{"button",            CGUIControl::GUICONTROL_BUTTON},
+    {"checkmark",         CGUIControl::GUICONTROL_CHECKMARK},
+    {"fadelabel",         CGUIControl::GUICONTROL_FADELABEL},
+    {"image",             CGUIControl::GUICONTROL_IMAGE},
+    {"largeimage",        CGUIControl::GUICONTROL_IMAGE},
+    {"image",             CGUIControl::GUICONTROL_BORDEREDIMAGE},
+    {"label",             CGUIControl::GUICONTROL_LABEL},
+    {"label",             CGUIControl::GUICONTROL_LISTLABEL},
+    {"group",             CGUIControl::GUICONTROL_GROUP},
+    {"group",             CGUIControl::GUICONTROL_LISTGROUP},
+    {"progress",          CGUIControl::GUICONTROL_PROGRESS},
+    {"radiobutton",       CGUIControl::GUICONTROL_RADIO},
+    {"rss",               CGUIControl::GUICONTROL_RSS},
+    {"selectbutton",      CGUIControl::GUICONTROL_SELECTBUTTON},
+    {"slider",            CGUIControl::GUICONTROL_SLIDER},
+    {"sliderex",          CGUIControl::GUICONTROL_SETTINGS_SLIDER},
+    {"spincontrol",       CGUIControl::GUICONTROL_SPIN},
+    {"spincontrolex",     CGUIControl::GUICONTROL_SPINEX},
+    {"textbox",           CGUIControl::GUICONTROL_TEXTBOX},
+    {"togglebutton",      CGUIControl::GUICONTROL_TOGGLEBUTTON},
+    {"videowindow",       CGUIControl::GUICONTROL_VIDEO},
+    {"mover",             CGUIControl::GUICONTROL_MOVER},
+    {"resize",            CGUIControl::GUICONTROL_RESIZE},
+    {"buttonscroller",    CGUIControl::GUICONTROL_BUTTONBAR},
+    {"edit",              CGUIControl::GUICONTROL_EDIT},
+    {"visualisation",     CGUIControl::GUICONTROL_VISUALISATION},
+    {"karvisualisation",  CGUIControl::GUICONTROL_VISUALISATION},
+    {"multiimage",        CGUIControl::GUICONTROL_MULTI_IMAGE},
+    {"grouplist",         CGUIControl::GUICONTROL_GROUPLIST},
+    {"scrollbar",         CGUIControl::GUICONTROL_SCROLLBAR},
+    {"multiselect",       CGUIControl::GUICONTROL_MULTISELECT},
+    {"list",              CGUIControl::GUICONTAINER_LIST},
+    {"wraplist",          CGUIControl::GUICONTAINER_WRAPLIST},
+    {"fixedlist",         CGUIControl::GUICONTAINER_FIXEDLIST},
+    {"panel",             CGUIControl::GUICONTAINER_PANEL}};
+
+CGUIControl::GUICONTROLTYPES CGUIControlFactory::TranslateControlType(const CStdString &type)
+{
+  for (unsigned int i = 0; i < sizeof(controls) / sizeof(controls[0]); ++i)
+    if (0 == type.CompareNoCase(controls[i].name))
+      return controls[i].type;
+  return CGUIControl::GUICONTROL_UNKNOWN;
+}
+
+CStdString CGUIControlFactory::TranslateControlType(CGUIControl::GUICONTROLTYPES type)
+{
+  for (unsigned int i = 0; i < sizeof(controls) / sizeof(controls[0]); ++i)
+    if (type == controls[i].type)
+      return controls[i].name;
+  return "";
+}
+
+CGUIControlFactory::CGUIControlFactory(void)
+{}
+
+CGUIControlFactory::~CGUIControlFactory(void)
+{}
+
+bool CGUIControlFactory::GetIntRange(const TiXmlNode* pRootNode, const char* strTag, int& iMinValue, int& iMaxValue, int& iIntervalValue)
+{
+  const TiXmlNode* pNode = pRootNode->FirstChild(strTag);
+  if (!pNode || !pNode->FirstChild()) return false;
+  iMinValue = atoi(pNode->FirstChild()->Value());
+  const char* maxValue = strchr(pNode->FirstChild()->Value(), ',');
+  if (maxValue)
+  {
+    maxValue++;
+    iMaxValue = atoi(maxValue);
+
+    const char* intervalValue = strchr(maxValue, ',');
+    if (intervalValue)
+    {
+      intervalValue++;
+      iIntervalValue = atoi(intervalValue);
+    }
+  }
+
+  return true;
+}
+
+bool CGUIControlFactory::GetFloatRange(const TiXmlNode* pRootNode, const char* strTag, float& fMinValue, float& fMaxValue, float& fIntervalValue)
+{
+  const TiXmlNode* pNode = pRootNode->FirstChild(strTag);
+  if (!pNode || !pNode->FirstChild()) return false;
+  fMinValue = (float)atof(pNode->FirstChild()->Value());
+  const char* maxValue = strchr(pNode->FirstChild()->Value(), ',');
+  if (maxValue)
+  {
+    maxValue++;
+    fMaxValue = (float)atof(maxValue);
+
+    const char* intervalValue = strchr(maxValue, ',');
+    if (intervalValue)
+    {
+      intervalValue++;
+      fIntervalValue = (float)atof(intervalValue);
+    }
+  }
+
+  return true;
+}
+
+bool CGUIControlFactory::GetFloat(const TiXmlNode* pRootNode, const char* strTag, float& value)
+{
+  const TiXmlNode* pNode = pRootNode->FirstChild(strTag );
+  if (!pNode || !pNode->FirstChild()) return false;
+  return g_SkinInfo.ResolveConstant(pNode->FirstChild()->Value(), value);
+}
+
+bool CGUIControlFactory::GetUnsigned(const TiXmlNode* pRootNode, const char* strTag, unsigned int &value)
+{
+  const TiXmlNode* pNode = pRootNode->FirstChild(strTag );
+  if (!pNode || !pNode->FirstChild()) return false;
+  return g_SkinInfo.ResolveConstant(pNode->FirstChild()->Value(), value);
+}
+
+bool CGUIControlFactory::GetDimension(const TiXmlNode *pRootNode, const char* strTag, float &value, float &min)
+{
+  const TiXmlElement* pNode = pRootNode->FirstChildElement(strTag);
+  if (!pNode || !pNode->FirstChild()) return false;
+  if (0 == strnicmp("auto", pNode->FirstChild()->Value(), 4))
+  { // auto-width - at least min must be set
+    g_SkinInfo.ResolveConstant(pNode->Attribute("max"), value);
+    g_SkinInfo.ResolveConstant(pNode->Attribute("min"), min);
+    if (!min) min = 1;
+    return true;
+  }
+  return g_SkinInfo.ResolveConstant(pNode->FirstChild()->Value(), value);
+}
+
+bool CGUIControlFactory::GetPath(const TiXmlNode* pRootNode, const char* strTag, CStdString& strStringPath)
+{
+  const TiXmlNode* pNode = pRootNode->FirstChild(strTag );
+  if (!pNode) return false;
+  strStringPath = pNode->FirstChild() ? pNode->FirstChild()->Value() : "";
+  strStringPath.Replace('/', '\\');
+  return true;
+}
+
+bool CGUIControlFactory::GetAspectRatio(const TiXmlNode* pRootNode, const char* strTag, CAspectRatio &aspect)
+{
+  CStdString ratio;
+  const TiXmlElement *node = pRootNode->FirstChildElement(strTag);
+  if (!node || !node->FirstChild())
+    return false;
+
+  ratio = node->FirstChild()->Value();
+  if (ratio.CompareNoCase("keep") == 0) aspect.ratio = CAspectRatio::AR_KEEP;
+  else if (ratio.CompareNoCase("scale") == 0) aspect.ratio = CAspectRatio::AR_SCALE;
+  else if (ratio.CompareNoCase("center") == 0) aspect.ratio = CAspectRatio::AR_CENTER;
+  else if (ratio.CompareNoCase("stretch") == 0) aspect.ratio = CAspectRatio::AR_STRETCH;
+
+  const char *attribute = node->Attribute("align");
+  if (attribute)
+  {
+    CStdString align(attribute);
+    if (align.CompareNoCase("center") == 0) aspect.align = ASPECT_ALIGN_CENTER | (aspect.align & ASPECT_ALIGNY_MASK);
+    else if (align.CompareNoCase("right") == 0) aspect.align = ASPECT_ALIGN_RIGHT | (aspect.align & ASPECT_ALIGNY_MASK);
+    else if (align.CompareNoCase("left") == 0) aspect.align = ASPECT_ALIGN_LEFT | (aspect.align & ASPECT_ALIGNY_MASK);
+  }
+  attribute = node->Attribute("aligny");
+  if (attribute)
+  {
+    CStdString align(attribute);
+    if (align.CompareNoCase("center") == 0) aspect.align = ASPECT_ALIGNY_CENTER | (aspect.align & ASPECT_ALIGN_MASK);
+    else if (align.CompareNoCase("bottom") == 0) aspect.align = ASPECT_ALIGNY_BOTTOM | (aspect.align & ASPECT_ALIGN_MASK);
+    else if (align.CompareNoCase("top") == 0) aspect.align = ASPECT_ALIGNY_TOP | (aspect.align & ASPECT_ALIGN_MASK);
+  }
+  attribute = node->Attribute("scalediffuse");
+  if (attribute)
+  {
+    CStdString scale(attribute);
+    if (scale.CompareNoCase("true") == 0 || scale.CompareNoCase("yes") == 0)
+      aspect.scaleDiffuse = true;
+    else
+      aspect.scaleDiffuse = false;
+  }
+  return true;
+}
+
+bool CGUIControlFactory::GetInfoTexture(const TiXmlNode* pRootNode, const char* strTag, CTextureInfo &image, CGUIInfoLabel &info, int parentID)
+{
+  GetTexture(pRootNode, strTag, image);
+  image.filename = "";
+  GetInfoLabel(pRootNode, strTag, info, parentID);
+  return true;
+}
+
+bool CGUIControlFactory::GetTexture(const TiXmlNode* pRootNode, const char* strTag, CTextureInfo &image)
+{
+  const TiXmlElement* pNode = pRootNode->FirstChildElement(strTag);
+  if (!pNode) return false;
+  const char *border = pNode->Attribute("border");
+  if (border)
+    GetRectFromString(border, image.border);
+  image.orientation = 0;
+  const char *flipX = pNode->Attribute("flipx");
+  if (flipX && strcmpi(flipX, "true") == 0) image.orientation = 1;
+  const char *flipY = pNode->Attribute("flipy");
+  if (flipY && strcmpi(flipY, "true") == 0) image.orientation = 3 - image.orientation;  // either 3 or 2
+  image.diffuse = pNode->Attribute("diffuse");
+  const char *background = pNode->Attribute("background");
+  if (background && strnicmp(background, "true", 4) == 0)
+    image.useLarge = true;
+  image.filename = (pNode->FirstChild() && pNode->FirstChild()->ValueStr() != "-") ? pNode->FirstChild()->Value() : "";
+  return true;
+}
+
+void CGUIControlFactory::GetRectFromString(const CStdString &string, FRECT &rect)
+{
+  // format is rect="left,right,top,bottom"
+  CStdStringArray strRect;
+  StringUtils::SplitString(string, ",", strRect);
+  if (strRect.size() == 1)
+  {
+    g_SkinInfo.ResolveConstant(strRect[0], rect.left);
+    rect.top = rect.left;
+    rect.right = rect.left;
+    rect.bottom = rect.left;
+  }
+  else if (strRect.size() == 4)
+  {
+    g_SkinInfo.ResolveConstant(strRect[0], rect.left);
+    g_SkinInfo.ResolveConstant(strRect[1], rect.top);
+    g_SkinInfo.ResolveConstant(strRect[2], rect.right);
+    g_SkinInfo.ResolveConstant(strRect[3], rect.bottom);
+  }
+}
+
+bool CGUIControlFactory::GetAlignment(const TiXmlNode* pRootNode, const char* strTag, uint32_t& alignment)
+{
+  const TiXmlNode* pNode = pRootNode->FirstChild(strTag);
+  if (!pNode || !pNode->FirstChild()) return false;
+
+  CStdString strAlign = pNode->FirstChild()->Value();
+  if (strAlign == "right" || strAlign == "bottom") alignment = XBFONT_RIGHT;
+  else if (strAlign == "center") alignment = XBFONT_CENTER_X;
+  else if (strAlign == "justify") alignment = XBFONT_JUSTIFIED;
+  else alignment = XBFONT_LEFT;
+  return true;
+}
+
+bool CGUIControlFactory::GetAlignmentY(const TiXmlNode* pRootNode, const char* strTag, uint32_t& alignment)
+{
+  const TiXmlNode* pNode = pRootNode->FirstChild(strTag );
+  if (!pNode || !pNode->FirstChild())
+  {
+    return false;
+  }
+
+  CStdString strAlign = pNode->FirstChild()->Value();
+
+  alignment = 0;
+  if (strAlign == "center")
+  {
+    alignment = XBFONT_CENTER_Y;
+  }
+
+  return true;
+}
+
+bool CGUIControlFactory::GetConditionalVisibility(const TiXmlNode* control, int &condition, CGUIInfoBool &allowHiddenFocus)
+{
+  const TiXmlElement* node = control->FirstChildElement("visible");
+  if (!node) return false;
+  vector<CStdString> conditions;
+  while (node)
+  {
+    const char *hidden = node->Attribute("allowhiddenfocus");
+    if (hidden)
+      allowHiddenFocus.Parse(hidden);
+    // add to our condition string
+    if (!node->NoChildren())
+      conditions.push_back(node->FirstChild()->Value());
+    node = node->NextSiblingElement("visible");
+  }
+  if (!conditions.size())
+    return false;
+  if (conditions.size() == 1)
+    condition = g_infoManager.TranslateString(conditions[0]);
+  else
+  { // multiple conditions should be anded together
+    CStdString conditionString = "[";
+    for (unsigned int i = 0; i < conditions.size() - 1; i++)
+      conditionString += conditions[i] + "] + [";
+    conditionString += conditions[conditions.size() - 1] + "]";
+    condition = g_infoManager.TranslateString(conditionString);
+  }
+  return (condition != 0);
+}
+
+bool CGUIControlFactory::GetCondition(const TiXmlNode *control, const char *tag, int &condition)
+{
+  CStdString condString;
+  if (XMLUtils::GetString(control, tag, condString))
+  {
+    condition = g_infoManager.TranslateString(condString);
+    return true;
+  }
+  return false;
+}
+
+bool CGUIControlFactory::GetConditionalVisibility(const TiXmlNode *control, int &condition)
+{
+  CGUIInfoBool allowHiddenFocus;
+  return GetConditionalVisibility(control, condition, allowHiddenFocus);
+}
+
+bool CGUIControlFactory::GetAnimations(const TiXmlNode *control, const FRECT &rect, vector<CAnimation> &animations)
+{
+  const TiXmlElement* node = control->FirstChildElement("animation");
+  bool ret = false;
+  if (node)
+    animations.clear();
+  while (node)
+  {
+    ret = true;
+    if (node->FirstChild())
+    {
+      CAnimation anim;
+      anim.Create(node, rect);
+      animations.push_back(anim);
+      if (strcmpi(node->FirstChild()->Value(), "VisibleChange") == 0)
+      { // add the hidden one as well
+        TiXmlElement hidden(*node);
+        hidden.FirstChild()->SetValue("hidden");
+        const char *start = hidden.Attribute("start");
+        const char *end = hidden.Attribute("end");
+        if (start && end)
+        {
+          CStdString temp = end;
+          hidden.SetAttribute("end", start);
+          hidden.SetAttribute("start", temp.c_str());
+        }
+        else if (start)
+          hidden.SetAttribute("end", start);
+        else if (end)
+          hidden.SetAttribute("start", end);
+        CAnimation anim2;
+        anim2.Create(&hidden, rect);
+        animations.push_back(anim2);
+      }
+    }
+    node = node->NextSiblingElement("animation");
+  }
+  return ret;
+}
+
+bool CGUIControlFactory::GetActions(const TiXmlNode* pRootNode, const char* strTag, CGUIAction& action)
+{
+  action.m_actions.clear();
+  const TiXmlElement* pElement = pRootNode->FirstChildElement(strTag);
+  while (pElement)
+  {
+    if (pElement->FirstChild())
+    {
+      CGUIAction::cond_action_pair pair;
+      pair.condition = pElement->Attribute("condition");
+      pair.action = pElement->FirstChild()->Value();
+      action.m_actions.push_back(pair);
+    }
+    pElement = pElement->NextSiblingElement(strTag);
+  }
+  return action.m_actions.size() > 0;
+}
+
+bool CGUIControlFactory::GetHitRect(const TiXmlNode *control, CRect &rect)
+{
+  const TiXmlElement* node = control->FirstChildElement("hitrect");
+  if (node)
+  {
+    if (node->Attribute("x")) g_SkinInfo.ResolveConstant(node->Attribute("x"), rect.x1);
+    if (node->Attribute("y")) g_SkinInfo.ResolveConstant(node->Attribute("y"), rect.y1);
+    if (node->Attribute("w"))
+    {
+      g_SkinInfo.ResolveConstant(node->Attribute("w"), rect.x2);
+      rect.x2 += rect.x1;
+    }
+    if (node->Attribute("h"))
+    {
+      g_SkinInfo.ResolveConstant(node->Attribute("h"), rect.y2);
+      rect.y2 += rect.y1;
+    }
+    return true;
+  }
+  return false;
+}
+
+bool CGUIControlFactory::GetColor(const TiXmlNode *control, const char *strTag, color_t &value)
+{
+  const TiXmlElement* node = control->FirstChildElement(strTag);
+  if (node && node->FirstChild())
+  {
+    value = g_colorManager.GetColor(node->FirstChild()->Value());
+    return true;
+  }
+  return false;
+}
+
+bool CGUIControlFactory::GetInfoColor(const TiXmlNode *control, const char *strTag, CGUIInfoColor &value,int parentID)
+{
+  const TiXmlElement* node = control->FirstChildElement(strTag);
+  if (node && node->FirstChild())
+  {
+    value.Parse(node->FirstChild()->Value(), parentID);
+    return true;
+  }
+  return false;
+}
+
+void CGUIControlFactory::GetInfoLabel(const TiXmlNode *pControlNode, const CStdString &labelTag, CGUIInfoLabel &infoLabel, int parentID)
+{
+  vector<CGUIInfoLabel> labels;
+  GetInfoLabels(pControlNode, labelTag, labels, parentID);
+  if (labels.size())
+    infoLabel = labels[0];
+}
+
+bool CGUIControlFactory::GetInfoLabelFromElement(const TiXmlElement *element, CGUIInfoLabel &infoLabel, int parentID)
+{
+  if (!element || !element->FirstChild())
+    return false;
+
+  CStdString label = element->FirstChild()->Value();
+  if (label.IsEmpty() || label == "-")
+    return false;
+
+  CStdString fallback = element->Attribute("fallback");
+  if (StringUtils::IsNaturalNumber(label))
+    label = g_localizeStrings.Get(atoi(label));
+  else // we assume the skin xml's aren't encoded as UTF-8
+    g_charsetConverter.unknownToUTF8(label);
+  if (StringUtils::IsNaturalNumber(fallback))
+    fallback = g_localizeStrings.Get(atoi(fallback));
+  else
+    g_charsetConverter.unknownToUTF8(fallback);
+  infoLabel.SetLabel(label, fallback, parentID);
+  return true;
+}
+
+void CGUIControlFactory::GetInfoLabels(const TiXmlNode *pControlNode, const CStdString &labelTag, vector<CGUIInfoLabel> &infoLabels, int parentID)
+{
+  // we can have the following infolabels:
+  // 1.  <number>1234</number> -> direct number
+  // 2.  <label>number</label> -> lookup in localizestrings
+  // 3.  <label fallback="blah">$LOCALIZE(blah) $INFO(blah)</label> -> infolabel with given fallback
+  // 4.  <info>ListItem.Album</info> (uses <label> as fallback)
+  int labelNumber = 0;
+  if (XMLUtils::GetInt(pControlNode, "number", labelNumber))
+  {
+    CStdString label;
+    label.Format("%i", labelNumber);
+    infoLabels.push_back(CGUIInfoLabel(label));
+    return; // done
+  }
+  const TiXmlElement *labelNode = pControlNode->FirstChildElement(labelTag);
+  while (labelNode)
+  {
+    CGUIInfoLabel label;
+    if (GetInfoLabelFromElement(labelNode, label, parentID))
+      infoLabels.push_back(label);
+    labelNode = labelNode->NextSiblingElement(labelTag);
+  }
+  const TiXmlNode *infoNode = pControlNode->FirstChild("info");
+  if (infoNode)
+  { // <info> nodes override <label>'s (backward compatibility)
+    CStdString fallback;
+    if (infoLabels.size())
+      fallback = infoLabels[0].GetLabel(0);
+    infoLabels.clear();
+    while (infoNode)
+    {
+      if (infoNode->FirstChild())
+      {
+        CStdString info;
+        info.Format("$INFO[%s]", infoNode->FirstChild()->Value());
+        infoLabels.push_back(CGUIInfoLabel(info, fallback, parentID));
+      }
+      infoNode = infoNode->NextSibling("info");
+    }
+  }
+}
+
+// Convert a string to a GUI label, by translating/parsing the label for localisable strings
+CStdString CGUIControlFactory::FilterLabel(const CStdString &label)
+{
+  CStdString viewLabel = label;
+  if (StringUtils::IsNaturalNumber(viewLabel))
+    viewLabel = g_localizeStrings.Get(atoi(label));
+  else
+    g_charsetConverter.unknownToUTF8(viewLabel);
+  return viewLabel;
+}
+
+bool CGUIControlFactory::GetString(const TiXmlNode* pRootNode, const char *strTag, CStdString &text)
+{
+  if (!XMLUtils::GetString(pRootNode, strTag, text))
+    return false;
+  if (text == "-")
+    text.Empty();
+  if (StringUtils::IsNaturalNumber(text))
+    text = g_localizeStrings.Get(atoi(text.c_str()));
+  else
+    g_charsetConverter.unknownToUTF8(text);
+  return true;
+}
+
+CStdString CGUIControlFactory::GetType(const TiXmlElement *pControlNode)
+{
+  CStdString type;
+  const char *szType = pControlNode->Attribute("type");
+  if (szType)
+    type = szType;
+  else  // backward compatibility - not desired
+    XMLUtils::GetString(pControlNode, "type", type);
+  return type;
+}
+
+CGUIControl* CGUIControlFactory::Create(int parentID, const FRECT &rect, TiXmlElement* pControlNode, bool insideContainer)
+{
+  // resolve any <include> tag's in this control
+  g_SkinInfo.ResolveIncludes(pControlNode);
+
+  // get the control type
+  CStdString strType = GetType(pControlNode);
+  CGUIControl::GUICONTROLTYPES type = TranslateControlType(strType);
+
+  // resolve again with strType set so that <default> tags are added
+  g_SkinInfo.ResolveIncludes(pControlNode, strType);
+
+  int id = 0;
+  float posX = 0, posY = 0;
+  float width = 0, height = 0;
+  float minWidth = 0;
+
+  CGUIAction leftActions, rightActions, upActions, downActions, backActions, nextActions, prevActions;
+
+  int pageControl = 0;
+  CGUIInfoColor colorDiffuse(0xFFFFFFFF);
+  int defaultControl = 0;
+  bool  defaultAlways = false;
+  CStdString strTmp;
+  int singleInfo = 0;
+  CStdString strLabel;
+  int iUrlSet=0;
+  int iToggleSelect;
+
+  float spinWidth = 16;
+  float spinHeight = 16;
+  float spinPosX = 0, spinPosY = 0;
+  float checkWidth = 0, checkHeight = 0;
+  CStdString strSubType;
+  int iType = SPIN_CONTROL_TYPE_TEXT;
+  int iMin = 0;
+  int iMax = 100;
+  int iInterval = 1;
+  float fMin = 0.0f;
+  float fMax = 1.0f;
+  float fInterval = 0.1f;
+  bool bReverse = true;
+  bool bReveal = false;
+  CTextureInfo textureBackground, textureLeft, textureRight, textureMid, textureOverlay;
+  CTextureInfo textureNib, textureNibFocus, textureBar, textureBarFocus;
+  CTextureInfo textureLeftFocus, textureRightFocus;
+  CTextureInfo textureUp, textureDown;
+  CTextureInfo textureUpFocus, textureDownFocus;
+  CTextureInfo texture, borderTexture;
+  CGUIInfoLabel textureFile;
+  CTextureInfo textureCheckMark, textureCheckMarkNF;
+  CTextureInfo textureFocus, textureNoFocus;
+  CTextureInfo textureAltFocus, textureAltNoFocus;
+  CTextureInfo textureRadioOn, textureRadioOff;
+  CTextureInfo imageNoFocus, imageFocus;
+  CGUIInfoLabel texturePath;
+  FRECT borderSize = { 0, 0, 0, 0};
+
+  float sliderWidth = 150, sliderHeight = 16;
+  CPoint offset;
+
+  bool bHasPath = false;
+  CGUIAction clickActions;
+  CGUIAction altclickActions;
+  CGUIAction focusActions;
+  CGUIAction unfocusActions;
+  CGUIAction textChangeActions;
+  CStdString strTitle = "";
+  CStdString strRSSTags = "";
+
+  DWORD dwBuddyControlID = 0;
+  int iNumSlots = 7;
+  float buttonGap = 5;
+  int iDefaultSlot = 2;
+  int iMovementRange = 0;
+  bool bHorizontal = false;
+  int iAlpha = 0;
+  bool bWrapAround = true;
+  bool bSmoothScrolling = true;
+  CAspectRatio aspect;
+#ifdef PRE_SKIN_VERSION_9_10_COMPATIBILITY
+  if (insideContainer)  // default for inside containers is keep
+    aspect.ratio = CAspectRatio::AR_KEEP;
+#endif
+
+  int iVisibleCondition = 0;
+  CGUIInfoBool allowHiddenFocus(false);
+  int enableCondition = 0;
+
+  vector<CAnimation> animations;
+
+  bool bScrollLabel = false;
+  bool bPulse = true;
+  unsigned int timePerImage = 0;
+  unsigned int fadeTime = 0;
+  unsigned int timeToPauseAtEnd = 0;
+  bool randomized = false;
+  bool loop = true;
+  bool wrapMultiLine = false;
+  ORIENTATION orientation = VERTICAL;
+  bool showOnePage = true;
+  bool scrollOut = true;
+  int preloadItems = 0;
+
+  CLabelInfo labelInfo;
+  CLabelInfo spinInfo;
+
+  CGUIInfoColor textColor3;
+  CGUIInfoColor headlineColor;
+
+  float radioWidth = 0;
+  float radioHeight = 0;
+  float radioPosX = 0;
+  float radioPosY = 0;
+
+  CStdString altLabel;
+  CStdString strLabel2;
+
+  int focusPosition = 0;
+  int scrollTime = 200;
+  bool useControlCoords = false;
+  bool renderFocusedLast = false;
+
+  CRect hitRect;
+  CPoint camera;
+  bool   hasCamera = false;
+  bool resetOnLabelChange = true;
+  bool bPassword = false;
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Read control properties from XML
+  //
+
+  if (!pControlNode->Attribute("id", (int*) &id))
+    XMLUtils::GetInt(pControlNode, "id", (int&) id);       // backward compatibility - not desired
+  // TODO: Perhaps we should check here whether id is valid for focusable controls
+  // such as buttons etc.  For labels/fadelabels/images it does not matter
+
+  GetFloat(pControlNode, "posx", posX);
+  GetFloat(pControlNode, "posy", posY);
+  GetFloat(pControlNode, "left", posX);
+  GetFloat(pControlNode, "top", posY);
+  // Convert these from relative coords
+  CStdString pos;
+  XMLUtils::GetString(pControlNode, "posx", pos);
+  if (pos.Right(1) == "r")
+    posX = (rect.right - rect.left) - posX;
+  XMLUtils::GetString(pControlNode, "posy", pos);
+  if (pos.Right(1) == "r")
+    posY = (rect.bottom - rect.top) - posY;
+  XMLUtils::GetString(pControlNode, "left", pos);
+  if (pos.Right(1) == "r")
+    posX = (rect.right - rect.left) - posX;
+  XMLUtils::GetString(pControlNode, "top", pos);
+  if (pos.Right(1) == "r")
+    posY = (rect.bottom - rect.top) - posY;
+
+  GetDimension(pControlNode, "width", width, minWidth);
+  GetFloat(pControlNode, "height", height);
+  GetFloat(pControlNode, "offsetx", offset.x);
+  GetFloat(pControlNode, "offsety", offset.y);
+
+  // adjust width and height accordingly for groups.  Groups should
+  // take the width/height of the parent (adjusted for positioning)
+  // if none is defined.
+  if (type == CGUIControl::GUICONTROL_GROUP || type == CGUIControl::GUICONTROL_GROUPLIST)
+  {
+    if (!width)
+      width = max(rect.right - posX, 0.0f);
+    if (!height)
+      height = max(rect.bottom - posY, 0.0f);
+  }
+
+  hitRect.SetRect(posX, posY, posX + width, posY + height);
+  GetHitRect(pControlNode, hitRect);
+
+  if (!GetActions(pControlNode, "onup",    upActions))    upActions.SetNavigation(id);
+  if (!GetActions(pControlNode, "ondown",  downActions))  downActions.SetNavigation(id);
+  if (!GetActions(pControlNode, "onleft",  leftActions))  leftActions.SetNavigation(id);
+  if (!GetActions(pControlNode, "onright", rightActions)) rightActions.SetNavigation(id);
+  if (!GetActions(pControlNode, "onnext",  nextActions))  nextActions.SetNavigation(id);
+  if (!GetActions(pControlNode, "onprev",  prevActions))  prevActions.SetNavigation(id);
+  GetActions(pControlNode, "onback",  backActions);
+
+  if (XMLUtils::GetInt(pControlNode, "defaultcontrol", defaultControl))
+  {
+    const char *always = pControlNode->FirstChildElement("defaultcontrol")->Attribute("always");
+    if (always && strnicmp(always, "true", 4) == 0)
+      defaultAlways = true;
+  }
+  XMLUtils::GetInt(pControlNode, "pagecontrol", pageControl);
+
+  GetInfoColor(pControlNode, "colordiffuse", colorDiffuse, parentID);
+
+  GetConditionalVisibility(pControlNode, iVisibleCondition, allowHiddenFocus);
+  GetCondition(pControlNode, "enable", enableCondition);
+
+  // note: animrect here uses .right and .bottom as width and height respectively (nonstandard)
+  FRECT animRect = { posX, posY, width, height };
+  GetAnimations(pControlNode, animRect, animations);
+
+  GetInfoColor(pControlNode, "textcolor", labelInfo.textColor, parentID);
+  GetInfoColor(pControlNode, "focusedcolor", labelInfo.focusedColor, parentID);
+  GetInfoColor(pControlNode, "disabledcolor", labelInfo.disabledColor, parentID);
+  GetInfoColor(pControlNode, "shadowcolor", labelInfo.shadowColor, parentID);
+  GetInfoColor(pControlNode, "selectedcolor", labelInfo.selectedColor, parentID);
+  GetFloat(pControlNode, "textoffsetx", labelInfo.offsetX);
+  GetFloat(pControlNode, "textoffsety", labelInfo.offsetY);
+  int angle = 0;  // use the negative angle to compensate for our vertically flipped cartesian plane
+  if (XMLUtils::GetInt(pControlNode, "angle", angle)) labelInfo.angle = (float)-angle;
+  CStdString strFont;
+  if (XMLUtils::GetString(pControlNode, "font", strFont))
+    labelInfo.font = g_fontManager.GetFont(strFont);
+  GetAlignment(pControlNode, "align", labelInfo.align);
+  uint32_t alignY = 0;
+  if (GetAlignmentY(pControlNode, "aligny", alignY))
+    labelInfo.align |= alignY;
+  if (GetFloat(pControlNode, "textwidth", labelInfo.width))
+    labelInfo.align |= XBFONT_TRUNCATED;
+
+  GetActions(pControlNode, "onclick", clickActions);
+  GetActions(pControlNode, "ontextchange", textChangeActions);
+  GetActions(pControlNode, "onfocus", focusActions);
+  GetActions(pControlNode, "onunfocus", unfocusActions);
+  focusActions.m_sendThreadMessages = unfocusActions.m_sendThreadMessages = true;
+  GetActions(pControlNode, "altclick", altclickActions);
+
+  CStdString infoString;
+  if (XMLUtils::GetString(pControlNode, "info", infoString))
+    singleInfo = g_infoManager.TranslateString(infoString);
+
+  GetTexture(pControlNode, "texturefocus", textureFocus);
+  GetTexture(pControlNode, "texturenofocus", textureNoFocus);
+  GetTexture(pControlNode, "alttexturefocus", textureAltFocus);
+  GetTexture(pControlNode, "alttexturenofocus", textureAltNoFocus);
+  CStdString strToggleSelect;
+  XMLUtils::GetString(pControlNode, "usealttexture", strToggleSelect);
+  XMLUtils::GetString(pControlNode, "selected", strToggleSelect);
+  iToggleSelect = g_infoManager.TranslateString(strToggleSelect);
+
+  XMLUtils::GetBoolean(pControlNode, "haspath", bHasPath);
+
+  GetTexture(pControlNode, "textureup", textureUp);
+  GetTexture(pControlNode, "texturedown", textureDown);
+  GetTexture(pControlNode, "textureupfocus", textureUpFocus);
+  GetTexture(pControlNode, "texturedownfocus", textureDownFocus);
+
+  GetTexture(pControlNode, "textureleft", textureLeft);
+  GetTexture(pControlNode, "textureright", textureRight);
+  GetTexture(pControlNode, "textureleftfocus", textureLeftFocus);
+  GetTexture(pControlNode, "texturerightfocus", textureRightFocus);
+
+  GetInfoColor(pControlNode, "spincolor", spinInfo.textColor, parentID);
+  if (XMLUtils::GetString(pControlNode, "spinfont", strFont))
+    spinInfo.font = g_fontManager.GetFont(strFont);
+  if (!spinInfo.font) spinInfo.font = labelInfo.font;
+
+  GetFloat(pControlNode, "spinwidth", spinWidth);
+  GetFloat(pControlNode, "spinheight", spinHeight);
+  GetFloat(pControlNode, "spinposx", spinPosX);
+  GetFloat(pControlNode, "spinposy", spinPosY);
+  GetFloat(pControlNode, "spinleft", spinPosX);
+  GetFloat(pControlNode, "spinright", spinPosY);
+
+  GetFloat(pControlNode, "markwidth", checkWidth);
+  GetFloat(pControlNode, "markheight", checkHeight);
+  GetFloat(pControlNode, "sliderwidth", sliderWidth);
+  GetFloat(pControlNode, "sliderheight", sliderHeight);
+  GetTexture(pControlNode, "texturecheckmark", textureCheckMark);
+  GetTexture(pControlNode, "texturecheckmarknofocus", textureCheckMarkNF);
+  GetTexture(pControlNode, "textureradiofocus", textureRadioOn);    // backward compatibility
+  GetTexture(pControlNode, "textureradionofocus", textureRadioOff);
+  GetTexture(pControlNode, "textureradioon", textureRadioOn);
+  GetTexture(pControlNode, "textureradiooff", textureRadioOff);
+
+  GetTexture(pControlNode, "texturesliderbackground", textureBackground);
+  GetTexture(pControlNode, "texturesliderbar", textureBar);
+  GetTexture(pControlNode, "texturesliderbarfocus", textureBarFocus);
+  GetTexture(pControlNode, "textureslidernib", textureNib);
+  GetTexture(pControlNode, "textureslidernibfocus", textureNibFocus);
+
+  XMLUtils::GetString(pControlNode, "title", strTitle);
+  XMLUtils::GetString(pControlNode, "tagset", strRSSTags);
+  GetInfoColor(pControlNode, "headlinecolor", headlineColor, parentID);
+  GetInfoColor(pControlNode, "titlecolor", textColor3, parentID);
+
+  if (XMLUtils::GetString(pControlNode, "subtype", strSubType))
+  {
+    strSubType.ToLower();
+
+    if ( strSubType == "int")
+      iType = SPIN_CONTROL_TYPE_INT;
+    else if ( strSubType == "page")
+      iType = SPIN_CONTROL_TYPE_PAGE;
+    else if ( strSubType == "float")
+      iType = SPIN_CONTROL_TYPE_FLOAT;
+    else
+      iType = SPIN_CONTROL_TYPE_TEXT;
+  }
+
+  if (!GetIntRange(pControlNode, "range", iMin, iMax, iInterval))
+  {
+    GetFloatRange(pControlNode, "range", fMin, fMax, fInterval);
+  }
+
+  XMLUtils::GetBoolean(pControlNode, "reverse", bReverse);
+  XMLUtils::GetBoolean(pControlNode, "reveal", bReveal);
+
+  GetTexture(pControlNode, "texturebg", textureBackground);
+  GetTexture(pControlNode, "lefttexture", textureLeft);
+  GetTexture(pControlNode, "midtexture", textureMid);
+  GetTexture(pControlNode, "righttexture", textureRight);
+  GetTexture(pControlNode, "overlaytexture", textureOverlay);
+
+  // the <texture> tag can be overridden by the <info> tag
+  GetInfoTexture(pControlNode, "texture", texture, textureFile, parentID);
+
+  GetTexture(pControlNode, "bordertexture", borderTexture);
+
+  GetTexture(pControlNode, "imagefolder", imageNoFocus);
+  GetTexture(pControlNode, "imagefolderfocus", imageFocus);
+
+  // fade label can have a whole bunch, but most just have one
+  vector<CGUIInfoLabel> infoLabels;
+  GetInfoLabels(pControlNode, "label", infoLabels, parentID);
+
+  GetString(pControlNode, "label", strLabel);
+  GetString(pControlNode, "altlabel", altLabel);
+  GetString(pControlNode, "label2", strLabel2);
+
+  XMLUtils::GetBoolean(pControlNode, "wrapmultiline", wrapMultiLine);
+  XMLUtils::GetInt(pControlNode,"urlset",iUrlSet);
+
+  // stuff for button scroller
+  if ( XMLUtils::GetString(pControlNode, "orientation", strTmp) )
+  {
+    if (strTmp.ToLower() == "horizontal")
+    {
+      bHorizontal = true;
+      orientation = HORIZONTAL;
+    }
+  }
+  GetFloat(pControlNode, "buttongap", buttonGap);
+  GetFloat(pControlNode, "itemgap", buttonGap);
+  XMLUtils::GetInt(pControlNode, "numbuttons", iNumSlots);
+  XMLUtils::GetInt(pControlNode, "movement", iMovementRange);
+  XMLUtils::GetInt(pControlNode, "defaultbutton", iDefaultSlot);
+  XMLUtils::GetInt(pControlNode, "alpha", iAlpha);
+  XMLUtils::GetBoolean(pControlNode, "wraparound", bWrapAround);
+  XMLUtils::GetBoolean(pControlNode, "smoothscrolling", bSmoothScrolling);
+  GetAspectRatio(pControlNode, "aspectratio", aspect);
+  XMLUtils::GetBoolean(pControlNode, "scroll", bScrollLabel);
+  XMLUtils::GetBoolean(pControlNode,"pulseonselect", bPulse);
+
+  GetInfoTexture(pControlNode, "imagepath", texture, texturePath, parentID);
+
+  GetUnsigned(pControlNode,"timeperimage", timePerImage);
+  GetUnsigned(pControlNode,"fadetime", fadeTime);
+  GetUnsigned(pControlNode,"pauseatend", timeToPauseAtEnd);
+  XMLUtils::GetBoolean(pControlNode, "randomize", randomized);
+  XMLUtils::GetBoolean(pControlNode, "loop", loop);
+  XMLUtils::GetBoolean(pControlNode, "scrollout", scrollOut);
+
+  GetFloat(pControlNode, "radiowidth", radioWidth);
+  GetFloat(pControlNode, "radioheight", radioHeight);
+  GetFloat(pControlNode, "radioposx", radioPosX);
+  GetFloat(pControlNode, "radioposy", radioPosY);
+  GetFloat(pControlNode, "radioleft", radioPosX);
+  GetFloat(pControlNode, "radiotop", radioPosY);
+  CStdString borderStr;
+  if (XMLUtils::GetString(pControlNode, "bordersize", borderStr))
+    GetRectFromString(borderStr, borderSize);
+
+  XMLUtils::GetBoolean(pControlNode, "showonepage", showOnePage);
+  XMLUtils::GetInt(pControlNode, "focusposition", focusPosition);
+  XMLUtils::GetInt(pControlNode, "scrolltime", scrollTime);
+  XMLUtils::GetInt(pControlNode, "preloaditems", preloadItems, 0, 2);
+
+  XMLUtils::GetBoolean(pControlNode, "usecontrolcoords", useControlCoords);
+  XMLUtils::GetBoolean(pControlNode, "renderfocusedlast", renderFocusedLast);
+  XMLUtils::GetBoolean(pControlNode, "resetonlabelchange", resetOnLabelChange);
+
+  XMLUtils::GetBoolean(pControlNode, "password", bPassword);
+
+  // view type
+  VIEW_TYPE viewType = VIEW_TYPE_NONE;
+  CStdString viewLabel;
+  if (type == CGUIControl::GUICONTAINER_PANEL)
+  {
+    viewType = VIEW_TYPE_ICON;
+    viewLabel = g_localizeStrings.Get(536);
+  }
+  else if (type == CGUIControl::GUICONTAINER_LIST)
+  {
+    viewType = VIEW_TYPE_LIST;
+    viewLabel = g_localizeStrings.Get(535);
+  }
+  else
+  {
+    viewType = VIEW_TYPE_WRAP;
+    viewLabel = g_localizeStrings.Get(541);
+  }
+  TiXmlElement *itemElement = pControlNode->FirstChildElement("viewtype");
+  if (itemElement && itemElement->FirstChild())
+  {
+    CStdString type = itemElement->FirstChild()->Value();
+    if (type == "list")
+      viewType = VIEW_TYPE_LIST;
+    else if (type == "icon")
+      viewType = VIEW_TYPE_ICON;
+    else if (type == "biglist")
+      viewType = VIEW_TYPE_BIG_LIST;
+    else if (type == "bigicon")
+      viewType = VIEW_TYPE_BIG_ICON;
+    else if (type == "wide")
+      viewType = VIEW_TYPE_WIDE;
+    else if (type == "bigwide")
+      viewType = VIEW_TYPE_BIG_WIDE;
+    else if (type == "wrap")
+      viewType = VIEW_TYPE_WRAP;
+    else if (type == "bigwrap")
+      viewType = VIEW_TYPE_BIG_WRAP;
+    const char *label = itemElement->Attribute("label");
+    if (label)
+      viewLabel = CGUIInfoLabel::GetLabel(FilterLabel(label));
+  }
+
+  TiXmlElement *cam = pControlNode->FirstChildElement("camera");
+  if (cam)
+  {
+    hasCamera = true;
+    g_SkinInfo.ResolveConstant(cam->Attribute("x"), camera.x);
+    g_SkinInfo.ResolveConstant(cam->Attribute("y"), camera.y);
+  }
+
+  XMLUtils::GetInt(pControlNode, "scrollspeed", labelInfo.scrollSpeed);
+  spinInfo.scrollSpeed = labelInfo.scrollSpeed;
+
+  GetString(pControlNode, "scrollsuffix", labelInfo.scrollSuffix);
+  spinInfo.scrollSuffix = labelInfo.scrollSuffix;
+
+  /////////////////////////////////////////////////////////////////////////////
+  // Instantiate a new control using the properties gathered above
+  //
+
+  CGUIControl *control = NULL;
+  if (type == CGUIControl::GUICONTROL_GROUP)
+  {
+    if (insideContainer)
+    {
+      control = new CGUIListGroup(parentID, id, posX, posY, width, height);
+    }
+    else
+    {
+      control = new CGUIControlGroup(
+        parentID, id, posX, posY, width, height);
+      ((CGUIControlGroup *)control)->SetDefaultControl(defaultControl, defaultAlways);
+      ((CGUIControlGroup *)control)->SetRenderFocusedLast(renderFocusedLast);
+    }
+  }
+  else if (type == CGUIControl::GUICONTROL_GROUPLIST)
+  {
+    control = new CGUIControlGroupList(
+      parentID, id, posX, posY, width, height, buttonGap, pageControl, orientation, useControlCoords, labelInfo.align, scrollTime);
+    ((CGUIControlGroup *)control)->SetRenderFocusedLast(renderFocusedLast);
+  }
+  else if (type == CGUIControl::GUICONTROL_LABEL)
+  {
+    const CGUIInfoLabel &content = (infoLabels.size()) ? infoLabels[0] : CGUIInfoLabel("");
+    if (insideContainer)
+    { // inside lists we use CGUIListLabel
+      control = new CGUIListLabel(parentID, id, posX, posY, width, height, labelInfo, content, bScrollLabel);
+    }
+    else
+    {
+      control = new CGUILabelControl(
+        parentID, id, posX, posY, width, height,
+        labelInfo, wrapMultiLine, bHasPath);
+      ((CGUILabelControl *)control)->SetInfo(content);
+      ((CGUILabelControl *)control)->SetWidthControl(minWidth, bScrollLabel);
+    }
+  }
+  else if (type == CGUIControl::GUICONTROL_EDIT)
+  {
+    control = new CGUIEditControl(
+      parentID, id, posX, posY, width, height, textureFocus, textureNoFocus,
+      labelInfo, strLabel);
+
+    CGUIInfoLabel hint_text;
+    GetInfoLabel(pControlNode, "hinttext", hint_text, parentID);
+    ((CGUIEditControl *) control)->SetHint(hint_text);
+
+    if (bPassword)
+      ((CGUIEditControl *) control)->SetInputType(CGUIEditControl::INPUT_TYPE_PASSWORD, 0);
+    ((CGUIEditControl *) control)->SetTextChangeActions(textChangeActions);          
+  }
+  else if (type == CGUIControl::GUICONTROL_VIDEO)
+  {
+    control = new CGUIVideoControl(
+      parentID, id, posX, posY, width, height);
+  }
+  else if (type == CGUIControl::GUICONTROL_FADELABEL)
+  {
+    control = new CGUIFadeLabelControl(
+      parentID, id, posX, posY, width, height,
+      labelInfo, scrollOut, timeToPauseAtEnd, resetOnLabelChange);
+
+    ((CGUIFadeLabelControl *)control)->SetInfo(infoLabels);
+  }
+  else if (type == CGUIControl::GUICONTROL_RSS)
+  {
+    control = new CGUIRSSControl(
+      parentID, id, posX, posY, width, height,
+      labelInfo, textColor3, headlineColor, strRSSTags);
+
+    std::map<int,CSettings::RssSet>::iterator iter=g_settings.m_mapRssUrls.find(iUrlSet);
+    if (iter != g_settings.m_mapRssUrls.end())
+    {
+      ((CGUIRSSControl *)control)->SetUrls(iter->second.url,iter->second.rtl);
+      ((CGUIRSSControl *)control)->SetIntervals(iter->second.interval);
+    }
+    else
+      CLog::Log(LOGERROR,"invalid rss url set referenced in skin");
+  }
+  else if (type == CGUIControl::GUICONTROL_BUTTON)
+  {
+    control = new CGUIButtonControl(
+      parentID, id, posX, posY, width, height,
+      textureFocus, textureNoFocus,
+      labelInfo);
+
+    ((CGUIButtonControl *)control)->SetLabel(strLabel);
+    ((CGUIButtonControl *)control)->SetLabel2(strLabel2);
+    ((CGUIButtonControl *)control)->SetClickActions(clickActions);
+    ((CGUIButtonControl *)control)->SetFocusActions(focusActions);
+    ((CGUIButtonControl *)control)->SetUnFocusActions(unfocusActions);
+  }
+  else if (type == CGUIControl::GUICONTROL_TOGGLEBUTTON)
+  {
+    control = new CGUIToggleButtonControl(
+      parentID, id, posX, posY, width, height,
+      textureFocus, textureNoFocus,
+      textureAltFocus, textureAltNoFocus, labelInfo);
+
+    ((CGUIToggleButtonControl *)control)->SetLabel(strLabel);
+    ((CGUIToggleButtonControl *)control)->SetAltLabel(altLabel);
+    ((CGUIToggleButtonControl *)control)->SetClickActions(clickActions);
+    ((CGUIToggleButtonControl *)control)->SetAltClickActions(altclickActions);
+    ((CGUIToggleButtonControl *)control)->SetFocusActions(focusActions);
+    ((CGUIToggleButtonControl *)control)->SetUnFocusActions(unfocusActions);
+    ((CGUIToggleButtonControl *)control)->SetToggleSelect(iToggleSelect);
+  }
+  else if (type == CGUIControl::GUICONTROL_CHECKMARK)
+  {
+    control = new CGUICheckMarkControl(
+      parentID, id, posX, posY, width, height,
+      textureCheckMark, textureCheckMarkNF,
+      checkWidth, checkHeight, labelInfo);
+
+    ((CGUICheckMarkControl *)control)->SetLabel(strLabel);
+  }
+  else if (type == CGUIControl::GUICONTROL_RADIO)
+  {
+    control = new CGUIRadioButtonControl(
+      parentID, id, posX, posY, width, height,
+      textureFocus, textureNoFocus,
+      labelInfo,
+      textureRadioOn, textureRadioOff);
+
+    ((CGUIRadioButtonControl *)control)->SetLabel(strLabel);
+    ((CGUIRadioButtonControl *)control)->SetRadioDimensions(radioPosX, radioPosY, radioWidth, radioHeight);
+    ((CGUIRadioButtonControl *)control)->SetToggleSelect(iToggleSelect);
+    ((CGUIRadioButtonControl *)control)->SetClickActions(clickActions);
+    ((CGUIRadioButtonControl *)control)->SetFocusActions(focusActions);
+    ((CGUIRadioButtonControl *)control)->SetUnFocusActions(unfocusActions);
+  }
+  else if (type == CGUIControl::GUICONTROL_MULTISELECT)
+  {
+    CGUIInfoLabel label;
+    if (infoLabels.size())
+      label = infoLabels[0];
+    control = new CGUIMultiSelectTextControl(
+      parentID, id, posX, posY, width, height,
+      textureFocus, textureNoFocus, labelInfo, label);
+  }
+  else if (type == CGUIControl::GUICONTROL_SPIN)
+  {
+    control = new CGUISpinControl(
+      parentID, id, posX, posY, width, height,
+      textureUp, textureDown, textureUpFocus, textureDownFocus,
+      labelInfo, iType);
+
+    ((CGUISpinControl *)control)->SetReverse(bReverse);
+
+    if (iType == SPIN_CONTROL_TYPE_INT)
+    {
+      ((CGUISpinControl *)control)->SetRange(iMin, iMax);
+    }
+    else if (iType == SPIN_CONTROL_TYPE_PAGE)
+    {
+      ((CGUISpinControl *)control)->SetRange(iMin, iMax);
+      ((CGUISpinControl *)control)->SetShowRange(true);
+      ((CGUISpinControl *)control)->SetReverse(false);
+      ((CGUISpinControl *)control)->SetShowOnePage(showOnePage);
+    }
+    else if (iType == SPIN_CONTROL_TYPE_FLOAT)
+    {
+      ((CGUISpinControl *)control)->SetFloatRange(fMin, fMax);
+      ((CGUISpinControl *)control)->SetFloatInterval(fInterval);
+    }
+  }
+  else if (type == CGUIControl::GUICONTROL_SLIDER)
+  {
+    control = new CGUISliderControl(
+      parentID, id, posX, posY, width, height,
+      textureBar, textureNib, textureNibFocus, SPIN_CONTROL_TYPE_TEXT);
+
+    ((CGUISliderControl *)control)->SetInfo(singleInfo);
+  }
+  else if (type == CGUIControl::GUICONTROL_SETTINGS_SLIDER)
+  {
+    labelInfo.align |= XBFONT_CENTER_Y;    // always center text vertically
+    control = new CGUISettingsSliderControl(
+      parentID, id, posX, posY, width, height, sliderWidth, sliderHeight, textureFocus, textureNoFocus,
+      textureBar, textureNib, textureNibFocus, labelInfo, SPIN_CONTROL_TYPE_TEXT);
+
+    ((CGUISettingsSliderControl *)control)->SetText(strLabel);
+    ((CGUISettingsSliderControl *)control)->SetInfo(singleInfo);
+  }
+  else if (type == CGUIControl::GUICONTROL_SCROLLBAR)
+  {
+    control = new CGUIScrollBar(
+      parentID, id, posX, posY, width, height,
+      textureBackground, textureBar, textureBarFocus, textureNib, textureNibFocus, orientation, showOnePage);
+  }
+  else if (type == CGUIControl::GUICONTROL_PROGRESS)
+  {
+    control = new CGUIProgressControl(
+      parentID, id, posX, posY, width, height,
+      textureBackground, textureLeft, textureMid, textureRight,
+      textureOverlay, bReveal);
+    ((CGUIProgressControl *)control)->SetInfo(singleInfo);
+  }
+  else if (type == CGUIControl::GUICONTROL_IMAGE)
+  {
+    if (strType == "largeimage")
+      texture.useLarge = true;
+
+    // use a bordered texture if we have <bordersize> or <bordertexture> specified.
+    if (borderTexture.filename.IsEmpty() && borderStr.IsEmpty())
+      control = new CGUIImage(
+        parentID, id, posX, posY, width, height, texture);
+    else
+      control = new CGUIBorderedImage(
+        parentID, id, posX, posY, width, height, texture, borderTexture, borderSize);
+#ifdef PRE_SKIN_VERSION_9_10_COMPATIBILITY
+    if (insideContainer && textureFile.IsConstant())
+      aspect.ratio = CAspectRatio::AR_STRETCH;
+#endif
+    ((CGUIImage *)control)->SetInfo(textureFile);
+    ((CGUIImage *)control)->SetAspectRatio(aspect);
+    ((CGUIImage *)control)->SetCrossFade(fadeTime);
+  }
+  else if (type == CGUIControl::GUICONTROL_MULTI_IMAGE)
+  {
+    control = new CGUIMultiImage(
+      parentID, id, posX, posY, width, height, texture, timePerImage, fadeTime, randomized, loop, timeToPauseAtEnd);
+    ((CGUIMultiImage *)control)->SetInfo(texturePath);
+    ((CGUIMultiImage *)control)->SetAspectRatio(aspect);
+  }
+  else if (type == CGUIControl::GUICONTAINER_LIST)
+  {
+    control = new CGUIListContainer(parentID, id, posX, posY, width, height, orientation, scrollTime, preloadItems);
+    ((CGUIListContainer *)control)->LoadLayout(pControlNode);
+    ((CGUIListContainer *)control)->LoadContent(pControlNode);
+    ((CGUIListContainer *)control)->SetType(viewType, viewLabel);
+    ((CGUIListContainer *)control)->SetPageControl(pageControl);
+    ((CGUIListContainer *)control)->SetRenderOffset(offset);
+  }
+  else if (type == CGUIControl::GUICONTAINER_WRAPLIST)
+  {
+    control = new CGUIWrappingListContainer(parentID, id, posX, posY, width, height, orientation, scrollTime, preloadItems, focusPosition);
+    ((CGUIWrappingListContainer *)control)->LoadLayout(pControlNode);
+    ((CGUIWrappingListContainer *)control)->LoadContent(pControlNode);
+    ((CGUIWrappingListContainer *)control)->SetType(viewType, viewLabel);
+    ((CGUIWrappingListContainer *)control)->SetPageControl(pageControl);
+    ((CGUIWrappingListContainer *)control)->SetRenderOffset(offset);
+  }
+  else if (type == CGUIControl::GUICONTAINER_FIXEDLIST)
+  {
+    control = new CGUIFixedListContainer(parentID, id, posX, posY, width, height, orientation, scrollTime, preloadItems, focusPosition, iMovementRange);
+    ((CGUIFixedListContainer *)control)->LoadLayout(pControlNode);
+    ((CGUIFixedListContainer *)control)->LoadContent(pControlNode);
+    ((CGUIFixedListContainer *)control)->SetType(viewType, viewLabel);
+    ((CGUIFixedListContainer *)control)->SetPageControl(pageControl);
+    ((CGUIFixedListContainer *)control)->SetRenderOffset(offset);
+  }
+  else if (type == CGUIControl::GUICONTAINER_PANEL)
+  {
+    control = new CGUIPanelContainer(parentID, id, posX, posY, width, height, orientation, scrollTime, preloadItems);
+    ((CGUIPanelContainer *)control)->LoadLayout(pControlNode);
+    ((CGUIPanelContainer *)control)->LoadContent(pControlNode);
+    ((CGUIPanelContainer *)control)->SetType(viewType, viewLabel);
+    ((CGUIPanelContainer *)control)->SetPageControl(pageControl);
+    ((CGUIPanelContainer *)control)->SetRenderOffset(offset);
+  }
+  else if (type == CGUIControl::GUICONTROL_TEXTBOX)
+  {
+    control = new CGUITextBox(
+      parentID, id, posX, posY, width, height,
+      labelInfo, scrollTime);
+
+    ((CGUITextBox *)control)->SetPageControl(pageControl);
+    if (infoLabels.size())
+      ((CGUITextBox *)control)->SetInfo(infoLabels[0]);
+    ((CGUITextBox *)control)->SetAutoScrolling(pControlNode);
+  }
+  else if (type == CGUIControl::GUICONTROL_SELECTBUTTON)
+  {
+    control = new CGUISelectButtonControl(
+      parentID, id, posX, posY,
+      width, height, textureFocus, textureNoFocus,
+      labelInfo,
+      textureBackground, textureLeft, textureLeftFocus, textureRight, textureRightFocus);
+
+    ((CGUISelectButtonControl *)control)->SetLabel(strLabel);
+  }
+  else if (type == CGUIControl::GUICONTROL_MOVER)
+  {
+    control = new CGUIMoverControl(
+      parentID, id, posX, posY, width, height,
+      textureFocus, textureNoFocus);
+  }
+  else if (type == CGUIControl::GUICONTROL_RESIZE)
+  {
+    control = new CGUIResizeControl(
+      parentID, id, posX, posY, width, height,
+      textureFocus, textureNoFocus);
+  }
+  else if (type == CGUIControl::GUICONTROL_BUTTONBAR)
+  {
+    control = new CGUIButtonScroller(
+      parentID, id, posX, posY, width, height, buttonGap, iNumSlots, iDefaultSlot,
+      iMovementRange, bHorizontal, iAlpha, bWrapAround, bSmoothScrolling,
+      textureFocus, textureNoFocus, labelInfo);
+    ((CGUIButtonScroller *)control)->LoadButtons(pControlNode);
+  }
+  else if (type == CGUIControl::GUICONTROL_SPINEX)
+  {
+    control = new CGUISpinControlEx(
+      parentID, id, posX, posY, width, height, spinWidth, spinHeight,
+      labelInfo, textureFocus, textureNoFocus, textureUp, textureDown, textureUpFocus, textureDownFocus,
+      labelInfo, iType);
+
+    ((CGUISpinControlEx *)control)->SetSpinPosition(spinPosX);
+    ((CGUISpinControlEx *)control)->SetText(strLabel);
+    ((CGUISpinControlEx *)control)->SetReverse(bReverse);
+  }
+  else if (type == CGUIControl::GUICONTROL_VISUALISATION)
+  {
+    control = new CGUIVisualisationControl(parentID, id, posX, posY, width, height);
+  }
+
+  // things that apply to all controls
+  if (control)
+  {
+    control->SetHitRect(hitRect);
+    control->SetVisibleCondition(iVisibleCondition, allowHiddenFocus);
+    control->SetEnableCondition(enableCondition);
+    control->SetAnimations(animations);
+    control->SetColorDiffuse(colorDiffuse);
+    control->SetNavigationActions(upActions, downActions, leftActions, rightActions, backActions);
+    control->SetPulseOnSelect(bPulse);
+    if (hasCamera)
+      control->SetCamera(camera);
+  }
+  return control;
+}
+
+void CGUIControlFactory::ScaleElement(TiXmlElement *element, RESOLUTION fileRes, RESOLUTION destRes)
+{
+  if (element->FirstChild())
+  {
+    const char *value = element->FirstChild()->Value();
+    if (value)
+    {
+      float v = (float)atof(value);
+      CStdString name = element->Value();
+      if (name == "posx" ||
+          name == "left" ||
+          name == "width" ||
+          name == "textoffsetx" ||
+          name == "textwidth" ||
+          name == "spinwidth" ||
+          name == "spinposx" ||
+          name == "spinleft" ||
+          name == "markwidth" ||
+          name == "sliderwidth" ||
+          name == "radiowidth" ||
+          name == "radioposx" ||
+          name == "radioleft")
+      {
+        // scale
+        v *= (float)g_settings.m_ResInfo[destRes].iWidth / g_settings.m_ResInfo[fileRes].iWidth;
+        CStdString floatValue;
+        floatValue.Format("%f", v);
+        element->FirstChild()->SetValue(floatValue);
+      }
+      else if (name == "posy" ||
+          name == "top" ||
+          name == "height" ||
+          name == "textoffsety" ||
+          name == "spinheight" ||
+          name == "spinposy" ||
+          name == "spintop" ||
+          name == "markheight" ||
+          name == "sliderheight" ||
+          name == "buttongap" ||  // should really depend on orientation
+          name == "radioheight" ||
+          name == "radioposy" ||
+          name == "radiotop")
+      {
+        // scale
+        v *= (float)g_settings.m_ResInfo[destRes].iHeight / g_settings.m_ResInfo[fileRes].iHeight;
+        CStdString floatValue;
+        floatValue.Format("%f", v);
+        element->FirstChild()->SetValue(floatValue);
+      }
+    }
+  }
+}
Index: xbmc/guilib/GUIControlFactory.cpp
===================================================================
--- xbmc/guilib/GUIControlFactory.cpp	(revision 33042)
+++ xbmc/guilib/GUIControlFactory.cpp	(working copy)
@@ -728,17 +728,42 @@
   // TODO: Perhaps we should check here whether id is valid for focusable controls
   // such as buttons etc.  For labels/fadelabels/images it does not matter
 
-  GetFloat(pControlNode, "posx", posX);
-  GetFloat(pControlNode, "posy", posY);
-  // Convert these from relative coords
   CStdString pos;
-  XMLUtils::GetString(pControlNode, "posx", pos);
-  if (pos.Right(1) == "r")
-    posX = (rect.right - rect.left) - posX;
-  XMLUtils::GetString(pControlNode, "posy", pos);
-  if (pos.Right(1) == "r")
-    posY = (rect.bottom - rect.top) - posY;
+  if (GetFloat(pControlNode, "left", posX))
+  {
+    GetFloat(pControlNode, "left", posX); // Kodi uses these now, so I liked the idea lol
+	XMLUtils::GetString(pControlNode, "left", pos);
+	if (pos.Right(1) == "r")
+		posX = (rect.right - rect.left) - posX;
+  }
 
+  if (GetFloat(pControlNode, "posx", posX))
+  {
+	GetFloat(pControlNode, "posx", posX);
+	XMLUtils::GetString(pControlNode, "posx", pos);
+	if (pos.Right(1) == "r")
+		posX = (rect.right - rect.left) - posX;
+  }
+  
+  if (GetFloat(pControlNode, "top", posY)) // Kodi uses these now, so I liked the idea lol
+  {
+    GetFloat(pControlNode, "top", posY); 
+	XMLUtils::GetString(pControlNode, "top", pos);
+	if (pos.Right(1) == "r")
+		posY = (rect.bottom - rect.top) - posY;
+  }
+  
+  if (GetFloat(pControlNode, "posy", posY))
+  {
+	GetFloat(pControlNode, "posy", posY);
+    // Convert these from relative coords
+	XMLUtils::GetString(pControlNode, "posy", pos);
+	if (pos.Right(1) == "r")
+		posY = (rect.bottom - rect.top) - posY;
+  }
+
+
+
   GetDimension(pControlNode, "width", width, minWidth);
   GetFloat(pControlNode, "height", height);
   GetFloat(pControlNode, "offsetx", offset.x);
@@ -843,6 +868,8 @@
   GetFloat(pControlNode, "spinheight", spinHeight);
   GetFloat(pControlNode, "spinposx", spinPosX);
   GetFloat(pControlNode, "spinposy", spinPosY);
+  GetFloat(pControlNode, "spinleft", spinPosX);
+  GetFloat(pControlNode, "spinright", spinPosY);
 
   GetFloat(pControlNode, "markwidth", checkWidth);
   GetFloat(pControlNode, "markheight", checkHeight);
@@ -947,6 +974,8 @@
   GetFloat(pControlNode, "radioheight", radioHeight);
   GetFloat(pControlNode, "radioposx", radioPosX);
   GetFloat(pControlNode, "radioposy", radioPosY);
+  GetFloat(pControlNode, "radioleft", radioPosX);
+  GetFloat(pControlNode, "radiotop", radioPosY);
   CStdString borderStr;
   if (XMLUtils::GetString(pControlNode, "bordersize", borderStr))
     GetRectFromString(borderStr, borderSize);
@@ -1367,15 +1396,18 @@
       float v = (float)atof(value);
       CStdString name = element->Value();
       if (name == "posx" ||
+          name == "left" ||
           name == "width" ||
           name == "textoffsetx" ||
           name == "textwidth" ||
           name == "spinwidth" ||
           name == "spinposx" ||
+          name == "spinleft" ||
           name == "markwidth" ||
           name == "sliderwidth" ||
           name == "radiowidth" ||
-          name == "radioposx")
+          name == "radioposx" ||
+          name == "radioleft")
       {
         // scale
         v *= (float)g_settings.m_ResInfo[destRes].iWidth / g_settings.m_ResInfo[fileRes].iWidth;
@@ -1384,15 +1416,18 @@
         element->FirstChild()->SetValue(floatValue);
       }
       else if (name == "posy" ||
+          name == "top" ||
           name == "height" ||
           name == "textoffsety" ||
           name == "spinheight" ||
           name == "spinposy" ||
+          name == "spintop" ||
           name == "markheight" ||
           name == "sliderheight" ||
           name == "buttongap" ||  // should really depend on orientation
           name == "radioheight" ||
-          name == "radioposy")
+          name == "radioposy" ||
+          name == "radiotop")
       {
         // scale
         v *= (float)g_settings.m_ResInfo[destRes].iHeight / g_settings.m_ResInfo[fileRes].iHeight;
Index: xbmc/guilib/GUIFixedListContainer.cpp
===================================================================
--- xbmc/guilib/GUIFixedListContainer.cpp	(revision 33042)
+++ xbmc/guilib/GUIFixedListContainer.cpp	(working copy)
@@ -23,6 +23,8 @@
 #include "GUIListItem.h"
 #include "GUIInfoManager.h"
 
+#include "settings/GUISettings.h"
+
 CGUIFixedListContainer::CGUIFixedListContainer(int parentID, int controlID, float posX, float posY, float width, float height, ORIENTATION orientation, int scrollTime, int preloadItems, int fixedPosition, int cursorRange)
     : CGUIBaseContainer(parentID, controlID, posX, posY, width, height, orientation, scrollTime, preloadItems)
 {
@@ -56,29 +58,51 @@
     // smooth scrolling (for analog controls)
   case ACTION_SCROLL_UP:
     {
-      m_analogScrollCount += action.GetAmount() * action.GetAmount();
-      bool handled = false;
-      while (m_analogScrollCount > 0.4)
-      {
-        handled = true;
-        m_analogScrollCount -= 0.4f;
-          Scroll(-1);
-      }
-      return handled;
-    }
+		m_analogScrollCount += action.GetAmount() * action.GetAmount();
+		bool handled = false;
+		if (!g_guiSettings.GetBool("mygames.fastscrolling"))
+		{
+			while (m_analogScrollCount > 8.5)
+			{
+				handled = true;
+				m_analogScrollCount -= 8.5f;
+				Scroll(-1);
+			}
+		}
+		  else
+		{
+			while (m_analogScrollCount > 0.8)
+			{
+				handled = true;
+				m_analogScrollCount -= 0.8f;
+				Scroll(-1);
+			}
+		}
+	}
     break;
   case ACTION_SCROLL_DOWN:
     {
-      m_analogScrollCount += action.GetAmount() * action.GetAmount();
-      bool handled = false;
-      while (m_analogScrollCount > 0.4)
-      {
-        handled = true;
-        m_analogScrollCount -= 0.4f;
-          Scroll(1);
-      }
-      return handled;
-    }
+		m_analogScrollCount += action.GetAmount() * action.GetAmount();
+		bool handled = false;
+		if (!g_guiSettings.GetBool("mygames.fastscrolling"))
+		{
+			while (m_analogScrollCount > 8.5)
+			{
+				handled = true;
+				m_analogScrollCount -= 8.5f;
+				Scroll(1);
+			}
+		}
+		  else
+		{
+			while (m_analogScrollCount > 0.8)
+			{
+				handled = true;
+				m_analogScrollCount -= 0.8f;
+				Scroll(1);
+			}
+		}
+	}
     break;
   }
   return CGUIBaseContainer::OnAction(action);
Index: xbmc/guilib/GUIFontManager.cpp
===================================================================
--- xbmc/guilib/GUIFontManager.cpp	(revision 33042)
+++ xbmc/guilib/GUIFontManager.cpp	(working copy)
@@ -31,6 +31,7 @@
 #include "utils/StringUtils.h"
 #include "../xbmc/FileSystem/File.h"
 #include "../xbmc/FileSystem/SpecialProtocol.h"
+#include "settings/GUIWindowSettingsCategory.h"
 
 using namespace std;
 
@@ -96,11 +97,11 @@
   }
   else
     strPath = strFilename;
-
   // Check if the file exists, otherwise try loading it from the global media dir
   if (!XFILE::CFile::Exists(strPath))
   {
-    strPath = URIUtils::AddFileToFolder("special://xbmc/media/Fonts", URIUtils::GetFileName(strFilename));
+	CStdString ThemeFont(URIUtils::ReplaceExtension(g_guiSettings.GetString("lookandfeel.skintheme"), ""));
+    strPath = "special://xbmc/emustation/themes/" + ThemeFont + "/" + ThemeFont + ".ttf";
   }
 
   // check if we already have this font file loaded (font object could differ only by color or style)
@@ -116,7 +117,7 @@
       // Now try to load it from media\fonts
       if (strFilename[1] != ':')
       {
-        strPath = "Q:\\media\\Fonts\\";
+        strPath = "Q:\\system\\media\\Fonts\\";
         strPath += strFilename;
       }
 
@@ -373,6 +374,7 @@
       const TiXmlNode *pNode = fontNode->FirstChild("name");
       if (pNode)
       {
+        CStdString strFakeFontFileName(URIUtils::ReplaceExtension(g_guiSettings.GetString("lookandfeel.font").c_str(), ".ttf"));;
         CStdString strFontName = pNode->FirstChild()->Value();
         color_t shadowColor = 0;
         color_t textColor = 0;
@@ -414,7 +416,7 @@
             XMLUtils::GetFloat(fontNode, "linespacing", lineSpacing);
             XMLUtils::GetFloat(fontNode, "aspect", aspect);
 
-            LoadTTF(strFontName, strFontFileName, textColor, shadowColor, iSize, iStyle, false, lineSpacing, aspect);
+            LoadTTF(strFontName, strFakeFontFileName, textColor, shadowColor, iSize, iStyle, false, lineSpacing, aspect);
           }
         }
       }
Index: xbmc/guilib/GUIListContainer.cpp
===================================================================
--- xbmc/guilib/GUIListContainer.cpp	(revision 33042)
+++ xbmc/guilib/GUIListContainer.cpp	(working copy)
@@ -23,6 +23,8 @@
 #include "GUIListItem.h"
 #include "GUIInfoManager.h"
 
+#include "settings/GUISettings.h"
+
 CGUIListContainer::CGUIListContainer(int parentID, int controlID, float posX, float posY, float width, float height, ORIENTATION orientation, int scrollTime, int preloadItems)
     : CGUIBaseContainer(parentID, controlID, posX, posY, width, height, orientation, scrollTime, preloadItems)
 {
@@ -67,43 +69,51 @@
     // smooth scrolling (for analog controls)
   case ACTION_SCROLL_UP:
     {
-      m_analogScrollCount += action.GetAmount() * action.GetAmount();
-      bool handled = false;
-      while (m_analogScrollCount > 0.4)
-      {
-        handled = true;
-        m_analogScrollCount -= 0.4f;
-        if (m_offset > 0 && m_cursor <= m_itemsPerPage / 2)
-        {
-          Scroll(-1);
-        }
-        else if (m_cursor > 0)
-        {
-          SetCursor(m_cursor - 1);
-        }
-      }
-      return handled;
-    }
+		m_analogScrollCount += action.GetAmount() * action.GetAmount();
+		bool handled = false;
+		if (!g_guiSettings.GetBool("mygames.fastscrolling"))
+		{
+			while (m_analogScrollCount > 8.5)
+			{
+				handled = true;
+				m_analogScrollCount -= 8.5f;
+				Scroll(-1);
+			}
+		}
+		  else
+		{
+			while (m_analogScrollCount > 0.8)
+			{
+				handled = true;
+				m_analogScrollCount -= 0.8f;
+				Scroll(-1);
+			}
+		}
+	}
     break;
   case ACTION_SCROLL_DOWN:
     {
-      m_analogScrollCount += action.GetAmount() * action.GetAmount();
-      bool handled = false;
-      while (m_analogScrollCount > 0.4)
-      {
-        handled = true;
-        m_analogScrollCount -= 0.4f;
-        if (m_offset + m_itemsPerPage < (int)m_items.size() && m_cursor >= m_itemsPerPage / 2)
-        {
-          Scroll(1);
-        }
-        else if (m_cursor < m_itemsPerPage - 1 && m_offset + m_cursor < (int)m_items.size() - 1)
-        {
-          SetCursor(m_cursor + 1);
-        }
-      }
-      return handled;
-    }
+		m_analogScrollCount += action.GetAmount() * action.GetAmount();
+		bool handled = false;
+		if (!g_guiSettings.GetBool("mygames.fastscrolling"))
+		{
+			while (m_analogScrollCount > 8.5)
+			{
+				handled = true;
+				m_analogScrollCount -= 8.5f;
+				Scroll(1);
+			}
+		}
+		  else
+		{
+			while (m_analogScrollCount > 0.8)
+			{
+				handled = true;
+				m_analogScrollCount -= 0.8f;
+				Scroll(1);
+			}
+		}
+	}
     break;
   }
   return CGUIBaseContainer::OnAction(action);
Index: xbmc/guilib/GUIListLabel.cpp
===================================================================
--- xbmc/guilib/GUIListLabel.cpp	(revision 33042)
+++ xbmc/guilib/GUIListLabel.cpp	(working copy)
@@ -19,6 +19,7 @@
  */
 
 #include "include.h"
+#include "SkinInfo.h"
 #include "GUIListLabel.h"
 #include "utils/CharsetConverter.h"
 #include <limits>
@@ -26,16 +27,17 @@
 CGUIListLabel::CGUIListLabel(int parentID, int controlID, float posX, float posY, float width, float height, const CLabelInfo& labelInfo, const CGUIInfoLabel &info, bool alwaysScroll)
     : CGUIControl(parentID, controlID, posX, posY, width, height)
     , m_label(posX, posY, width, height, labelInfo, alwaysScroll ? CGUILabel::OVER_FLOW_SCROLL : CGUILabel::OVER_FLOW_TRUNCATE)
+    , m_info(info)
 {
-  m_info = info;
-  m_alwaysScroll = alwaysScroll;
-  // TODO: Remove this "correction"
-  if (labelInfo.align & XBFONT_RIGHT)
-    m_label.SetMaxRect(m_posX - m_width, m_posY, m_width, m_height);
-  else if (labelInfo.align & XBFONT_CENTER_X)
-    m_label.SetMaxRect(m_posX - m_width*0.5f, m_posY, m_width, m_height);
+  if (g_SkinInfo.GetVersion() <= 2.10)
+  {
+	if (labelInfo.align & XBFONT_RIGHT)
+		m_label.SetMaxRect(m_posX - m_width, m_posY, m_width, m_height);
+	else if (labelInfo.align & XBFONT_CENTER_X)
+		m_label.SetMaxRect(m_posX - m_width*0.5f, m_posY, m_width, m_height);
+  }
   if (m_info.IsConstant())
-    SetLabel(m_info.GetLabel(m_parentID, true));
+	SetLabel(m_info.GetLabel(m_parentID, true));
   ControlType = GUICONTROL_LISTLABEL;
 }
 
Index: xbmc/guilib/GUIPanelContainer.cpp
===================================================================
--- xbmc/guilib/GUIPanelContainer.cpp	(revision 33042)
+++ xbmc/guilib/GUIPanelContainer.cpp	(working copy)
@@ -23,6 +23,8 @@
 #include "GUIListItem.h"
 #include "GUIInfoManager.h"
 
+#include "settings/GUISettings.h"
+
 using namespace std;
 
 CGUIPanelContainer::CGUIPanelContainer(int parentID, int controlID, float posX, float posY, float width, float height, ORIENTATION orientation, int scrollTime, int preloadItems)
@@ -391,7 +393,14 @@
 
 float CGUIPanelContainer::AnalogScrollSpeed() const
 {
-  return 10.0f / m_itemsPerPage;
+		if (!g_guiSettings.GetBool("mygames.fastscrolling"))
+		{
+			return 18.5f / m_itemsPerPage;
+		}
+		else
+		{
+			return 10.0f / m_itemsPerPage;
+		}
 }
 
 int CGUIPanelContainer::CorrectOffset(int offset, int cursor) const
Index: xbmc/guilib/GUIStaticItem.cpp
===================================================================
--- xbmc/guilib/GUIStaticItem.cpp	(revision 33042)
+++ xbmc/guilib/GUIStaticItem.cpp	(working copy)
@@ -35,11 +35,18 @@
   const TiXmlNode *click = item->FirstChild("onclick");
   if (click && click->FirstChild())
   {
-    CGUIInfoLabel label, label2, thumb, icon;
+    CGUIInfoLabel label, label2, SortLabel, thumb, icon;
     CGUIControlFactory::GetInfoLabel(item, "label", label, parentID);
     CGUIControlFactory::GetInfoLabel(item, "label2", label2, parentID);
     CGUIControlFactory::GetInfoLabel(item, "thumb", thumb, parentID);
     CGUIControlFactory::GetInfoLabel(item, "icon", icon, parentID);
+	
+    CGUIControlFactory::GetInfoLabel(item, "name", label, parentID);
+    CGUIControlFactory::GetInfoLabel(item, "details", label2, parentID);
+    CGUIControlFactory::GetInfoLabel(item, "mediapath", SortLabel, parentID);
+    CGUIControlFactory::GetInfoLabel(item, "thumbnail", thumb, parentID);
+    CGUIControlFactory::GetInfoLabel(item, "synopsis", icon, parentID);
+	
     const char *id = item->Attribute("id");
     int visibleCondition = 0;
     CGUIControlFactory::GetConditionalVisibility(item, visibleCondition);
@@ -46,6 +53,7 @@
     CGUIControlFactory::GetActions(item, "onclick", m_clickActions);
     SetLabel(label.GetLabel(parentID));
     SetLabel2(label2.GetLabel(parentID));
+    SetSortLabel(SortLabel.GetLabel(parentID));
     SetThumbnailImage(thumb.GetLabel(parentID, true));
     SetIconImage(icon.GetLabel(parentID, true));
     if (!label.IsConstant())  m_info.push_back(make_pair(label, "label"));
@@ -52,6 +60,13 @@
     if (!label2.IsConstant()) m_info.push_back(make_pair(label2, "label2"));
     if (!thumb.IsConstant())  m_info.push_back(make_pair(thumb, "thumb"));
     if (!icon.IsConstant())   m_info.push_back(make_pair(icon, "icon"));
+	
+    if (!label.IsConstant())  m_info.push_back(make_pair(label, "name"));
+    if (!label2.IsConstant()) m_info.push_back(make_pair(label2, "details"));
+    if (!SortLabel.IsConstant()) m_info.push_back(make_pair(SortLabel, "mediapath"));
+    if (!thumb.IsConstant())  m_info.push_back(make_pair(thumb, "thumbnail"));
+    if (!icon.IsConstant())   m_info.push_back(make_pair(icon, "synopsis"));
+	
     m_iprogramCount = id ? atoi(id) : 0;
     m_idepth = visibleCondition;
     // add any properties
@@ -71,15 +86,23 @@
   }
   else
   {
-    CStdString label, label2, thumb, icon;
+    CStdString label, label2, SortLabel, thumb, icon;
     label  = item->Attribute("label");  label  = CGUIControlFactory::FilterLabel(label);
     label2 = item->Attribute("label2"); label2 = CGUIControlFactory::FilterLabel(label2);
     thumb  = item->Attribute("thumb");  thumb  = CGUIControlFactory::FilterLabel(thumb);
     icon   = item->Attribute("icon");   icon   = CGUIControlFactory::FilterLabel(icon);
+	
+    label  = item->Attribute("name");  label  = CGUIControlFactory::FilterLabel(label);
+    label2 = item->Attribute("details"); label2 = CGUIControlFactory::FilterLabel(label2);
+    SortLabel = item->Attribute("mediapath"); SortLabel = CGUIControlFactory::FilterLabel(SortLabel);
+    thumb  = item->Attribute("thumbnail");  thumb  = CGUIControlFactory::FilterLabel(thumb);
+    icon   = item->Attribute("synopsis");   icon   = CGUIControlFactory::FilterLabel(icon);
+	
     const char *id = item->Attribute("id");
     SetLabel(CGUIInfoLabel::GetLabel(label, parentID));
     SetPath(item->FirstChild()->Value());
     SetLabel2(CGUIInfoLabel::GetLabel(label2, parentID));
+    SetSortLabel(CGUIInfoLabel::GetLabel(SortLabel, parentID));
     SetThumbnailImage(CGUIInfoLabel::GetLabel(thumb, parentID, true));
     SetIconImage(CGUIInfoLabel::GetLabel(icon, parentID, true));
     m_iprogramCount = id ? atoi(id) : 0;
@@ -103,6 +126,17 @@
       SetThumbnailImage(value);
     else if (name.Equals("icon"))
       SetIconImage(value);
+  
+    if (name.Equals("name"))
+      SetLabel(value);
+    else if (name.Equals("details"))
+      SetLabel2(value);
+    else if (name.Equals("mediapath"))
+      SetSortLabel(value);
+    else if (name.Equals("thumbnail"))
+      SetThumbnailImage(value);
+    else if (name.Equals("synopsis"))
+      SetIconImage(value);
     else
       SetProperty(name, value);
   }
Index: xbmc/guilib/GUIVisualisationControl.cpp
===================================================================
--- xbmc/guilib/GUIVisualisationControl.cpp	(revision 33042)
+++ xbmc/guilib/GUIVisualisationControl.cpp	(working copy)
@@ -161,7 +161,7 @@
 
   if (m_currentVis.Equals("None"))
     return;
-  strVisz.Format("Q:\\visualisations\\%s", m_currentVis.c_str());
+  strVisz.Format("Q:\\system\\visualisations\\%s", m_currentVis.c_str());
   m_pVisualisation = factory.LoadVisualisation(strVisz);
   if (m_pVisualisation)
   {
Index: xbmc/guilib/GUIWrappingListContainer.cpp
===================================================================
--- xbmc/guilib/GUIWrappingListContainer.cpp	(revision 33042)
+++ xbmc/guilib/GUIWrappingListContainer.cpp	(working copy)
@@ -22,6 +22,8 @@
 #include "GUIWrappingListContainer.h"
 #include "FileItem.h"
 
+#include "settings/GUISettings.h"
+
 CGUIWrappingListContainer::CGUIWrappingListContainer(int parentID, int controlID, float posX, float posY, float width, float height, ORIENTATION orientation, int scrollTime, int preloadItems, int fixedPosition)
     : CGUIBaseContainer(parentID, controlID, posX, posY, width, height, orientation, scrollTime, preloadItems)
 {
@@ -57,29 +59,51 @@
     // smooth scrolling (for analog controls)
   case ACTION_SCROLL_UP:
     {
-      m_analogScrollCount += action.GetAmount() * action.GetAmount();
-      bool handled = false;
-      while (m_analogScrollCount > 0.4)
-      {
-        handled = true;
-        m_analogScrollCount -= 0.4f;
-        Scroll(-1);
-      }
-      return handled;
-    }
+		m_analogScrollCount += action.GetAmount() * action.GetAmount();
+		bool handled = false;
+		if (!g_guiSettings.GetBool("mygames.fastscrolling"))
+		{
+			while (m_analogScrollCount > 8.5)
+			{
+				handled = true;
+				m_analogScrollCount -= 8.5f;
+				Scroll(-1);
+			}
+		}
+		  else
+		{
+			while (m_analogScrollCount > 0.8)
+			{
+				handled = true;
+				m_analogScrollCount -= 0.8f;
+				Scroll(-1);
+			}
+		}
+	}
     break;
   case ACTION_SCROLL_DOWN:
     {
-      m_analogScrollCount += action.GetAmount() * action.GetAmount();
-      bool handled = false;
-      while (m_analogScrollCount > 0.4)
-      {
-        handled = true;
-        m_analogScrollCount -= 0.4f;
-        Scroll(1);
-      }
-      return handled;
-    }
+		m_analogScrollCount += action.GetAmount() * action.GetAmount();
+		bool handled = false;
+		if (!g_guiSettings.GetBool("mygames.fastscrolling"))
+		{
+			while (m_analogScrollCount > 8.5)
+			{
+				handled = true;
+				m_analogScrollCount -= 8.5f;
+				Scroll(1);
+			}
+		}
+		  else
+		{
+			while (m_analogScrollCount > 0.8)
+			{
+				handled = true;
+				m_analogScrollCount -= 0.8f;
+				Scroll(1);
+			}
+		}
+	}
     break;
   }
   return CGUIBaseContainer::OnAction(action);
Index: xbmc/guilib/SkinInfo.cpp
===================================================================
--- xbmc/guilib/SkinInfo.cpp	(revision 33042)
+++ xbmc/guilib/SkinInfo.cpp	(working copy)
@@ -38,7 +38,7 @@
 
 CSkinInfo::CSkinInfo()
 {
-  m_DefaultResolution = PAL_4x3;
+  m_DefaultResolution = HDTV_720p;
   m_DefaultResolutionWide = INVALID;
   m_strBaseDir = "";
   m_iNumCreditLines = 0;
@@ -55,7 +55,7 @@
 void CSkinInfo::Load(const CStdString& strSkinDir, bool loadIncludes)
 {
   m_strBaseDir = strSkinDir;
-  m_DefaultResolution = PAL_4x3;
+  m_DefaultResolution = HDTV_720p;
   m_DefaultResolutionWide = INVALID;
   m_effectsSlowDown = 1.0f;
   m_skinzoom = 1.0f;
@@ -187,21 +187,21 @@
   switch (res)
   {
   case PAL_4x3:
-    strRes = "PAL";
+    strRes = "xml_sd";
     break;
   case PAL_16x9:
-    strRes = "PAL16x9";
+    strRes = "xml_sd";
     break;
   case NTSC_4x3:
   case HDTV_480p_4x3:
-    strRes = "NTSC";
+    strRes = "xml_sd";
     break;
   case NTSC_16x9:
   case HDTV_480p_16x9:
-    strRes = "ntsc16x9";
+    strRes = "xml_sd";
     break;
   case HDTV_720p:
-    strRes = "720p";
+    strRes = "xml";
     break;
   case HDTV_1080i:
     strRes = "1080i";
@@ -216,15 +216,15 @@
 
 RESOLUTION CSkinInfo::TranslateResolution(const CStdString &res, RESOLUTION def)
 {
-  if (res.Equals("pal"))
+  if (res.Equals("xml_sd"))
     return PAL_4x3;
-  else if (res.Equals("pal16x9"))
+  else if (res.Equals("xml_sd"))
     return PAL_16x9;
-  else if (res.Equals("ntsc"))
+  else if (res.Equals("xml_sd"))
     return NTSC_4x3;
-  else if (res.Equals("ntsc16x9"))
+  else if (res.Equals("xml_sd"))
     return NTSC_16x9;
-  else if (res.Equals("720p"))
+  else if (res.Equals("xml"))
     return HDTV_720p;
   else if (res.Equals("1080i"))
     return HDTV_1080i;
@@ -349,15 +349,15 @@
   if (XMLUtils::GetString(root, tag, strRes))
   {
     strRes.ToLower();
-    if (strRes == "pal")
+    if (strRes == "xml_sd")
       res = PAL_4x3;
-    else if (strRes == "pal16x9")
+    else if (strRes == "xml_sd")
       res = PAL_16x9;
-    else if (strRes == "ntsc")
+    else if (strRes == "xml_sd")
       res = NTSC_4x3;
-    else if (strRes == "ntsc16x9")
+    else if (strRes == "xml_sd")
       res = NTSC_16x9;
-    else if (strRes == "720p")
+    else if (strRes == "xml")
       res = HDTV_720p;
     else if (strRes == "1080i")
       res = HDTV_1080i;
Index: xbmc/guilib/TextureBundle.cpp
===================================================================
--- xbmc/guilib/TextureBundle.cpp	(revision 33042)
+++ xbmc/guilib/TextureBundle.cpp	(working copy)
@@ -114,9 +114,10 @@
     // if we are the theme bundle, we only load if the user has chosen
     // a valid theme (or the skin has a default one)
     CStdString themeXPR = g_guiSettings.GetString("lookandfeel.skintheme");
-    if (!themeXPR.IsEmpty() && themeXPR.CompareNoCase("SKINDEFAULT"))
+	CStdString ThemeName(URIUtils::ReplaceExtension(themeXPR, ""));
+    if (!themeXPR.IsEmpty() && themeXPR.CompareNoCase("SIMPLE"))
     {
-      strPath = URIUtils::AddFileToFolder(g_graphicsContext.GetMediaDir(), "media");
+      strPath = URIUtils::AddFileToFolder("Q:/emustation/themes/",ThemeName);
       strPath = URIUtils::AddFileToFolder(strPath, themeXPR);
     }
     else
@@ -123,7 +124,7 @@
       return false;
   }
   else
-    strPath = URIUtils::AddFileToFolder(g_graphicsContext.GetMediaDir(), "media/Textures.xpr");
+      strPath = URIUtils::AddFileToFolder("Q:/emustation/themes/SIMPLE","SIMPLE.xpr");
 
   if (GetFileAttributes(strPath.c_str()) == -1)
     return false;
@@ -133,18 +134,18 @@
 #ifdef _XBOX
   if (ALIGN % XGetDiskSectorSize(strPath.Left(3).c_str()))
   {
-    CLog::Log(LOGWARNING, "Disk sector size is not supported, caching textures.xpr");
+    CLog::Log(LOGWARNING, "Disk sector size is not supported, caching SIMPLE.xpr");
 
     WIN32_FIND_DATA FindData[2];
     FindClose(FindFirstFile(strPath.c_str(), &FindData[0]));
-    HANDLE hFind = FindFirstFile("Z:\\Textures.xpr", &FindData[1]);
+    HANDLE hFind = FindFirstFile("Z:\\SIMPLE.xpr", &FindData[1]);
     FindClose(hFind);
 
     if (hFind == INVALID_HANDLE_VALUE || FindData[0].nFileSizeLow != FindData[1].nFileSizeLow ||
         CompareFileTime(&FindData[0].ftLastWriteTime, &FindData[1].ftLastWriteTime))
     {
-      SetFileAttributes("Z:\\Textures.xpr", FILE_ATTRIBUTE_NORMAL); //must set readable before overwriting
-      if (!CopyFile(strPath, "Z:\\Textures.xpr", FALSE))
+      SetFileAttributes("Z:\\SIMPLE.xpr", FILE_ATTRIBUTE_NORMAL); //must set readable before overwriting
+      if (!CopyFile(strPath, "Z:\\SIMPLE.xpr", FALSE))
       {
         CLog::Log(LOGERROR, "Unable to open file: %s: %x", strPath.c_str(), GetLastError());
         return false;
@@ -156,7 +157,7 @@
         CloseHandle(m_hFile);
       }
     }
-    strPath = "Z:\\Textures.xpr";
+    strPath = "Z:\\SIMPLE.xpr";
   }
 #endif
 
Index: xbmc/guilib/TextureManager.cpp
===================================================================
--- xbmc/guilib/TextureManager.cpp	(revision 33042)
+++ xbmc/guilib/TextureManager.cpp	(working copy)
@@ -33,6 +33,7 @@
 #include "../xbmc/FileSystem/Directory.h"
 #include "../xbmc/FileSystem/SpecialProtocol.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
 
 #ifdef HAS_XBOX_D3D
 #include <XGraphics.h>
@@ -769,8 +770,12 @@
   { // texture doesn't include the full path, so check all fallbacks
     for (vector<CStdString>::iterator it = m_texturePaths.begin(); it != m_texturePaths.end(); ++it)
     {
-      CStdString path = URIUtils::AddFileToFolder(it->c_str(), "media");
+      // CStdString path = URIUtils::AddFileToFolder("special://xbmc/emustation/themes/",URIUtils::ReplaceExtension(g_guiSettings.GetString("lookandfeel.skintheme"), ""));
+      // path = URIUtils::AddFileToFolder(path, "media");
+      // path = URIUtils::AddFileToFolder(path, textureName);
+	  CStdString path = URIUtils::AddFileToFolder(it->c_str(), "media");
       path = URIUtils::AddFileToFolder(path, textureName);
+	  // CLog::Log(LOGNOTICE, "%s", path.c_str());
       if (directory)
       {
         if (XFILE::CDirectory::Exists(path))
Index: xbmc/GUIViewStateScripts.cpp
===================================================================
--- xbmc/GUIViewStateScripts.cpp	(revision 33042)
+++ xbmc/GUIViewStateScripts.cpp	(working copy)
@@ -71,9 +71,9 @@
   else
     share.strName = "Scripts";
 
-  share.strPath = "special://home/scripts";
+  share.strPath = "special://home/system/scripts";
   if (!CDirectory::Exists(share.strPath))
-    share.strPath = "special://xbmc/scripts";
+    share.strPath = "special://xbmc/system/scripts";
   share.m_iDriveType = CMediaSource::SOURCE_TYPE_LOCAL;
   m_sources.push_back(share);
 
Index: xbmc/GUIWindowGameSaves.cpp
===================================================================
--- xbmc/GUIWindowGameSaves.cpp	(revision 33042)
+++ xbmc/GUIWindowGameSaves.cpp	(working copy)
@@ -40,7 +40,6 @@
 #include "utils/CharsetConverter.h"
 
 using namespace XFILE;
-using namespace XFILE;
 
 #define CONTROL_BTNVIEWASICONS     2
 #define CONTROL_BTNSORTBY          3
@@ -185,8 +184,8 @@
   bool bParentExists = URIUtils::GetParentPath(strDirectory, strParentPath);
   if (bParentExists)
     m_strParentPath = strParentPath;
-  else
-    m_strParentPath = "";
+ // else
+ //   m_strParentPath = ""; // removing this fixes the gamesave menu showing no names for saves.
   //FILE *newfile;
   CFile newfile;
   // flatten any folders with 1 save
@@ -290,7 +289,7 @@
           item->m_bIsFolder = false;
           item->SetPath(savemetaXBX);
         }
-        item->GetMusicInfoTag()->SetTitle(item->GetLabel());  // Note we set ID as the TITLE to save code makign a SORT ID and a ID varible to the FileItem
+        item->GetMusicInfoTag()->SetTitle(item->GetLabel());  // Note we set ID as the TITLE to save code making a SORT ID and a ID variable to the FileItem
         item->SetLabel(strDescription);
         item->SetIconImage("defaultProgram.png");
         formatter.FormatLabel2(item.get());
Index: xbmc/GUIWindowScripts.cpp
===================================================================
--- xbmc/GUIWindowScripts.cpp	(revision 33042)
+++ xbmc/GUIWindowScripts.cpp	(working copy)
@@ -67,7 +67,7 @@
   case GUI_MSG_WINDOW_INIT:
     {
       if (m_vecItems->GetPath() == "?")
-        m_vecItems->SetPath("Q:\\scripts"); //g_settings.m_szDefaultScripts;
+        m_vecItems->SetPath("Q:\\system\\scripts"); //g_settings.m_szDefaultScripts;
 
       return CGUIMediaWindow::OnMessage(message);
     }
Index: xbmc/interfaces/Builtins.cpp
===================================================================
--- xbmc/interfaces/Builtins.cpp	(revision 33042)
+++ xbmc/interfaces/Builtins.cpp	(working copy)
@@ -52,6 +52,8 @@
 #include "FileSystem/RarManager.h"
 #include "FileSystem/VideoDatabaseDirectory.h"
 #include "FileSystem/ZipManager.h"
+#include "FileSystem/SpecialProtocol.h"
+#include "FileSystem/File.h"
 
 #include "utils/URIUtils.h"
 #include "xbox/xbeheader.h"
@@ -77,6 +79,7 @@
 #include <vector>
 #include "settings/AdvancedSettings.h"
 
+
 using namespace std;
 using namespace XFILE;
 using namespace MEDIA_DETECT;
@@ -106,7 +109,8 @@
   { "ReplaceWindow",              true,   "Replaces the current window with the new one" },
   { "TakeScreenshot",             false,  "Takes a Screenshot" },
   { "RunScript",                  true,   "Run the specified script" },
-  { "RunXBE",                     true,   "Run the specified executeable" },
+  { "RunXBE",                     true,   "Run the specified executable" },
+  { "XBEREGION",                  true,   "Check specified executable region" },
   { "RunPlugin",                  true,   "Run the specified plugin" },
   { "Extract",                    true,   "Extracts the specified archive" },
   { "PlayMedia",                  true,   "Play the specified media file (or playlist)" },
@@ -306,10 +310,12 @@
   }
   else if (execute.Equals("setfocus") || execute.Equals("control.setfocus") && params.size())
   {
-    int controlID = atol(params[0].c_str());
-    int subItem = (params.size() > 1) ? atol(params[1].c_str())+1 : 0;
-    CGUIMessage msg(GUI_MSG_SETFOCUS, g_windowManager.GetActiveWindow(), controlID, subItem);
-    g_windowManager.SendMessage(msg);
+	int controlID = atol(params[0].c_str());
+	int subItem = (params.size() > 1) ? atol(params[1].c_str())+1 : 0;
+	int absID = 0;
+	absID = 1;
+	CGUIMessage msg(GUI_MSG_SETFOCUS, g_windowManager.GetFocusedWindow(), controlID, subItem, absID);
+	g_windowManager.SendMessage(msg);
   }
   else if (execute.Equals("runscript") && params.size())
   {
@@ -383,6 +389,9 @@
         }
         else
           iRegion = 0;
+	  
+        CLog::Log(LOGNOTICE, "Test");
+        CLog::Log(LOGNOTICE, "Test %d", int(iRegion));
 
         CUtil::RunXBE(params[0].c_str(),NULL,F_VIDEO(iRegion));
       }
@@ -391,6 +400,47 @@
     {
       CLog::Log(LOGERROR, "CBuiltins::Execute, runxbe called with no arguments.");
     }
+    }
+	else if (execute.Equals("xberegion"))
+	{
+    // only useful if there is actually an XBE to execute
+    if (params.size())
+    {
+      CFileItem item(params[0]);
+      item.SetPath(params[0]);
+      if (item.IsXBE())
+      {
+        int iRegion;
+		CXBE xbe;
+		iRegion = xbe.ExtractGameRegion(params[0]);
+
+		if (iRegion < 1 || iRegion > 7)
+		{
+			// CLog::Log(LOGNOTICE, "0 - NTSC");
+			Execute("skin.setstring(xberegion,)");
+		}
+		else if (iRegion == 1)
+		{
+			// CLog::Log(LOGNOTICE, "1 - NTSC");
+			Execute("skin.setstring(xberegion,ntsc)");
+		}
+		else if (iRegion == 2)
+		{
+			// CLog::Log(LOGNOTICE, "2 - NTSC-J");
+			Execute("skin.setstring(xberegion,ntsc-j)");
+		}
+		else if (iRegion == 4)
+		{
+			// CLog::Log(LOGNOTICE, "4 - PAL");
+			Execute("skin.setstring(xberegion,pal)");
+		}
+		else
+		{
+			// CLog::Log(LOGNOTICE, "NTSC");
+			Execute("skin.setstring(xberegion,)");
+		}
+      }
+    }
   }
   else if (execute.Equals("runplugin"))
   {
@@ -860,7 +910,7 @@
 
     CStdString strTmpTheme;
     // find current theme
-    if (!g_guiSettings.GetString("lookandfeel.skintheme").Equals("skindefault"))
+    if (!g_guiSettings.GetString("lookandfeel.skintheme").Equals("SIMPLE"))
       for (unsigned int i=0;i<vecTheme.size();++i)
       {
         strTmpTheme = g_guiSettings.GetString("lookandfeel.skintheme");
@@ -878,23 +928,18 @@
     else if (iParam == -1)
       iTheme--;
     if (iTheme > (int)vecTheme.size()-1)
-      iTheme = -1;
-    if (iTheme < -1)
+      iTheme = 0;
+    if (iTheme < 0)
       iTheme = vecTheme.size()-1;
 
     CStdString strSkinTheme;
     if (iTheme==-1)
-      g_guiSettings.SetString("lookandfeel.skintheme","skindefault");
+      g_guiSettings.SetString("lookandfeel.skintheme","SIMPLE");
     else
     {
       strSkinTheme.Format("%s.xpr",vecTheme[iTheme]);
       g_guiSettings.SetString("lookandfeel.skintheme",strSkinTheme);
     }
-    // also set the default color theme
-    CStdString colorTheme(URIUtils::ReplaceExtension(strSkinTheme, ".xml"));
-
-    g_guiSettings.SetString("lookandfeel.skincolors", colorTheme);
-
     g_application.DelayLoadSkin();
   }
   else if (execute.Equals("skin.setstring") || execute.Equals("skin.setimage") || execute.Equals("skin.setfile") ||
Index: xbmc/lib/cximage-6.0
===================================================================
--- xbmc/lib/cximage-6.0	(revision 33042)
+++ xbmc/lib/cximage-6.0	(working copy)

Property changes on: xbmc/lib/cximage-6.0
___________________________________________________________________
Modified: svn:ignore
## -1,2 +1,3 ##
-
 Makefile
+ImageLib.ncb
+ImageLib.suo
Index: xbmc/lib/cximage-6.0/jasper
===================================================================
--- xbmc/lib/cximage-6.0/jasper	(revision 33042)
+++ xbmc/lib/cximage-6.0/jasper	(working copy)

Property changes on: xbmc/lib/cximage-6.0/jasper
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+Release
Index: xbmc/lib/cximage-6.0/jpeg
===================================================================
--- xbmc/lib/cximage-6.0/jpeg	(revision 33042)
+++ xbmc/lib/cximage-6.0/jpeg	(working copy)

Property changes on: xbmc/lib/cximage-6.0/jpeg
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+Release
Index: xbmc/lib/cximage-6.0/png
===================================================================
--- xbmc/lib/cximage-6.0/png	(revision 33042)
+++ xbmc/lib/cximage-6.0/png	(working copy)

Property changes on: xbmc/lib/cximage-6.0/png
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+Release
Index: xbmc/lib/cximage-6.0/raw
===================================================================
--- xbmc/lib/cximage-6.0/raw	(revision 33042)
+++ xbmc/lib/cximage-6.0/raw	(working copy)

Property changes on: xbmc/lib/cximage-6.0/raw
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+Release
Index: xbmc/lib/cximage-6.0/zlib
===================================================================
--- xbmc/lib/cximage-6.0/zlib	(revision 33042)
+++ xbmc/lib/cximage-6.0/zlib	(working copy)

Property changes on: xbmc/lib/cximage-6.0/zlib
___________________________________________________________________
Modified: svn:ignore
## -1,2 +1,3 ##
 zconf.h
 Makefile
+Release
Index: xbmc/lib/libapetag
===================================================================
--- xbmc/lib/libapetag	(revision 33042)
+++ xbmc/lib/libapetag	(working copy)

Property changes on: xbmc/lib/libapetag
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+Release
Index: xbmc/lib/libGoAhead/WebServer.h
===================================================================
--- xbmc/lib/libGoAhead/WebServer.h	(revision 33042)
+++ xbmc/lib/libGoAhead/WebServer.h	(working copy)
@@ -63,7 +63,7 @@
 
 	CWebServer();
 	virtual ~CWebServer();
-  bool						Start(const char* szLocalAddress, int port = 80, const char* web = "special://home/web", bool wait = true);
+  bool						Start(const char* szLocalAddress, int port = 80, const char* web = "special://home/system/web", bool wait = true);
 	void						Stop();
 
 	DWORD						SuspendThread();
Index: xbmc/lib/libhts/Win32
===================================================================
--- xbmc/lib/libhts/Win32	(revision 33042)
+++ xbmc/lib/libhts/Win32	(working copy)

Property changes on: xbmc/lib/libhts/Win32
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+Release
Index: xbmc/lib/libPython
===================================================================
--- xbmc/lib/libPython	(revision 33042)
+++ xbmc/lib/libPython	(working copy)

Property changes on: xbmc/lib/libPython
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+XBPyErrorPath.h
Index: xbmc/lib/libPython/python/XBOXbuild
===================================================================
--- xbmc/lib/libPython/python/XBOXbuild	(revision 33042)
+++ xbmc/lib/libPython/python/XBOXbuild	(working copy)

Property changes on: xbmc/lib/libPython/python/XBOXbuild
___________________________________________________________________
Added: svn:ignore
## -0,0 +1,3 ##
+_elementtree.suo
+Debug
+python.suo
Index: xbmc/lib/libPython/xbmcmodule/controlimage.cpp
===================================================================
--- xbmc/lib/libPython/xbmcmodule/controlimage.cpp	(revision 33042)
+++ xbmc/lib/libPython/xbmcmodule/controlimage.cpp	(working copy)
@@ -107,7 +107,7 @@
     "filename       : string - image filename.\n"
     "\n"
     "example:\n"
-    "  - self.image.setImage('special://home/scripts/test.png')\n");
+    "  - self.image.setImage('special://home/system/scripts/test.png')\n");
 
   PyObject* ControlImage_SetImage(ControlImage *self, PyObject *args)
   {
Index: xbmc/lib/libPython/xbmcmodule/dialog.cpp
===================================================================
--- xbmc/lib/libPython/xbmcmodule/dialog.cpp	(revision 33042)
+++ xbmc/lib/libPython/xbmcmodule/dialog.cpp	(working copy)
@@ -31,11 +31,11 @@
 #include "dialogs/GUIDialogProgress.h"
 #include "dialogs/GUIDialogYesNo.h"
 #include "dialogs/GUIDialogSelect.h"
+#include "dialogs/GUIDialogTextViewer.h"
 #include "storage/MediaManager.h"
 #include "ApplicationMessenger.h"
 
 using namespace std;
-
 #define ACTIVE_WINDOW  g_windowManager.GetActiveWindow()
 
 #ifndef __GNUC__
@@ -116,6 +116,47 @@
     return Py_BuildValue((char*)"b", pDialog->IsConfirmed());
   }
 
+  PyDoc_STRVAR(textviewer__doc__,
+    "ok(heading, line1[, line2, line3]) -- Show a dialog 'OK'.\n"
+    "\n"
+    "heading        : string or unicode - dialog heading.\n"
+    "line1          : string or unicode - line #1 text.\n"
+    "line2          : [opt] string or unicode - line #2 text.\n"
+    "line3          : [opt] string or unicode - line #3 text.\n"
+    "\n"
+    "*Note, Returns True if 'Ok' was pressed, else False.\n"
+    "\n"
+    "example:\n"
+    "  - dialog = xbmcgui.Dialog()\n"
+    "  - ok = dialog.ok('XBMC', 'There was an error.')\n");
+
+  PyObject* Dialog_Textviewer(PyObject *self, PyObject *args)
+  {
+    const int window = WINDOW_DIALOG_TEXT_VIEWER;
+    PyObject* unicodeLine[2];
+    for (int i = 0; i < 2; i++) unicodeLine[i] = NULL;
+
+    CGUIDialogTextViewer* pDialog = (CGUIDialogTextViewer*)g_windowManager.GetWindow(window);
+    if (PyXBMCWindowIsNull(pDialog)) return NULL;
+
+    // get lines, last 2 lines are optional.
+    string utf8Line[2];
+    if (!PyArg_ParseTuple(args, (char*)"OO|OO", &unicodeLine[0], &unicodeLine[1]))  return NULL;
+
+    for (int i = 0; i < 2; i++)
+    {
+      if (unicodeLine[i] && !PyXBMCGetUnicodeString(utf8Line[i], unicodeLine[i], i+1))
+        return NULL;
+    }
+    pDialog->SetHeading(utf8Line[0]);
+    pDialog->SetText(utf8Line[1]);
+
+    //send message and wait for user input
+    PyXBMCWaitForThreadMessage(TMSG_DIALOG_DOMODAL, window, ACTIVE_WINDOW);
+
+    return Py_BuildValue((char*)"b");
+  }
+
   PyDoc_STRVAR(browse__doc__,
     "browse(type, heading, shares[, mask, useThumbs, treatAsFolder, default]) -- Show a 'Browse' dialog.\n"
     "\n"
@@ -511,6 +552,7 @@
     {(char*)"ok", (PyCFunction)Dialog_OK, METH_VARARGS, ok__doc__},
     {(char*)"browse", (PyCFunction)Dialog_Browse, METH_VARARGS, browse__doc__},
     {(char*)"numeric", (PyCFunction)Dialog_Numeric, METH_VARARGS, numeric__doc__},
+    {(char*)"textviewer", (PyCFunction)Dialog_Textviewer, METH_VARARGS, textviewer__doc__},
     {NULL, NULL, 0, NULL}
   };
 
Index: xbmc/lib/libPython/xbmcmodule/language.cpp
===================================================================
--- xbmc/lib/libPython/xbmcmodule/language.cpp	(revision 33042)
+++ xbmc/lib/libPython/xbmcmodule/language.cpp	(working copy)
@@ -66,7 +66,7 @@
 
     CStdString languagePath = cScriptPath;
     if (URIUtils::IsPlugin(languagePath))
-      languagePath.Replace("plugin://", "special://home/plugins/");
+      languagePath.Replace("plugin://", "special://home/system/plugins/");
 
     // Path where the language strings reside
     URIUtils::AddFileToFolder(languagePath, "resources", languagePath);
Index: xbmc/lib/libPython/xbmcmodule/listitem.cpp
===================================================================
--- xbmc/lib/libPython/xbmcmodule/listitem.cpp	(revision 33042)
+++ xbmc/lib/libPython/xbmcmodule/listitem.cpp	(working copy)
@@ -851,7 +851,7 @@
     "       Once you use a keyword, all following arguments require the keyword.\n"
     "\n"
     "example:\n"
-    "  - listitem.addContextMenuItems([('Theater Showtimes', 'XBMC.RunScript(special://home/scripts/showtimes/default.py,Iron Man)',)])\n");
+    "  - listitem.addContextMenuItems([('Theater Showtimes', 'XBMC.RunScript(special://home/system/scripts/showtimes/default.py,Iron Man)',)])\n");
 
   PyObject* ListItem_AddContextMenuItems(ListItem *self, PyObject *args, PyObject *kwds)
   {
Index: xbmc/lib/libPython/xbmcmodule/PythonSettings.cpp
===================================================================
--- xbmc/lib/libPython/xbmcmodule/PythonSettings.cpp	(revision 33042)
+++ xbmc/lib/libPython/xbmcmodule/PythonSettings.cpp	(working copy)
@@ -63,7 +63,7 @@
 
     CStdString scriptPath = cScriptPath;
     if (URIUtils::IsPlugin(scriptPath))
-      scriptPath.Replace("plugin://", "special://home/plugins/");
+      scriptPath.Replace("plugin://", "special://home/system/plugins/");
 
     if (!CScriptSettings::SettingsExist(scriptPath))
     {
@@ -176,7 +176,7 @@
     Py_END_ALLOW_THREADS
 
     // refresh weather if weather settings
-    if (ok && path.Find("special://home/plugins/weather/"))
+    if (ok && path.Find("special://home/system/plugins/weather/"))
     {
       g_weatherManager.Refresh();
       g_weatherManager.Reset();
@@ -200,7 +200,7 @@
     "\n"
     "Settings(path) -- Creates a new Settings class.\n"
     "\n"
-    "path            : string - path to script. (eg special://home/scripts/Apple Movie Trailers)\n"
+    "path            : string - path to script. (eg special://home/system/scripts/Apple Movie Trailers)\n"
     "\n"
     "*Note, settings folder structure is eg(resources/settings.xml)\n"
     "\n"
Index: xbmc/lib/libPython/xbmcmodule/xbmcmodule.cpp
===================================================================
--- xbmc/lib/libPython/xbmcmodule/xbmcmodule.cpp	(revision 33042)
+++ xbmc/lib/libPython/xbmcmodule/xbmcmodule.cpp	(working copy)
@@ -186,7 +186,7 @@
     "script         : string - script filename to execute.\n"
     "\n"
     "example:\n"
-    "  - xbmc.executescript('special://home/scripts/update.py')\n");
+    "  - xbmc.executescript('special://home/system/scripts/update.py')\n");
 
   PyObject* XBMC_ExecuteScript(PyObject *self, PyObject *args)
   {
@@ -321,7 +321,7 @@
   PyDoc_STRVAR(getSkinDir__doc__,
     "getSkinDir() -- Returns the active skin directory as a string.\n"
     "\n"
-    "*Note, This is not the full path like 'special://home/skin/MediaCenter', but only 'MediaCenter'.\n"
+    "*Note, This is not the full path like 'special://home/MediaCenter', but only 'MediaCenter'.\n"
     "\n"
     "example:\n"
     "  - skindir = xbmc.getSkinDir()\n");
@@ -476,7 +476,7 @@
     "filename       : string - filename of the wav file to play.\n"
     "\n"
     "example:\n"
-    "  - xbmc.playSFX('special://xbmc/scripts/dingdong.wav')\n");
+    "  - xbmc.playSFX('special://xbmc/system/scripts/dingdong.wav')\n");
 
   PyObject* XBMC_PlaySFX(PyObject *self, PyObject *args)
   {
@@ -646,7 +646,7 @@
       strText = CSpecialProtocol::ReplaceOldPath(strText, 0);
 
     if (URIUtils::IsPlugin(strText))
-      strText.Replace("plugin://", "special://home/plugins/");
+      strText.Replace("plugin://", "special://home/system/plugins/");
 
     strPath = CSpecialProtocol::TranslatePath(strText);
 
Index: xbmc/lib/libPython/xbmcmodule/xbmcplugin.cpp
===================================================================
--- xbmc/lib/libPython/xbmcmodule/xbmcplugin.cpp	(revision 33042)
+++ xbmc/lib/libPython/xbmcmodule/xbmcplugin.cpp	(working copy)
@@ -462,7 +462,7 @@
     "*Note, You can use the above as keywords for arguments.\n"
     "\n"
     "example:\n"
-    "  - xbmcplugin.setPluginFanart(int(sys.argv[1]), 'special://home/plugins/video/Apple movie trailers II/fanart.png', color2='0xFFFF3300')\n");
+    "  - xbmcplugin.setPluginFanart(int(sys.argv[1]), 'special://home/system/plugins/video/Apple movie trailers II/fanart.png', color2='0xFFFF3300')\n");
 
   PyObject* XBMCPLUGIN_SetPluginFanart(PyTypeObject *type, PyObject *args, PyObject *kwds)
   {
Index: xbmc/lib/libPython/XBPython.cpp
===================================================================
--- xbmc/lib/libPython/XBPython.cpp	(revision 33042)
+++ xbmc/lib/libPython/XBPython.cpp	(working copy)
@@ -30,6 +30,7 @@
 #include "python/Include/Python.h"
 #include "cores/DllLoader/DllLoaderContainer.h"
 #include "GUIPassword.h"
+#include "TextureManager.h"
 
 #include "XBPython.h"
 #include "XBPythonDll.h"
@@ -41,6 +42,7 @@
 #include "xbox/network.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
+#include "FileSystem/File.h"
 
 XBPython g_pythonParser;
 
@@ -51,6 +53,7 @@
 extern "C" HMODULE __stdcall dllLoadLibraryA(LPCSTR file);
 extern "C" BOOL __stdcall dllFreeLibrary(HINSTANCE hLibModule);
 
+using namespace XFILE;
 
 XBPython::XBPython()
 {
@@ -294,6 +297,7 @@
     DllLoaderContainer::UnloadPythonDlls();
     m_hModule = NULL;
     mainThreadState = NULL;
+	g_TextureManager.Flush(); // prob not needed but I added it here anyway
   }
 }
 
@@ -321,6 +325,7 @@
 void XBPython::Process()
 {
   CStdString strAutoExecPy;
+  CStdString strReturnRomPy;
 
   // initialize if init was called from another thread
   if (bThreadInitialize) Initialize();
@@ -330,7 +335,8 @@
     bStartup = false;
 
     // autoexec.py - system
-    strAutoExecPy = "special://xbmc/scripts/autoexec.py";
+    strAutoExecPy = "special://xbmc/system/scripts/autoexec.py";
+    strReturnRomPy = "special://emustation_scripts/return_rom.py";
 
     if (XFILE::CFile::Exists(strAutoExecPy))
     {
@@ -341,6 +347,14 @@
     }
     else
       CLog::Log(LOGDEBUG, "%s - no system autoexec.py (%s) found, skipping", __FUNCTION__, CSpecialProtocol::TranslatePath(strAutoExecPy).c_str());
+    
+	if (XFILE::CFile::Exists(strReturnRomPy))
+    {
+      evalFile(strReturnRomPy);
+	  // CFile::Delete(strReturnRomPy);
+    }
+    else
+      CLog::Log(LOGDEBUG, "%s - no emustation return_rom.py (%s) found, skipping", __FUNCTION__, CSpecialProtocol::TranslatePath(strAutoExecPy).c_str());
   }
 
   if (bLogin)
Index: xbmc/lib/libPython/XBPyThread.cpp
===================================================================
--- xbmc/lib/libPython/XBPyThread.cpp	(revision 33042)
+++ xbmc/lib/libPython/XBPyThread.cpp	(working copy)
@@ -25,6 +25,7 @@
 #include "XBPythonDll.h"
 #include "FileSystem/SpecialProtocol.h"
 #include "FileSystem/Directory.h"
+#include "FileSystem/File.h"
 #include "FileItem.h"
 #include "GUIWindowManager.h"
 #include "dialogs/GUIDialogKaiToast.h"
@@ -31,6 +32,7 @@
 #include "utils/URIUtils.h"
 #include "LocalizeStrings.h"
 #include "utils/log.h"
+#include "XBPyErrorPath.h"
 
 #include "XBPyThread.h"
 #include "XBPython.h"
@@ -157,10 +159,10 @@
 
   // add on any addon modules the user has installed
   // fetch directory
-  if (XFILE::CDirectory::Exists("Q:\\scripts\\.modules"))
+  if (XFILE::CDirectory::Exists("Q:\\system\\scripts\\_modules"))
   {
     CFileItemList items;
-    XFILE::CDirectory::GetDirectory("Q:\\scripts\\.modules", items, "/");
+    XFILE::CDirectory::GetDirectory("Q:\\system\\scripts\\_modules", items, "/");
     for (int i = 0; i < items.Size(); ++i)
     {
       CFileItemPtr pItem = items[i];
@@ -224,7 +226,7 @@
     PyErr_Fetch(&exc_type, &exc_value, &exc_traceback);
     if (exc_type == 0 && exc_value == 0 && exc_traceback == 0)
     {
-      CLog::Log(LOGINFO, "Strange: No Python exception occured");
+      CLog::Log(LOGINFO, "Strange: No Python exception occurred");
     }
     else
     {
@@ -231,12 +233,14 @@
       if (exc_type != NULL && (pystring = PyObject_Str(exc_type)) != NULL && (PyString_Check(pystring)))
       {
         if (strncmp(PyString_AsString(pystring), "<type 'exceptions.KeyboardInterrupt'>", 37) == 0)
-          CLog::Log(LOGINFO, "Scriptresult: Interrupted by user");
+          CLog::Log(LOGINFO, "Script result: Interrupted by user");
         else
         {
           PyObject *tracebackModule;
 
-          CLog::Log(LOGINFO, "-->Python script returned the following error<--");
+          CLog::Log(LOGERROR, "--> ------------------------------------------ <--");
+          CLog::Log(LOGERROR, "--> Python script returned the following error <--");
+          CLog::Log(LOGERROR, "--> ------------------------------------------ <--");
           CLog::Log(LOGERROR, "Error Type: %s", PyString_AsString(PyObject_Str(exc_type)));
           if (PyObject_Str(exc_value))
           CLog::Log(LOGERROR, "Error Contents: %s", PyString_AsString(PyObject_Str(exc_value)));
@@ -257,13 +261,24 @@
             Py_DECREF(strRetval);
             Py_DECREF(tracebackModule);
           }
-          CLog::Log(LOGINFO, "-->End of Python script error report<--");
+          CLog::Log(LOGERROR, "--> --------------------------------- <--");
+          CLog::Log(LOGERROR, "--> End of Python script error report <--");
+          CLog::Log(LOGERROR, "--> --------------------------------- <--");
+		  CStdString strOutPutPath;
+		  time_t time_v = time(0);
+		  struct tm * now = localtime(&time_v);
+		  char buffer [26];
+		  strftime (buffer,26,"%d_%m_%y %H.%M.%S",now);
+		  strOutPutPath.Format("%s%s.log",strOutPutPathHeaderFile.c_str(),buffer);
+		  // CLog::Log(LOGERROR, strOutPutPath.c_str());
+		  CLog::Close();
+          XFILE::CFile::Cache("Q:/system/xbmc.log",strOutPutPath.c_str());
         }
       }
       else
       {
         pystring = NULL;
-        CLog::Log(LOGINFO, "<unknown exception type>");
+        CLog::Log(LOGERROR, "<unknown exception type>");
       }
     }
     if (pystring != NULL && strncmp(PyString_AsString(pystring), "<type 'exceptions.KeyboardInterrupt'>", 37) != 0)
@@ -281,7 +296,7 @@
           URIUtils::RemoveSlashAtEnd(path);
           URIUtils::Split(path, path2, script);
         }
-
+		
         desc.Format(g_localizeStrings.Get(2100), script);
         pDlgToast->QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(257), desc);
       }
@@ -292,7 +307,7 @@
     Py_XDECREF(pystring);
   }
   else
-    CLog::Log(LOGINFO, "Scriptresult: Success");
+    CLog::Log(LOGINFO, "Script result: Success");
 
   // clear the thread state and release our hold on the global interpreter
   PyThreadState_Swap(NULL);
Index: xbmc/lib/UnrarXLib
===================================================================
--- xbmc/lib/UnrarXLib	(revision 33042)
+++ xbmc/lib/UnrarXLib	(working copy)

Property changes on: xbmc/lib/UnrarXLib
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+Release
Index: xbmc/music/windows/GUIWindowMusicNav.cpp
===================================================================
--- xbmc/music/windows/GUIWindowMusicNav.cpp	(revision 33042)
+++ xbmc/music/windows/GUIWindowMusicNav.cpp	(working copy)
@@ -723,7 +723,7 @@
   CFileItemList items;
 
   CStdString itemPath = m_vecItems->Get(iItem)->GetPath();
-  itemPath.Replace("plugin://", "special://home/plugins/");
+  itemPath.Replace("plugin://", "special://home/system/plugins/");
   CStdString picturePath = itemPath;
   CFileItem item(picturePath, true);
   CStdString cachedThumb = item.GetCachedProgramThumb();
Index: xbmc/pictures/Picture.cpp
===================================================================
--- xbmc/pictures/Picture.cpp	(revision 33042)
+++ xbmc/pictures/Picture.cpp	(working copy)
@@ -100,42 +100,48 @@
     }
   }
 
-  //ImageLib is sooo sloow for jpegs. Try our own decoder first. If it fails, fall back to ImageLib.
-  if (URIUtils::GetExtension(file).Equals(".jpg") || URIUtils::GetExtension(file).Equals(".tbn"))
+   MEMORYSTATUS stat;
+   GlobalMemoryStatus(&stat);
+   DWORD dwMegFree = (DWORD)(stat.dwAvailPhys / (1024 * 1024));
+  if (dwMegFree >= 8)
   {
-    CJpegIO jpegImage;
-    if (jpegImage.Open(file, width, height))
-    {
-      if (jpegImage.OrgWidth() == 0 || jpegImage.OrgHeight() == 0)
-        return NULL;
+	//ImageLib is sooo sloow for jpegs. Try our own decoder first. If it fails, fall back to ImageLib.
+	  if (URIUtils::GetExtension(file).Equals(".jpg") || URIUtils::GetExtension(file).Equals(".tbn"))
+	  {
+		CJpegIO jpegImage;
+		if (jpegImage.Open(file, width, height))
+		{
+		  if (jpegImage.OrgWidth() == 0 || jpegImage.OrgHeight() == 0)
+			return NULL;
 
-      memset(&m_info, 0, sizeof(ImageInfo));
-      m_info.originalwidth = jpegImage.OrgWidth();
-      m_info.originalheight = jpegImage.OrgHeight();
-      m_info.width = jpegImage.Width();
-      m_info.height = jpegImage.Height();
-      LPDIRECT3DTEXTURE8 pTexture = NULL;
-      g_graphicsContext.Get3DDevice()->CreateTexture(((m_info.width + 3) / 4) * 4, ((m_info.height + 3) / 4) * 4, 1, 0, D3DFMT_LIN_A8R8G8B8 , D3DPOOL_MANAGED, &pTexture);
-      if (pTexture)
-      {
-        D3DLOCKED_RECT lr;
-        if ( D3D_OK == pTexture->LockRect( 0, &lr, NULL, 0 ))
-        {
-          DWORD destPitch = lr.Pitch;
-          BYTE *pixels = (BYTE *)lr.pBits;
-          bool ret = jpegImage.Decode(pixels, destPitch, XB_FMT_A8R8G8B8);
-          pTexture->UnlockRect( 0 );
-          if (ret)
-            return pTexture;
-          else
-            return NULL;
-        }
-      }
-      else {
-        CLog::Log(LOGERROR, "%s - failed to create texture while loading image %s", __FUNCTION__, file.c_str());
-        return NULL;
-      }
-    }
+		  memset(&m_info, 0, sizeof(ImageInfo));
+		  m_info.originalwidth = jpegImage.OrgWidth();
+		  m_info.originalheight = jpegImage.OrgHeight();
+		  m_info.width = jpegImage.Width();
+		  m_info.height = jpegImage.Height();
+		  LPDIRECT3DTEXTURE8 pTexture = NULL;
+		  g_graphicsContext.Get3DDevice()->CreateTexture(((m_info.width + 3) / 4) * 4, ((m_info.height + 3) / 4) * 4, 1, 0, D3DFMT_LIN_A8R8G8B8 , D3DPOOL_MANAGED, &pTexture);
+		  if (pTexture)
+		  {
+			D3DLOCKED_RECT lr;
+			if ( D3D_OK == pTexture->LockRect( 0, &lr, NULL, 0 ))
+			{
+			  DWORD destPitch = lr.Pitch;
+			  BYTE *pixels = (BYTE *)lr.pBits;
+			  bool ret = jpegImage.Decode(pixels, destPitch, XB_FMT_A8R8G8B8);
+			  pTexture->UnlockRect( 0 );
+			  if (ret)
+				return pTexture;
+			  else
+				return NULL;
+			}
+		  }
+		  else {
+			CLog::Log(LOGERROR, "%s - failed to create texture while loading image using JpegIO %s", __FUNCTION__, file.c_str());
+			return NULL;
+		  }
+		}
+	  }
   }
   DllImageLib dll;
   if (!dll.Load()) return NULL;
@@ -174,7 +180,7 @@
     }
   }
   else
-    CLog::Log(LOGERROR, "%s - failed to create texture while loading image %s", __FUNCTION__, file.c_str());
+    CLog::Log(LOGERROR, "%s - failed to create texture while loading image using ImageLib %s", __FUNCTION__, file.c_str());
   dll.ReleaseImage(&m_info);
   return pTexture;
 
Index: xbmc/PluginSettings.cpp
===================================================================
--- xbmc/PluginSettings.cpp	(revision 33042)
+++ xbmc/PluginSettings.cpp	(working copy)
@@ -149,7 +149,7 @@
   URIUtils::AddFileToFolder(m_userFileName, "settings.xml", m_userFileName);
   
   // Create our final path
-  CStdString pluginFileName = "special://home/plugins/";
+  CStdString pluginFileName = "special://home/system/plugins/";
 
   URIUtils::AddFileToFolder(pluginFileName, url.GetHostName(), pluginFileName);
   URIUtils::AddFileToFolder(pluginFileName, url.GetFileName(), pluginFileName);
@@ -220,7 +220,7 @@
 bool CPluginSettings::SettingsExist(const CStdString& strPath)
 {
   CURL url(strPath);
-  CStdString pluginFileName = "special://home/plugins/";
+  CStdString pluginFileName = "special://home/system/plugins/";
 
   // Create our final path
   URIUtils::AddFileToFolder(pluginFileName, url.GetHostName(), pluginFileName);
Index: xbmc/programs/GUIWindowPrograms.cpp
===================================================================
--- xbmc/programs/GUIWindowPrograms.cpp	(revision 33042)
+++ xbmc/programs/GUIWindowPrograms.cpp	(working copy)
@@ -1,22 +1,22 @@
 /*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
 
 #include "programs/GUIWindowPrograms.h"
 #include "Util.h"
@@ -40,7 +40,12 @@
 #include "utils/URIUtils.h"
 #include "LocalizeStrings.h"
 #include "utils/log.h"
+#include "interfaces/Builtins.h"
+#include "settings/AdvancedSettings.h"
+#include "Application.h"
+#include "dialogs/GUIDialogOK.h"
 
+
 using namespace XFILE;
 
 #define CONTROL_BTNVIEWASICONS 2
@@ -50,12 +55,19 @@
 #define CONTROL_THUMBS        51
 #define CONTROL_LABELFILES    12
 
+CStdString check_xbe_path;
+CStdString patched_xbe_path;
+CStdString ws_xbe_path;
+CStdString xhd_xbe_path;
+CStdString hd_xbe_path;
+CStdString xresizer_xbe_path;
+
 CGUIWindowPrograms::CGUIWindowPrograms(void)
-    : CGUIMediaWindow(WINDOW_PROGRAMS, "MyPrograms.xml")
+: CGUIMediaWindow(WINDOW_PROGRAMS, "MyPrograms.xml")
 {
-  m_thumbLoader.SetObserver(this);
-  m_dlgProgress = NULL;
-  m_rootDir.AllowNonLocalSources(false); // no nonlocal shares for this window please
+	m_thumbLoader.SetObserver(this);
+	m_dlgProgress = NULL;
+	m_rootDir.AllowNonLocalSources(false); // no nonlocal shares for this window please
 }
 
 
@@ -65,692 +77,836 @@
 
 bool CGUIWindowPrograms::OnMessage(CGUIMessage& message)
 {
-  switch ( message.GetMessage() )
-  {
-  case GUI_MSG_WINDOW_DEINIT:
-    {
-      if (m_thumbLoader.IsLoading())
-        m_thumbLoader.StopThread();
-      m_database.Close();
-    }
-    break;
+	switch ( message.GetMessage() )
+	{
+	case GUI_MSG_WINDOW_DEINIT:
+		{
+			if (m_thumbLoader.IsLoading())
+			m_thumbLoader.StopThread();
+			m_database.Close();
+		}
+		break;
 
-  case GUI_MSG_WINDOW_INIT:
-    {
-      m_iRegionSet = 0;
-      m_dlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+	case GUI_MSG_WINDOW_INIT:
+		{
+			// Disable autoregion if not stock kernels or M8+.
+			m_iRegionSet = 0;
+			m_dlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+			// is this the first time accessing this window?
+			if (m_vecItems->GetPath() == "?" && message.GetStringParam().IsEmpty())
+			message.SetStringParam(g_settings.m_defaultProgramSource);
 
-      // is this the first time accessing this window?
-      if (m_vecItems->GetPath() == "?" && message.GetStringParam().IsEmpty())
-        message.SetStringParam(g_settings.m_defaultProgramSource);
+			m_database.Open();
 
-      m_database.Open();
+			return CGUIMediaWindow::OnMessage(message);
+		}
+		break;
 
-      return CGUIMediaWindow::OnMessage(message);
-    }
-  break;
+	case GUI_MSG_CLICKED:
+		{
+			if (message.GetSenderId() == CONTROL_BTNSORTBY)
+			{
+				// need to update shortcuts manually
+				if (CGUIMediaWindow::OnMessage(message))
+				{
+					LABEL_MASKS labelMasks;
+					m_guiState->GetSortMethodLabelMasks(labelMasks);
+					CLabelFormatter formatter("", labelMasks.m_strLabel2File);
+					for (int i=0;i<m_vecItems->Size();++i)
+					{
+						CFileItemPtr item = m_vecItems->Get(i);
+						if (item->IsShortCut())
+						formatter.FormatLabel2(item.get());
+					}
+					return true;
+				}
+				else
+				return false;
+			}
+			if (m_viewControl.HasControl(message.GetSenderId()))  // list/thumb control
+			{
+				if (message.GetParam1() == ACTION_PLAYER_PLAY)
+				{
+					OnPlayMedia(m_viewControl.GetSelectedItem());
+					return true;
+				}
+			}
+		}
+		break;
+	}
 
-  case GUI_MSG_CLICKED:
-    {
-      if (message.GetSenderId() == CONTROL_BTNSORTBY)
-      {
-        // need to update shortcuts manually
-        if (CGUIMediaWindow::OnMessage(message))
-        {
-          LABEL_MASKS labelMasks;
-          m_guiState->GetSortMethodLabelMasks(labelMasks);
-          CLabelFormatter formatter("", labelMasks.m_strLabel2File);
-          for (int i=0;i<m_vecItems->Size();++i)
-          {
-            CFileItemPtr item = m_vecItems->Get(i);
-            if (item->IsShortCut())
-              formatter.FormatLabel2(item.get());
-          }
-          return true;
-        }
-        else
-          return false;
-      }
-      if (m_viewControl.HasControl(message.GetSenderId()))  // list/thumb control
-      {
-        if (message.GetParam1() == ACTION_PLAYER_PLAY)
-        {
-          OnPlayMedia(m_viewControl.GetSelectedItem());
-          return true;
-        }
-      }
-    }
-    break;
-  }
-
-  return CGUIMediaWindow::OnMessage(message);
+	return CGUIMediaWindow::OnMessage(message);
 }
 
 void CGUIWindowPrograms::GetContextButtons(int itemNumber, CContextButtons &buttons)
 {
-  if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
-    return;
-  CFileItemPtr item = m_vecItems->Get(itemNumber);
-  if (item && !item->GetPropertyBOOL("pluginreplacecontextitems"))
-  {
-    if ( m_vecItems->IsVirtualDirectoryRoot() )
-    {
-      CGUIDialogContextMenu::GetContextButtons("programs", item, buttons);
-    }
-    else
-    {
-      if (item->IsXBE() || item->IsShortCut())
-      {
-        CStdString strLaunch = g_localizeStrings.Get(518); // Launch
-        if (g_guiSettings.GetBool("myprograms.gameautoregion"))
-        {
-          int iRegion = GetRegion(itemNumber);
-          if (iRegion == VIDEO_NTSCM)
-            strLaunch += " (NTSC-M)";
-          if (iRegion == VIDEO_NTSCJ)
-            strLaunch += " (NTSC-J)";
-          if (iRegion == VIDEO_PAL50)
-            strLaunch += " (PAL)";
-          if (iRegion == VIDEO_PAL60)
-            strLaunch += " (PAL-60)";
-        }
-        buttons.Add(CONTEXT_BUTTON_LAUNCH, strLaunch);
-  
-        DWORD dwTitleId = CUtil::GetXbeID(item->GetPath());
-        CStdString strTitleID;
-        CStdString strGameSavepath;
-        strTitleID.Format("%08X",dwTitleId);
-        URIUtils::AddFileToFolder("E:\\udata\\",strTitleID,strGameSavepath);
-  
-        if (CDirectory::Exists(strGameSavepath))
-          buttons.Add(CONTEXT_BUTTON_GAMESAVES, 20322);         // Goto GameSaves
-  
-        if (g_guiSettings.GetBool("myprograms.gameautoregion"))
-          buttons.Add(CONTEXT_BUTTON_LAUNCH_IN, 519); // launch in video mode
-  
-        if (g_passwordManager.IsMasterLockUnlocked(false) || g_settings.GetCurrentProfile().canWriteDatabases())
-        {
-          if (item->IsShortCut())
-            buttons.Add(CONTEXT_BUTTON_RENAME, 16105); // rename
-          else
-            buttons.Add(CONTEXT_BUTTON_RENAME, 520); // edit xbe title
-        }
-  
-        if (m_database.ItemHasTrainer(dwTitleId))
-          buttons.Add(CONTEXT_BUTTON_TRAINER_OPTIONS, 12015); // trainer options
-      }
-      buttons.Add(CONTEXT_BUTTON_SCAN_TRAINERS, 12012); // scan trainers
-  
-      buttons.Add(CONTEXT_BUTTON_GOTO_ROOT, 20128); // Go to Root
-    }  
-  }
-  CGUIMediaWindow::GetContextButtons(itemNumber, buttons);
-  if (item && !item->GetPropertyBOOL("pluginreplacecontextitems")) 
-    buttons.Add(CONTEXT_BUTTON_SETTINGS, 5);      // Settings 
+	if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
+	return;
+	CFileItemPtr item = m_vecItems->Get(itemNumber);
+	if (item && !item->GetPropertyBOOL("pluginreplacecontextitems"))
+	{
+		if ( m_vecItems->IsVirtualDirectoryRoot() )
+		{
+			CGUIDialogContextMenu::GetContextButtons("programs", item, buttons);
+		}
+		else
+		{
+			if (item->IsXBE() || item->IsShortCut())
+			{
+				// if (!CFile::Exists("special://xbmc/system/scripts/XBMC4Gamers Extras/Synopsis/y_button_loader.py") && CFile::Exists("special://xbmc/system/scripts/XBMC4Gamers Extras/Synopsis/default.py"))
+				// {
+					// buttons.Add(CONTEXT_BUTTON_SYNOPSIS, "Synopsis");         // Synopsis
+				// }
+
+				URIUtils::GetParentPath(item->GetPath(), check_xbe_path);
+				check_xbe_path = CURL(check_xbe_path).GetWithoutUserDetails();
+				CURL::Decode(check_xbe_path);
+				
+				if (CFile::Exists(check_xbe_path+"default720p.xbe"))
+				{
+					hd_xbe_path = (check_xbe_path+"default720p.xbe");
+					buttons.Add(CONTEXT_BUTTON_PATCHED720XBE, "Launch (720p)");         // Patched XBE
+				}
+				
+				if (CFile::Exists(check_xbe_path+"default_p.xbe"))
+				{
+					patched_xbe_path = (check_xbe_path+"default_p.xbe");
+					buttons.Add(CONTEXT_BUTTON_PATCHEDXBE, "Launch (Patched)");         // Patched XBE
+				}
+				
+				if (CFile::Exists(check_xbe_path+"defaultws.xbe"))
+				{
+					ws_xbe_path = (check_xbe_path+"defaultws.xbe");
+					buttons.Add(CONTEXT_BUTTON_PATCHEDWSXBE, "Launch (Widescreen)");         // Patched XBE
+				}
+				
+				if (CFile::Exists(check_xbe_path+"defaultxhd.xbe"))
+				{
+					xhd_xbe_path = (check_xbe_path+"defaultxhd.xbe");
+					buttons.Add(CONTEXT_BUTTON_PATCHEDXHDXBE, "Launch (XHD)");         // Patched XBE
+				}
+				
+				if (CFile::Exists(check_xbe_path+"xresizer.xbe"))
+				{
+					xresizer_xbe_path = (check_xbe_path+"xresizer.xbe");
+					buttons.Add(CONTEXT_BUTTON_XRESIZERXBE, "Resize Screen");         // Patched XBE
+				}
+				
+				CStdString strLaunch = g_localizeStrings.Get(518); // Launch
+				if (g_guiSettings.GetBool("myprograms.gameautoregion"))
+				{
+					int iRegion = GetRegion(itemNumber);
+					if (iRegion == VIDEO_NTSCM)
+					strLaunch += " (NTSC-M)";
+					if (iRegion == VIDEO_NTSCJ)
+					strLaunch += " (NTSC-J)";
+					if (iRegion == VIDEO_PAL50)
+					strLaunch += " (PAL)";
+					if (iRegion == VIDEO_PAL60)
+					strLaunch += " (PAL-60)";
+				}
+				
+				buttons.Add(CONTEXT_BUTTON_LAUNCH, strLaunch);
+
+				DWORD dwTitleId = CUtil::GetXbeID(item->GetPath());
+				CStdString strTitleID;
+				CStdString strGameSavepath;
+				strTitleID.Format("%08X",dwTitleId);
+				URIUtils::AddFileToFolder("E:\\udata\\",strTitleID,strGameSavepath);
+				
+				if (CDirectory::Exists(strGameSavepath))
+					buttons.Add(CONTEXT_BUTTON_GAMESAVES, 20322);         // Goto GameSaves
+
+				if (g_guiSettings.GetBool("myprograms.gameautoregion"))
+					buttons.Add(CONTEXT_BUTTON_LAUNCH_IN, 519); // launch in video mode
+
+				if (g_passwordManager.IsMasterLockUnlocked(false) || g_settings.GetCurrentProfile().canWriteDatabases())
+				{
+					if (!g_guiSettings.GetBool("mygames.usesynopsisname"))
+					{
+						if (item->IsShortCut())
+						buttons.Add(CONTEXT_BUTTON_RENAME, 16105); // rename
+						else
+						buttons.Add(CONTEXT_BUTTON_RENAME, 520); // edit xbe title
+					}
+				}
+
+				if (m_database.ItemHasTrainer(dwTitleId))
+				buttons.Add(CONTEXT_BUTTON_TRAINER_OPTIONS, 12015); // trainer options
+			}
+			buttons.Add(CONTEXT_BUTTON_SCAN_TRAINERS, 12012); // scan trainers
+
+			buttons.Add(CONTEXT_BUTTON_GOTO_ROOT, 20128); // Go to Root
+		}  
+	}
+	CGUIMediaWindow::GetContextButtons(itemNumber, buttons);
+	if (item && !item->GetPropertyBOOL("pluginreplacecontextitems")) 
+	buttons.Add(CONTEXT_BUTTON_SETTINGS, 5);      // Settings 
 }
 
 bool CGUIWindowPrograms::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
 {
-  CFileItemPtr item = (itemNumber >= 0 && itemNumber < m_vecItems->Size()) ? m_vecItems->Get(itemNumber) : CFileItemPtr();
+	CFileItemPtr item = (itemNumber >= 0 && itemNumber < m_vecItems->Size()) ? m_vecItems->Get(itemNumber) : CFileItemPtr();
 
-  if (item && m_vecItems->IsVirtualDirectoryRoot())
-  {
-    if (CGUIDialogContextMenu::OnContextButton("programs", item, button))
-    {
-      Update("");
-      return true;
-    }
-  }
-  switch (button)
-  {
-  case CONTEXT_BUTTON_RENAME:
-    {
-      CStdString strDescription;
-      CShortcut cut;
-      if (item->IsShortCut())
-      {
-        cut.Create(item->GetPath());
-        strDescription = cut.m_strLabel;
-      }
-      else
-        strDescription = item->GetLabel();
+	if (item && m_vecItems->IsVirtualDirectoryRoot())
+	{
+		if (CGUIDialogContextMenu::OnContextButton("programs", item, button))
+		{
+			Update("");
+			return true;
+		}
+	}
+	switch (button)
+	{
+	case CONTEXT_BUTTON_RENAME:
+		{
+			CStdString strDescription;
+			CShortcut cut;
+			if (item->IsShortCut())
+			{
+				cut.Create(item->GetPath());
+				strDescription = cut.m_strLabel;
+			}
+			else
+			strDescription = item->GetLabel();
 
-      if (CGUIDialogKeyboard::ShowAndGetInput(strDescription, g_localizeStrings.Get(16008), false))
-      {
-        if (item->IsShortCut())
-        {
-          cut.m_strLabel = strDescription;
-          cut.Save(item->GetPath());
-        }
-        else
-        {
-          // SetXBEDescription will truncate to 40 characters.
-          CUtil::SetXBEDescription(item->GetPath(),strDescription);
-          m_database.SetDescription(item->GetPath(),strDescription);
-        }
-        Update(m_vecItems->GetPath());
-      }
-      return true;
-    }
+			if (CGUIDialogKeyboard::ShowAndGetInput(strDescription, g_localizeStrings.Get(16008), false))
+			{
+				if (item->IsShortCut())
+				{
+					cut.m_strLabel = strDescription;
+					cut.Save(item->GetPath());
+				}
+				else
+				{
+					// SetXBEDescription will truncate to 40 characters.
+					CUtil::SetXBEDescription(item->GetPath(),strDescription);
+					m_database.SetDescription(item->GetPath(),strDescription);
+				}
+				Update(m_vecItems->GetPath());
+			}
+			return true;
+		}
 
-  case CONTEXT_BUTTON_TRAINER_OPTIONS:
-    {
-      DWORD dwTitleId = CUtil::GetXbeID(item->GetPath());
-      if (CGUIDialogTrainerSettings::ShowForTitle(dwTitleId,&m_database))
-        Update(m_vecItems->GetPath());
-      return true;
-    }
+	case CONTEXT_BUTTON_TRAINER_OPTIONS:
+		{
+			DWORD dwTitleId = CUtil::GetXbeID(item->GetPath());
+			if (CGUIDialogTrainerSettings::ShowForTitle(dwTitleId,&m_database))
+			Update(m_vecItems->GetPath());
+			return true;
+		}
 
-  case CONTEXT_BUTTON_SCAN_TRAINERS:
-    {
-      PopulateTrainersList();
-      Update(m_vecItems->GetPath());
-      return true;
-    }
+	case CONTEXT_BUTTON_SCAN_TRAINERS:
+		{
+			PopulateTrainersList();
+			Update(m_vecItems->GetPath());
+			return true;
+		}
 
-  case CONTEXT_BUTTON_SETTINGS:
-    g_windowManager.ActivateWindow(WINDOW_SETTINGS_MYPROGRAMS);
-    return true;
+	case CONTEXT_BUTTON_SETTINGS:
+		g_windowManager.ActivateWindow(WINDOW_SETTINGS_MYPROGRAMS);
+		return true;
 
-  case CONTEXT_BUTTON_GOTO_ROOT:
-    Update("");
-    return true;
+	case CONTEXT_BUTTON_GOTO_ROOT:
+		Update("");
+		return true;
 
-  case CONTEXT_BUTTON_LAUNCH:
-    OnClick(itemNumber);
-    return true;
+	case CONTEXT_BUTTON_LAUNCH:
+		OnClick(itemNumber);
+		return true;
 
-  case CONTEXT_BUTTON_GAMESAVES:
-    {
-      CStdString strTitleID;
-      CStdString strGameSavepath;
-      strTitleID.Format("%08X",CUtil::GetXbeID(item->GetPath()));
-      URIUtils::AddFileToFolder("E:\\udata\\",strTitleID,strGameSavepath);
-      g_windowManager.ActivateWindow(WINDOW_GAMESAVES,strGameSavepath);
-      return true;
-    }
-  case CONTEXT_BUTTON_LAUNCH_IN:
-    OnChooseVideoModeAndLaunch(itemNumber);
-    return true;
-  default:
-    break;
-  }
-  return CGUIMediaWindow::OnContextButton(itemNumber, button);
+	// case CONTEXT_BUTTON_SYNOPSIS:
+		// {
+			// CBuiltins::Execute("runscript(special://xbmc/system/scripts/XBMC4Gamers Extras/Synopsis/default.py)");
+			// CBuiltins::Execute("ActivateWindow(1101)");
+			// return true;
+		// }
+	case CONTEXT_BUTTON_PATCHED720XBE:
+		{
+			CBuiltins::Execute("runxbe("+hd_xbe_path+")");
+			return true;
+		}
+	case CONTEXT_BUTTON_PATCHEDXBE:
+		{
+			CBuiltins::Execute("runxbe("+patched_xbe_path+")");
+			return true;
+		}
+	case CONTEXT_BUTTON_PATCHEDWSXBE:
+		{
+			CBuiltins::Execute("runxbe("+ws_xbe_path+")");
+			return true;
+		}
+	case CONTEXT_BUTTON_PATCHEDXHDXBE:
+		{
+			CBuiltins::Execute("runxbe("+xhd_xbe_path+")");
+			return true;
+		}
+	case CONTEXT_BUTTON_XRESIZERXBE:
+		{
+			CBuiltins::Execute("runxbe("+xresizer_xbe_path+")");
+			return true;
+		}
+	case CONTEXT_BUTTON_GAMESAVES:
+		{
+			CStdString strTitleID;
+			CStdString strGameSavepath;
+			strTitleID.Format("%08X",CUtil::GetXbeID(item->GetPath()));
+			URIUtils::AddFileToFolder("E:\\udata\\",strTitleID,strGameSavepath);
+			g_windowManager.ActivateWindow(WINDOW_GAMESAVES,strGameSavepath);
+			return true;
+		}
+	case CONTEXT_BUTTON_LAUNCH_IN:
+		OnChooseVideoModeAndLaunch(itemNumber);
+		return true;
+	default:
+		break;
+	}
+	return CGUIMediaWindow::OnContextButton(itemNumber, button);
 }
 
 bool CGUIWindowPrograms::OnChooseVideoModeAndLaunch(int item)
 {
-  if (item < 0 || item >= m_vecItems->Size()) return false;
-  // calculate our position
-  float posX = 200;
-  float posY = 100;
-  const CGUIControl *pList = GetControl(CONTROL_LIST);
-  if (pList)
-  {
-    posX = pList->GetXPosition() + pList->GetWidth() / 2;
-    posY = pList->GetYPosition() + pList->GetHeight() / 2;
-  }
+	if (item < 0 || item >= m_vecItems->Size()) return false;
+	// calculate our position
+	float posX = 200;
+	float posY = 100;
+	const CGUIControl *pList = GetControl(CONTROL_LIST);
+	if (pList)
+	{
+		posX = pList->GetXPosition() + pList->GetWidth() / 2;
+		posY = pList->GetYPosition() + pList->GetHeight() / 2;
+	}
 
-  // grab the context menu
-  CGUIDialogContextMenu *pMenu = (CGUIDialogContextMenu *)g_windowManager.GetWindow(WINDOW_DIALOG_CONTEXT_MENU);
-  if (!pMenu) return false;
+	// grab the context menu
+	CGUIDialogContextMenu *pMenu = (CGUIDialogContextMenu *)g_windowManager.GetWindow(WINDOW_DIALOG_CONTEXT_MENU);
+	if (!pMenu) return false;
 
-  pMenu->Initialize();
+	pMenu->Initialize();
 
-  int btn_PAL;
-  int btn_NTSCM;
-  int btn_NTSCJ;
-  int btn_PAL60;
-  CStdString strPAL, strNTSCJ, strNTSCM, strPAL60;
-  strPAL = "PAL";
-  strNTSCM = "NTSC-M";
-  strNTSCJ = "NTSC-J";
-  strPAL60 = "PAL-60";
-  int iRegion = GetRegion(item,true);
+	int btn_PAL;
+	int btn_NTSCM;
+	int btn_NTSCJ;
+	int btn_PAL60;
+	CStdString strPAL, strNTSCJ, strNTSCM, strPAL60;
+	strPAL = "PAL";
+	strNTSCM = "NTSC-M";
+	strNTSCJ = "NTSC-J";
+	strPAL60 = "PAL-60";
+	int iRegion = GetRegion(item,true);
 
-  if (iRegion == VIDEO_NTSCM)
-    strNTSCM += " (default)";
-  if (iRegion == VIDEO_NTSCJ)
-    strNTSCJ += " (default)";
-  if (iRegion == VIDEO_PAL50)
-    strPAL += " (default)";
+	if (iRegion == VIDEO_NTSCM)
+	strNTSCM += " (default)";
+	if (iRegion == VIDEO_NTSCJ)
+	strNTSCJ += " (default)";
+	if (iRegion == VIDEO_PAL50)
+	strPAL += " (default)";
 
-  btn_PAL = pMenu->AddButton(strPAL);
-  btn_NTSCM = pMenu->AddButton(strNTSCM);
-  btn_NTSCJ = pMenu->AddButton(strNTSCJ);
-  btn_PAL60 = pMenu->AddButton(strPAL60);
+	btn_PAL = pMenu->AddButton(strPAL);
+	btn_NTSCM = pMenu->AddButton(strNTSCM);
+	btn_NTSCJ = pMenu->AddButton(strNTSCJ);
+	btn_PAL60 = pMenu->AddButton(strPAL60);
 
-  pMenu->OffsetPosition(posX, posY);
-  pMenu->DoModal();
-  int btnid = pMenu->GetButton();
+	pMenu->OffsetPosition(posX, posY);
+	pMenu->DoModal();
+	int btnid = pMenu->GetButton();
 
-  if (btnid == btn_NTSCM)
-  {
-    m_iRegionSet = VIDEO_NTSCM;
-    m_database.SetRegion(m_vecItems->Get(item)->GetPath(),1);
-  }
-  if (btnid == btn_NTSCJ)
-  {
-    m_iRegionSet = VIDEO_NTSCJ;
-    m_database.SetRegion(m_vecItems->Get(item)->GetPath(),2);
-  }
-  if (btnid == btn_PAL)
-  {
-    m_iRegionSet = VIDEO_PAL50;
-    m_database.SetRegion(m_vecItems->Get(item)->GetPath(),4);
-  }
-  if (btnid == btn_PAL60)
-  {
-    m_iRegionSet = VIDEO_PAL60;
-    m_database.SetRegion(m_vecItems->Get(item)->GetPath(),8);
-  }
+	if (btnid == btn_NTSCM)
+	{
+		m_iRegionSet = VIDEO_NTSCM;
+		m_database.SetRegion(m_vecItems->Get(item)->GetPath(),1);
+	}
+	if (btnid == btn_NTSCJ)
+	{
+		m_iRegionSet = VIDEO_NTSCJ;
+		m_database.SetRegion(m_vecItems->Get(item)->GetPath(),2);
+	}
+	if (btnid == btn_PAL)
+	{
+		m_iRegionSet = VIDEO_PAL50;
+		m_database.SetRegion(m_vecItems->Get(item)->GetPath(),4);
+	}
+	if (btnid == btn_PAL60)
+	{
+		m_iRegionSet = VIDEO_PAL60;
+		m_database.SetRegion(m_vecItems->Get(item)->GetPath(),8);
+	}
 
-  if (btnid > -1)
-    return OnClick(item);
+	if (btnid > -1)
+	return OnClick(item);
 
-  return true;
+	return true;
 }
 
 bool CGUIWindowPrograms::Update(const CStdString &strDirectory)
 {
-  if (m_thumbLoader.IsLoading())
-    m_thumbLoader.StopThread();
+	if (m_thumbLoader.IsLoading())
+	m_thumbLoader.StopThread();
 
-  if (!CGUIMediaWindow::Update(strDirectory))
-    return false;
+	if (!CGUIMediaWindow::Update(strDirectory))
+	return false;
 
-  m_thumbLoader.Load(*m_vecItems);
-  return true;
+	m_thumbLoader.Load(*m_vecItems);
+	return true;
 }
 
 bool CGUIWindowPrograms::OnPlayMedia(int iItem)
 {
-  if ( iItem < 0 || iItem >= (int)m_vecItems->Size() ) return false;
-  CFileItemPtr pItem = m_vecItems->Get(iItem);
+	if ( iItem < 0 || iItem >= (int)m_vecItems->Size() ) return false;
+	CFileItemPtr pItem = m_vecItems->Get(iItem);
 
-  if (pItem->IsDVD())
-    return MEDIA_DETECT::CAutorun::PlayDisc();
+	if (pItem->IsDVD())
+	return MEDIA_DETECT::CAutorun::PlayDisc();
 
-  if (pItem->m_bIsFolder) return false;
+	if (pItem->m_bIsFolder) return false;
 
-  // launch xbe...
-  char szPath[1024];
-  char szParameters[1024];
+	if (!CFile::Exists(pItem->GetPath()) && g_guiSettings.GetBool("mygames.slowgameparsing"))
+	{
+	CGUIDialogOK *dialog = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_OK);
+	if (dialog)
+	{
+		dialog->SetHeading(g_localizeStrings.Get(33049));
+		dialog->SetLine(0, "No default.xbe found for this item.");
+		dialog->SetLine(1, "Disable fast game parsing if this is a folder or you will have");
+		dialog->SetLine(2, "to fix this game.");
+		dialog->DoModal();
+	}
+		return false;
+	}
 
-  m_database.IncTimesPlayed(pItem->GetPath());
+	// launch xbe...
+	char szPath[1024];
+	char szParameters[1024];
 
-  int iRegion = m_iRegionSet?m_iRegionSet:GetRegion(iItem);
+	m_database.IncTimesPlayed(pItem->GetPath());
 
-  DWORD dwTitleId = 0;
-  if (!pItem->IsOnDVD())
-    dwTitleId = m_database.GetTitleId(pItem->GetPath());
-  if (!dwTitleId)
-    dwTitleId = CUtil::GetXbeID(pItem->GetPath());
-  CStdString strTrainer = m_database.GetActiveTrainer(dwTitleId);
-  if (strTrainer != "")
-  {
-    CTrainer trainer;
-    if (trainer.Load(strTrainer))
-    {
-      m_database.GetTrainerOptions(strTrainer,dwTitleId,trainer.GetOptions(),trainer.GetNumberOfOptions());
-      CUtil::InstallTrainer(trainer);
-    }
-  }
+	int iRegion = m_iRegionSet?m_iRegionSet:GetRegion(iItem);
 
-  m_database.Close();
-  memset(szParameters, 0, sizeof(szParameters));
+	DWORD dwTitleId = 0;
+	if (!pItem->IsOnDVD())
+	dwTitleId = m_database.GetTitleId(pItem->GetPath());
+	if (!dwTitleId)
+	dwTitleId = CUtil::GetXbeID(pItem->GetPath());
+	CStdString strTrainer = m_database.GetActiveTrainer(dwTitleId);
+	if (strTrainer != "")
+	{
+		CTrainer trainer;
+		if (trainer.Load(strTrainer))
+		{
+			m_database.GetTrainerOptions(strTrainer,dwTitleId,trainer.GetOptions(),trainer.GetNumberOfOptions());
+			CUtil::InstallTrainer(trainer);
+		}
+	}
 
-  strcpy(szPath, pItem->GetPath().c_str());
+	m_database.Close();
 
-  if (pItem->IsShortCut())
-  {
-    CUtil::RunShortcut(pItem->GetPath().c_str());
-    return false;
-  }
+	// CBuiltins::Execute("Skin.SetBool(showloading)");
+	// Sleep(3000);
 
-  if (strlen(szParameters))
-    CUtil::RunXBE(szPath, szParameters,F_VIDEO(iRegion));
-  else
-    CUtil::RunXBE(szPath,NULL,F_VIDEO(iRegion));
-  return true;
+	memset(szParameters, 0, sizeof(szParameters));
+
+	strcpy(szPath, pItem->GetPath().c_str());
+
+	if (pItem->IsShortCut())
+	{
+		CUtil::RunShortcut(pItem->GetPath().c_str());
+		return false;
+	}
+	
+	if (strlen(szParameters))
+	CUtil::RunXBE(szPath, szParameters,F_VIDEO(iRegion));
+	else
+	CUtil::RunXBE(szPath,NULL,F_VIDEO(iRegion));
+	return true;
 }
 
 int CGUIWindowPrograms::GetRegion(int iItem, bool bReload)
 {
-  if (!g_guiSettings.GetBool("myprograms.gameautoregion"))
-    return 0;
+	if (!g_guiSettings.GetBool("myprograms.gameautoregion"))
+	return 0;
 
-  int iRegion;
-  if (bReload || m_vecItems->Get(iItem)->IsOnDVD())
-  {
-    CXBE xbe;
-    iRegion = xbe.ExtractGameRegion(m_vecItems->Get(iItem)->GetPath());
-  }
-  else
-  {
-    m_database.Open();
-    iRegion = m_database.GetRegion(m_vecItems->Get(iItem)->GetPath());
-    m_database.Close();
-  }
-  if (iRegion == -1)
-  {
-    if (g_guiSettings.GetBool("myprograms.gameautoregion"))
-    {
-      CXBE xbe;
-      iRegion = xbe.ExtractGameRegion(m_vecItems->Get(iItem)->GetPath());
-      if (iRegion < 1 || iRegion > 7)
-        iRegion = 0;
-      m_database.SetRegion(m_vecItems->Get(iItem)->GetPath(),iRegion);
-    }
-    else
-      iRegion = 0;
-  }
+	int iRegion;
+	if (bReload || m_vecItems->Get(iItem)->IsOnDVD())
+	{
+		CXBE xbe;
+		iRegion = xbe.ExtractGameRegion(m_vecItems->Get(iItem)->GetPath());
+	}
+	else
+	{
+		m_database.Open();
+		iRegion = m_database.GetRegion(m_vecItems->Get(iItem)->GetPath());
+		m_database.Close();
+	}
+	if (iRegion == -1)
+	{
+		if (g_guiSettings.GetBool("myprograms.gameautoregion"))
+		{
+			CXBE xbe;
+			iRegion = xbe.ExtractGameRegion(m_vecItems->Get(iItem)->GetPath());
+			if (iRegion < 1 || iRegion > 7)
+			iRegion = 0;
+			m_database.SetRegion(m_vecItems->Get(iItem)->GetPath(),iRegion);
+		}
+		else
+		iRegion = 0;
+	}
 
-  if (bReload)
-    return CXBE::FilterRegion(iRegion,true);
-  else
-    return CXBE::FilterRegion(iRegion);
+	if (bReload)
+	return CXBE::FilterRegion(iRegion,true);
+	else
+	return CXBE::FilterRegion(iRegion);
 }
 
 void CGUIWindowPrograms::PopulateTrainersList()
 {
-  CDirectory directory;
-  CFileItemList trainers;
-  CFileItemList archives;
-  CFileItemList inArchives;
-  // first, remove any dead items
-  std::vector<CStdString> vecTrainerPath;
-  m_database.GetAllTrainers(vecTrainerPath);
-  CGUIDialogProgress* m_dlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
-  m_dlgProgress->SetLine(0,12023);
-  m_dlgProgress->SetLine(1,"");
-  m_dlgProgress->SetLine(2,"");
-  m_dlgProgress->StartModal();
-  m_dlgProgress->SetHeading(12012);
-  m_dlgProgress->ShowProgressBar(true);
-  m_dlgProgress->Progress();
+	CDirectory directory;
+	CFileItemList trainers;
+	CFileItemList archives;
+	CFileItemList inArchives;
+	// first, remove any dead items
+	std::vector<CStdString> vecTrainerPath;
+	m_database.GetAllTrainers(vecTrainerPath);
+	CGUIDialogProgress* m_dlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+	m_dlgProgress->SetLine(0,12023);
+	m_dlgProgress->SetLine(1,"");
+	m_dlgProgress->SetLine(2,"");
+	m_dlgProgress->StartModal();
+	m_dlgProgress->SetHeading(12012);
+	m_dlgProgress->ShowProgressBar(true);
+	m_dlgProgress->Progress();
 
-  bool bBreak=false;
-  bool bDatabaseState = m_database.IsOpen();
-  if (!bDatabaseState)
-    m_database.Open();
-  m_database.BeginTransaction();
-  for (unsigned int i=0;i<vecTrainerPath.size();++i)
-  {
-    m_dlgProgress->SetPercentage((int)((float)i/(float)vecTrainerPath.size()*100.f));
-    CStdString strLine;
-    strLine.Format("%s %i / %i",g_localizeStrings.Get(12013).c_str(), i+1,vecTrainerPath.size());
-    m_dlgProgress->SetLine(1,strLine);
-    m_dlgProgress->Progress();
-    if (!CFile::Exists(vecTrainerPath[i]) || vecTrainerPath[i].find(g_guiSettings.GetString("myprograms.trainerpath",false)) == -1)
-      m_database.RemoveTrainer(vecTrainerPath[i]);
-    if (m_dlgProgress->IsCanceled())
-    {
-      bBreak = true;
-      m_database.RollbackTransaction();
-      break;
-    }
-  }
-  if (!bBreak)
-  {
-    CLog::Log(LOGDEBUG,"trainerpath %s",g_guiSettings.GetString("myprograms.trainerpath",false).c_str());
-    directory.GetDirectory(g_guiSettings.GetString("myprograms.trainerpath").c_str(),trainers,".xbtf|.etm");
-    if (g_guiSettings.GetString("myprograms.trainerpath",false).IsEmpty())
-    {
-      m_database.RollbackTransaction();
-      m_dlgProgress->Close();
+	bool bBreak=false;
+	bool bDatabaseState = m_database.IsOpen();
+	if (!bDatabaseState)
+	m_database.Open();
+	m_database.BeginTransaction();
+	for (unsigned int i=0;i<vecTrainerPath.size();++i)
+	{
+		m_dlgProgress->SetPercentage((int)((float)i/(float)vecTrainerPath.size()*100.f));
+		CStdString strLine;
+		strLine.Format("%s %i / %i",g_localizeStrings.Get(12013).c_str(), i+1,vecTrainerPath.size());
+		m_dlgProgress->SetLine(1,strLine);
+		m_dlgProgress->Progress();
+		if (!CFile::Exists(vecTrainerPath[i]) || vecTrainerPath[i].find(g_guiSettings.GetString("myprograms.trainerpath",false)) == -1)
+		m_database.RemoveTrainer(vecTrainerPath[i]);
+		if (m_dlgProgress->IsCanceled())
+		{
+			bBreak = true;
+			m_database.RollbackTransaction();
+			break;
+		}
+	}
+	if (!bBreak)
+	{
+		CLog::Log(LOGDEBUG,"trainerpath %s",g_guiSettings.GetString("myprograms.trainerpath",false).c_str());
+		directory.GetDirectory(g_guiSettings.GetString("myprograms.trainerpath").c_str(),trainers,".xbtf|.etm");
+		if (g_guiSettings.GetString("myprograms.trainerpath",false).IsEmpty())
+		{
+			m_database.RollbackTransaction();
+			m_dlgProgress->Close();
 
-      return;
-    }
+			return;
+		}
 
-    directory.GetDirectory(g_guiSettings.GetString("myprograms.trainerpath").c_str(),archives,".rar|.zip",false); // TODO: ZIP SUPPORT
-    for( int i=0;i<archives.Size();++i)
-    {
-      if (stricmp(URIUtils::GetExtension(archives[i]->GetPath()),".rar") == 0)
-      {
-        g_RarManager.GetFilesInRar(inArchives,archives[i]->GetPath(),false);
-        CHDDirectory dir;
-        dir.SetMask(".xbtf|.etm");
-        for (int j=0;j<inArchives.Size();++j)
-          if (dir.IsAllowed(inArchives[j]->GetPath()))
-          {
-            CFileItemPtr item(new CFileItem(*inArchives[j]));
-            CStdString strPathInArchive = item->GetPath();
-            CStdString path;
-            URIUtils::CreateArchivePath(path, "rar", archives[i]->GetPath(), strPathInArchive,"");
-            item->SetPath(path);
-            trainers.Add(item);
-          }
-      }
-      if (stricmp(URIUtils::GetExtension(archives[i]->GetPath()),".zip")==0)
-      {
-        // add trainers in zip
-        CStdString strZipPath;
-        URIUtils::CreateArchivePath(strZipPath,"zip",archives[i]->GetPath(),"");
-        CFileItemList zipTrainers;
-        directory.GetDirectory(strZipPath,zipTrainers,".etm|.xbtf");
-        for (int j=0;j<zipTrainers.Size();++j)
-        {
-          CFileItemPtr item(new CFileItem(*zipTrainers[j]));
-          trainers.Add(item);
-        }
-      }
-    }
-    if (!m_dlgProgress)
-      m_dlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
-    m_dlgProgress->SetPercentage(0);
-    m_dlgProgress->ShowProgressBar(true);
+		directory.GetDirectory(g_guiSettings.GetString("myprograms.trainerpath").c_str(),archives,".rar|.zip",false); // TODO: ZIP SUPPORT
+		for( int i=0;i<archives.Size();++i)
+		{
+			if (stricmp(URIUtils::GetExtension(archives[i]->GetPath()),".rar") == 0)
+			{
+				g_RarManager.GetFilesInRar(inArchives,archives[i]->GetPath(),false);
+				CHDDirectory dir;
+				dir.SetMask(".xbtf|.etm");
+				for (int j=0;j<inArchives.Size();++j)
+				if (dir.IsAllowed(inArchives[j]->GetPath()))
+				{
+					CFileItemPtr item(new CFileItem(*inArchives[j]));
+					CStdString strPathInArchive = item->GetPath();
+					CStdString path;
+					URIUtils::CreateArchivePath(path, "rar", archives[i]->GetPath(), strPathInArchive,"");
+					item->SetPath(path);
+					trainers.Add(item);
+				}
+			}
+			if (stricmp(URIUtils::GetExtension(archives[i]->GetPath()),".zip")==0)
+			{
+				// add trainers in zip
+				CStdString strZipPath;
+				URIUtils::CreateArchivePath(strZipPath,"zip",archives[i]->GetPath(),"");
+				CFileItemList zipTrainers;
+				directory.GetDirectory(strZipPath,zipTrainers,".etm|.xbtf");
+				for (int j=0;j<zipTrainers.Size();++j)
+				{
+					CFileItemPtr item(new CFileItem(*zipTrainers[j]));
+					trainers.Add(item);
+				}
+			}
+		}
+		if (!m_dlgProgress)
+		m_dlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+		m_dlgProgress->SetPercentage(0);
+		m_dlgProgress->ShowProgressBar(true);
 
-    CLog::Log(LOGDEBUG,"# trainers %i",trainers.Size());
-    m_dlgProgress->SetLine(1,"");
-    int j=0;
-    while (j < trainers.Size())
-    {
-      if (trainers[j]->m_bIsFolder)
-        trainers.Remove(j);
-      else
-        j++;
-    }
-    for (int i=0;i<trainers.Size();++i)
-    {
-      CLog::Log(LOGDEBUG,"found trainer %s",trainers[i]->GetPath().c_str());
-      m_dlgProgress->SetPercentage((int)((float)(i)/trainers.Size()*100.f));
-      CStdString strLine;
-      strLine.Format("%s %i / %i",g_localizeStrings.Get(12013).c_str(), i+1,trainers.Size());
-      m_dlgProgress->SetLine(0,strLine);
-      m_dlgProgress->SetLine(2,"");
-      m_dlgProgress->Progress();
-      if (m_database.HasTrainer(trainers[i]->GetPath())) // skip existing trainers
-        continue;
+		CLog::Log(LOGDEBUG,"# trainers %i",trainers.Size());
+		m_dlgProgress->SetLine(1,"");
+		int j=0;
+		while (j < trainers.Size())
+		{
+			if (trainers[j]->m_bIsFolder)
+			trainers.Remove(j);
+			else
+			j++;
+		}
+		for (int i=0;i<trainers.Size();++i)
+		{
+			CLog::Log(LOGDEBUG,"found trainer %s",trainers[i]->GetPath().c_str());
+			m_dlgProgress->SetPercentage((int)((float)(i)/trainers.Size()*100.f));
+			CStdString strLine;
+			strLine.Format("%s %i / %i",g_localizeStrings.Get(12013).c_str(), i+1,trainers.Size());
+			m_dlgProgress->SetLine(0,strLine);
+			m_dlgProgress->SetLine(2,"");
+			m_dlgProgress->Progress();
+			if (m_database.HasTrainer(trainers[i]->GetPath())) // skip existing trainers
+			continue;
 
-      CTrainer trainer;
-      if (trainer.Load(trainers[i]->GetPath()))
-      {
-        m_dlgProgress->SetLine(1,trainer.GetName());
-        m_dlgProgress->SetLine(2,"");
-        m_dlgProgress->Progress();
-        unsigned int iTitle1, iTitle2, iTitle3;
-        trainer.GetTitleIds(iTitle1,iTitle2,iTitle3);
-        if (iTitle1)
-          m_database.AddTrainer(iTitle1,trainers[i]->GetPath());
-        if (iTitle2)
-          m_database.AddTrainer(iTitle2,trainers[i]->GetPath());
-        if (iTitle3)
-          m_database.AddTrainer(iTitle3,trainers[i]->GetPath());
-      }
-      if (m_dlgProgress->IsCanceled())
-      {
-        m_database.RollbackTransaction();
-        break;
-      }
-    }
-  }
-  m_database.CommitTransaction();
-  m_dlgProgress->Close();
+			CTrainer trainer;
+			if (trainer.Load(trainers[i]->GetPath()))
+			{
+				m_dlgProgress->SetLine(1,trainer.GetName());
+				m_dlgProgress->SetLine(2,"");
+				m_dlgProgress->Progress();
+				unsigned int iTitle1, iTitle2, iTitle3;
+				trainer.GetTitleIds(iTitle1,iTitle2,iTitle3);
+				if (iTitle1)
+				m_database.AddTrainer(iTitle1,trainers[i]->GetPath());
+				if (iTitle2)
+				m_database.AddTrainer(iTitle2,trainers[i]->GetPath());
+				if (iTitle3)
+				m_database.AddTrainer(iTitle3,trainers[i]->GetPath());
+			}
+			if (m_dlgProgress->IsCanceled())
+			{
+				m_database.RollbackTransaction();
+				break;
+			}
+		}
+	}
+	m_database.CommitTransaction();
+	m_dlgProgress->Close();
 
-  if (!bDatabaseState)
-    m_database.Close();
-  else
-    Update(m_vecItems->GetPath());
+	if (!bDatabaseState)
+	m_database.Close();
+	else
+	Update(m_vecItems->GetPath());
 }
 
 bool CGUIWindowPrograms::GetDirectory(const CStdString &strDirectory, CFileItemList &items)
 {
-  bool bFlattened=false;
-  if (URIUtils::IsDVD(strDirectory))
-  {
-    CStdString strPath;
-    URIUtils::AddFileToFolder(strDirectory,"default.xbe",strPath);
-    if (CFile::Exists(strPath)) // flatten dvd
-    {
-      CFileItemPtr item(new CFileItem("default.xbe"));
-      item->SetPath(strPath);
-      items.Add(item);
-      items.SetPath(strDirectory);
-      bFlattened = true;
-    }
-  }
-  if (!bFlattened)
-    if (!CGUIMediaWindow::GetDirectory(strDirectory, items))
-      return false;
+	bool bFlattened=false;
+	if (URIUtils::IsDVD(strDirectory))
+	{
+		CStdString strPath;
+		URIUtils::AddFileToFolder(strDirectory,"default.xbe",strPath);
+		if (CFile::Exists(strPath)) // flatten dvd
+		{
+			CFileItemPtr item(new CFileItem("default.xbe"));
+			item->SetPath(strPath);
+			items.Add(item);
+			items.SetPath(strDirectory);
+			bFlattened = true;
+		}
+	}
+	if (!bFlattened)
+	if (!CGUIMediaWindow::GetDirectory(strDirectory, items))
+	return false;
 
-  if (items.IsVirtualDirectoryRoot())
-  {
-    items.SetLabel("");
-    return true;
-  }
+	if (items.IsVirtualDirectoryRoot())
+	{
+		items.SetLabel("");
+		return true;
+	}
 
-  if (strDirectory.Equals("plugin://programs/"))
-  {
-    items.SetContent("plugins");
-    items.SetLabel(g_localizeStrings.Get(24001));
-  }
+	if (strDirectory.Equals("plugin://programs/"))
+	{
+		items.SetContent("plugins");
+		items.SetLabel(g_localizeStrings.Get(24001));
+	}
 
-  // flatten any folders
-  m_database.BeginTransaction();
-  DWORD dwTick=timeGetTime();
-  bool bProgressVisible = false;
-  for (int i = 0; i < items.Size(); i++)
-  {
-    CStdString shortcutPath;
-    CFileItemPtr item = items[i];
-    if (!bProgressVisible && timeGetTime()-dwTick>1500 && m_dlgProgress)
-    { // tag loading takes more then 1.5 secs, show a progress dialog
-      m_dlgProgress->SetHeading(189);
-      m_dlgProgress->SetLine(0, 20120);
-      m_dlgProgress->SetLine(1,"");
-      m_dlgProgress->SetLine(2, item->GetLabel());
-      m_dlgProgress->StartModal();
-      bProgressVisible = true;
-    }
-    if (bProgressVisible)
-    {
-      m_dlgProgress->SetLine(2,item->GetLabel());
-      m_dlgProgress->Progress();
-    }
+	// flatten any folders
+	m_database.BeginTransaction();
+	DWORD dwTick=timeGetTime();
+	int fastgameparsing = g_guiSettings.GetBool("mygames.slowgameparsing");
+	int synopsisparsing = g_guiSettings.GetBool("mygames.usesynopsisname");
+	CBuiltins::Execute("Skin.SetString(disablecancel,true)");
+	bool bProgressVisible = false;
+	CStdString description;
+	m_dlgProgress->SetPercentage(0);
+	m_dlgProgress->ShowProgressBar(true);
+	for (int i = 0; i < items.Size(); i++)
+	{
+		m_dlgProgress->SetPercentage((int)((float)(i)/items.Size()*100.f));
+		CStdString shortcutPath;
+		CFileItemPtr item = items[i];
+		CStdString xml_path = item->GetPath();
 
-    if (item->m_bIsFolder && !item->IsParentFolder() && !item->IsPlugin())
-    { // folder item - let's check for a default.xbe file, and flatten if we have one
-      CStdString defaultXBE;
-      URIUtils::AddFileToFolder(item->GetPath(), "default.xbe", defaultXBE);
-      if (CFile::Exists(defaultXBE))
-      { // yes, format the item up
-        item->SetPath(defaultXBE);
-        item->m_bIsFolder = false;
-      }
-    }
-    else if (item->IsShortCut())
-    { // resolve the shortcut to set it's description etc.
-      // and save the old shortcut path (so we can reassign it later)
-      CShortcut cut;
-      if (cut.Create(item->GetPath()))
-      {
-        shortcutPath = item->GetPath();
-        item->SetPath(cut.m_strPath);
-        item->SetThumbnailImage(cut.m_strThumb);
+		if (item->m_bIsFolder && !item->IsParentFolder() && !item->IsPlugin())
+		{ // folder item - let's check for a default.xbe file, and flatten if we have one
+			CStdString defaultXBE;
+			URIUtils::AddFileToFolder(item->GetPath(), "default.xbe", defaultXBE);
+			if ( !fastgameparsing )
+			{
+				if (CFile::Exists(defaultXBE))
+				{
+					item->SetPath(defaultXBE);
+					item->m_bIsFolder = false;
+				}
+			}
+			else
+			{
+				item->SetPath(defaultXBE);
+				item->m_bIsFolder = false;
+			}
+		}
+		
+		else if (item->IsShortCut())
+		{ // resolve the shortcut to set it's description etc.
+			// and save the old shortcut path (so we can reassign it later)
+			CShortcut cut;
+			if (cut.Create(item->GetPath()))
+			{
+				shortcutPath = item->GetPath();
+				item->SetPath(cut.m_strPath);
+				item->SetThumbnailImage(cut.m_strThumb);
 
-        LABEL_MASKS labelMasks;
-        m_guiState->GetSortMethodLabelMasks(labelMasks);
-        CLabelFormatter formatter("", labelMasks.m_strLabel2File);
-        if (!cut.m_strLabel.IsEmpty())
-        {
-          item->SetLabel(cut.m_strLabel);
-          __stat64 stat;
-          if (CFile::Stat(item->GetPath(),&stat) == 0)
-            item->m_dwSize = stat.st_size;
+				LABEL_MASKS labelMasks;
+				m_guiState->GetSortMethodLabelMasks(labelMasks);
+				CLabelFormatter formatter("", labelMasks.m_strLabel2File);
+				if (!cut.m_strLabel.IsEmpty())
+				{
+					item->SetLabel(cut.m_strLabel);
+					__stat64 stat;
+					if (CFile::Stat(item->GetPath(),&stat) == 0)
+					item->m_dwSize = stat.st_size;
 
-          formatter.FormatLabel2(item.get());
-          item->SetLabelPreformated(true);
-        }
-      }
-    }
-    if (item->IsXBE())
-    {
-      if (URIUtils::GetFileName(item->GetPath()).Equals("default_ffp.xbe"))
-      {
-        m_vecItems->Remove(i--);
-        continue;
-      }
-      // add to database if not already there
-      DWORD dwTitleID = item->IsOnDVD() ? 0 : m_database.GetProgramInfo(item.get());
-      if (!dwTitleID)
-      {
-        CStdString description;
-        if (CUtil::GetXBEDescription(item->GetPath(), description) && (!item->IsLabelPreformated() && !item->GetLabel().IsEmpty()))
-          item->SetLabel(description);
+					formatter.FormatLabel2(item.get());
+					item->SetLabelPreformated(true);
+				}
+			}
+		}
+		if (item->IsXBE())
+		{
+			if (URIUtils::GetFileName(item->GetPath()).Equals("default_ffp.xbe"))
+			{
+				m_vecItems->Remove(i--);
+				continue;
+			}
+			else if (URIUtils::GetFileName(item->GetPath()).Equals("default_p.xbe"))
+			{
+				m_vecItems->Remove(i--);
+				continue;
+			}    
+			else if (URIUtils::GetFileName(item->GetPath()).Equals("defaultws.xbe"))
+			{
+				m_vecItems->Remove(i--);
+				continue;
+			}   
+			else if (URIUtils::GetFileName(item->GetPath()).Equals("defaultxhd.xbe"))
+			{
+				m_vecItems->Remove(i--);
+				continue;
+			}   
+			else if (URIUtils::GetFileName(item->GetPath()).Equals("default720p.xbe"))
+			{
+				m_vecItems->Remove(i--);
+				continue;
+			}
+			// add to database if not already there
+			DWORD dwTitleID = item->IsOnDVD() ? 0 : m_database.GetProgramInfo(item.get());
+			if (!dwTitleID)
+			{
+				if (!bProgressVisible)
+				{
+					m_dlgProgress->SetHeading(189);
+					m_dlgProgress->SetLine(0, 20120);
+					m_dlgProgress->SetLine(1,"");
+					m_dlgProgress->SetLine(2, "Initializing...");
+					m_dlgProgress->StartModal();
+					bProgressVisible = true;
+				}
+				if (CUtil::GetXBEDescription(item->GetPath(), description) && (!item->IsLabelPreformated() && !item->GetLabel().IsEmpty()))
+				{
+					// Get synopsis title for description if found and the settings is enabled
+					if (synopsisparsing)
+					{
+						URIUtils::AddFileToFolder(xml_path,"_resources\\default.xml",xml_path);
+						if (CFile::Exists(xml_path))
+						{
+							TiXmlDocument xml_path_load;
+							xml_path_load.LoadFile(xml_path);
+							TiXmlElement *pRootElement = xml_path_load.RootElement();
+							if (pRootElement)
+							{
+								XMLUtils::GetString(pRootElement,"title", description);
+							}
+						}
+					}
+					item->SetLabel(description);
+					if (bProgressVisible)
+					{
+						m_dlgProgress->SetLine(2,description);
+						m_dlgProgress->Progress();
+					}
+				}
+				dwTitleID = CUtil::GetXbeID(item->GetPath());
+				if (!item->IsOnDVD())
+				m_database.AddProgramInfo(item.get(), dwTitleID);
+			}
+			// SetOverlayIcons()
+			if (m_database.ItemHasTrainer(dwTitleID))
+			{
+				if (m_database.GetActiveTrainer(dwTitleID) != "")
+				item->SetOverlayImage(CGUIListItem::ICON_OVERLAY_TRAINED);
+				else
+				item->SetOverlayImage(CGUIListItem::ICON_OVERLAY_HAS_TRAINER);
+			}
+		}
+		if (!shortcutPath.IsEmpty())
+		item->SetPath(shortcutPath);
+	}
+	m_database.CommitTransaction();
+	// set the cached thumbs
+	items.SetThumbnailImage("");
+	items.SetCachedProgramThumbs();
+	items.SetCachedProgramThumb();
+	if (!items.HasThumbnail())
+	items.SetUserProgramThumb();
 
-        dwTitleID = CUtil::GetXbeID(item->GetPath());
-        if (!item->IsOnDVD())
-          m_database.AddProgramInfo(item.get(), dwTitleID);
-      }
+	if (bProgressVisible)
+	m_dlgProgress->Close();
+	CBuiltins::Execute("Skin.SetString(disablecancel,)");
 
-      // SetOverlayIcons()
-      if (m_database.ItemHasTrainer(dwTitleID))
-      {
-        if (m_database.GetActiveTrainer(dwTitleID) != "")
-          item->SetOverlayImage(CGUIListItem::ICON_OVERLAY_TRAINED);
-        else
-          item->SetOverlayImage(CGUIListItem::ICON_OVERLAY_HAS_TRAINER);
-      }
-    }
-    if (!shortcutPath.IsEmpty())
-      item->SetPath(shortcutPath);
-  }
-  m_database.CommitTransaction();
-  // set the cached thumbs
-  items.SetThumbnailImage("");
-  items.SetCachedProgramThumbs();
-  items.SetCachedProgramThumb();
-  if (!items.HasThumbnail())
-    items.SetUserProgramThumb();
-
-  if (bProgressVisible)
-    m_dlgProgress->Close();
-
-  return true;
+	return true;
 }
 
 CStdString CGUIWindowPrograms::GetStartFolder(const CStdString &dir)
 {
-  if (dir.Equals("Plugins") || dir.Equals("Addons"))
-    return "plugin://programs/";
-    
-  SetupShares();
-  VECSOURCES shares;
-  m_rootDir.GetSources(shares);
-  bool bIsSourceName = false;
-  int iIndex = CUtil::GetMatchingSource(dir, shares, bIsSourceName);
-  if (iIndex > -1)
-  {
-    if (iIndex < (int)shares.size() && shares[iIndex].m_iHasLock == 2)
-    {
-      CFileItem item(shares[iIndex]);
-      if (!g_passwordManager.IsItemUnlocked(&item,"programs"))
-        return "";
-    }
-    if (bIsSourceName)
-      return shares[iIndex].strPath;
-    return dir;
-  }
-  return CGUIMediaWindow::GetStartFolder(dir);
-}
+	if (dir.Equals("Plugins") || dir.Equals("Addons"))
+	return "plugin://programs/";
+	
+	SetupShares();
+	VECSOURCES shares;
+	m_rootDir.GetSources(shares);
+	bool bIsSourceName = false;
+	int iIndex = CUtil::GetMatchingSource(dir, shares, bIsSourceName);
+	if (iIndex > -1)
+	{
+		if (iIndex < (int)shares.size() && shares[iIndex].m_iHasLock == 2)
+		{
+			CFileItem item(shares[iIndex]);
+			if (!g_passwordManager.IsItemUnlocked(&item,"programs"))
+			return "";
+		}
+		if (bIsSourceName)
+		return shares[iIndex].strPath;
+		return dir;
+	}
+	return CGUIMediaWindow::GetStartFolder(dir);
+}
\ No newline at end of file
Index: xbmc/programs/GUIWindowPrograms.h
===================================================================
--- xbmc/programs/GUIWindowPrograms.h	(revision 33042)
+++ xbmc/programs/GUIWindowPrograms.h	(working copy)
@@ -25,6 +25,9 @@
 #include "dialogs/GUIDialogProgress.h"
 #include "ThumbLoader.h"
 
+
+class TiXmlElement;
+
 class CGUIWindowPrograms :
       public CGUIMediaWindow, public IBackgroundLoaderObserver
 {
Index: xbmc/ScriptSettings.cpp
===================================================================
--- xbmc/ScriptSettings.cpp	(revision 33042)
+++ xbmc/ScriptSettings.cpp	(working copy)
@@ -37,10 +37,10 @@
 
   // create the users filepath
   URIUtils::RemoveSlashAtEnd(m_scriptPath);
-  if (m_scriptPath.Find("special://home/plugins/") >= 0)
+  if (m_scriptPath.Find("special://home/system/plugins/") >= 0)
   {
     CStdString userPath = m_scriptPath;
-    userPath.Replace("special://home/plugins/", "plugin://");
+    userPath.Replace("special://home/system/plugins/", "plugin://");
     CURL url(userPath);
     m_userFileName.Format("special://profile/plugin_data/%s/%s", url.GetHostName(), url.GetFileName());
   }
Index: xbmc/SectionLoader.cpp
===================================================================
--- xbmc/SectionLoader.cpp	(revision 33042)
+++ xbmc/SectionLoader.cpp	(working copy)
@@ -29,7 +29,8 @@
 class CSectionLoader g_sectionLoader;
 
 //  delay for unloading dll's
-#define UNLOAD_DELAY 10*1000 // 10 sec.
+// #define UNLOAD_DELAY 10*1000 // 10 sec.
+#define UNLOAD_DELAY 500 // 0.5 sec.
 
 //Define this to get loggin on all calls to load/unload sections/dlls
 //#define LOGALL
Index: xbmc/settings/AdvancedSettings.cpp
===================================================================
--- xbmc/settings/AdvancedSettings.cpp	(revision 33042)
+++ xbmc/settings/AdvancedSettings.cpp	(working copy)
@@ -101,6 +101,10 @@
   m_usePCDVDROM = false;
   m_fullScreenOnMovieStart = true;
   m_noDVDROM = false;
+  m_enableintro = false;
+  m_fastscanning = true;
+  m_slowscrolling = true;
+  m_splashImage = true;
   m_cachePath = "Z:\\";
   m_displayRemoteCodes = false;
 
@@ -214,7 +218,7 @@
 
   m_bPythonVerbose = false;
 
-  m_bgInfoLoaderMaxThreads = 1;
+  m_bgInfoLoaderMaxThreads = 3;
 }
 
 bool CAdvancedSettings::Load()
@@ -446,6 +450,10 @@
 
   XMLUtils::GetBoolean(pRootElement, "usepcdvdrom", m_usePCDVDROM);
   XMLUtils::GetBoolean(pRootElement, "nodvdrom", m_noDVDROM);
+  XMLUtils::GetBoolean(pRootElement, "enableintro", m_enableintro);
+  XMLUtils::GetBoolean(pRootElement, "fasterscanning", m_fastscanning);
+  XMLUtils::GetBoolean(pRootElement, "slowscrolling", m_slowscrolling);
+  XMLUtils::GetBoolean(pRootElement, "splash", m_splashImage);
   XMLUtils::GetBoolean(pRootElement, "disablemodchipdetection", m_DisableModChipDetection);
   XMLUtils::GetBoolean(pRootElement, "powersave", m_bPowerSave);
 
@@ -694,7 +702,7 @@
   }
 
   XMLUtils::GetInt(pRootElement, "bginfoloadermaxthreads", m_bgInfoLoaderMaxThreads);
-  m_bgInfoLoaderMaxThreads = std::max(1, m_bgInfoLoaderMaxThreads);
+  m_bgInfoLoaderMaxThreads = std::max(3, m_bgInfoLoaderMaxThreads);
 
   // load in the GUISettings overrides:
   g_guiSettings.LoadXML(pRootElement, true);  // true to hide the settings we read in
Index: xbmc/settings/AdvancedSettings.h
===================================================================
--- xbmc/settings/AdvancedSettings.h	(revision 33042)
+++ xbmc/settings/AdvancedSettings.h	(working copy)
@@ -117,6 +117,10 @@
     bool m_usePCDVDROM;
     bool m_fullScreenOnMovieStart;
     bool m_noDVDROM;
+    bool m_enableintro;
+    bool m_fastscanning;
+    bool m_slowscrolling;
+    bool m_splashImage;
     CStdString m_cachePath;
     bool m_displayRemoteCodes;
     CStdString m_videoCleanDateTimeRegExp;
Index: xbmc/settings/GUIDialogProfileSettings.cpp
===================================================================
--- xbmc/settings/GUIDialogProfileSettings.cpp	(revision 33042)
+++ xbmc/settings/GUIDialogProfileSettings.cpp	(working copy)
@@ -98,16 +98,25 @@
 {
   // clear out any old settings
   m_settings.clear();
-
-  AddButton(1,20093);
+  
+// Rocky5 Edits // 
+	if (m_strName.IsEmpty())
+	{
+		if (CGUIDialogKeyboard::ShowAndGetInput(m_strName,g_localizeStrings.Get(20093),false))
+		{
+			m_bNeedSave = true;
+			SET_CONTROL_LABEL(1000,m_strName);
+		}
+	}
+//  AddButton(1,20093);
   AddButton(2,20065);
   if (!m_bIsDefault && m_bShowDetails)
-    AddButton(3,20070);
+//    AddButton(3,20070);
 
   if (m_bShowDetails)
-    AddButton(4,20066);
+//    AddButton(4,20066);
   if (!m_bShowDetails && m_locks.mode == LOCK_MODE_EVERYONE && g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE)
-    AddButton(4,20066);
+//    AddButton(4,20066);
 
   if (!m_bIsDefault && m_bShowDetails)
   {
@@ -240,7 +249,7 @@
       strDirectory = share.strPath;
     else
       strDirectory = URIUtils::AddFileToFolder("special://masterprofile/",m_strDirectory);
-    if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares,g_localizeStrings.Get(657),strDirectory,true))
+// Rocky5 Edits //    if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares,g_localizeStrings.Get(657),strDirectory,true))
     {
       m_strDirectory = strDirectory;
       if (!m_bIsDefault)
@@ -345,8 +354,35 @@
       g_settings.AddProfile(profile);
       bool bExists = CFile::Exists(URIUtils::AddFileToFolder("special://masterprofile/",
                                                           dialog->m_strDirectory+"/guisettings.xml"));
+// // Rocky5 Edits // New code
+	if (bExists)
+        if (!CGUIDialogYesNo::ShowAndGetInput(20058,20104,20105,20022))
+          bExists = false;
 
+      if (!bExists)
+      {
+        // create some new settings
+        CGUISettings localSettings;
+        CStdString path = URIUtils::AddFileToFolder("special://masterprofile/", dialog->m_strDirectory);
+        path = URIUtils::AddFileToFolder(path, "guisettings.xml");
+        g_settings.SaveSettings(path, &localSettings);
+      }
+
+      bExists = CFile::Exists(URIUtils::AddFileToFolder("special://masterprofile/",
+                                                     dialog->m_strDirectory+"/sources.xml"));
       if (bExists)
+        if (!CGUIDialogYesNo::ShowAndGetInput(20058,20106,20105,20022))
+          bExists = false;
+
+      if (!bExists)
+      {
+        CFile::Cache(URIUtils::AddFileToFolder("special://masterprofile/","sources.xml"),
+                         URIUtils::AddFileToFolder("special://masterprofile/",
+                         dialog->m_strDirectory+"/sources.xml"));
+      }
+    }
+/* Old code
+      if (bExists)
         if (!CGUIDialogYesNo::ShowAndGetInput(20058,20104,20105,20022))
           bExists = false;
 
@@ -386,7 +422,7 @@
           }
       }
     }
-
+*/
     /*if (!dialog->m_bIsNewUser)
       if (!CGUIDialogYesNo::ShowAndGetInput(20067,20103,20022,20022))
         return false;*/
Index: xbmc/settings/GUISettings.cpp
===================================================================
--- xbmc/settings/GUISettings.cpp	(revision 33042)
+++ xbmc/settings/GUISettings.cpp	(working copy)
@@ -20,6 +20,8 @@
 
 #include "system.h"
 #include "utils/log.h"
+#include "Util.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/GUISettings.h"
 #include "dialogs/GUIDialogFileBrowser.h"
 #ifdef HAS_XBOX_HARDWARE
@@ -33,7 +35,6 @@
 #endif
 #include "storage/MediaManager.h"
 #include "FileSystem/SpecialProtocol.h"
-#include "settings/AdvancedSettings.h"
 #include "LocalizeStrings.h"
 #include "GUIFont.h" // for FONT_STYLE_* definitions
 
@@ -215,13 +216,22 @@
   AddCategory(1, "myprograms", 16000);
   AddBool(1, "myprograms.autoffpatch", 29999, false);
   AddSeparator(2,"myprograms.sep1");
-  AddBool(3, "myprograms.gameautoregion",511,false);
-  AddInt(4, "myprograms.ntscmode", 16110, 0, 0, 1, 3, SPIN_CONTROL_TEXT);
+  // Disable autoregion if not stock kernels or M8+.
+  int boool = 0;
+  if (CUtil::CheckForKernelPatchable(boool))
+  {
+	 AddBool(3, "myprograms.gameautoregion",511,false);
+	 AddInt(4, "myprograms.ntscmode", 16110, 0, 0, 1, 3, SPIN_CONTROL_TEXT);
+  }
   AddSeparator(5,"myprograms.sep2");
   AddString(6, "myprograms.trainerpath", 20003, "select folder", BUTTON_CONTROL_PATH_INPUT, false, 657);
   AddSeparator(7,"myprograms.sep3");
   AddBool(8, "myprograms.usedashpath", 13007, true);
   AddString(9, "myprograms.dashboard", 13006, "C:\\xboxdash.xbe", BUTTON_CONTROL_PATH_INPUT, false, 655);
+  AddCategory(1, "mygames", 32000);
+  AddBool(1, "mygames.fastscrolling",32001,true);
+  AddBool(2, "mygames.slowgameparsing",32002,false);
+  AddBool(3, "mygames.usesynopsisname",32003,false);
 
   // My Weather settings
   AddGroup(2, 8);
@@ -235,7 +245,8 @@
 
   // My Music Settings
   AddGroup(3, 2);
-  AddCategory(3,"musiclibrary",14022);
+  //AddCategory(3,"musiclibrary",14022);
+ 
   AddBool(1, "musiclibrary.enabled", 421, true);
   AddBool(2, "musiclibrary.showcompilationartists", 13414, true);
   AddSeparator(3,"musiclibrary.sep1");
@@ -267,7 +278,8 @@
   AddBool(11, "musicplayer.outputtoallspeakers", 252, false);
 #endif
 
-  AddCategory(3, "musicfiles", 14081);
+  //AddCategory(3, "musicfiles", 14081);
+ 
   AddBool(1, "musicfiles.usetags", 258, false);
   AddString(2, "musicfiles.trackformat", 13307, "[%N. ]%A - %T", EDIT_CONTROL_INPUT, false, 16016);
   AddString(3, "musicfiles.trackformatright", 13387, "%D", EDIT_CONTROL_INPUT, false, 16016);
@@ -278,7 +290,8 @@
   AddString(0, "musicfiles.librarytrackformatright", 13387, "", EDIT_CONTROL_INPUT, false, 16016);
   AddBool(4, "musicfiles.findremotethumbs", 14059, true);
 
-  AddCategory(3, "scrobbler", 15221);
+  //AddCategory(3, "scrobbler", 15221);
+ 
   AddBool(1, "scrobbler.lastfmsubmit", 15201, false);
   AddBool(2, "scrobbler.lastfmsubmitradio", 15250, false);
   AddString(3, "scrobbler.lastfmusername", 15202, "", EDIT_CONTROL_INPUT, false, 15202);
@@ -288,7 +301,8 @@
   AddString(7, "scrobbler.librefmusername", 15218, "", EDIT_CONTROL_INPUT, false, 15218);
   AddString(8, "scrobbler.librefmpass", 15219, "", EDIT_CONTROL_MD5_INPUT, false, 15219);
 
-  AddCategory(3, "audiocds", 620);
+  //AddCategory(3, "audiocds", 620);
+ 
   AddBool(2, "audiocds.usecddb", 227, true);
   AddSeparator(3, "audiocds.sep1");
   AddPath(4,"audiocds.recordingpath",20000,"select writable folder",BUTTON_CONTROL_PATH_INPUT,false,657);
@@ -298,7 +312,8 @@
   AddInt(8, "audiocds.bitrate", 623, 192, 128, 32, 320, SPIN_CONTROL_INT_PLUS, MASK_KBPS);
   AddInt(9, "audiocds.compressionlevel", 665, 5, 0, 1, 8, SPIN_CONTROL_INT_PLUS);
 
-  AddCategory(3, "karaoke", 13327);
+  //AddCategory(3, "karaoke", 13327);
+ 
   AddBool(1, "karaoke.enabled", 13323, false);
   AddBool(2, "karaoke.voiceenabled", 13361, false);
   AddInt(3, "karaoke.volume", 13376, 100, 0, 1, 100, SPIN_CONTROL_INT, MASK_PERCENT);
@@ -329,7 +344,7 @@
   AddInt(1, "videooutput.aspect", 21374, VIDEO_NORMAL, VIDEO_NORMAL, 1, VIDEO_WIDESCREEN, SPIN_CONTROL_TEXT);
   AddBool(2,  "videooutput.hd480p", 21378, true);
   AddBool(3,  "videooutput.hd720p", 21379, true);
-  AddBool(4,  "videooutput.hd1080i", 21380, false);
+  // AddBool(4,  "videooutput.hd1080i", 21380, false);
 
   AddCategory(4, "audiooutput", 772);
   AddInt(3, "audiooutput.mode", 337, AUDIO_ANALOG, AUDIO_ANALOG, 1, AUDIO_DIGITAL, SPIN_CONTROL_TEXT);
@@ -394,7 +409,8 @@
   AddInt(14, "cacheunknown.internet", 14060, 1024, 0, 256, 16384, SPIN_CONTROL_INT_PLUS, MASK_KB, TEXT_OFF);
 
   // !! Should be the last category, else disabling it will cause problems!
-  AddCategory(4, "masterlock", 12360);
+  //AddCategory(4, "masterlock", 12360);
+ 
   AddString(1, "masterlock.lockcode"       , 20100, "-", BUTTON_CONTROL_STANDARD);
   AddBool(4, "masterlock.startuplock"      , 20076,false);
   AddBool(5, "masterlock.enableshutdown"   , 12362,false);  
@@ -402,8 +418,9 @@
   AddInt(0,"masterlock.maxretries", 12364, 3, 3, 1, 100, SPIN_CONTROL_TEXT);
 
   // video settings
-  AddGroup(5, 3);
-  AddCategory(5, "videolibrary", 14022);
+  AddGroup(5, 3); 
+  //AddCategory(5, "videolibrary", 14022);
+ 
   AddBool(2, "videolibrary.enabled", 421, true);
   AddBool(3, "videolibrary.showunwatchedplots", 20369, true);
   AddBool(4, "videolibrary.seasonthumbs", 20382, true);
@@ -418,7 +435,7 @@
   AddString(13, "videolibrary.import", 648, "", BUTTON_CONTROL_STANDARD);
 
   AddCategory(5, "videoplayer", 14086);
-  AddInt(1, "videoplayer.resumeautomatically", 12017, RESUME_ASK, RESUME_NO, 1, RESUME_ASK, SPIN_CONTROL_TEXT);
+  //AddInt(1, "videoplayer.resumeautomatically", 12017, RESUME_ASK, RESUME_NO, 1, RESUME_ASK, SPIN_CONTROL_TEXT);
   AddString(2, "videoplayer.calibrate", 214, "", BUTTON_CONTROL_STANDARD);
   AddSeparator(3, "videoplayer.sep1");
   AddInt(4, "videoplayer.rendermethod", 13354, RENDER_HQ_RGB_SHADER, RENDER_LQ_RGB_SHADER, 1, RENDER_HQ_RGB_SHADERV2, SPIN_CONTROL_TEXT);
@@ -433,13 +450,16 @@
   AddBool(14, "videoplayer.fast", 22026, false);
   AddInt(15, "videoplayer.skiploopfilter", 14100, VS_SKIPLOOP_NONREF, VS_SKIPLOOP_DEFAULT, 1, VS_SKIPLOOP_ALL, SPIN_CONTROL_TEXT);
 
-  AddCategory(5, "myvideos", 14081);
+  //AddCategory(5, "myvideos", 14081);
+ 
+  AddInt(0, "videoplayer.resumeautomatically", 12017, RESUME_ASK, RESUME_NO, 1, RESUME_ASK, SPIN_CONTROL_TEXT);
   AddBool(0, "myvideos.treatstackasfile", 20051, true);
   AddBool(0, "myvideos.extractflags",20433, false);
   AddBool(3, "myvideos.cleanstrings", 20418, false);
   AddBool(0, "myvideos.extractthumb",20433, false);
 
-  AddCategory(5, "subtitles", 287);
+  //AddCategory(5, "subtitles", 287);
+ 
   AddString(1, "subtitles.font", 288, "Arial.ttf", SPIN_CONTROL_TEXT);
   AddInt(2, "subtitles.height", 289, 28, 16, 2, 74, SPIN_CONTROL_TEXT); // use text as there is a disk based lookup needed
   AddInt(3, "subtitles.style", 736, FONT_STYLE_BOLD, FONT_STYLE_NORMAL, 1, FONT_STYLE_BOLD | FONT_STYLE_ITALICS, SPIN_CONTROL_TEXT);
@@ -450,7 +470,8 @@
   AddSeparator(12,"subtitles.sep2");
   AddBool(13, "subtitles.searchrars", 13249, false);
 
-  AddCategory(5, "dvds", 14087);
+  //AddCategory(5, "dvds", 14087);
+ 
   AddInt(2, "dvds.playerregion", 21372, 0, 0, 1, 8, SPIN_CONTROL_INT_PLUS, -1, TEXT_OFF);
   AddBool(3, "dvds.automenu", 21882, false);
   AddBool(4, "dvds.useexternaldvdplayer", 20001, false);
@@ -458,6 +479,7 @@
 
   // Don't add the category - makes them hidden in the GUI
   //AddCategory(5, "postprocessing", 14041);
+ 
   AddBool(2, "postprocessing.enable", 286, false);
   AddBool(3, "postprocessing.auto", 307, true); // only has effect if PostProcessing.Enable is on.
   AddBool(4, "postprocessing.verticaldeblocking", 308, false);
@@ -467,7 +489,8 @@
   AddBool(8, "postprocessing.autobrightnesscontrastlevels", 310, false);
   AddBool(9, "postprocessing.dering", 311, false);
 
-  AddCategory(5, "scrapers", 21412);
+  //AddCategory(5, "scrapers", 21412);
+ 
   AddString(1, "scrapers.moviedefault", 21413, "tmdb.xml", SPIN_CONTROL_TEXT);
   AddString(2, "scrapers.tvshowdefault", 21414, "tvdb.xml", SPIN_CONTROL_TEXT);
   AddString(3, "scrapers.musicvideodefault", 21415, "mtv.xml", SPIN_CONTROL_TEXT);
@@ -477,7 +500,8 @@
   // network settings
   AddGroup(6, 705);
 
-  AddCategory(6, "services", 14036);
+  //AddCategory(6, "services", 14036);
+ 
   AddBool(1, "services.upnpserver", 21360, false);
   AddBool(2, "services.upnprenderer", 21881, false);
   AddSeparator(3,"services.sep3");
@@ -503,7 +527,8 @@
   AddString(14,"services.ftpserverpassword",1246, "xbox", EDIT_CONTROL_HIDDEN_INPUT, true, 1246);
   AddBool(15,  "services.ftpautofatx",      771, true);
 
-  AddCategory(6,"autodetect",           1250  );
+  //AddCategory(6,"autodetect",           1250  );
+ 
   AddBool(1,    "autodetect.onoff",     1251, false);
   AddBool(2,    "autodetect.popupinfo", 1254, true);
   AddString(3,  "autodetect.nickname",  1252, "XBMC-NickName",EDIT_CONTROL_INPUT, false, 1252);
@@ -510,7 +535,8 @@
   AddSeparator(4, "autodetect.sep1");
   AddBool(5,    "autodetect.senduserpw",1255, true); // can be in advanced.xml! default:true
 
-  AddCategory(6, "smb", 1200);
+  //AddCategory(6, "smb", 1200);
+ 
   AddString(3, "smb.winsserver",  1207,   "",  EDIT_CONTROL_IP_INPUT);
   AddString(4, "smb.workgroup",   1202,   "WORKGROUP", EDIT_CONTROL_INPUT, false, 1202);
 
@@ -519,7 +545,8 @@
   AddString(2, "network.ipaddress", 719, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
   AddString(3, "network.subnet", 720, "255.255.255.0", EDIT_CONTROL_IP_INPUT);
   AddString(4, "network.gateway", 721, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
-  AddString(5, "network.dns", 722, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
+  AddString(5, "network.dns", 34006, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
+  AddString(6, "network.dns2", 34007, "0.0.0.0", EDIT_CONTROL_IP_INPUT);
   AddString(6, "network.dnssuffix", 22002, "", EDIT_CONTROL_INPUT, true);
   AddInt(7, "network.bandwidth", 14042, 0, 0, 512, 100*1024, SPIN_CONTROL_INT_PLUS, MASK_KBPS, TEXT_OFF);
 
@@ -532,7 +559,8 @@
 
   // appearance settings
   AddGroup(7, 480);
-  AddCategory(7,"lookandfeel", 166);
+  //AddCategory(7,"lookandfeel", 166);
+ 
   AddString(1, "lookandfeel.skin",166,DEFAULT_SKIN, SPIN_CONTROL_TEXT);
   AddString(2, "lookandfeel.skintheme",15111,"SKINDEFAULT", SPIN_CONTROL_TEXT);
   AddString(3, "lookandfeel.skincolors",14078, "SKINDEFAULT", SPIN_CONTROL_TEXT);
Index: xbmc/settings/GUIWindowSettingsCategory.cpp
===================================================================
--- xbmc/settings/GUIWindowSettingsCategory.cpp	(revision 33042)
+++ xbmc/settings/GUIWindowSettingsCategory.cpp	(working copy)
@@ -104,10 +104,10 @@
 
 #define PREDEFINED_SCREENSAVERS          5
 
-#define RSSEDITOR_PATH "special://home/scripts/RSS Editor/default.py"
+#define RSSEDITOR_PATH "special://home/system/scripts/RSS Editor/default.py"
 
 CGUIWindowSettingsCategory::CGUIWindowSettingsCategory(void)
-    : CGUIWindow(WINDOW_SETTINGS_MYPICTURES, "SettingsCategory.xml")
+	: CGUIWindow(WINDOW_SETTINGS_MYPICTURES, "SettingsCategory.xml")
 {
   m_pOriginalSpin = NULL;
   m_pOriginalRadioButton = NULL;
@@ -145,206 +145,221 @@
   switch (message.GetMessage())
   {
   case GUI_MSG_CLICKED:
-    {
-      unsigned int iControl = message.GetSenderId();
-      /*   if (iControl >= CONTROL_START_BUTTONS && iControl < CONTROL_START_BUTTONS + m_vecSections.size())
-         {
-          // change the setting...
-          m_iSection = iControl-CONTROL_START_BUTTONS;
-          CheckNetworkSettings();
-          CreateSettings();
-          return true;
-         }*/
-      for (unsigned int i = 0; i < m_vecSettings.size(); i++)
-      {
-        if (m_vecSettings[i]->GetID() == iControl)
-          OnClick(m_vecSettings[i]);
-      }
-    }
-    break;
+	{
+	  unsigned int iControl = message.GetSenderId();
+	  /*   if (iControl >= CONTROL_START_BUTTONS && iControl < CONTROL_START_BUTTONS + m_vecSections.size())
+		 {
+		  // change the setting...
+		  m_iSection = iControl-CONTROL_START_BUTTONS;
+		  CheckNetworkSettings();
+		  CreateSettings();
+		  return true;
+		 }*/
+	  for (unsigned int i = 0; i < m_vecSettings.size(); i++)
+	  {
+		if (m_vecSettings[i]->GetID() == iControl)
+		  OnClick(m_vecSettings[i]);
+	  }
+	}
+	break;
   case GUI_MSG_FOCUSED:
-    {
-      CGUIWindow::OnMessage(message);
-      int focusedControl = GetFocusedControlID();
-      if (focusedControl >= CONTROL_START_BUTTONS && focusedControl < (int)(CONTROL_START_BUTTONS + m_vecSections.size()) &&
-          focusedControl - CONTROL_START_BUTTONS != m_iSection)
-      {
-        // changing section, check for updates and cancel any delayed changes
-        m_delayedSetting = NULL;
-        CheckForUpdates();
+	{
+	  CGUIWindow::OnMessage(message);
+	  int focusedControl = GetFocusedControlID();
+	  if (focusedControl >= CONTROL_START_BUTTONS && focusedControl < (int)(CONTROL_START_BUTTONS + m_vecSections.size()) &&
+		  focusedControl - CONTROL_START_BUTTONS != m_iSection)
+	  {
+		// changing section, check for updates and cancel any delayed changes
+		m_delayedSetting = NULL;
+		CheckForUpdates();
 
-        if (m_vecSections[focusedControl-CONTROL_START_BUTTONS]->m_strCategory == "masterlock")
-        {
-          if (!g_passwordManager.IsMasterLockUnlocked(true))
-          { // unable to go to this category - focus the previous one
-            SET_CONTROL_FOCUS(CONTROL_START_BUTTONS + m_iSection, 0);
-            return false;
-          }
-        }
-        m_iSection = focusedControl - CONTROL_START_BUTTONS;
-        CheckNetworkSettings();
+		if (m_vecSections[focusedControl-CONTROL_START_BUTTONS]->m_strCategory == "masterlock")
+		{
+		  if (!g_passwordManager.IsMasterLockUnlocked(true))
+		  { // unable to go to this category - focus the previous one
+			SET_CONTROL_FOCUS(CONTROL_START_BUTTONS + m_iSection, 0);
+			return false;
+		  }
+		}
+		m_iSection = focusedControl - CONTROL_START_BUTTONS;
+		CheckNetworkSettings();
 
-        CreateSettings();
-      }
-      return true;
-    }
+		CreateSettings();
+	  }
+	  return true;
+	}
   case GUI_MSG_LOAD_SKIN:
-    {
-      // Do we need to reload the language file
-      if (!m_strNewLanguage.IsEmpty())
-      {
-        g_guiSettings.SetString("locale.language", m_strNewLanguage);
-        g_settings.Save();
+	{
+	  // Do we need to reload the language file
+	  if (!m_strNewLanguage.IsEmpty())
+	  {
+		g_guiSettings.SetString("locale.language", m_strNewLanguage);
+		g_settings.Save();
 
-        CStdString strLangInfoPath;
-        strLangInfoPath.Format("special://xbmc/language/%s/langinfo.xml", m_strNewLanguage.c_str());
-        g_langInfo.Load(strLangInfoPath);
+		CStdString strLangInfoPath;
+		strLangInfoPath.Format("special://xbmc/system/language/%s/langinfo.xml", m_strNewLanguage.c_str());
+		g_langInfo.Load(strLangInfoPath);
 
-        if (g_langInfo.ForceUnicodeFont() && !g_fontManager.IsFontSetUnicode())
-        {
-          CLog::Log(LOGINFO, "Language needs a ttf font, loading first ttf font available");
-          CStdString strFontSet;
-          if (g_fontManager.GetFirstFontSetUnicode(strFontSet))
-          {
-            m_strNewSkinFontSet=strFontSet;
-          }
-          else
-            CLog::Log(LOGERROR, "No ttf font found but needed: %s", strFontSet.c_str());
-        }
+		if (g_langInfo.ForceUnicodeFont() && !g_fontManager.IsFontSetUnicode())
+		{
+		  CLog::Log(LOGINFO, "Language needs a ttf font, loading first ttf font available");
+		  CStdString strFontSet;
+		  if (g_fontManager.GetFirstFontSetUnicode(strFontSet))
+		  {
+			m_strNewSkinFontSet=strFontSet;
+		  }
+		  else
+			CLog::Log(LOGERROR, "No ttf font found but needed: %s", strFontSet.c_str());
+		}
 
-        g_charsetConverter.reset();
+		g_charsetConverter.reset();
 
-        CStdString strKeyboardLayoutConfigurationPath;
-        strKeyboardLayoutConfigurationPath.Format("special://xbmc/language/%s/keyboardmap.xml", m_strNewLanguage.c_str());
-        CLog::Log(LOGINFO, "load keyboard layout configuration info file: %s", strKeyboardLayoutConfigurationPath.c_str());
-        g_keyboardLayoutConfiguration.Load(strKeyboardLayoutConfigurationPath);
+		CStdString strKeyboardLayoutConfigurationPath;
+		strKeyboardLayoutConfigurationPath.Format("special://xbmc/system/language/%s/keyboardmap.xml", m_strNewLanguage.c_str());
+		CLog::Log(LOGINFO, "load keyboard layout configuration info file: %s", strKeyboardLayoutConfigurationPath.c_str());
+		g_keyboardLayoutConfiguration.Load(strKeyboardLayoutConfigurationPath);
 
-        g_localizeStrings.Load("special://xbmc/language/", m_strNewLanguage);
+		g_localizeStrings.Load("special://xbmc/system/language/", m_strNewLanguage);
 
-        // also tell our weather to reload, as this must be localized
-        g_weatherManager.Refresh();
-      }
+		// also tell our weather to reload, as this must be localized
+		g_weatherManager.Refresh();
+	  }
 
-      // Do we need to reload the skin font set
-      if (!m_strNewSkinFontSet.IsEmpty())
-      {
-        g_guiSettings.SetString("lookandfeel.font", m_strNewSkinFontSet);
-        g_settings.Save();
-      }
+	  // Do we need to reload the skin font set
+	  if (!m_strNewSkinFontSet.IsEmpty())
+	  {
+		g_guiSettings.SetString("lookandfeel.font", m_strNewSkinFontSet);
+		g_settings.Save();
+	  }
 
-      // Reload another skin
-      if (!m_strNewSkin.IsEmpty())
-      {
-        g_guiSettings.SetString("lookandfeel.skin", m_strNewSkin);
-        g_settings.Save();
-      }
+	  // Reload another skin
+	  if (!m_strNewSkin.IsEmpty())
+	  {
+		g_guiSettings.SetString("lookandfeel.skin", m_strNewSkin);
+		g_settings.Save();
+	  }
 
-      // Reload a skin theme
-      if (!m_strNewSkinTheme.IsEmpty())
-      {
-        g_guiSettings.SetString("lookandfeel.skintheme", m_strNewSkinTheme);
-        // also set the default color theme
-        CStdString colorTheme(URIUtils::ReplaceExtension(m_strNewSkinTheme, ".xml"));
-        if (colorTheme.Equals("Textures.xml"))
-          colorTheme = "defaults.xml";
-        g_guiSettings.SetString("lookandfeel.skincolors", colorTheme);
-        g_settings.Save();
-      }
+	  // Reload a skin theme
+	  if (!m_strNewSkinTheme.IsEmpty())
+	  {
+		g_guiSettings.SetString("lookandfeel.skintheme", m_strNewSkinTheme);
+		CStdString ThemeName(URIUtils::ReplaceExtension(m_strNewSkinTheme, ""));
+		// Sounds.xml
+		if (CFile::Exists("special://xbmc/emustation/themes/" + ThemeName + "/sounds/sounds.xml"))
+		{
+			g_guiSettings.SetString("lookandfeel.soundskin",ThemeName);
+		}
+		else
+		{
+			g_guiSettings.SetString("lookandfeel.soundskin","SIMPLE");
+		}
+		// Colors.xml
+		if (CFile::Exists("special://xbmc/emustation/themes/" + ThemeName + "/colors.xml"))
+		{
+			g_guiSettings.SetString("lookandfeel.skincolors",ThemeName);
+		}
+		else
+		{
+			g_guiSettings.SetString("lookandfeel.skincolors","SIMPLE");
+		}
+		g_guiSettings.SetString("lookandfeel.font",ThemeName);
+		g_settings.Save();
+	  }
 
-      // Reload a skin color
-      if (!m_strNewSkinColors.IsEmpty())
-      {
-        g_guiSettings.SetString("lookandfeel.skincolors", m_strNewSkinColors);
-        g_settings.Save();
-      }
+	  // Reload a skin color
+	  if (!m_strNewSkinColors.IsEmpty())
+	  {
+		g_guiSettings.SetString("lookandfeel.skincolors", m_strNewSkinColors);
+		g_settings.Save();
+	  }
 
-      // Reload a resolution
-      if (m_NewResolution != INVALID)
-      {
-        g_guiSettings.SetInt("videoscreen.resolution", m_NewResolution);
-        //set the gui resolution, if newRes is AUTORES newRes will be set to the highest available resolution
-        g_graphicsContext.SetVideoResolution(m_NewResolution, TRUE);
-        //set our lookandfeelres to the resolution set in graphiccontext
-        g_guiSettings.m_LookAndFeelResolution = m_NewResolution;
-      }
+	  // Reload a resolution
+	  if (m_NewResolution != INVALID)
+	  {
+		g_guiSettings.SetInt("videoscreen.resolution", m_NewResolution);
+		//set the gui resolution, if newRes is AUTORES newRes will be set to the highest available resolution
+		g_graphicsContext.SetVideoResolution(m_NewResolution, TRUE);
+		//set our lookandfeelres to the resolution set in graphiccontext
+		g_guiSettings.m_LookAndFeelResolution = m_NewResolution;
+	  }
 
-      if (IsActive())
-        m_returningFromSkinLoad = true;
-    }
-    break;
+	  if (IsActive())
+		m_returningFromSkinLoad = true;
+	}
+	break;
   case GUI_MSG_WINDOW_INIT:
-    {
-      m_delayedSetting = NULL;
-      if (message.GetParam1() != WINDOW_INVALID && !m_returningFromSkinLoad)
-      { // coming to this window first time (ie not returning back from some other window)
-        // so we reset our section and control states
-        m_iSection = 0;
-        ResetControlStates();
-      }
-      m_returningFromSkinLoad = false;
-      m_iScreen = (int)message.GetParam2() - (int)CGUIWindow::GetID();
-      return CGUIWindow::OnMessage(message);
-    }
-    break;
+	{
+	  m_delayedSetting = NULL;
+	  if (message.GetParam1() != WINDOW_INVALID && !m_returningFromSkinLoad)
+	  { // coming to this window first time (ie not returning back from some other window)
+		// so we reset our section and control states
+		m_iSection = 0;
+		ResetControlStates();
+	  }
+	  m_returningFromSkinLoad = false;
+	  m_iScreen = (int)message.GetParam2() - (int)CGUIWindow::GetID();
+	  return CGUIWindow::OnMessage(message);
+	}
+	break;
   case GUI_MSG_UPDATE_ITEM:
-    if (m_delayedSetting)
-    {
-      OnSettingChanged(m_delayedSetting);
-      m_delayedSetting = NULL;
-      return true;
-    }
-    break;
+	if (m_delayedSetting)
+	{
+	  OnSettingChanged(m_delayedSetting);
+	  m_delayedSetting = NULL;
+	  return true;
+	}
+	break;
   case GUI_MSG_WINDOW_DEINIT:
-    {
-      m_delayedSetting = NULL;
-      // Hardware based stuff
-      // TODO: This should be done in a completely separate screen
-      // to give warning to the user that it writes to the EEPROM.
-      if ((g_guiSettings.GetInt("audiooutput.mode") == AUDIO_DIGITAL))
-      {
-        g_audioConfig.SetAC3Enabled(g_guiSettings.GetBool("audiooutput.ac3passthrough"));
-        g_audioConfig.SetDTSEnabled(g_guiSettings.GetBool("audiooutput.dtspassthrough"));
-        g_audioConfig.SetAACEnabled(g_guiSettings.GetBool("audiooutput.aacpassthrough"));
-        g_audioConfig.SetMP1Enabled(g_guiSettings.GetBool("audiooutput.mp1passthrough"));
-        g_audioConfig.SetMP2Enabled(g_guiSettings.GetBool("audiooutput.mp2passthrough"));
-        g_audioConfig.SetMP3Enabled(g_guiSettings.GetBool("audiooutput.mp3passthrough"));
-        if (g_audioConfig.NeedsSave())
-        { // should we perhaps show a dialog here?
-          g_audioConfig.Save();
-        }
-      }
-      switch(g_guiSettings.GetInt("videooutput.aspect"))
-      {
-      case VIDEO_NORMAL:
-        g_videoConfig.SetNormal();
-        break;
-      case VIDEO_LETTERBOX:
-        g_videoConfig.SetLetterbox(true);
-        break;
-      case VIDEO_WIDESCREEN:
-        g_videoConfig.SetWidescreen(true);
-        break;
-      }
-      g_videoConfig.Set480p(g_guiSettings.GetBool("videooutput.hd480p"));
-      g_videoConfig.Set720p(g_guiSettings.GetBool("videooutput.hd720p"));
-      g_videoConfig.Set1080i(g_guiSettings.GetBool("videooutput.hd1080i"));
+	{
+	  m_delayedSetting = NULL;
+	  // Hardware based stuff
+	  // TODO: This should be done in a completely separate screen
+	  // to give warning to the user that it writes to the EEPROM.
+	  if ((g_guiSettings.GetInt("audiooutput.mode") == AUDIO_DIGITAL))
+	  {
+		g_audioConfig.SetAC3Enabled(g_guiSettings.GetBool("audiooutput.ac3passthrough"));
+		g_audioConfig.SetDTSEnabled(g_guiSettings.GetBool("audiooutput.dtspassthrough"));
+		g_audioConfig.SetAACEnabled(g_guiSettings.GetBool("audiooutput.aacpassthrough"));
+		g_audioConfig.SetMP1Enabled(g_guiSettings.GetBool("audiooutput.mp1passthrough"));
+		g_audioConfig.SetMP2Enabled(g_guiSettings.GetBool("audiooutput.mp2passthrough"));
+		g_audioConfig.SetMP3Enabled(g_guiSettings.GetBool("audiooutput.mp3passthrough"));
+		if (g_audioConfig.NeedsSave())
+		{ // should we perhaps show a dialog here?
+		  g_audioConfig.Save();
+		}
+	  }
+	  switch(g_guiSettings.GetInt("videooutput.aspect"))
+	  {
+	  case VIDEO_NORMAL:
+		g_videoConfig.SetNormal();
+		break;
+	  case VIDEO_LETTERBOX:
+		g_videoConfig.SetLetterbox(true);
+		break;
+	  case VIDEO_WIDESCREEN:
+		g_videoConfig.SetWidescreen(true);
+		break;
+	  }
+	  g_videoConfig.Set480p(g_guiSettings.GetBool("videooutput.hd480p"));
+	  g_videoConfig.Set720p(g_guiSettings.GetBool("videooutput.hd720p"));
+	  g_videoConfig.Set1080i(g_guiSettings.GetBool("videooutput.hd1080i"));
 
-      if (g_videoConfig.NeedsSave())
-        g_videoConfig.Save();
+	  if (g_videoConfig.NeedsSave())
+		g_videoConfig.Save();
 
-      if (g_timezone.GetTimeZoneIndex() != g_guiSettings.GetInt("locale.timezone"))
-        g_timezone.SetTimeZoneIndex(g_guiSettings.GetInt("locale.timezone"));
+	  if (g_timezone.GetTimeZoneIndex() != g_guiSettings.GetInt("locale.timezone"))
+		g_timezone.SetTimeZoneIndex(g_guiSettings.GetInt("locale.timezone"));
 
-      if (g_timezone.GetDST() != g_guiSettings.GetBool("locale.usedst"))
-        g_timezone.SetDST(g_guiSettings.GetBool("locale.usedst"));
+	  if (g_timezone.GetDST() != g_guiSettings.GetBool("locale.usedst"))
+		g_timezone.SetDST(g_guiSettings.GetBool("locale.usedst"));
 
-      CheckForUpdates();
-      CheckNetworkSettings();
-      CGUIWindow::OnMessage(message);
-      FreeControls();
-      return true;
-    }
-    break;
+	  CheckForUpdates();
+	  CheckNetworkSettings();
+	  CGUIWindow::OnMessage(message);
+	  FreeControls();
+	  return true;
+	}
+	break;
   }
   return CGUIWindow::OnMessage(message);
 }
@@ -359,12 +374,12 @@
   m_pOriginalButton = (CGUIButtonControl *)GetControl(CONTROL_DEFAULT_BUTTON);
   m_pOriginalImage = (CGUIImage *)GetControl(CONTROL_DEFAULT_SEPARATOR);
   if (!m_pOriginalCategoryButton || !m_pOriginalSpin || !m_pOriginalRadioButton || !m_pOriginalButton)
-    return ;
+	return ;
   m_pOriginalEdit = (CGUIEditControl *)GetControl(CONTROL_DEFAULT_EDIT);
   if (!m_pOriginalEdit || m_pOriginalEdit->GetControlType() != CGUIControl::GUICONTROL_EDIT)
   {
-    delete m_pOriginalEdit;
-    m_pOriginalEdit = new CGUIEditControl(*m_pOriginalButton);
+	delete m_pOriginalEdit;
+	m_pOriginalEdit = new CGUIEditControl(*m_pOriginalButton);
   }
   m_pOriginalSpin->SetVisible(false);
   m_pOriginalRadioButton->SetVisible(false);
@@ -375,7 +390,7 @@
   // setup our control groups...
   CGUIControlGroupList *group = (CGUIControlGroupList *)GetControl(CATEGORY_GROUP_ID);
   if (!group)
-    return;
+	return;
   // get a list of different sections
   CSettingsGroup *pSettingsGroup = g_guiSettings.GetGroup(m_iScreen);
   if (!pSettingsGroup) return ;
@@ -387,22 +402,22 @@
   int j=0;
   for (unsigned int i = 0; i < m_vecSections.size(); i++)
   {
-    if (m_vecSections[i]->m_labelID == 12360 && !g_settings.IsMasterUser())
-      continue;
-    CGUIButtonControl *pButton = NULL;
-    if (m_pOriginalCategoryButton->GetControlType() == CGUIControl::GUICONTROL_TOGGLEBUTTON)
-      pButton = new CGUIToggleButtonControl(*(CGUIToggleButtonControl *)m_pOriginalCategoryButton);
-    else
-      pButton = new CGUIButtonControl(*m_pOriginalCategoryButton);
-    pButton->SetLabel(g_localizeStrings.Get(m_vecSections[i]->m_labelID));
-    pButton->SetID(CONTROL_START_BUTTONS + j);
-    pButton->SetVisible(true);
-    pButton->AllocResources();
-    group->AddControl(pButton);
-    j++;
+	if (m_vecSections[i]->m_labelID == 12360 && !g_settings.IsMasterUser())
+	  continue;
+	CGUIButtonControl *pButton = NULL;
+	if (m_pOriginalCategoryButton->GetControlType() == CGUIControl::GUICONTROL_TOGGLEBUTTON)
+	  pButton = new CGUIToggleButtonControl(*(CGUIToggleButtonControl *)m_pOriginalCategoryButton);
+	else
+	  pButton = new CGUIButtonControl(*m_pOriginalCategoryButton);
+	pButton->SetLabel(g_localizeStrings.Get(m_vecSections[i]->m_labelID));
+	pButton->SetID(CONTROL_START_BUTTONS + j);
+	pButton->SetVisible(true);
+	pButton->AllocResources();
+	group->AddControl(pButton);
+	j++;
   }
   if (m_iSection < 0 || m_iSection >= (int)m_vecSections.size())
-    m_iSection = 0;
+	m_iSection = 0;
   CreateSettings();
   // set focus correctly
   m_defaultControl = CONTROL_START_BUTTONS;
@@ -414,419 +429,419 @@
 
   CGUIControlGroupList *group = (CGUIControlGroupList *)GetControl(SETTINGS_GROUP_ID);
   if (!group)
-    return;
+	return;
   vecSettings settings;
   g_guiSettings.GetSettingsGroup(m_vecSections[m_iSection]->m_strCategory, settings);
   int iControlID = CONTROL_START_CONTROL;
   for (unsigned int i = 0; i < settings.size(); i++)
   {
-    CSetting *pSetting = settings[i];
-    AddSetting(pSetting, group->GetWidth(), iControlID);
-    CStdString strSetting = pSetting->GetSetting();
-    if (strSetting.Equals("myprograms.ntscmode"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      for (int i = pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i++)
-      {
-        pControl->AddLabel(g_localizeStrings.Get(16106 + i), i);
-      }
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("musicplayer.visualisation"))
-    {
-      FillInVisualisations(pSetting, GetSetting(pSetting->GetSetting())->GetID());
-    }
-    else if (strSetting.Equals("musiclibrary.scraper"))
-    {
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
-      FillInScrapers(pControl, g_guiSettings.GetString("musiclibrary.scraper"), "music");
-    }
-    else if (strSetting.Equals("scrapers.moviedefault"))
-    {
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
-      FillInScrapers(pControl, g_guiSettings.GetString("scrapers.moviedefault"), "movies");
-    }
-    else if (strSetting.Equals("scrapers.tvshowdefault"))
-    {
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
-      FillInScrapers(pControl, g_guiSettings.GetString("scrapers.tvshowdefault"), "tvshows");
-    }
-    else if (strSetting.Equals("scrapers.musicvideodefault"))
-    {
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
-      FillInScrapers(pControl, g_guiSettings.GetString("scrapers.musicvideodefault"), "musicvideos");
-    }
-    else if (strSetting.Equals("karaoke.port0voicemask"))
-    {
-      FillInVoiceMasks(0, pSetting);
-    }
-    else if (strSetting.Equals("karaoke.port1voicemask"))
-    {
-      FillInVoiceMasks(1, pSetting);
-    }
-    else if (strSetting.Equals("karaoke.port2voicemask"))
-    {
-      FillInVoiceMasks(2, pSetting);
-    }
-    else if (strSetting.Equals("karaoke.port3voicemask"))
-    {
-      FillInVoiceMasks(3, pSetting);
-    }
-    else if (strSetting.Equals("audiooutput.mode"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(338), AUDIO_ANALOG);
-      if (g_audioConfig.HasDigitalOutput())
-        pControl->AddLabel(g_localizeStrings.Get(339), AUDIO_DIGITAL);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("videooutput.aspect"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(21375), VIDEO_NORMAL);
-      pControl->AddLabel(g_localizeStrings.Get(21376), VIDEO_LETTERBOX);
-      pControl->AddLabel(g_localizeStrings.Get(21377), VIDEO_WIDESCREEN);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("audiocds.encoder"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel("Lame", CDDARIP_ENCODER_LAME);
-      pControl->AddLabel("Vorbis", CDDARIP_ENCODER_VORBIS);
-      pControl->AddLabel("Wav", CDDARIP_ENCODER_WAV);
-      pControl->AddLabel("Flac", CDDARIP_ENCODER_FLAC);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("audiocds.quality"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(604), CDDARIP_QUALITY_CBR);
-      pControl->AddLabel(g_localizeStrings.Get(601), CDDARIP_QUALITY_MEDIUM);
-      pControl->AddLabel(g_localizeStrings.Get(602), CDDARIP_QUALITY_STANDARD);
-      pControl->AddLabel(g_localizeStrings.Get(603), CDDARIP_QUALITY_EXTREME);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("lcd.type"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(351), LCD_TYPE_NONE);
-      pControl->AddLabel("LCD - HD44780", LCD_TYPE_LCD_HD44780);
-      pControl->AddLabel("LCD - KS0073", LCD_TYPE_LCD_KS0073);
-      pControl->AddLabel("VFD", LCD_TYPE_VFD);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("lcd.modchip"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel("SmartXX", MODCHIP_SMARTXX);
-      pControl->AddLabel("Xenium", MODCHIP_XENIUM);
-      pControl->AddLabel("Xecuter3", MODCHIP_XECUTER3);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("harddisk.aamlevel"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(21388), AAM_QUIET);
-      pControl->AddLabel(g_localizeStrings.Get(21387), AAM_FAST);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("harddisk.apmlevel"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(21391), APM_HIPOWER);
-      pControl->AddLabel(g_localizeStrings.Get(21392), APM_LOPOWER);
-      pControl->AddLabel(g_localizeStrings.Get(21393), APM_HIPOWER_STANDBY);
-      pControl->AddLabel(g_localizeStrings.Get(21394), APM_LOPOWER_STANDBY);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("system.targettemperature"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      for (int i = pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i++)
-      {
-        CTemperature temp=CTemperature::CreateFromCelsius(i);
-        pControl->AddLabel(temp.ToString(), i);
-      }
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("system.fanspeed") || strSetting.Equals("system.minfanspeed"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      CStdString strPercentMask = g_localizeStrings.Get(14047);
-      for (int i=pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i += pSettingInt->m_iStep)
-      {
-        CStdString strLabel;
-        strLabel.Format(strPercentMask.c_str(), i*2);
-        pControl->AddLabel(strLabel, i);
-      }
-      pControl->SetValue(int(pSettingInt->GetData()));
-    }
-    else if (strSetting.Equals("harddisk.remoteplayspindown"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(474), SPIN_DOWN_NONE);
-      pControl->AddLabel(g_localizeStrings.Get(475), SPIN_DOWN_MUSIC);
-      pControl->AddLabel(g_localizeStrings.Get(13002), SPIN_DOWN_VIDEO);
-      pControl->AddLabel(g_localizeStrings.Get(476), SPIN_DOWN_BOTH);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("services.webserverusername"))
-    {
-      // get password from the webserver if it's running (and update our settings)
-      if (g_application.m_pWebServer)
-      {
-        ((CSettingString *)GetSetting(strSetting)->GetSetting())->SetData(g_application.m_pWebServer->GetUserName());
-        g_settings.Save();
-      }
-    }
-    else if (strSetting.Equals("services.webserverpassword"))
-    {
-      // get password from the webserver if it's running (and update our settings)
-      if (g_application.m_pWebServer)
-      {
-        ((CSettingString *)GetSetting(strSetting)->GetSetting())->SetData(g_application.m_pWebServer->GetPassword());
-        g_settings.Save();
-      }
-    }
-    else if (strSetting.Equals("services.webserverport"))
-    {
-      CBaseSettingControl *control = GetSetting(pSetting->GetSetting());
-      control->SetDelayed();
-    }
-    else if (strSetting.Equals("services.esport"))
-    {
-      CBaseSettingControl *control = GetSetting(pSetting->GetSetting());
-      control->SetDelayed();
-    }
-    else if (strSetting.Equals("network.assignment"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(718), NETWORK_DASH);
-      pControl->AddLabel(g_localizeStrings.Get(716), NETWORK_DHCP);
-      pControl->AddLabel(g_localizeStrings.Get(717), NETWORK_STATIC);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("network.httpproxyport"))
-    {
-      CBaseSettingControl *control = GetSetting(pSetting->GetSetting());
-      control->SetDelayed();
-    }
-    else if (strSetting.Equals("subtitles.style"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(738), FONT_STYLE_NORMAL);
-      pControl->AddLabel(g_localizeStrings.Get(739), FONT_STYLE_BOLD);
-      pControl->AddLabel(g_localizeStrings.Get(740), FONT_STYLE_ITALICS);
-      pControl->AddLabel(g_localizeStrings.Get(741), FONT_STYLE_BOLD_ITALICS);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("subtitles.color"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      for (int i = SUBTITLE_COLOR_START; i <= SUBTITLE_COLOR_END; i++)
-        pControl->AddLabel(g_localizeStrings.Get(760 + i), i);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("subtitles.height"))
-    {
-      FillInSubtitleHeights(pSetting);
-    }
-    else if (strSetting.Equals("subtitles.font"))
-    {
-      FillInSubtitleFonts(pSetting);
-    }
-    else if (strSetting.Equals("subtitles.charset") || strSetting.Equals("locale.charset"))
-    {
-      FillInCharSets(pSetting);
-    }
-    else if (strSetting.Equals("lookandfeel.font"))
-    {
-      FillInSkinFonts(pSetting);
-    }
-    else if (strSetting.Equals("lookandfeel.skin"))
-    {
-      FillInSkins(pSetting);
-    }
-    else if (strSetting.Equals("lookandfeel.soundskin"))
-    {
-      FillInSoundSkins(pSetting);
-    }
-    else if (strSetting.Equals("locale.language"))
-    {
-      FillInLanguages(pSetting);
-    }
-    else if (strSetting.Equals("locale.timezone"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      for (int i=0; i < g_timezone.GetNumberOfTimeZones(); i++)
-        pControl->AddLabel(g_timezone.GetTimeZoneString(i), i);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("videoscreen.resolution"))
-    {
-      FillInResolutions(pSetting, false);
-    }
-    else if (strSetting.Equals("lookandfeel.skintheme"))
-    {
-      FillInSkinThemes(pSetting);
-    }
-    else if (strSetting.Equals("lookandfeel.skincolors"))
-    {
-      FillInSkinColors(pSetting);
-    }
-    else if (strSetting.Equals("screensaver.mode"))
-    {
-      FillInScreenSavers(pSetting);
-    }
-    else if (strSetting.Equals("videoplayer.displayresolution") || strSetting.Equals("pictures.displayresolution"))
-    {
-      FillInResolutions(pSetting, true);
-    }
-    else if (strSetting.Equals("videoplayer.framerateconversions"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(231), FRAME_RATE_LEAVE_AS_IS); // "None"
-      pControl->AddLabel(g_videoConfig.HasPAL() ? g_localizeStrings.Get(12380) : g_localizeStrings.Get(12381), FRAME_RATE_CONVERT); // "Play PAL videos at NTSC rates" or "Play NTSC videos at PAL rates"
-      if (g_videoConfig.HasPAL() && g_videoConfig.HasPAL60())
-        pControl->AddLabel(g_localizeStrings.Get(12382), FRAME_RATE_USE_PAL60); // "Play NTSC videos in PAL60"
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("videoplayer.skiploopfilter"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(14101), VS_SKIPLOOP_DEFAULT);
-      pControl->AddLabel(g_localizeStrings.Get(14102), VS_SKIPLOOP_NONREF);
-      pControl->AddLabel(g_localizeStrings.Get(14103), VS_SKIPLOOP_BIDIR);
-      pControl->AddLabel(g_localizeStrings.Get(14104), VS_SKIPLOOP_NONKEY);
-      pControl->AddLabel(g_localizeStrings.Get(14105), VS_SKIPLOOP_ALL);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("videolibrary.flattentvshows"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(20420), 0); // Never
-      pControl->AddLabel(g_localizeStrings.Get(20421), 1); // One Season
-      pControl->AddLabel(g_localizeStrings.Get(20422), 2); // Always
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("system.ledcolour"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(13340), LED_COLOUR_NO_CHANGE);
-      pControl->AddLabel(g_localizeStrings.Get(13341), LED_COLOUR_GREEN);
-      pControl->AddLabel(g_localizeStrings.Get(13342), LED_COLOUR_ORANGE);
-      pControl->AddLabel(g_localizeStrings.Get(13343), LED_COLOUR_RED);
-      pControl->AddLabel(g_localizeStrings.Get(13344), LED_COLOUR_CYCLE);
-      pControl->AddLabel(g_localizeStrings.Get(351), LED_COLOUR_OFF);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("system.leddisableonplayback") || strSetting.Equals("lcd.disableonplayback"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(106), LED_PLAYBACK_OFF);     // No
-      pControl->AddLabel(g_localizeStrings.Get(13002), LED_PLAYBACK_VIDEO);   // Video Only
-      pControl->AddLabel(g_localizeStrings.Get(475), LED_PLAYBACK_MUSIC);    // Music Only
-      pControl->AddLabel(g_localizeStrings.Get(476), LED_PLAYBACK_VIDEO_MUSIC); // Video & Music
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("videoplayer.rendermethod"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(13355), RENDER_LQ_RGB_SHADER);
-      pControl->AddLabel(g_localizeStrings.Get(13356), RENDER_OVERLAYS);
-      pControl->AddLabel(g_localizeStrings.Get(13357), RENDER_HQ_RGB_SHADER);
-      pControl->AddLabel(g_localizeStrings.Get(21397), RENDER_HQ_RGB_SHADERV2);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("musicplayer.replaygaintype"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(351), REPLAY_GAIN_NONE);
-      pControl->AddLabel(g_localizeStrings.Get(639), REPLAY_GAIN_TRACK);
-      pControl->AddLabel(g_localizeStrings.Get(640), REPLAY_GAIN_ALBUM);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("musicplayer.defaultplayer"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(22027), PLAYER_PAPLAYER);
-      pControl->AddLabel(g_localizeStrings.Get(22029), PLAYER_MPLAYER);
-      pControl->AddLabel(g_localizeStrings.Get(22028), PLAYER_DVDPLAYER);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("lookandfeel.startupwindow"))
-    {
-      FillInStartupWindow(pSetting);
-    }
-    else if (strSetting.Equals("services.ftpserveruser"))
-    {
-      FillInFTPServerUser(pSetting);
-    }
-    else if (strSetting.Equals("autodetect.nickname"))
-    {
+	CSetting *pSetting = settings[i];
+	AddSetting(pSetting, group->GetWidth(), iControlID);
+	CStdString strSetting = pSetting->GetSetting();
+	if (strSetting.Equals("myprograms.ntscmode"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  for (int i = pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i++)
+	  {
+		pControl->AddLabel(g_localizeStrings.Get(16106 + i), i);
+	  }
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("musicplayer.visualisation"))
+	{
+	  FillInVisualisations(pSetting, GetSetting(pSetting->GetSetting())->GetID());
+	}
+	else if (strSetting.Equals("musiclibrary.scraper"))
+	{
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
+	  FillInScrapers(pControl, g_guiSettings.GetString("musiclibrary.scraper"), "music");
+	}
+	else if (strSetting.Equals("scrapers.moviedefault"))
+	{
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
+	  FillInScrapers(pControl, g_guiSettings.GetString("scrapers.moviedefault"), "movies");
+	}
+	else if (strSetting.Equals("scrapers.tvshowdefault"))
+	{
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
+	  FillInScrapers(pControl, g_guiSettings.GetString("scrapers.tvshowdefault"), "tvshows");
+	}
+	else if (strSetting.Equals("scrapers.musicvideodefault"))
+	{
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
+	  FillInScrapers(pControl, g_guiSettings.GetString("scrapers.musicvideodefault"), "musicvideos");
+	}
+	else if (strSetting.Equals("karaoke.port0voicemask"))
+	{
+	  FillInVoiceMasks(0, pSetting);
+	}
+	else if (strSetting.Equals("karaoke.port1voicemask"))
+	{
+	  FillInVoiceMasks(1, pSetting);
+	}
+	else if (strSetting.Equals("karaoke.port2voicemask"))
+	{
+	  FillInVoiceMasks(2, pSetting);
+	}
+	else if (strSetting.Equals("karaoke.port3voicemask"))
+	{
+	  FillInVoiceMasks(3, pSetting);
+	}
+	else if (strSetting.Equals("audiooutput.mode"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(338), AUDIO_ANALOG);
+	  if (g_audioConfig.HasDigitalOutput())
+		pControl->AddLabel(g_localizeStrings.Get(339), AUDIO_DIGITAL);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("videooutput.aspect"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(21375), VIDEO_NORMAL);
+	  pControl->AddLabel(g_localizeStrings.Get(21376), VIDEO_LETTERBOX);
+	  pControl->AddLabel(g_localizeStrings.Get(21377), VIDEO_WIDESCREEN);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("audiocds.encoder"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel("Lame", CDDARIP_ENCODER_LAME);
+	  pControl->AddLabel("Vorbis", CDDARIP_ENCODER_VORBIS);
+	  pControl->AddLabel("Wav", CDDARIP_ENCODER_WAV);
+	  pControl->AddLabel("Flac", CDDARIP_ENCODER_FLAC);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("audiocds.quality"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(604), CDDARIP_QUALITY_CBR);
+	  pControl->AddLabel(g_localizeStrings.Get(601), CDDARIP_QUALITY_MEDIUM);
+	  pControl->AddLabel(g_localizeStrings.Get(602), CDDARIP_QUALITY_STANDARD);
+	  pControl->AddLabel(g_localizeStrings.Get(603), CDDARIP_QUALITY_EXTREME);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("lcd.type"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(351), LCD_TYPE_NONE);
+	  pControl->AddLabel("LCD - HD44780", LCD_TYPE_LCD_HD44780);
+	  pControl->AddLabel("LCD - KS0073", LCD_TYPE_LCD_KS0073);
+	  pControl->AddLabel("VFD", LCD_TYPE_VFD);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("lcd.modchip"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel("SmartXX", MODCHIP_SMARTXX);
+	  pControl->AddLabel("Xenium", MODCHIP_XENIUM);
+	  pControl->AddLabel("Xecuter3", MODCHIP_XECUTER3);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("harddisk.aamlevel"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(21388), AAM_QUIET);
+	  pControl->AddLabel(g_localizeStrings.Get(21387), AAM_FAST);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("harddisk.apmlevel"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(21391), APM_HIPOWER);
+	  pControl->AddLabel(g_localizeStrings.Get(21392), APM_LOPOWER);
+	  pControl->AddLabel(g_localizeStrings.Get(21393), APM_HIPOWER_STANDBY);
+	  pControl->AddLabel(g_localizeStrings.Get(21394), APM_LOPOWER_STANDBY);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("system.targettemperature"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  for (int i = pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i++)
+	  {
+		CTemperature temp=CTemperature::CreateFromCelsius(i);
+		pControl->AddLabel(temp.ToString(), i);
+	  }
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("system.fanspeed") || strSetting.Equals("system.minfanspeed"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  CStdString strPercentMask = g_localizeStrings.Get(14047);
+	  for (int i=pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i += pSettingInt->m_iStep)
+	  {
+		CStdString strLabel;
+		strLabel.Format(strPercentMask.c_str(), i*2);
+		pControl->AddLabel(strLabel, i);
+	  }
+	  pControl->SetValue(int(pSettingInt->GetData()));
+	}
+	else if (strSetting.Equals("harddisk.remoteplayspindown"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(474), SPIN_DOWN_NONE);
+	  pControl->AddLabel(g_localizeStrings.Get(475), SPIN_DOWN_MUSIC);
+	  pControl->AddLabel(g_localizeStrings.Get(13002), SPIN_DOWN_VIDEO);
+	  pControl->AddLabel(g_localizeStrings.Get(476), SPIN_DOWN_BOTH);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("services.webserverusername"))
+	{
+	  // get password from the webserver if it's running (and update our settings)
+	  if (g_application.m_pWebServer)
+	  {
+		((CSettingString *)GetSetting(strSetting)->GetSetting())->SetData(g_application.m_pWebServer->GetUserName());
+		g_settings.Save();
+	  }
+	}
+	else if (strSetting.Equals("services.webserverpassword"))
+	{
+	  // get password from the webserver if it's running (and update our settings)
+	  if (g_application.m_pWebServer)
+	  {
+		((CSettingString *)GetSetting(strSetting)->GetSetting())->SetData(g_application.m_pWebServer->GetPassword());
+		g_settings.Save();
+	  }
+	}
+	else if (strSetting.Equals("services.webserverport"))
+	{
+	  CBaseSettingControl *control = GetSetting(pSetting->GetSetting());
+	  control->SetDelayed();
+	}
+	else if (strSetting.Equals("services.esport"))
+	{
+	  CBaseSettingControl *control = GetSetting(pSetting->GetSetting());
+	  control->SetDelayed();
+	}
+	else if (strSetting.Equals("network.assignment"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(718), NETWORK_DASH);
+	  pControl->AddLabel(g_localizeStrings.Get(716), NETWORK_DHCP);
+	  pControl->AddLabel(g_localizeStrings.Get(717), NETWORK_STATIC);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("network.httpproxyport"))
+	{
+	  CBaseSettingControl *control = GetSetting(pSetting->GetSetting());
+	  control->SetDelayed();
+	}
+	else if (strSetting.Equals("subtitles.style"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(738), FONT_STYLE_NORMAL);
+	  pControl->AddLabel(g_localizeStrings.Get(739), FONT_STYLE_BOLD);
+	  pControl->AddLabel(g_localizeStrings.Get(740), FONT_STYLE_ITALICS);
+	  pControl->AddLabel(g_localizeStrings.Get(741), FONT_STYLE_BOLD_ITALICS);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("subtitles.color"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  for (int i = SUBTITLE_COLOR_START; i <= SUBTITLE_COLOR_END; i++)
+		pControl->AddLabel(g_localizeStrings.Get(760 + i), i);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("subtitles.height"))
+	{
+	  FillInSubtitleHeights(pSetting);
+	}
+	else if (strSetting.Equals("subtitles.font"))
+	{
+	  FillInSubtitleFonts(pSetting);
+	}
+	else if (strSetting.Equals("subtitles.charset") || strSetting.Equals("locale.charset"))
+	{
+	  FillInCharSets(pSetting);
+	}
+	else if (strSetting.Equals("lookandfeel.font"))
+	{
+	  FillInSkinFonts(pSetting);
+	}
+	else if (strSetting.Equals("lookandfeel.skin"))
+	{
+	  FillInSkins(pSetting);
+	}
+	else if (strSetting.Equals("lookandfeel.soundskin"))
+	{
+	  FillInSoundSkins(pSetting);
+	}
+	else if (strSetting.Equals("locale.language"))
+	{
+	  FillInLanguages(pSetting);
+	}
+	else if (strSetting.Equals("locale.timezone"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  for (int i=0; i < g_timezone.GetNumberOfTimeZones(); i++)
+		pControl->AddLabel(g_timezone.GetTimeZoneString(i), i);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("videoscreen.resolution"))
+	{
+	  FillInResolutions(pSetting, false);
+	}
+	else if (strSetting.Equals("lookandfeel.skintheme"))
+	{
+	  FillInSkinThemes(pSetting);
+	}
+	else if (strSetting.Equals("lookandfeel.skincolors"))
+	{
+	  FillInSkinColors(pSetting);
+	}
+	else if (strSetting.Equals("screensaver.mode"))
+	{
+	  FillInScreenSavers(pSetting);
+	}
+	else if (strSetting.Equals("videoplayer.displayresolution") || strSetting.Equals("pictures.displayresolution"))
+	{
+	  FillInResolutions(pSetting, true);
+	}
+	else if (strSetting.Equals("videoplayer.framerateconversions"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(231), FRAME_RATE_LEAVE_AS_IS); // "None"
+	  pControl->AddLabel(g_videoConfig.HasPAL() ? g_localizeStrings.Get(12380) : g_localizeStrings.Get(12381), FRAME_RATE_CONVERT); // "Play PAL videos at NTSC rates" or "Play NTSC videos at PAL rates"
+	  if (g_videoConfig.HasPAL() && g_videoConfig.HasPAL60())
+		pControl->AddLabel(g_localizeStrings.Get(12382), FRAME_RATE_USE_PAL60); // "Play NTSC videos in PAL60"
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("videoplayer.skiploopfilter"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(14101), VS_SKIPLOOP_DEFAULT);
+	  pControl->AddLabel(g_localizeStrings.Get(14102), VS_SKIPLOOP_NONREF);
+	  pControl->AddLabel(g_localizeStrings.Get(14103), VS_SKIPLOOP_BIDIR);
+	  pControl->AddLabel(g_localizeStrings.Get(14104), VS_SKIPLOOP_NONKEY);
+	  pControl->AddLabel(g_localizeStrings.Get(14105), VS_SKIPLOOP_ALL);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("videolibrary.flattentvshows"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(20420), 0); // Never
+	  pControl->AddLabel(g_localizeStrings.Get(20421), 1); // One Season
+	  pControl->AddLabel(g_localizeStrings.Get(20422), 2); // Always
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("system.ledcolour"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(13340), LED_COLOUR_NO_CHANGE);
+	  pControl->AddLabel(g_localizeStrings.Get(13341), LED_COLOUR_GREEN);
+	  pControl->AddLabel(g_localizeStrings.Get(13342), LED_COLOUR_ORANGE);
+	  pControl->AddLabel(g_localizeStrings.Get(13343), LED_COLOUR_RED);
+	  pControl->AddLabel(g_localizeStrings.Get(13344), LED_COLOUR_CYCLE);
+	  pControl->AddLabel(g_localizeStrings.Get(351), LED_COLOUR_OFF);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("system.leddisableonplayback") || strSetting.Equals("lcd.disableonplayback"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(106), LED_PLAYBACK_OFF);     // No
+	  pControl->AddLabel(g_localizeStrings.Get(13002), LED_PLAYBACK_VIDEO);   // Video Only
+	  pControl->AddLabel(g_localizeStrings.Get(475), LED_PLAYBACK_MUSIC);    // Music Only
+	  pControl->AddLabel(g_localizeStrings.Get(476), LED_PLAYBACK_VIDEO_MUSIC); // Video & Music
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("videoplayer.rendermethod"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(13355), RENDER_LQ_RGB_SHADER);
+	  pControl->AddLabel(g_localizeStrings.Get(13356), RENDER_OVERLAYS);
+	  pControl->AddLabel(g_localizeStrings.Get(13357), RENDER_HQ_RGB_SHADER);
+	  pControl->AddLabel(g_localizeStrings.Get(21397), RENDER_HQ_RGB_SHADERV2);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("musicplayer.replaygaintype"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(351), REPLAY_GAIN_NONE);
+	  pControl->AddLabel(g_localizeStrings.Get(639), REPLAY_GAIN_TRACK);
+	  pControl->AddLabel(g_localizeStrings.Get(640), REPLAY_GAIN_ALBUM);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("musicplayer.defaultplayer"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(22027), PLAYER_PAPLAYER);
+	  pControl->AddLabel(g_localizeStrings.Get(22029), PLAYER_MPLAYER);
+	  pControl->AddLabel(g_localizeStrings.Get(22028), PLAYER_DVDPLAYER);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("lookandfeel.startupwindow"))
+	{
+	  FillInStartupWindow(pSetting);
+	}
+	else if (strSetting.Equals("services.ftpserveruser"))
+	{
+	  FillInFTPServerUser(pSetting);
+	}
+	else if (strSetting.Equals("autodetect.nickname"))
+	{
 #ifdef HAS_XBOX_HARDWARE
-      CStdString strXboxNickNameOut;
-      if (CUtil::GetXBOXNickName(strXboxNickNameOut))
-        g_guiSettings.SetString("autodetect.nickname", strXboxNickNameOut.c_str());
+	  CStdString strXboxNickNameOut;
+	  if (CUtil::GetXBOXNickName(strXboxNickNameOut))
+		g_guiSettings.SetString("autodetect.nickname", strXboxNickNameOut.c_str());
 #endif
-    }
-    else if (strSetting.Equals("dvds.externaldvdplayer"))
-    {
-      CSettingString *pSettingString = (CSettingString *)pSetting;
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(GetSetting(strSetting)->GetID());
-      if (pSettingString->GetData().IsEmpty())
-        pControl->SetLabel2(g_localizeStrings.Get(20009));
-    }
-    else if (strSetting.Equals("locale.country"))
-    {
-      FillInRegions(pSetting);
-    }
-    else if (strSetting.Equals("videoplayer.resumeautomatically"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(106), RESUME_NO);
-      pControl->AddLabel(g_localizeStrings.Get(107), RESUME_YES);
-      pControl->AddLabel(g_localizeStrings.Get(12020), RESUME_ASK);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("videoplayer.defaultplayer"))
-    {
-      CSettingInt *pSettingInt = (CSettingInt*)pSetting;
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->AddLabel(g_localizeStrings.Get(22029), PLAYER_MPLAYER);
-      pControl->AddLabel(g_localizeStrings.Get(22028), PLAYER_DVDPLAYER);
-      pControl->SetValue(pSettingInt->GetData());
-    }
-    else if (strSetting.Equals("weather.plugin"))
-    {
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
-      FillInWeatherPlugins(pControl, g_guiSettings.GetString("weather.plugin"));
-    }
+	}
+	else if (strSetting.Equals("dvds.externaldvdplayer"))
+	{
+	  CSettingString *pSettingString = (CSettingString *)pSetting;
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(GetSetting(strSetting)->GetID());
+	  if (pSettingString->GetData().IsEmpty())
+		pControl->SetLabel2(g_localizeStrings.Get(20009));
+	}
+	else if (strSetting.Equals("locale.country"))
+	{
+	  FillInRegions(pSetting);
+	}
+	else if (strSetting.Equals("videoplayer.resumeautomatically"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(106), RESUME_NO);
+	  pControl->AddLabel(g_localizeStrings.Get(107), RESUME_YES);
+	  pControl->AddLabel(g_localizeStrings.Get(12020), RESUME_ASK);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("videoplayer.defaultplayer"))
+	{
+	  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->AddLabel(g_localizeStrings.Get(22029), PLAYER_MPLAYER);
+	  pControl->AddLabel(g_localizeStrings.Get(22028), PLAYER_DVDPLAYER);
+	  pControl->SetValue(pSettingInt->GetData());
+	}
+	else if (strSetting.Equals("weather.plugin"))
+	{
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
+	  FillInWeatherPlugins(pControl, g_guiSettings.GetString("weather.plugin"));
+	}
   }
   // update our settings (turns controls on/off as appropriate)
   UpdateSettings();
@@ -836,374 +851,376 @@
 {
   for (unsigned int i = 0; i < m_vecSettings.size(); i++)
   {
-    CBaseSettingControl *pSettingControl = m_vecSettings[i];
-    pSettingControl->Update();
-    CStdString strSetting = pSettingControl->GetSetting()->GetSetting();
-    if (strSetting.Equals("filelists.allowfiledeletion"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(!g_settings.GetCurrentProfile().filesLocked() || g_passwordManager.bMasterUser);
-    }
-    else if (strSetting.Equals("filelists.showaddsourcebuttons"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_settings.GetCurrentProfile().canWriteSources() || g_passwordManager.bMasterUser);
-    }
-    else if (strSetting.Equals("myprograms.ntscmode"))
-    { // set visibility based on our other setting...
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("myprograms.gameautoregion"));
-    }
-    else if (strSetting.Equals("masterlock.startuplock") || strSetting.Equals("masterlock.enableshutdown"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE);
-    }
-    else if (!strSetting.Equals("services.esenabled")
-             && strSetting.Left(11).Equals("services.es"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("services.esenabled"));
-    }
-    else if (strSetting.Equals("audiocds.quality"))
-    { // only visible if we are not ripping as WAV or FLAC
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_WAV &&
-                                         g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_FLAC);
-    }
-    else if (strSetting.Equals("audiocds.bitrate"))
-    { // only visible if we are ripping to CBR
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_WAV && 
-                                         g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_FLAC &&
-                                         g_guiSettings.GetInt("audiocds.quality") == CDDARIP_QUALITY_CBR);
-    }
-    else if (strSetting.Equals("audiocds.compressionlevel"))
-    { // only visible if we are doing FLAC ripping
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiocds.encoder") == CDDARIP_ENCODER_FLAC);
-    }
-    else if (
-             strSetting.Equals("musicplayer.outputtoallspeakers") ||
-             strSetting.Equals("audiooutput.ac3passthrough") ||
-             strSetting.Equals("audiooutput.dtspassthrough") ||
-             strSetting.Equals("audiooutput.aacpassthrough") ||
-             strSetting.Equals("audiooutput.mp1passthrough") ||
-             strSetting.Equals("audiooutput.mp2passthrough") ||
-             strSetting.Equals("audiooutput.mp3passthrough"))
-    { // only visible if we are in digital mode
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiooutput.mode") == AUDIO_DIGITAL);
-    }
-    else if (strSetting.Equals("videooutput.hd480p") || strSetting.Equals("videooutput.hd720p") || strSetting.Equals("videooutput.hd1080i"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      // disable if we do not have the HDTV pack and are not NTSC
+	CBaseSettingControl *pSettingControl = m_vecSettings[i];
+	pSettingControl->Update();
+	CStdString strSetting = pSettingControl->GetSetting()->GetSetting();
+	if (strSetting.Equals("filelists.allowfiledeletion"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(!g_settings.GetCurrentProfile().filesLocked() || g_passwordManager.bMasterUser);
+	}
+	else if (strSetting.Equals("filelists.showaddsourcebuttons"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_settings.GetCurrentProfile().canWriteSources() || g_passwordManager.bMasterUser);
+	}
+	else if (strSetting.Equals("myprograms.ntscmode"))
+	{ // set visibility based on our other setting...
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("myprograms.gameautoregion"));
+	}
+	else if (strSetting.Equals("masterlock.startuplock") || strSetting.Equals("masterlock.enableshutdown"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE);
+	}
+	else if (!strSetting.Equals("services.esenabled")
+			 && strSetting.Left(11).Equals("services.es"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("services.esenabled"));
+	}
+	else if (strSetting.Equals("audiocds.quality"))
+	{ // only visible if we are not ripping as WAV or FLAC
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_WAV &&
+										 g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_FLAC);
+	}
+	else if (strSetting.Equals("audiocds.bitrate"))
+	{ // only visible if we are ripping to CBR
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_WAV && 
+										 g_guiSettings.GetInt("audiocds.encoder") != CDDARIP_ENCODER_FLAC &&
+										 g_guiSettings.GetInt("audiocds.quality") == CDDARIP_QUALITY_CBR);
+	}
+	else if (strSetting.Equals("audiocds.compressionlevel"))
+	{ // only visible if we are doing FLAC ripping
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiocds.encoder") == CDDARIP_ENCODER_FLAC);
+	}
+	else if (
+			 strSetting.Equals("musicplayer.outputtoallspeakers") ||
+			 strSetting.Equals("audiooutput.ac3passthrough") ||
+			 strSetting.Equals("audiooutput.dtspassthrough") ||
+			 strSetting.Equals("audiooutput.aacpassthrough") ||
+			 strSetting.Equals("audiooutput.mp1passthrough") ||
+			 strSetting.Equals("audiooutput.mp2passthrough") ||
+			 strSetting.Equals("audiooutput.mp3passthrough"))
+	{ // only visible if we are in digital mode
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiooutput.mode") == AUDIO_DIGITAL);
+	}
+	else if (strSetting.Equals("videooutput.hd480p") || strSetting.Equals("videooutput.hd720p") || strSetting.Equals("videooutput.hd1080i"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  // disable if we do not have the HDTV pack and are not NTSC
 #ifdef HAS_XBOX_HARDWARE
-      if (pControl) pControl->SetEnabled(g_videoConfig.HasNTSC() && g_videoConfig.HasHDPack());
+	  if (pControl) pControl->SetEnabled(g_videoConfig.HasNTSC() && g_videoConfig.HasHDPack());
 #endif
-    }
-    else if (strSetting.Equals("musicplayer.crossfadealbumtracks"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("musicplayer.crossfade") > 0);
-    }
-    else if (strSetting.Left(12).Equals("karaoke.port") || strSetting.Equals("karaoke.volume"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("karaoke.voiceenabled"));
-    }
-    else if (strSetting.Equals("system.fanspeed"))
-    { // only visible if we have fancontrolspeed enabled
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("system.fanspeedcontrol"));
-    }
-    else if (strSetting.Equals("system.targettemperature") || strSetting.Equals("system.minfanspeed"))
-    { // only visible if we have autotemperature enabled
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("system.autotemperature"));
-    }
-    else if (strSetting.Equals("harddisk.remoteplayspindowndelay"))
-    { // only visible if we have spin down enabled
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("harddisk.remoteplayspindown") != SPIN_DOWN_NONE);
-    }
-    else if (strSetting.Equals("harddisk.remoteplayspindownminduration"))
-    { // only visible if we have spin down enabled
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("harddisk.remoteplayspindown") != SPIN_DOWN_NONE);
-    }
-    else if (strSetting.Equals("services.ftpserveruser") || strSetting.Equals("services.ftpserverpassword") || strSetting.Equals("services.ftpautofatx"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      pControl->SetEnabled(g_guiSettings.GetBool("services.ftpserver"));
-    }
-    else if (strSetting.Equals("services.webserverusername"))
-    {
-      CGUIEditControl *pControl = (CGUIEditControl *)GetControl(pSettingControl->GetID());
-      if (pControl)
-        pControl->SetEnabled(g_guiSettings.GetBool("services.webserver"));
-    }
-    else if (strSetting.Equals("services.webserverpassword"))
-    { // Fill in a blank pass if we don't have it
-      CGUIEditControl *pControl = (CGUIEditControl *)GetControl(pSettingControl->GetID());
-      if (((CSettingString *)pSettingControl->GetSetting())->GetData().size() == 0 && pControl)
-      {
-        pControl->SetLabel2(g_localizeStrings.Get(734));
-        pControl->SetEnabled(g_guiSettings.GetBool("services.webserver"));
-      }
-    }
-    else if (strSetting.Equals("network.ipaddress") || strSetting.Equals("network.subnet") || strSetting.Equals("network.gateway") || strSetting.Equals("network.dns"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      if (pControl)
-      {
-        if (g_guiSettings.GetInt("network.assignment") != NETWORK_STATIC)
-        {
-          //We are in non Static Mode! Setting the Received IP Information
-          if(strSetting.Equals("network.ipaddress"))
-            pControl->SetLabel2(g_application.getNetwork().m_networkinfo.ip);
-          else if(strSetting.Equals("network.subnet"))
-            pControl->SetLabel2(g_application.getNetwork().m_networkinfo.subnet);
-          else if(strSetting.Equals("network.gateway"))
-            pControl->SetLabel2(g_application.getNetwork().m_networkinfo.gateway);
-          else if(strSetting.Equals("network.dns"))
-            pControl->SetLabel2(g_application.getNetwork().m_networkinfo.DNS1);
-        }
-        pControl->SetEnabled(g_guiSettings.GetInt("network.assignment") == NETWORK_STATIC);
-      }
-    }
-    else if (strSetting.Equals("network.httpproxyserver")   || strSetting.Equals("network.httpproxyport") ||
-             strSetting.Equals("network.httpproxyusername") || strSetting.Equals("network.httpproxypassword"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("network.usehttpproxy"));
-    }
-    else if (strSetting.Equals("scrobbler.lastfmusername") || strSetting.Equals("scrobbler.lastfmpass"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      if (pControl)
-        pControl->SetEnabled(g_guiSettings.GetBool("scrobbler.lastfmsubmit") | g_guiSettings.GetBool("scrobbler.lastfmsubmitradio"));
-    }
-    else if (strSetting.Equals("scrobbler.librefmusername") || strSetting.Equals("scrobbler.librefmpass"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("scrobbler.librefmsubmit"));
-    }
-    else if (strSetting.Equals("postprocessing.verticaldeblocklevel"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.verticaldeblocking") &&
-                           g_guiSettings.GetBool("postprocessing.enable") &&
-                           !g_guiSettings.GetBool("postprocessing.auto"));
-    }
-    else if (strSetting.Equals("postprocessing.horizontaldeblocklevel"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.horizontaldeblocking") &&
-                           g_guiSettings.GetBool("postprocessing.enable") &&
-                           !g_guiSettings.GetBool("postprocessing.auto"));
-    }
-    else if (strSetting.Equals("postprocessing.verticaldeblocking") || strSetting.Equals("postprocessing.horizontaldeblocking") || strSetting.Equals("postprocessing.autobrightnesscontrastlevels") || strSetting.Equals("postprocessing.dering"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.enable") &&
-                           !g_guiSettings.GetBool("postprocessing.auto"));
-    }
-    else if (strSetting.Equals("postprocessing.auto"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.enable"));
-    }
-    else if (strSetting.Equals("VideoPlayer.InvertFieldSync"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->SetEnabled(g_guiSettings.GetBool("VideoPlayer.FieldSync"));
-    }
-    else if (strSetting.Equals("subtitles.color") || strSetting.Equals("subtitles.style") || strSetting.Equals("subtitles.charset"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->SetEnabled(CUtil::IsUsingTTFSubtitles());
-    }
-    else if (strSetting.Equals("locale.charset"))
-    { // TODO: Determine whether we are using a TTF font or not.
-      //   CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      //   if (pControl) pControl->SetEnabled(g_guiSettings.GetString("lookandfeel.font").Right(4) == ".ttf");
-    }
-    else if (strSetting.Equals("screensaver.dimlevel"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") == "Dim");
-    }
-    else if (strSetting.Equals("screensaver.slideshowpath"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") == "SlideShow");
-    }
-    else if (strSetting.Equals("screensaver.slideshowshuffle"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") == "SlideShow" ||
-                           g_guiSettings.GetString("screensaver.mode") == "Fanart Slideshow");
-    }
-    else if (strSetting.Equals("screensaver.preview")           ||
-             strSetting.Equals("screensaver.usedimonpause")     ||
-             strSetting.Equals("screensaver.usemusicvisinstead"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") != "None");
-      if (strSetting.Equals("screensaver.usedimonpause") && g_guiSettings.GetString("screensaver.mode").Equals("Dim"))
-        pControl->SetEnabled(false);
-    }
-    else if (strSetting.Left(16).Equals("weather.areacode"))
-    {
-      CSettingString *pSetting = (CSettingString *)GetSetting(strSetting)->GetSetting();
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(GetSetting(strSetting)->GetID());
-      pControl->SetLabel2(g_weatherManager.GetAreaCity(pSetting->GetData()));
-    }
-    else if (strSetting.Equals("weather.plugin"))
-    {
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-      if (pControl->GetCurrentLabel().Equals(g_localizeStrings.Get(13611)))
-        g_guiSettings.SetString("weather.plugin", "");
-      else
-        g_guiSettings.SetString("weather.plugin", pControl->GetCurrentLabel());
-    }
-    else if (strSetting.Equals("system.leddisableonplayback"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
-      // LED_COLOUR_NO_CHANGE: we can't disable the LED on playback, 
-      //                       we have no previos reference LED COLOUR, to set the LED colour back
-      pControl->SetEnabled(g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_NO_CHANGE && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_OFF);
-    }
-    else if (strSetting.Equals("musicfiles.trackformat"))
-    {
-      if (m_strOldTrackFormat != g_guiSettings.GetString("musicfiles.trackformat"))
-      {
-        CUtil::DeleteMusicDatabaseDirectoryCache();
-        m_strOldTrackFormat = g_guiSettings.GetString("musicfiles.trackformat");
-      }
-    }
-    else if (strSetting.Equals("musicfiles.trackformatright"))
-    {
-      if (m_strOldTrackFormatRight != g_guiSettings.GetString("musicfiles.trackformatright"))
-      {
-        CUtil::DeleteMusicDatabaseDirectoryCache();
-        m_strOldTrackFormatRight = g_guiSettings.GetString("musicfiles.trackformatright");
-      }
-    }
+	}
+	else if (strSetting.Equals("musicplayer.crossfadealbumtracks"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("musicplayer.crossfade") > 0);
+	}
+	else if (strSetting.Left(12).Equals("karaoke.port") || strSetting.Equals("karaoke.volume"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("karaoke.voiceenabled"));
+	}
+	else if (strSetting.Equals("system.fanspeed"))
+	{ // only visible if we have fancontrolspeed enabled
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("system.fanspeedcontrol"));
+	}
+	else if (strSetting.Equals("system.targettemperature") || strSetting.Equals("system.minfanspeed"))
+	{ // only visible if we have autotemperature enabled
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("system.autotemperature"));
+	}
+	else if (strSetting.Equals("harddisk.remoteplayspindowndelay"))
+	{ // only visible if we have spin down enabled
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("harddisk.remoteplayspindown") != SPIN_DOWN_NONE);
+	}
+	else if (strSetting.Equals("harddisk.remoteplayspindownminduration"))
+	{ // only visible if we have spin down enabled
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("harddisk.remoteplayspindown") != SPIN_DOWN_NONE);
+	}
+	else if (strSetting.Equals("services.ftpserveruser") || strSetting.Equals("services.ftpserverpassword") || strSetting.Equals("services.ftpautofatx"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetBool("services.ftpserver"));
+	}
+	else if (strSetting.Equals("services.webserverusername"))
+	{
+	  CGUIEditControl *pControl = (CGUIEditControl *)GetControl(pSettingControl->GetID());
+	  if (pControl)
+		pControl->SetEnabled(g_guiSettings.GetBool("services.webserver"));
+	}
+	else if (strSetting.Equals("services.webserverpassword"))
+	{ // Fill in a blank pass if we don't have it
+	  CGUIEditControl *pControl = (CGUIEditControl *)GetControl(pSettingControl->GetID());
+	  if (((CSettingString *)pSettingControl->GetSetting())->GetData().size() == 0 && pControl)
+	  {
+		pControl->SetLabel2(g_localizeStrings.Get(734));
+		pControl->SetEnabled(g_guiSettings.GetBool("services.webserver"));
+	  }
+	}
+	else if (strSetting.Equals("network.ipaddress") || strSetting.Equals("network.subnet") || strSetting.Equals("network.gateway") || strSetting.Equals("network.dns") || strSetting.Equals("network.dns2"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  if (pControl)
+	  {
+		if (g_guiSettings.GetInt("network.assignment") != NETWORK_STATIC)
+		{
+		  //We are in non Static Mode! Setting the Received IP Information
+		  if(strSetting.Equals("network.ipaddress"))
+			pControl->SetLabel2(g_application.getNetwork().m_networkinfo.ip);
+		  else if(strSetting.Equals("network.subnet"))
+			pControl->SetLabel2(g_application.getNetwork().m_networkinfo.subnet);
+		  else if(strSetting.Equals("network.gateway"))
+			pControl->SetLabel2(g_application.getNetwork().m_networkinfo.gateway);
+		  else if(strSetting.Equals("network.dns"))
+			pControl->SetLabel2(g_application.getNetwork().m_networkinfo.DNS1);
+		  else if(strSetting.Equals("network.dns2"))
+			pControl->SetLabel2(g_application.getNetwork().m_networkinfo.DNS2);
+		}
+		pControl->SetEnabled(g_guiSettings.GetInt("network.assignment") == NETWORK_STATIC);
+	  }
+	}
+	else if (strSetting.Equals("network.httpproxyserver")   || strSetting.Equals("network.httpproxyport") ||
+			 strSetting.Equals("network.httpproxyusername") || strSetting.Equals("network.httpproxypassword"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("network.usehttpproxy"));
+	}
+	else if (strSetting.Equals("scrobbler.lastfmusername") || strSetting.Equals("scrobbler.lastfmpass"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  if (pControl)
+		pControl->SetEnabled(g_guiSettings.GetBool("scrobbler.lastfmsubmit") | g_guiSettings.GetBool("scrobbler.lastfmsubmitradio"));
+	}
+	else if (strSetting.Equals("scrobbler.librefmusername") || strSetting.Equals("scrobbler.librefmpass"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("scrobbler.librefmsubmit"));
+	}
+	else if (strSetting.Equals("postprocessing.verticaldeblocklevel"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.verticaldeblocking") &&
+						   g_guiSettings.GetBool("postprocessing.enable") &&
+						   !g_guiSettings.GetBool("postprocessing.auto"));
+	}
+	else if (strSetting.Equals("postprocessing.horizontaldeblocklevel"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.horizontaldeblocking") &&
+						   g_guiSettings.GetBool("postprocessing.enable") &&
+						   !g_guiSettings.GetBool("postprocessing.auto"));
+	}
+	else if (strSetting.Equals("postprocessing.verticaldeblocking") || strSetting.Equals("postprocessing.horizontaldeblocking") || strSetting.Equals("postprocessing.autobrightnesscontrastlevels") || strSetting.Equals("postprocessing.dering"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.enable") &&
+						   !g_guiSettings.GetBool("postprocessing.auto"));
+	}
+	else if (strSetting.Equals("postprocessing.auto"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetBool("postprocessing.enable"));
+	}
+	else if (strSetting.Equals("VideoPlayer.InvertFieldSync"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetBool("VideoPlayer.FieldSync"));
+	}
+	else if (strSetting.Equals("subtitles.color") || strSetting.Equals("subtitles.style") || strSetting.Equals("subtitles.charset"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->SetEnabled(CUtil::IsUsingTTFSubtitles());
+	}
+	else if (strSetting.Equals("locale.charset"))
+	{ // TODO: Determine whether we are using a TTF font or not.
+	  //   CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  //   if (pControl) pControl->SetEnabled(g_guiSettings.GetString("lookandfeel.font").Right(4) == ".ttf");
+	}
+	else if (strSetting.Equals("screensaver.dimlevel"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") == "Dim");
+	}
+	else if (strSetting.Equals("screensaver.slideshowpath"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") == "SlideShow");
+	}
+	else if (strSetting.Equals("screensaver.slideshowshuffle"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") == "SlideShow" ||
+						   g_guiSettings.GetString("screensaver.mode") == "Fanart Slideshow");
+	}
+	else if (strSetting.Equals("screensaver.preview")           ||
+			 strSetting.Equals("screensaver.usedimonpause")     ||
+			 strSetting.Equals("screensaver.usemusicvisinstead"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->SetEnabled(g_guiSettings.GetString("screensaver.mode") != "None");
+	  if (strSetting.Equals("screensaver.usedimonpause") && g_guiSettings.GetString("screensaver.mode").Equals("Dim"))
+		pControl->SetEnabled(false);
+	}
+	else if (strSetting.Left(16).Equals("weather.areacode"))
+	{
+	  CSettingString *pSetting = (CSettingString *)GetSetting(strSetting)->GetSetting();
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(GetSetting(strSetting)->GetID());
+	  pControl->SetLabel2(g_weatherManager.GetAreaCity(pSetting->GetData()));
+	}
+	else if (strSetting.Equals("weather.plugin"))
+	{
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	  if (pControl->GetCurrentLabel().Equals(g_localizeStrings.Get(13611)))
+		g_guiSettings.SetString("weather.plugin", "");
+	  else
+		g_guiSettings.SetString("weather.plugin", pControl->GetCurrentLabel());
+	}
+	else if (strSetting.Equals("system.leddisableonplayback"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(GetSetting(strSetting)->GetID());
+	  // LED_COLOUR_NO_CHANGE: we can't disable the LED on playback, 
+	  //                       we have no previos reference LED COLOUR, to set the LED colour back
+	  pControl->SetEnabled(g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_NO_CHANGE && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_OFF);
+	}
+	else if (strSetting.Equals("musicfiles.trackformat"))
+	{
+	  if (m_strOldTrackFormat != g_guiSettings.GetString("musicfiles.trackformat"))
+	  {
+		CUtil::DeleteMusicDatabaseDirectoryCache();
+		m_strOldTrackFormat = g_guiSettings.GetString("musicfiles.trackformat");
+	  }
+	}
+	else if (strSetting.Equals("musicfiles.trackformatright"))
+	{
+	  if (m_strOldTrackFormatRight != g_guiSettings.GetString("musicfiles.trackformatright"))
+	  {
+		CUtil::DeleteMusicDatabaseDirectoryCache();
+		m_strOldTrackFormatRight = g_guiSettings.GetString("musicfiles.trackformatright");
+	  }
+	}
 #ifdef HAS_TIME_SERVER
-    else if (strSetting.Equals("locale.timeserveraddress"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("locale.timeserver"));
-    }
-    else if (strSetting.Equals("locale.time") || strSetting.Equals("locale.date"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(!g_guiSettings.GetBool("locale.timeserver"));
-      SYSTEMTIME curTime;
-      GetLocalTime(&curTime);
-      CStdString time;
-      if (strSetting.Equals("locale.time"))
-        time = g_infoManager.GetTime();
-      else
-        time = g_infoManager.GetDate();
-      CSettingString *pSettingString = (CSettingString*)pSettingControl->GetSetting();
-      pSettingString->SetData(time);
-      pSettingControl->Update();
-    }
+	else if (strSetting.Equals("locale.timeserveraddress"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("locale.timeserver"));
+	}
+	else if (strSetting.Equals("locale.time") || strSetting.Equals("locale.date"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(!g_guiSettings.GetBool("locale.timeserver"));
+	  SYSTEMTIME curTime;
+	  GetLocalTime(&curTime);
+	  CStdString time;
+	  if (strSetting.Equals("locale.time"))
+		time = g_infoManager.GetTime();
+	  else
+		time = g_infoManager.GetDate();
+	  CSettingString *pSettingString = (CSettingString*)pSettingControl->GetSetting();
+	  pSettingString->SetData(time);
+	  pSettingControl->Update();
+	}
 #endif
-    else if (strSetting.Equals("autodetect.nickname") || strSetting.Equals("autodetect.senduserpw"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("autodetect.onoff") && (g_settings.GetCurrentProfileIndex() == 0));
-    }
-    else if ( strSetting.Equals("autodetect.popupinfo"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("autodetect.onoff"));
-    }
-    else if (strSetting.Equals("dvds.externaldvdplayer"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("dvds.useexternaldvdplayer"));
-    }
-    else if (strSetting.Equals("myprograms.trainerpath") || strSetting.Equals("audiocds.recordingpath") || strSetting.Equals("debug.screenshotpath"))
-    {
-      CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
-      if (pControl && g_guiSettings.GetString(strSetting, false).IsEmpty())
-        pControl->SetLabel2("");
-    }
-    else if (strSetting.Equals("lookandfeel.rssedit"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      pControl->SetEnabled(XFILE::CFile::Exists(RSSEDITOR_PATH) && g_guiSettings.GetBool("lookandfeel.enablerssfeeds"));
-    }
-    else if (strSetting.Equals("myprograms.dashboard"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("myprograms.usedashpath"));
-    }
-    else if (strSetting.Equals("lcd.enableonpaused"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("lcd.disableonplayback") != LED_PLAYBACK_OFF && g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE);
-    }
-    else if (strSetting.Equals("musiclibrary.scrapersettings"))
-    {
-      CScraperParser parser;
-      bool enabled=false;
-      if (parser.Load("special://xbmc/system/scrapers/music/"+g_guiSettings.GetString("musiclibrary.scraper")))
-        enabled = parser.HasFunction("GetSettings");
+	else if (strSetting.Equals("autodetect.nickname") || strSetting.Equals("autodetect.senduserpw"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("autodetect.onoff") && (g_settings.GetCurrentProfileIndex() == 0));
+	}
+	else if ( strSetting.Equals("autodetect.popupinfo"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("autodetect.onoff"));
+	}
+	else if (strSetting.Equals("dvds.externaldvdplayer"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("dvds.useexternaldvdplayer"));
+	}
+	else if (strSetting.Equals("myprograms.trainerpath") || strSetting.Equals("audiocds.recordingpath") || strSetting.Equals("debug.screenshotpath"))
+	{
+	  CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(pSettingControl->GetID());
+	  if (pControl && g_guiSettings.GetString(strSetting, false).IsEmpty())
+		pControl->SetLabel2("");
+	}
+	else if (strSetting.Equals("lookandfeel.rssedit"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  pControl->SetEnabled(XFILE::CFile::Exists(RSSEDITOR_PATH) && g_guiSettings.GetBool("lookandfeel.enablerssfeeds"));
+	}
+	else if (strSetting.Equals("myprograms.dashboard"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("myprograms.usedashpath"));
+	}
+	else if (strSetting.Equals("lcd.enableonpaused"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("lcd.disableonplayback") != LED_PLAYBACK_OFF && g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE);
+	}
+	else if (strSetting.Equals("musiclibrary.scrapersettings"))
+	{
+	  CScraperParser parser;
+	  bool enabled=false;
+	  if (parser.Load("special://xbmc/system/scrapers/music/"+g_guiSettings.GetString("musiclibrary.scraper")))
+		enabled = parser.HasFunction("GetSettings");
 
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(enabled);
-    }
-    else if (strSetting.Equals("system.ledenableonpaused"))
-    {
-      // LED_COLOUR_NO_CHANGE: we can't enable LED on paused, 
-      //                       we have no previos reference LED COLOUR, to set the LED colour back
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("system.leddisableonplayback") != LED_PLAYBACK_OFF && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_OFF && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_NO_CHANGE);
-    }
-    else if (strSetting.Equals("lcd.modchip") || strSetting.Equals("lcd.backlight") || strSetting.Equals("lcd.disableonplayback"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE);
-    }
-    else if (strSetting.Equals("lcd.contrast"))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      // X3 can't control the contrast via software graying out!
-      if(g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE)
-      {
-        if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("lcd.modchip") != MODCHIP_XECUTER3);
-      }
-      else 
-      { 
-        if (pControl) pControl->SetEnabled(false); 
-      }
-    }
-    else if (strSetting.Equals("weather.pluginsettings"))
-    {
-      // Create our base path
-      CStdString basepath = "special://home/plugins/weather/" + g_guiSettings.GetString("weather.plugin");
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(!g_guiSettings.GetString("weather.plugin").IsEmpty() && CScriptSettings::SettingsExist(basepath));
-    }
-    else if (!strSetting.Equals("musiclibrary.enabled")
-      && strSetting.Left(13).Equals("musiclibrary."))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("musiclibrary.enabled"));
-    }
-    else if (!strSetting.Equals("videolibrary.enabled")
-      && strSetting.Left(13).Equals("videolibrary."))
-    {
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("videolibrary.enabled"));
-    }
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(enabled);
+	}
+	else if (strSetting.Equals("system.ledenableonpaused"))
+	{
+	  // LED_COLOUR_NO_CHANGE: we can't enable LED on paused, 
+	  //                       we have no previos reference LED COLOUR, to set the LED colour back
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("system.leddisableonplayback") != LED_PLAYBACK_OFF && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_OFF && g_guiSettings.GetInt("system.ledcolour") != LED_COLOUR_NO_CHANGE);
+	}
+	else if (strSetting.Equals("lcd.modchip") || strSetting.Equals("lcd.backlight") || strSetting.Equals("lcd.disableonplayback"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE);
+	}
+	else if (strSetting.Equals("lcd.contrast"))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  // X3 can't control the contrast via software graying out!
+	  if(g_guiSettings.GetInt("lcd.type") != LCD_TYPE_NONE)
+	  {
+		if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("lcd.modchip") != MODCHIP_XECUTER3);
+	  }
+	  else 
+	  { 
+		if (pControl) pControl->SetEnabled(false); 
+	  }
+	}
+	else if (strSetting.Equals("weather.pluginsettings"))
+	{
+	  // Create our base path
+	  CStdString basepath = "special://home/system/plugins/weather/" + g_guiSettings.GetString("weather.plugin");
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(!g_guiSettings.GetString("weather.plugin").IsEmpty() && CScriptSettings::SettingsExist(basepath));
+	}
+	else if (!strSetting.Equals("musiclibrary.enabled")
+	  && strSetting.Left(13).Equals("musiclibrary."))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("musiclibrary.enabled"));
+	}
+	else if (!strSetting.Equals("videolibrary.enabled")
+	  && strSetting.Left(13).Equals("videolibrary."))
+	{
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("videolibrary.enabled"));
+	}
   }
 }
 
@@ -1211,25 +1228,25 @@
 {
   for (unsigned int i = 0; i < m_vecSettings.size(); i++)
   {
-    CBaseSettingControl *pSettingControl = m_vecSettings[i];
-    CStdString strSetting = pSettingControl->GetSetting()->GetSetting();
-    if (strSetting.Equals("locale.time") || strSetting.Equals("locale.date"))
-    {
+	CBaseSettingControl *pSettingControl = m_vecSettings[i];
+	CStdString strSetting = pSettingControl->GetSetting()->GetSetting();
+	if (strSetting.Equals("locale.time") || strSetting.Equals("locale.date"))
+	{
 #ifdef HAS_TIME_SERVER
-      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-      if (pControl) pControl->SetEnabled(!g_guiSettings.GetBool("locale.timeserver"));
+	  CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+	  if (pControl) pControl->SetEnabled(!g_guiSettings.GetBool("locale.timeserver"));
 #endif
-      SYSTEMTIME curTime;
-      GetLocalTime(&curTime);
-      CStdString time;
-      if (strSetting.Equals("locale.time"))
-        time = g_infoManager.GetTime();
-      else
-        time = g_infoManager.GetDate();
-      CSettingString *pSettingString = (CSettingString*)pSettingControl->GetSetting();
-      pSettingString->SetData(time);
-      pSettingControl->Update();
-    }
+	  SYSTEMTIME curTime;
+	  GetLocalTime(&curTime);
+	  CStdString time;
+	  if (strSetting.Equals("locale.time"))
+		time = g_infoManager.GetTime();
+	  else
+		time = g_infoManager.GetDate();
+	  CSettingString *pSettingString = (CSettingString*)pSettingControl->GetSetting();
+	  pSettingString->SetData(time);
+	  pSettingControl->Update();
+	}
   }
 }
 
@@ -1238,44 +1255,44 @@
   CStdString strSetting = pSettingControl->GetSetting()->GetSetting();
   if (strSetting.Left(16).Equals("weather.areacode"))
   {
-    CStdString strSearch;
-    if (CGUIDialogKeyboard::ShowAndGetInput(strSearch, g_localizeStrings.Get(14024), false))
-    {
-      strSearch.Replace(" ", "+");
-      CStdString strResult = ((CSettingString *)pSettingControl->GetSetting())->GetData();
-      if (g_weatherManager.GetSearchResults(strSearch, strResult))
-        ((CSettingString *)pSettingControl->GetSetting())->SetData(strResult);
-      g_weatherManager.Refresh();
-    }
+	CStdString strSearch;
+	if (CGUIDialogKeyboard::ShowAndGetInput(strSearch, g_localizeStrings.Get(14024), false))
+	{
+	  strSearch.Replace(" ", "+");
+	  CStdString strResult = ((CSettingString *)pSettingControl->GetSetting())->GetData();
+	  if (g_weatherManager.GetSearchResults(strSearch, strResult))
+		((CSettingString *)pSettingControl->GetSetting())->SetData(strResult);
+	  g_weatherManager.Refresh();
+	}
   }
   else if (strSetting.Equals("weather.plugin"))
   {
-    g_weatherManager.Refresh();
+	g_weatherManager.Refresh();
   }
   else if (strSetting.Equals("weather.pluginsettings"))
   {
-    // Create our base path
-    CURL url("plugin://weather/" + g_guiSettings.GetString("weather.plugin"));
-    if (CGUIDialogPluginSettings::ShowAndGetInput(url))
-    {
-      // TODO: maybe have ShowAndGetInput return a bool if settings changed, then only reset weather if true.
-      g_weatherManager.Refresh();
-    }
+	// Create our base path
+	CURL url("plugin://weather/" + g_guiSettings.GetString("weather.plugin"));
+	if (CGUIDialogPluginSettings::ShowAndGetInput(url))
+	{
+	  // TODO: maybe have ShowAndGetInput return a bool if settings changed, then only reset weather if true.
+	  g_weatherManager.Refresh();
+	}
   }
   else if (strSetting.Equals("lookandfeel.rssedit"))
-    CBuiltins::Execute("RunScript("RSSEDITOR_PATH")");
+	CBuiltins::Execute("RunScript("RSSEDITOR_PATH")");
   else if (strSetting.Equals("musiclibrary.scrapersettings"))
   {
-    CMusicDatabase database;
-    database.Open();
-    SScraperInfo info;
-    database.GetScraperForPath("musicdb://",info);
+	CMusicDatabase database;
+	database.Open();
+	SScraperInfo info;
+	database.GetScraperForPath("musicdb://",info);
 
-    if (info.settings.LoadSettingsXML("special://xbmc/system/scrapers/music/" + info.strPath))
-        CGUIDialogPluginSettings::ShowAndGetInput(info);
+	if (info.settings.LoadSettingsXML("special://xbmc/system/scrapers/music/" + info.strPath))
+		CGUIDialogPluginSettings::ShowAndGetInput(info);
 
-    database.SetScraperForPath("musicdb://",info);
-    database.Close();
+	database.SetScraperForPath("musicdb://",info);
+	database.Close();
   }
 
   // if OnClick() returns false, the setting hasn't changed or doesn't
@@ -1282,18 +1299,18 @@
   // require immediate update
   if (!pSettingControl->OnClick())
   {
-    UpdateSettings();
-    if (!pSettingControl->IsDelayed())
-      return;
+	UpdateSettings();
+	if (!pSettingControl->IsDelayed())
+	  return;
   }
 
   if (pSettingControl->IsDelayed())
   { // delayed setting
-    m_delayedSetting = pSettingControl;
-    m_delayedTimer.StartZero();
+	m_delayedSetting = pSettingControl;
+	m_delayedTimer.StartZero();
   }
   else
-    OnSettingChanged(pSettingControl);
+	OnSettingChanged(pSettingControl);
 }
 
 void CGUIWindowSettingsCategory::CheckForUpdates()
@@ -1300,12 +1317,12 @@
 {
   for (unsigned int i = 0; i < m_vecSettings.size(); i++)
   {
-    CBaseSettingControl *pSettingControl = m_vecSettings[i];
-    if (pSettingControl->NeedsUpdate())
-    {
-      OnSettingChanged(pSettingControl);
-      pSettingControl->Reset();
-    }
+	CBaseSettingControl *pSettingControl = m_vecSettings[i];
+	if (pSettingControl->NeedsUpdate())
+	{
+	  OnSettingChanged(pSettingControl);
+	  pSettingControl->Reset();
+	}
   }
 }
 
@@ -1316,264 +1333,264 @@
   // ok, now check the various special things we need to do
   if (strSetting.Equals("musicplayer.visualisation"))
   { // new visualisation choosen...
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    if (pControl->GetValue() == 0)
-      pSettingString->SetData("None");
-    else
-      pSettingString->SetData(pControl->GetCurrentLabel() + ".vis");
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	if (pControl->GetValue() == 0)
+	  pSettingString->SetData("None");
+	else
+	  pSettingString->SetData(pControl->GetCurrentLabel() + ".vis");
   }
   else if (strSetting.Equals("debug.showloginfo"))
   {
-    g_advancedSettings.SetDebugMode(g_guiSettings.GetBool("debug.showloginfo"));
+	g_advancedSettings.SetDebugMode(g_guiSettings.GetBool("debug.showloginfo"));
   }
   /*else if (strSetting.Equals("musicfiles.repeat"))
   {
-    g_playlistPlayer.SetRepeat(PLAYLIST_MUSIC_TEMP, g_guiSettings.GetBool("musicfiles.repeat") ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
+	g_playlistPlayer.SetRepeat(PLAYLIST_MUSIC_TEMP, g_guiSettings.GetBool("musicfiles.repeat") ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
   }*/
   else if (strSetting.Equals("karaoke.port0voicemask"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    g_guiSettings.SetString("karaoke.port0voicemask", pControl->GetCurrentLabel());
-    FillInVoiceMaskValues(0, g_guiSettings.GetSetting("karaoke.port0voicemask"));
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	g_guiSettings.SetString("karaoke.port0voicemask", pControl->GetCurrentLabel());
+	FillInVoiceMaskValues(0, g_guiSettings.GetSetting("karaoke.port0voicemask"));
   }
   else if (strSetting.Equals("karaoke.port1voicemask"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    g_guiSettings.SetString("karaoke.port1voicemask", pControl->GetCurrentLabel());
-    FillInVoiceMaskValues(1, g_guiSettings.GetSetting("karaoke.port1voicemask"));
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	g_guiSettings.SetString("karaoke.port1voicemask", pControl->GetCurrentLabel());
+	FillInVoiceMaskValues(1, g_guiSettings.GetSetting("karaoke.port1voicemask"));
   }
   else if (strSetting.Equals("karaoke.port2voicemask"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    g_guiSettings.SetString("karaoke.port2voicemask", pControl->GetCurrentLabel());
-    FillInVoiceMaskValues(2, g_guiSettings.GetSetting("karaoke.port2voicemask"));
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	g_guiSettings.SetString("karaoke.port2voicemask", pControl->GetCurrentLabel());
+	FillInVoiceMaskValues(2, g_guiSettings.GetSetting("karaoke.port2voicemask"));
   }
   else if (strSetting.Equals("karaoke.port2voicemask"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    g_guiSettings.SetString("karaoke.port3voicemask", pControl->GetCurrentLabel());
-    FillInVoiceMaskValues(3, g_guiSettings.GetSetting("karaoke.port3voicemask"));
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	g_guiSettings.SetString("karaoke.port3voicemask", pControl->GetCurrentLabel());
+	FillInVoiceMaskValues(3, g_guiSettings.GetSetting("karaoke.port3voicemask"));
   }
   else if (strSetting.Equals("musiclibrary.cleanup"))
   {
-    CMusicDatabase musicdatabase;
-    musicdatabase.Clean();
-    CUtil::DeleteMusicDatabaseDirectoryCache();
+	CMusicDatabase musicdatabase;
+	musicdatabase.Clean();
+	CUtil::DeleteMusicDatabaseDirectoryCache();
   }
   else if (strSetting.Equals("musiclibrary.scraper"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    FillInScrapers(pControl, pControl->GetCurrentLabel(), "music");
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	FillInScrapers(pControl, pControl->GetCurrentLabel(), "music");
   }
   else if (strSetting.Equals("scrapers.moviedefault"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    FillInScrapers(pControl, pControl->GetCurrentLabel(), "movies");
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	FillInScrapers(pControl, pControl->GetCurrentLabel(), "movies");
   }
   else if (strSetting.Equals("scrapers.tvshowdefault"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    FillInScrapers(pControl, pControl->GetCurrentLabel(), "tvshows");
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	FillInScrapers(pControl, pControl->GetCurrentLabel(), "tvshows");
   }
   else if (strSetting.Equals("scrapers.musicvideodefault"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    FillInScrapers(pControl, pControl->GetCurrentLabel(), "musicvideos");
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	FillInScrapers(pControl, pControl->GetCurrentLabel(), "musicvideos");
   }
   else if (strSetting.Equals("videolibrary.cleanup"))
   {
-    if (CGUIDialogYesNo::ShowAndGetInput(313, 333, 0, 0))
-    {
-      CVideoDatabase videodatabase;
-      videodatabase.Open();
-      videodatabase.CleanDatabase();
-      videodatabase.Close();
-    }
+	if (CGUIDialogYesNo::ShowAndGetInput(313, 333, 0, 0))
+	{
+	  CVideoDatabase videodatabase;
+	  videodatabase.Open();
+	  videodatabase.CleanDatabase();
+	  videodatabase.Close();
+	}
   }
   else if (strSetting.Equals("videolibrary.export"))
-    CBuiltins::Execute("exportlibrary(video)");
+	CBuiltins::Execute("exportlibrary(video)");
   else if (strSetting.Equals("musiclibrary.export"))
-    CBuiltins::Execute("exportlibrary(music)");
+	CBuiltins::Execute("exportlibrary(music)");
 
   else if (strSetting.Equals("videolibrary.import"))
   {
-    CStdString path;
-    VECSOURCES shares;
-    g_mediaManager.GetLocalDrives(shares);
-    if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares, g_localizeStrings.Get(651) , path))
-    {
-      CVideoDatabase videodatabase;
-      videodatabase.Open();
-      videodatabase.ImportFromXML(path);
-      videodatabase.Close();
-    }
+	CStdString path;
+	VECSOURCES shares;
+	g_mediaManager.GetLocalDrives(shares);
+	if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares, g_localizeStrings.Get(651) , path))
+	{
+	  CVideoDatabase videodatabase;
+	  videodatabase.Open();
+	  videodatabase.ImportFromXML(path);
+	  videodatabase.Close();
+	}
   }
   else if (strSetting.Equals("musiclibrary.import"))
   {
-    CStdString path;
-    VECSOURCES shares;
-    g_mediaManager.GetLocalDrives(shares);
-    if (CGUIDialogFileBrowser::ShowAndGetFile(shares, "musicdb.xml", g_localizeStrings.Get(651) , path))
-    {
-      CMusicDatabase musicdatabase;
-      musicdatabase.Open();
-      musicdatabase.ImportFromXML(path);
-      musicdatabase.Close();
-    }
+	CStdString path;
+	VECSOURCES shares;
+	g_mediaManager.GetLocalDrives(shares);
+	if (CGUIDialogFileBrowser::ShowAndGetFile(shares, "musicdb.xml", g_localizeStrings.Get(651) , path))
+	{
+	  CMusicDatabase musicdatabase;
+	  musicdatabase.Open();
+	  musicdatabase.ImportFromXML(path);
+	  musicdatabase.Close();
+	}
   }
   else if (strSetting.Equals("scrobbler.lastfmsubmit") || strSetting.Equals("scrobbler.lastfmsubmitradio") || strSetting.Equals("scrobbler.lastfmusername") || strSetting.Equals("scrobbler.lastfmpass"))
   {
-    CStdString strPassword=g_guiSettings.GetString("scrobbler.lastfmpass");
-    CStdString strUserName=g_guiSettings.GetString("scrobbler.lastfmusername");
-    if ((g_guiSettings.GetBool("scrobbler.lastfmsubmit") || 
-         g_guiSettings.GetBool("scrobbler.lastfmsubmitradio")) &&
-         !strUserName.IsEmpty() && !strPassword.IsEmpty())
-    {
-      CLastfmScrobbler::GetInstance()->Init();
-    }
-    else
-    {
-      CLastfmScrobbler::GetInstance()->Term();
-    }
+	CStdString strPassword=g_guiSettings.GetString("scrobbler.lastfmpass");
+	CStdString strUserName=g_guiSettings.GetString("scrobbler.lastfmusername");
+	if ((g_guiSettings.GetBool("scrobbler.lastfmsubmit") || 
+		 g_guiSettings.GetBool("scrobbler.lastfmsubmitradio")) &&
+		 !strUserName.IsEmpty() && !strPassword.IsEmpty())
+	{
+	  CLastfmScrobbler::GetInstance()->Init();
+	}
+	else
+	{
+	  CLastfmScrobbler::GetInstance()->Term();
+	}
   }
   else if (strSetting.Equals("scrobbler.librefmsubmit") || strSetting.Equals("scrobbler.librefmsubmitradio") || strSetting.Equals("scrobbler.librefmusername") || strSetting.Equals("scrobbler.librefmpass"))
   {
-    CStdString strPassword=g_guiSettings.GetString("scrobbler.librefmpass");
-    CStdString strUserName=g_guiSettings.GetString("scrobbler.librefmusername");
-    if ((g_guiSettings.GetBool("scrobbler.librefmsubmit") || 
-         g_guiSettings.GetBool("scrobbler.librefmsubmitradio")) &&
-         !strUserName.IsEmpty() && !strPassword.IsEmpty())
-    {
-      CLibrefmScrobbler::GetInstance()->Init();
-    }
-    else
-    {
-      CLibrefmScrobbler::GetInstance()->Term();
-    }
+	CStdString strPassword=g_guiSettings.GetString("scrobbler.librefmpass");
+	CStdString strUserName=g_guiSettings.GetString("scrobbler.librefmusername");
+	if ((g_guiSettings.GetBool("scrobbler.librefmsubmit") || 
+		 g_guiSettings.GetBool("scrobbler.librefmsubmitradio")) &&
+		 !strUserName.IsEmpty() && !strPassword.IsEmpty())
+	{
+	  CLibrefmScrobbler::GetInstance()->Init();
+	}
+	else
+	{
+	  CLibrefmScrobbler::GetInstance()->Term();
+	}
   }
   else if (strSetting.Equals("musicplayer.outputtoallspeakers"))
   {
-    if (!g_application.IsPlaying())
-    {
-      g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
-    }
+	if (!g_application.IsPlaying())
+	{
+	  g_audioContext.SetActiveDevice(CAudioContext::DEFAULT_DEVICE);
+	}
   }
   else if (strSetting.Left(22).Equals("MusicPlayer.ReplayGain"))
   { // Update our replaygain settings
-    g_guiSettings.m_replayGain.iType = g_guiSettings.GetInt("musicplayer.replaygaintype");
-    g_guiSettings.m_replayGain.iPreAmp = g_guiSettings.GetInt("musicplayer.replaygainpreamp");
-    g_guiSettings.m_replayGain.iNoGainPreAmp = g_guiSettings.GetInt("musicplayer.replaygainnogainpreamp");
-    g_guiSettings.m_replayGain.bAvoidClipping = g_guiSettings.GetBool("musicplayer.replaygainavoidclipping");
+	g_guiSettings.m_replayGain.iType = g_guiSettings.GetInt("musicplayer.replaygaintype");
+	g_guiSettings.m_replayGain.iPreAmp = g_guiSettings.GetInt("musicplayer.replaygainpreamp");
+	g_guiSettings.m_replayGain.iNoGainPreAmp = g_guiSettings.GetInt("musicplayer.replaygainnogainpreamp");
+	g_guiSettings.m_replayGain.bAvoidClipping = g_guiSettings.GetBool("musicplayer.replaygainavoidclipping");
   }
 #ifdef HAS_LCD
   else if (strSetting.Equals("lcd.type"))
   {
-    g_lcd->Initialize();
+	g_lcd->Initialize();
   }
   else if (strSetting.Equals("lcd.backlight"))
   {
-    g_lcd->SetBackLight(((CSettingInt *)pSettingControl->GetSetting())->GetData());
+	g_lcd->SetBackLight(((CSettingInt *)pSettingControl->GetSetting())->GetData());
   }
   else if (strSetting.Equals("lcd.modchip"))
   {
-    g_lcd->Stop();
-    CLCDFactory factory;
-    delete g_lcd;
-    g_lcd = factory.Create();
-    g_lcd->Initialize();
+	g_lcd->Stop();
+	CLCDFactory factory;
+	delete g_lcd;
+	g_lcd = factory.Create();
+	g_lcd->Initialize();
   }
   else if (strSetting.Equals("lcd.contrast"))
   {
-    g_lcd->SetContrast(((CSettingInt *)pSettingControl->GetSetting())->GetData());
+	g_lcd->SetContrast(((CSettingInt *)pSettingControl->GetSetting())->GetData());
   }
 #endif
 #ifdef HAS_XBOX_HARDWARE
   else if (strSetting.Equals("system.targettemperature"))
   {
-    CSettingInt *pSetting = (CSettingInt*)pSettingControl->GetSetting();
-    CFanController::Instance()->SetTargetTemperature(pSetting->GetData());
+	CSettingInt *pSetting = (CSettingInt*)pSettingControl->GetSetting();
+	CFanController::Instance()->SetTargetTemperature(pSetting->GetData());
   }
   else if (strSetting.Equals("system.fanspeed"))
   {
-    CSettingInt *pSetting = (CSettingInt*)pSettingControl->GetSetting();
-    int iControlID = pSettingControl->GetID();
-    CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControlID);
-    g_windowManager.SendMessage(msg);
-    int iSpeed = (RESOLUTION)msg.GetParam1();
-    g_guiSettings.SetInt("system.fanspeed", iSpeed);
-    CFanController::Instance()->SetFanSpeed(iSpeed);
+	CSettingInt *pSetting = (CSettingInt*)pSettingControl->GetSetting();
+	int iControlID = pSettingControl->GetID();
+	CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControlID);
+	g_windowManager.SendMessage(msg);
+	int iSpeed = (RESOLUTION)msg.GetParam1();
+	g_guiSettings.SetInt("system.fanspeed", iSpeed);
+	CFanController::Instance()->SetFanSpeed(iSpeed);
   }
   else if (strSetting.Equals("system.autotemperature"))
   {
-    CSettingBool *pSetting = (CSettingBool*)pSettingControl->GetSetting();
-    if (pSetting->GetData())
-    {
-      g_guiSettings.SetBool("system.fanspeedcontrol", false);
-      CFanController::Instance()->Start(g_guiSettings.GetInt("system.targettemperature"), g_guiSettings.GetInt("system.minfanspeed") );
-    }
-    else
-      CFanController::Instance()->Stop();
+	CSettingBool *pSetting = (CSettingBool*)pSettingControl->GetSetting();
+	if (pSetting->GetData())
+	{
+	  g_guiSettings.SetBool("system.fanspeedcontrol", false);
+	  CFanController::Instance()->Start(g_guiSettings.GetInt("system.targettemperature"), g_guiSettings.GetInt("system.minfanspeed") );
+	}
+	else
+	  CFanController::Instance()->Stop();
   }
   else if (strSetting.Equals("system.minfanspeed"))
   {
-    CSettingInt *pSetting = (CSettingInt*)pSettingControl->GetSetting();
-    CFanController::Instance()->SetMinFanSpeed(pSetting->GetData());
+	CSettingInt *pSetting = (CSettingInt*)pSettingControl->GetSetting();
+	CFanController::Instance()->SetMinFanSpeed(pSetting->GetData());
   }
   else if (strSetting.Equals("system.fanspeedcontrol"))
   {
-    CSettingBool *pSetting = (CSettingBool*)pSettingControl->GetSetting();
-    if (pSetting->GetData())
-    {
-      g_guiSettings.SetBool("system.autotemperature", false);
-      CFanController::Instance()->Stop();
-      CFanController::Instance()->SetFanSpeed(g_guiSettings.GetInt("system.fanspeed"));
-    }
-    else
-      CFanController::Instance()->RestoreStartupSpeed();
+	CSettingBool *pSetting = (CSettingBool*)pSettingControl->GetSetting();
+	if (pSetting->GetData())
+	{
+	  g_guiSettings.SetBool("system.autotemperature", false);
+	  CFanController::Instance()->Stop();
+	  CFanController::Instance()->SetFanSpeed(g_guiSettings.GetInt("system.fanspeed"));
+	}
+	else
+	  CFanController::Instance()->RestoreStartupSpeed();
   }
   else if (strSetting.Equals("harddisk.aamlevel"))
   {
-    CSettingInt * pSetting = (CSettingInt*)pSettingControl->GetSetting();
-    int setting_level = pSetting->GetData();
+	CSettingInt * pSetting = (CSettingInt*)pSettingControl->GetSetting();
+	int setting_level = pSetting->GetData();
 
-    if (setting_level == AAM_QUIET)
-      XKHDD::SetAAMLevel(0x80);
-    else if (setting_level == AAM_FAST)
-      XKHDD::SetAAMLevel(0xFE);
+	if (setting_level == AAM_QUIET)
+	  XKHDD::SetAAMLevel(0x80);
+	else if (setting_level == AAM_FAST)
+	  XKHDD::SetAAMLevel(0xFE);
   }
   else if (strSetting.Equals("harddisk.apmlevel"))
   {
-    CSettingInt * pSetting = (CSettingInt*)pSettingControl->GetSetting();
-    int setting_level = pSetting->GetData();
+	CSettingInt * pSetting = (CSettingInt*)pSettingControl->GetSetting();
+	int setting_level = pSetting->GetData();
 
-    switch(setting_level)
-    {
-    case APM_LOPOWER:
-      XKHDD::SetAPMLevel(0x80);
-      break;
-    case APM_HIPOWER:
-      XKHDD::SetAPMLevel(0xFE);
-      break;
-    case APM_LOPOWER_STANDBY:
-      XKHDD::SetAPMLevel(0x01);
-      break;
-    case APM_HIPOWER_STANDBY:
-      XKHDD::SetAPMLevel(0x7F);
-      break;
-    }
+	switch(setting_level)
+	{
+	case APM_LOPOWER:
+	  XKHDD::SetAPMLevel(0x80);
+	  break;
+	case APM_HIPOWER:
+	  XKHDD::SetAPMLevel(0xFE);
+	  break;
+	case APM_LOPOWER_STANDBY:
+	  XKHDD::SetAPMLevel(0x01);
+	  break;
+	case APM_HIPOWER_STANDBY:
+	  XKHDD::SetAPMLevel(0x7F);
+	  break;
+	}
   }
   else if (strSetting.Equals("autodetect.nickname") )
   {
-    CStdString strXboxNickNameIn = g_guiSettings.GetString("autodetect.nickname");
-    CUtil::SetXBOXNickName(strXboxNickNameIn, strXboxNickNameIn);
+	CStdString strXboxNickNameIn = g_guiSettings.GetString("autodetect.nickname");
+	CUtil::SetXBOXNickName(strXboxNickNameIn, strXboxNickNameIn);
   }
 #endif
   else if (strSetting.Equals("services.ftpserver"))
   {
-    g_application.StopFtpServer();
-    if (g_guiSettings.GetBool("services.ftpserver"))
-      g_application.StartFtpServer();
+	g_application.StopFtpServer();
+	if (g_guiSettings.GetBool("services.ftpserver"))
+	  g_application.StartFtpServer();
   }
   else if (strSetting.Equals("services.ftpserverpassword"))
   {
@@ -1581,501 +1598,528 @@
   }
   else if (strSetting.Equals("services.ftpserveruser"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    g_guiSettings.SetString("services.ftpserveruser", pControl->GetCurrentLabel());
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	g_guiSettings.SetString("services.ftpserveruser", pControl->GetCurrentLabel());
   }
 
   else if ( strSetting.Equals("services.webserver") || strSetting.Equals("services.webserverport") || 
-            strSetting.Equals("services.webserverusername") || strSetting.Equals("services.webserverpassword"))
+			strSetting.Equals("services.webserverusername") || strSetting.Equals("services.webserverpassword"))
   {
-    if (strSetting.Equals("services.webserverport"))
-    {
-      CSettingString *pSetting = (CSettingString *)pSettingControl->GetSetting();
-      // check that it's a valid port
-      int port = atoi(pSetting->GetData().c_str());
-      if (port <= 0 || port > 65535)
-        pSetting->SetData("80");
-    }
-    g_application.StopWebServer();
-    if (g_guiSettings.GetBool("services.webserver"))
-    {
-      g_application.StartWebServer();
-      if (g_application.m_pWebServer) {
-        if (strSetting.Equals("services.webserverusername"))
-          g_application.m_pWebServer->SetUserName(g_guiSettings.GetString("services.webserverusername").c_str());
-        else
-          g_application.m_pWebServer->SetPassword(g_guiSettings.GetString("services.webserverpassword").c_str());
-      }
-    }
+	if (strSetting.Equals("services.webserverport"))
+	{
+	  CSettingString *pSetting = (CSettingString *)pSettingControl->GetSetting();
+	  // check that it's a valid port
+	  int port = atoi(pSetting->GetData().c_str());
+	  if (port <= 0 || port > 65535)
+		pSetting->SetData("80");
+	}
+	g_application.StopWebServer();
+	if (g_guiSettings.GetBool("services.webserver"))
+	{
+	  g_application.StartWebServer();
+	  if (g_application.m_pWebServer) {
+		if (strSetting.Equals("services.webserverusername"))
+		  g_application.m_pWebServer->SetUserName(g_guiSettings.GetString("services.webserverusername").c_str());
+		else
+		  g_application.m_pWebServer->SetPassword(g_guiSettings.GetString("services.webserverpassword").c_str());
+	  }
+	}
   }
   
   else if (strSetting.Equals("network.ipaddress"))
   {
-    if (g_guiSettings.GetInt("network.assignment") == NETWORK_STATIC)
-    {
-      CStdString strDefault = g_guiSettings.GetString("network.ipaddress").Left(g_guiSettings.GetString("network.ipaddress").ReverseFind('.'))+".1";
-      if (g_guiSettings.GetString("network.gateway").Equals("0.0.0.0"))
-        g_guiSettings.SetString("network.gateway",strDefault);
-      if (g_guiSettings.GetString("network.dns").Equals("0.0.0.0"))
-        g_guiSettings.SetString("network.dns",strDefault);
-
-    }
+	if (g_guiSettings.GetInt("network.assignment") == NETWORK_STATIC)
+	{
+	  CStdString strDefault = g_guiSettings.GetString("network.ipaddress").Left(g_guiSettings.GetString("network.ipaddress").ReverseFind('.'))+".1";
+	  if (g_guiSettings.GetString("network.gateway").Equals("0.0.0.0"))
+		g_guiSettings.SetString("network.gateway",strDefault);
+	  if (g_guiSettings.GetString("network.dns").Equals("0.0.0.0"))
+		g_guiSettings.SetString("network.dns",strDefault);
+      if (g_guiSettings.GetString("network.dns2").Equals("0.0.0.0"))
+        g_guiSettings.SetString("network.dns2",strDefault);
+	}
   }
-    
+	
   else if (strSetting.Equals("network.httpproxyport"))
   {
-    CSettingString *pSetting = (CSettingString *)pSettingControl->GetSetting();
-    // check that it's a valid port
-    int port = atoi(pSetting->GetData().c_str());
-    if (port <= 0 || port > 65535)
-      pSetting->SetData("8080");
+	CSettingString *pSetting = (CSettingString *)pSettingControl->GetSetting();
+	// check that it's a valid port
+	int port = atoi(pSetting->GetData().c_str());
+	if (port <= 0 || port > 65535)
+	  pSetting->SetData("8080");
   }
   else if (strSetting.Equals("videoplayer.calibrate") || strSetting.Equals("videoscreen.guicalibration"))
   { // activate the video calibration screen
-    g_windowManager.ActivateWindow(WINDOW_SCREEN_CALIBRATION);
+	g_windowManager.ActivateWindow(WINDOW_SCREEN_CALIBRATION);
   }
   else if (strSetting.Equals("dvds.externaldvdplayer"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CStdString path = pSettingString->GetData();
-    VECSOURCES shares;
-    g_mediaManager.GetLocalDrives(shares);
-    // TODO 2.0: Localize this
-    if (CGUIDialogFileBrowser::ShowAndGetFile(shares, ".xbe", g_localizeStrings.Get(655), path))
-      pSettingString->SetData(path);
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CStdString path = pSettingString->GetData();
+	VECSOURCES shares;
+	g_mediaManager.GetLocalDrives(shares);
+	// TODO 2.0: Localize this
+	if (CGUIDialogFileBrowser::ShowAndGetFile(shares, ".xbe", g_localizeStrings.Get(655), path))
+	  pSettingString->SetData(path);
   }
   else if (strSetting.Equals("subtitles.height"))
   {
-    if (!CUtil::IsUsingTTFSubtitles())
-    {
-      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-      ((CSettingInt *)pSettingControl->GetSetting())->FromString(pControl->GetCurrentLabel());
-    }
+	if (!CUtil::IsUsingTTFSubtitles())
+	{
+	  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	  ((CSettingInt *)pSettingControl->GetSetting())->FromString(pControl->GetCurrentLabel());
+	}
   }
   else if (strSetting.Equals("subtitles.font"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    pSettingString->SetData(pControl->GetCurrentLabel());
-    FillInSubtitleHeights(g_guiSettings.GetSetting("subtitles.height"));
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	pSettingString->SetData(pControl->GetCurrentLabel());
+	FillInSubtitleHeights(g_guiSettings.GetSetting("subtitles.height"));
   }
   else if (strSetting.Equals("subtitles.charset"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    CStdString newCharset="DEFAULT";
-    if (pControl->GetValue()!=0)
-     newCharset = g_charsetConverter.getCharsetNameByLabel(pControl->GetCurrentLabel());
-    if (newCharset != "" && (newCharset != pSettingString->GetData() || newCharset=="DEFAULT"))
-    {
-      pSettingString->SetData(newCharset);
-      g_charsetConverter.reset();
-    }
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CStdString newCharset="DEFAULT";
+	if (pControl->GetValue()!=0)
+	 newCharset = g_charsetConverter.getCharsetNameByLabel(pControl->GetCurrentLabel());
+	if (newCharset != "" && (newCharset != pSettingString->GetData() || newCharset=="DEFAULT"))
+	{
+	  pSettingString->SetData(newCharset);
+	  g_charsetConverter.reset();
+	}
   }
   else if (strSetting.Equals("locale.charset"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    CStdString newCharset="DEFAULT";
-    if (pControl->GetValue()!=0)
-     newCharset = g_charsetConverter.getCharsetNameByLabel(pControl->GetCurrentLabel());
-    if (newCharset != "" && (newCharset != pSettingString->GetData() || newCharset=="DEFAULT"))
-    {
-      pSettingString->SetData(newCharset);
-      g_charsetConverter.reset();
-    }
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CStdString newCharset="DEFAULT";
+	if (pControl->GetValue()!=0)
+	 newCharset = g_charsetConverter.getCharsetNameByLabel(pControl->GetCurrentLabel());
+	if (newCharset != "" && (newCharset != pSettingString->GetData() || newCharset=="DEFAULT"))
+	{
+	  pSettingString->SetData(newCharset);
+	  g_charsetConverter.reset();
+	}
   }
   else if (strSetting.Equals("lookandfeel.font"))
   { // new font choosen...
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    CStdString strSkinFontSet = pControl->GetCurrentLabel();
-    if (strSkinFontSet != ".svn" && strSkinFontSet != g_guiSettings.GetString("lookandfeel.font"))
-    {
-      m_strNewSkinFontSet = strSkinFontSet;
-      g_application.DelayLoadSkin();
-    }
-    else
-    { // Do not reload the language we are already using
-      m_strNewSkinFontSet.Empty();
-      g_application.CancelDelayLoadSkin();
-    }
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CStdString strSkinFontSet = pControl->GetCurrentLabel();
+	if (strSkinFontSet != ".svn" && strSkinFontSet != g_guiSettings.GetString("lookandfeel.font"))
+	{
+	  m_strNewSkinFontSet = strSkinFontSet;
+	  g_application.DelayLoadSkin();
+	}
+	else
+	{ // Do not reload the language we are already using
+	  m_strNewSkinFontSet.Empty();
+	  g_application.CancelDelayLoadSkin();
+	}
   }
   else if (strSetting.Equals("lookandfeel.skin"))
   { // new skin choosen...
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    CStdString strSkin = pControl->GetCurrentLabel();
-    CStdString strSkinPath = "Q:\\skin\\" + strSkin;
-    if (g_SkinInfo.Check(strSkinPath))
-    {
-      m_strErrorMessage.Empty();
-      pControl->SettingsCategorySetSpinTextColor(pControl->GetButtonLabelInfo().textColor);
-      if (strSkin != ".svn" && strSkin != g_guiSettings.GetString("lookandfeel.skin"))
-      {
-        m_strNewSkin = strSkin;
-        g_application.DelayLoadSkin();
-      }
-      else
-      { // Do not reload the skin we are already using
-        m_strNewSkin.Empty();
-        g_application.CancelDelayLoadSkin();
-      }
-    }
-    else
-    {
-      m_strErrorMessage.Format("Incompatible skin. We require skins of version %0.2f or higher", g_SkinInfo.GetMinVersion());
-      m_strNewSkin.Empty();
-      g_application.CancelDelayLoadSkin();
-      pControl->SettingsCategorySetSpinTextColor(pControl->GetButtonLabelInfo().disabledColor);
-    }
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CStdString strSkin = pControl->GetCurrentLabel();
+	CStdString strSkinPath = "special://xbmc/emustation/themes/" + strSkin;
+	if (g_SkinInfo.Check(strSkinPath))
+	{
+	  m_strErrorMessage.Empty();
+	  pControl->SettingsCategorySetSpinTextColor(pControl->GetButtonLabelInfo().textColor);
+	  if (strSkin != ".svn" && strSkin != g_guiSettings.GetString("lookandfeel.skin"))
+	  {
+		m_strNewSkin = strSkin;
+		g_application.DelayLoadSkin();
+	  }
+	  else
+	  { // Do not reload the skin we are already using
+		m_strNewSkin.Empty();
+		g_application.CancelDelayLoadSkin();
+	  }
+	}
+	else
+	{
+	  m_strErrorMessage.Format("Incompatible skin. We require skins of version %0.2f or higher", g_SkinInfo.GetMinVersion());
+	  m_strNewSkin.Empty();
+	  g_application.CancelDelayLoadSkin();
+	  pControl->SettingsCategorySetSpinTextColor(pControl->GetButtonLabelInfo().disabledColor);
+	}
   }
   else if (strSetting.Equals("lookandfeel.soundskin"))
   { // new sound skin choosen...
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    if (pControl->GetValue()==0)
-      g_guiSettings.SetString("lookandfeel.soundskin", "OFF");
-    else if (pControl->GetValue()==1)
-      g_guiSettings.SetString("lookandfeel.soundskin", "SKINDEFAULT");
-    else
-      g_guiSettings.SetString("lookandfeel.soundskin", pControl->GetCurrentLabel());
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	if (pControl->GetValue()==0)
+	  g_guiSettings.SetString("lookandfeel.soundskin", "OFF");
+	else if (pControl->GetValue()==1)
+	  g_guiSettings.SetString("lookandfeel.soundskin", "SIMPLE");
+	else
+	  g_guiSettings.SetString("lookandfeel.soundskin", pControl->GetCurrentLabel());
 
-    g_audioManager.Enable(true);
-    g_audioManager.Load();
+	g_audioManager.Enable(true);
+	g_audioManager.Load();
   }
   else if (strSetting.Equals("lookandfeel.enablemouse"))
   {
-    g_Mouse.SetEnabled(g_guiSettings.GetBool("lookandfeel.enablemouse"));
+	g_Mouse.SetEnabled(g_guiSettings.GetBool("lookandfeel.enablemouse"));
   }
   else if (strSetting.Equals("videoscreen.resolution"))
   { // new resolution choosen... - update if necessary
-    CSettingInt *pSettingInt = (CSettingInt *)pSettingControl->GetSetting();
-    int iControlID = pSettingControl->GetID();
-    CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControlID);
-    g_windowManager.SendMessage(msg);
-    m_NewResolution = (RESOLUTION)msg.GetParam1();
-    // reset our skin if necessary
-    // delay change of resolution
-    if (m_NewResolution != g_guiSettings.m_LookAndFeelResolution)
-    {
-      g_application.DelayLoadSkin();
-    }
-    else
-    { // Do not reload the resolution we are using
-      m_NewResolution = INVALID;
-      g_application.CancelDelayLoadSkin();
-    }
+	CSettingInt *pSettingInt = (CSettingInt *)pSettingControl->GetSetting();
+	int iControlID = pSettingControl->GetID();
+	CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControlID);
+	g_windowManager.SendMessage(msg);
+	m_NewResolution = (RESOLUTION)msg.GetParam1();
+	// reset our skin if necessary
+	// delay change of resolution
+	if (m_NewResolution != g_guiSettings.m_LookAndFeelResolution)
+	{
+	  g_application.DelayLoadSkin();
+	}
+	else
+	{ // Do not reload the resolution we are using
+	  m_NewResolution = INVALID;
+	  g_application.CancelDelayLoadSkin();
+	}
   }
   else if (strSetting.Equals("system.ledcolour"))
   { 
 #ifdef HAS_XBOX_HARDWARE
-    // Alter LED Colour immediately
-    int iData =  ((CSettingInt *)pSettingControl->GetSetting())->GetData();
-    if (iData == LED_COLOUR_NO_CHANGE)
-      // LED_COLOUR_NO_CHANGE: to prevent "led off" on colour immediately change, set to default green! 
-      //                       (we have no previos reference LED COLOUR, to set the LED colour back)
-      //                       on next boot the colour will not changed and the default BIOS led colour will used
-      ILED::CLEDControl(LED_COLOUR_GREEN); 
-    else
-      ILED::CLEDControl(iData);
+	// Alter LED Colour immediately
+	int iData =  ((CSettingInt *)pSettingControl->GetSetting())->GetData();
+	if (iData == LED_COLOUR_NO_CHANGE)
+	  // LED_COLOUR_NO_CHANGE: to prevent "led off" on colour immediately change, set to default green! 
+	  //                       (we have no previos reference LED COLOUR, to set the LED colour back)
+	  //                       on next boot the colour will not changed and the default BIOS led colour will used
+	  ILED::CLEDControl(LED_COLOUR_GREEN); 
+	else
+	  ILED::CLEDControl(iData);
 #endif
   }
   else if (strSetting.Equals("locale.language"))
   { // new language chosen...
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    CStdString strLanguage = pControl->GetCurrentLabel();
-    if (strLanguage != ".svn" && strLanguage != pSettingString->GetData())
-    {
-      m_strNewLanguage = strLanguage;
-      g_application.DelayLoadSkin();
-    }
-    else
-    { // Do not reload the language we are already using
-      m_strNewLanguage.Empty();
-      g_application.CancelDelayLoadSkin();
-    }
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CStdString strLanguage = pControl->GetCurrentLabel();
+	if (strLanguage != ".svn" && strLanguage != pSettingString->GetData())
+	{
+	  m_strNewLanguage = strLanguage;
+	  g_application.DelayLoadSkin();
+	}
+	else
+	{ // Do not reload the language we are already using
+	  m_strNewLanguage.Empty();
+	  g_application.CancelDelayLoadSkin();
+	}
   }
   else if (strSetting.Equals("lookandfeel.skintheme"))
   { //a new Theme was chosen
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
 
-    CStdString strSkinTheme;
+	CStdString strSkinTheme;
 
-    if (pControl->GetValue() == 0) // Use default theme
-      strSkinTheme = "SKINDEFAULT";
-    else
-      strSkinTheme = pControl->GetCurrentLabel() + ".xpr";
+	if (pControl->GetValue() == 0) // Use default theme
+	  strSkinTheme = "SIMPLE";
+	else
+	  strSkinTheme = pControl->GetCurrentLabel() + ".xpr";
 
-    if (strSkinTheme != pSettingString->GetData())
-    {
-      m_strNewSkinTheme = strSkinTheme;
-      g_application.DelayLoadSkin();
-    }
-    else
-    { // Do not reload the skin theme we are using
-      m_strNewSkinTheme.Empty();
-      g_application.CancelDelayLoadSkin();
-    }
+	if (strSkinTheme != pSettingString->GetData())
+	{
+	  m_strNewSkinTheme = strSkinTheme;
+	  g_application.DelayLoadSkin();
+	}
+	else
+	{ // Do not reload the skin theme we are using
+	  m_strNewSkinTheme.Empty();
+	  g_application.CancelDelayLoadSkin();
+	}
   }
   else if (strSetting.Equals("lookandfeel.skincolors"))
   { //a new color was chosen
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
 
-    CStdString strSkinColor;
+	CStdString strSkinColor;
 
-    if (pControl->GetValue() == 0) // Use default colors
-      strSkinColor = "SKINDEFAULT";
-    else
-      strSkinColor = pControl->GetCurrentLabel() + ".xml";
+	if (pControl->GetValue() == 0) // Use default colors
+	  strSkinColor = "SIMPLE";
+	else
+	  strSkinColor = pControl->GetCurrentLabel() + ".xml";
 
-    if (strSkinColor != pSettingString->GetData())
-    {
-      m_strNewSkinColors = strSkinColor;
-      g_application.DelayLoadSkin();
-    }
-    else
-    { // Do not reload the skin colors we are using
-      m_strNewSkinColors.Empty();
-      g_application.CancelDelayLoadSkin();
-    }
+	if (strSkinColor != pSettingString->GetData())
+	{
+	  m_strNewSkinColors = strSkinColor;
+	  g_application.DelayLoadSkin();
+	}
+	else
+	{ // Do not reload the skin colors we are using
+	  m_strNewSkinColors.Empty();
+	  g_application.CancelDelayLoadSkin();
+	}
   }
   else if (strSetting.Equals("videoplayer.displayresolution"))
   {
-    CSettingInt *pSettingInt = (CSettingInt *)pSettingControl->GetSetting();
-    int iControlID = pSettingControl->GetID();
-    CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControlID);
-    g_windowManager.SendMessage(msg);
-    pSettingInt->SetData(msg.GetParam1());
+	CSettingInt *pSettingInt = (CSettingInt *)pSettingControl->GetSetting();
+	int iControlID = pSettingControl->GetID();
+	CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControlID);
+	g_windowManager.SendMessage(msg);
+	pSettingInt->SetData(msg.GetParam1());
   }
   else if (strSetting.Equals("videoscreen.flickerfilter") || strSetting.Equals("videoscreen.soften"))
   { // reset display
-    g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE);
+	g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution, TRUE);
   }
   else if (strSetting.Equals("screensaver.mode"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
-    int iValue = pControl->GetValue();
-    CStdString strScreenSaver;
-    if (iValue == 0)
-      strScreenSaver = "None";
-    else if (iValue == 1)
-      strScreenSaver = "Dim";
-    else if (iValue == 2)
-      strScreenSaver = "Black";
-    else if (iValue == 3)
-      strScreenSaver = "SlideShow"; // PictureSlideShow
-    else if (iValue == 4)
-      strScreenSaver = "Fanart Slideshow"; //Fanart Slideshow
-    else
-      strScreenSaver = pControl->GetCurrentLabel() + ".xbs";
-    pSettingString->SetData(strScreenSaver);
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	int iValue = pControl->GetValue();
+	CStdString strScreenSaver;
+	if (iValue == 0)
+	  strScreenSaver = "None";
+	else if (iValue == 1)
+	  strScreenSaver = "Dim";
+	else if (iValue == 2)
+	  strScreenSaver = "Black";
+	else if (iValue == 3)
+	  strScreenSaver = "SlideShow"; // PictureSlideShow
+	else if (iValue == 4)
+	  strScreenSaver = "Fanart Slideshow"; //Fanart Slideshow
+	else
+	  strScreenSaver = pControl->GetCurrentLabel() + ".xbs";
+	pSettingString->SetData(strScreenSaver);
   }
   else if (strSetting.Equals("screensaver.preview"))
   {
-    g_application.ActivateScreenSaver(true);
+	g_application.ActivateScreenSaver(true);
   }
   else if (strSetting.Equals("screensaver.slideshowpath"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CStdString path = pSettingString->GetData();
-    VECSOURCES shares = g_settings.m_pictureSources;
-    g_mediaManager.GetLocalDrives(shares);
-    if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares, g_localizeStrings.Get(pSettingString->m_iHeadingString), path))
-      pSettingString->SetData(path);
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CStdString path = pSettingString->GetData();
+	VECSOURCES shares = g_settings.m_pictureSources;
+	g_mediaManager.GetLocalDrives(shares);
+	if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares, g_localizeStrings.Get(pSettingString->m_iHeadingString), path))
+	  pSettingString->SetData(path);
   }
   else if (strSetting.Equals("myprograms.dashboard"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CStdString path = pSettingString->GetData();
-    VECSOURCES shares;
-    g_mediaManager.GetLocalDrives(shares);
-    if (CGUIDialogFileBrowser::ShowAndGetFile(shares, ".xbe", g_localizeStrings.Get(pSettingString->m_iHeadingString), path))
-      pSettingString->SetData(path);
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CStdString path = pSettingString->GetData();
+	VECSOURCES shares;
+	g_mediaManager.GetLocalDrives(shares);
+	if (CGUIDialogFileBrowser::ShowAndGetFile(shares, ".xbe", g_localizeStrings.Get(pSettingString->m_iHeadingString), path))
+	  pSettingString->SetData(path);
   }
   else if (strSetting.Equals("myprograms.trainerpath") || strSetting.Equals("debug.screenshotpath") || strSetting.Equals("audiocds.recordingpath") || strSetting.Equals("cddaripper.path") || strSetting.Equals("subtitles.custompath"))
   {
-    CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
-    CStdString path = g_guiSettings.GetString(strSetting,false);
-    VECSOURCES shares;
-    g_mediaManager.GetLocalDrives(shares);
-    UpdateSettings();
-    bool bWriteOnly = true;
-    if (strSetting.Equals("myprograms.trainerpath"))
-      bWriteOnly = false;
+	CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
+	CStdString path = g_guiSettings.GetString(strSetting,false);
+	VECSOURCES shares;
+	g_mediaManager.GetLocalDrives(shares);
+	UpdateSettings();
+	bool bWriteOnly = true;
+	if (strSetting.Equals("myprograms.trainerpath"))
+	  bWriteOnly = false;
 
-    if (strSetting.Equals("subtitles.custompath"))
-    {
-      bWriteOnly = false;
-      shares = g_settings.m_videoSources;
-      g_mediaManager.GetLocalDrives(shares);
-    }
-    if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares, g_localizeStrings.Get(pSettingString->m_iHeadingString), path, bWriteOnly))
-    {
-      pSettingString->SetData(path);
+	if (strSetting.Equals("subtitles.custompath"))
+	{
+	  bWriteOnly = false;
+	  shares = g_settings.m_videoSources;
+	  g_mediaManager.GetLocalDrives(shares);
+	}
+	if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares, g_localizeStrings.Get(pSettingString->m_iHeadingString), path, bWriteOnly))
+	{
+	  pSettingString->SetData(path);
 
-      if (strSetting.Equals("myprograms.trainerpath"))
-      {
-        if (CGUIDialogYesNo::ShowAndGetInput(12012,20135,20022,20022))
-        {
-          CGUIWindowPrograms* pWindow = (CGUIWindowPrograms*)g_windowManager.GetWindow(WINDOW_PROGRAMS);
-          if (pWindow)
-            pWindow->PopulateTrainersList();
-        }
-      }
-    }
+	  if (strSetting.Equals("myprograms.trainerpath"))
+	  {
+		if (CGUIDialogYesNo::ShowAndGetInput(12012,20135,20022,20022))
+		{
+		  CGUIWindowPrograms* pWindow = (CGUIWindowPrograms*)g_windowManager.GetWindow(WINDOW_PROGRAMS);
+		  if (pWindow)
+			pWindow->PopulateTrainersList();
+		}
+	  }
+	}
   }
+  else if (strSetting.Equals("mygames.usesynopsisname"))
+  {
+	// CGUIDialogOK *dialog = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_OK);
+	// if (dialog)
+	// {
+		// dialog->SetHeading( g_localizeStrings.Get(33049) );
+		// dialog->SetLine( 0, "");
+		// dialog->SetLine( 1, g_localizeStrings.Get(32004));
+		// dialog->SetLine(2, "");
+		// dialog->DoModal();
+	// }
+	if (g_guiSettings.GetBool("mygames.usesynopsisname"))
+	{
+		CopyFile("P:\\Database\\MyPrograms6.db","P:\\Database\\MyPrograms-Default.db",1);
+		CFile::Delete("P:/Database/MyPrograms6.db");
+		if ( CFile::Exists("P:\\Database\\MyPrograms-Synopsis.db") )
+		CopyFile("P:\\Database\\MyPrograms-Synopsis.db","P:\\Database\\MyPrograms6.db",1);
+	}
+	else
+	{
+		CopyFile("P:\\Database\\MyPrograms6.db","P:\\Database\\MyPrograms-Synopsis.db",1);
+		CFile::Delete("P:/Database/MyPrograms6.db");
+		if ( CFile::Exists("P:\\Database\\MyPrograms-Default.db") )
+		CopyFile("P:\\Database\\MyPrograms-Default.db","P:\\Database\\MyPrograms6.db",1);
+	}
+  }
   else if (strSetting.Left(22).Equals("MusicPlayer.ReplayGain"))
   { // Update our replaygain settings
-    g_guiSettings.m_replayGain.iType = g_guiSettings.GetInt("musicplayer.replaygaintype");
-    g_guiSettings.m_replayGain.iPreAmp = g_guiSettings.GetInt("musicplayer.replaygainpreamp");
-    g_guiSettings.m_replayGain.iNoGainPreAmp = g_guiSettings.GetInt("musicplayer.replaygainnogainpreamp");
-    g_guiSettings.m_replayGain.bAvoidClipping = g_guiSettings.GetBool("musicplayer.replaygainavoidclipping");
+	g_guiSettings.m_replayGain.iType = g_guiSettings.GetInt("musicplayer.replaygaintype");
+	g_guiSettings.m_replayGain.iPreAmp = g_guiSettings.GetInt("musicplayer.replaygainpreamp");
+	g_guiSettings.m_replayGain.iNoGainPreAmp = g_guiSettings.GetInt("musicplayer.replaygainnogainpreamp");
+	g_guiSettings.m_replayGain.bAvoidClipping = g_guiSettings.GetBool("musicplayer.replaygainavoidclipping");
   }
   else if (strSetting.Equals("locale.country"))
   {
-    CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+	CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
 
-    const CStdString& strRegion=pControl->GetCurrentLabel();
-    g_langInfo.SetCurrentRegion(strRegion);
-    g_guiSettings.SetString("locale.country", strRegion);
-    g_weatherManager.Refresh(); // need to reset our weather, as temperatures need re-translating.
+	const CStdString& strRegion=pControl->GetCurrentLabel();
+	g_langInfo.SetCurrentRegion(strRegion);
+	g_guiSettings.SetString("locale.country", strRegion);
+	g_weatherManager.Refresh(); // need to reset our weather, as temperatures need re-translating.
   }
 #ifdef HAS_TIME_SERVER
   else if (strSetting.Equals("locale.timeserver") || strSetting.Equals("locale.timeserveraddress"))
   {
-    g_application.StopTimeServer();
-    if (g_guiSettings.GetBool("locale.timeserver"))
-      g_application.StartTimeServer();
+	g_application.StopTimeServer();
+	if (g_guiSettings.GetBool("locale.timeserver"))
+	  g_application.StartTimeServer();
   }
 #endif
   else if (strSetting.Equals("locale.time"))
   {
-    SYSTEMTIME curTime;
-    GetLocalTime(&curTime);
-    if (CGUIDialogNumeric::ShowAndGetTime(curTime, g_localizeStrings.Get(14066)))
-    { // yay!
-      SYSTEMTIME curDate;
-      GetLocalTime(&curDate);
-      CUtil::SetSysDateTimeYear(curDate.wYear, curDate.wMonth, curDate.wDay, curTime.wHour, curTime.wMinute);
-    }
+	SYSTEMTIME curTime;
+	GetLocalTime(&curTime);
+	if (CGUIDialogNumeric::ShowAndGetTime(curTime, g_localizeStrings.Get(14066)))
+	{ // yay!
+	  SYSTEMTIME curDate;
+	  GetLocalTime(&curDate);
+	  CUtil::SetSysDateTimeYear(curDate.wYear, curDate.wMonth, curDate.wDay, curTime.wHour, curTime.wMinute);
+	}
   }
   else if (strSetting.Equals("locale.date"))
   {
-    SYSTEMTIME curDate;
-    GetLocalTime(&curDate);
-    if (CGUIDialogNumeric::ShowAndGetDate(curDate, g_localizeStrings.Get(14067)))
-    { // yay!
-      SYSTEMTIME curTime;
-      GetLocalTime(&curTime);
-      CUtil::SetSysDateTimeYear(curDate.wYear, curDate.wMonth, curDate.wDay, curTime.wHour, curTime.wMinute);
-    }
+	SYSTEMTIME curDate;
+	GetLocalTime(&curDate);
+	if (CGUIDialogNumeric::ShowAndGetDate(curDate, g_localizeStrings.Get(14067)))
+	{ // yay!
+	  SYSTEMTIME curTime;
+	  GetLocalTime(&curTime);
+	  CUtil::SetSysDateTimeYear(curDate.wYear, curDate.wMonth, curDate.wDay, curTime.wHour, curTime.wMinute);
+	}
   }
   else if (strSetting.Equals("smb.winsserver") || strSetting.Equals("smb.workgroup") )
   {
-    if (g_guiSettings.GetString("smb.winsserver") == "0.0.0.0")
-      g_guiSettings.SetString("smb.winsserver", "");
+	if (g_guiSettings.GetString("smb.winsserver") == "0.0.0.0")
+	  g_guiSettings.SetString("smb.winsserver", "");
 
-    /* okey we really don't need to restarat, only deinit samba, but that could be damn hard if something is playing*/
-    //TODO - General way of handling setting changes that require restart
+	/* okey we really don't need to restarat, only deinit samba, but that could be damn hard if something is playing*/
+	//TODO - General way of handling setting changes that require restart
 
-    CGUIDialogOK *dlg = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
-    if (!dlg) return ;
-    dlg->SetHeading( g_localizeStrings.Get(14038) );
-    dlg->SetLine( 0, g_localizeStrings.Get(14039) );
-    dlg->SetLine( 1, g_localizeStrings.Get(14040));
-    dlg->SetLine( 2, "");
-    dlg->DoModal();
+	CGUIDialogOK *dlg = (CGUIDialogOK *)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+	if (!dlg) return ;
+	dlg->SetHeading( g_localizeStrings.Get(14038) );
+	dlg->SetLine( 0, g_localizeStrings.Get(14039) );
+	dlg->SetLine( 1, g_localizeStrings.Get(14040));
+	dlg->SetLine( 2, "");
+	dlg->DoModal();
 
-    if (dlg->IsConfirmed())
-    {
-      g_settings.Save();
-      g_application.getApplicationMessenger().RestartApp();
-    }
+	if (dlg->IsConfirmed())
+	{
+	  g_settings.Save();
+	  g_application.getApplicationMessenger().RestartApp();
+	}
   }
   else if (strSetting.Equals("services.upnpserver"))
   {
 #ifdef HAS_UPNP
-    if (g_guiSettings.GetBool("services.upnpserver"))
-      g_application.StartUPnPServer();
-    else
-      g_application.StopUPnPServer();
+	if (g_guiSettings.GetBool("services.upnpserver"))
+	  g_application.StartUPnPServer();
+	else
+	  g_application.StopUPnPServer();
 #endif
   }
   else if (strSetting.Equals("services.upnprenderer"))
   {
 #ifdef HAS_UPNP
-    if (g_guiSettings.GetBool("services.upnprenderer"))
-      g_application.StartUPnPRenderer();
-    else
-      g_application.StopUPnPRenderer();
+	if (g_guiSettings.GetBool("services.upnprenderer"))
+	  g_application.StartUPnPRenderer();
+	else
+	  g_application.StopUPnPRenderer();
 #endif
   }
   else if (strSetting.Equals("services.esenabled"))
   {
 #ifdef HAS_EVENT_SERVER
-    if (g_guiSettings.GetBool("services.esenabled"))
-      g_application.StartEventServer();
-    else
-    {
-      if (!g_application.StopEventServer(true))
-      {
-        g_guiSettings.SetBool("services.esenabled", true);
-        CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-        if (pControl) pControl->SetEnabled(true);
-      }
-    }
+	if (g_guiSettings.GetBool("services.esenabled"))
+	  g_application.StartEventServer();
+	else
+	{
+	  if (!g_application.StopEventServer(true))
+	  {
+		g_guiSettings.SetBool("services.esenabled", true);
+		CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+		if (pControl) pControl->SetEnabled(true);
+	  }
+	}
 #endif
   }
   else if (strSetting.Equals("services.esallinterfaces"))
   {
 #ifdef HAS_EVENT_SERVER
-    if (g_guiSettings.GetBool("services.esenabled"))
-    {
-      if (g_application.StopEventServer(true))
-        g_application.StartEventServer();
-      else
-      {
-        g_guiSettings.SetBool("services.esenabled", true);
-        CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
-        if (pControl) pControl->SetEnabled(true);
-      }
-    }
+	if (g_guiSettings.GetBool("services.esenabled"))
+	{
+	  if (g_application.StopEventServer(true))
+		g_application.StartEventServer();
+	  else
+	  {
+		g_guiSettings.SetBool("services.esenabled", true);
+		CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+		if (pControl) pControl->SetEnabled(true);
+	  }
+	}
 #endif
   }
   else if (strSetting.Equals("services.esinitialdelay") || 
-           strSetting.Equals("services.escontinuousdelay"))    
+		   strSetting.Equals("services.escontinuousdelay"))    
   {
 #ifdef HAS_EVENT_SERVER
-    if (g_guiSettings.GetBool("services.esenabled"))
-    {
-      g_application.RefreshEventServer();
-    }
+	if (g_guiSettings.GetBool("services.esenabled"))
+	{
+	  g_application.RefreshEventServer();
+	}
 #endif      
   }
   else if (strSetting.Equals("masterlock.lockcode"))
   {
-    // Now Prompt User to enter the old and then the new MasterCode!
-    if(g_passwordManager.SetMasterLockMode())
-    {
-      // We asked for the master password and saved the new one!
-      // Nothing todo here
-    }
+	// Now Prompt User to enter the old and then the new MasterCode!
+	if(g_passwordManager.SetMasterLockMode())
+	{
+	  // We asked for the master password and saved the new one!
+	  // Nothing todo here
+	}
   }
 
   else if (strSetting.Equals("lookandfeel.skinzoom"))
   {
-    g_fontManager.ReloadTTFFonts();
+	g_fontManager.ReloadTTFFonts();
   }
   else if (strSetting.Equals("videolibrary.flattentvshows") ||
-           strSetting.Equals("videolibrary.removeduplicates"))
+		   strSetting.Equals("videolibrary.removeduplicates"))
   {
-    CUtil::DeleteVideoDatabaseDirectoryCache();
+	CUtil::DeleteVideoDatabaseDirectoryCache();
   }
   else if (strSetting.Equals("system.mceremote"))
   {
-    CBuiltins::Execute("Action(reloadkeymaps)");
+	CBuiltins::Execute("Action(reloadkeymaps)");
   }
   UpdateSettings();
 }
@@ -2086,8 +2130,8 @@
   CGUIControlGroupList *control = (CGUIControlGroupList *)GetControl(CATEGORY_GROUP_ID);
   if (control)
   {
-    control->FreeResources();
-    control->ClearAll();
+	control->FreeResources();
+	control->ClearAll();
   }
   m_vecSections.clear();
   FreeSettingsControls();
@@ -2099,13 +2143,13 @@
   CGUIControlGroupList *control = (CGUIControlGroupList *)GetControl(SETTINGS_GROUP_ID);
   if (control)
   {
-    control->FreeResources();
-    control->ClearAll();
+	control->FreeResources();
+	control->ClearAll();
   }
 
   for(int i = 0; (size_t)i < m_vecSettings.size(); i++)
   {
-    delete m_vecSettings[i];
+	delete m_vecSettings[i];
   }
   m_vecSettings.clear();
 }
@@ -2116,48 +2160,48 @@
   CGUIControl *pControl = NULL;
   if (pSetting->GetControlType() == CHECKMARK_CONTROL)
   {
-    pControl = new CGUIRadioButtonControl(*m_pOriginalRadioButton);
-    if (!pControl) return ;
-    ((CGUIRadioButtonControl *)pControl)->SetLabel(g_localizeStrings.Get(pSetting->GetLabel()));
-    pControl->SetWidth(width);
-    pSettingControl = new CRadioButtonSettingControl((CGUIRadioButtonControl *)pControl, iControlID, pSetting);
+	pControl = new CGUIRadioButtonControl(*m_pOriginalRadioButton);
+	if (!pControl) return ;
+	((CGUIRadioButtonControl *)pControl)->SetLabel(g_localizeStrings.Get(pSetting->GetLabel()));
+	pControl->SetWidth(width);
+	pSettingControl = new CRadioButtonSettingControl((CGUIRadioButtonControl *)pControl, iControlID, pSetting);
   }
   else if (pSetting->GetControlType() == SPIN_CONTROL_FLOAT || pSetting->GetControlType() == SPIN_CONTROL_INT_PLUS || pSetting->GetControlType() == SPIN_CONTROL_TEXT || pSetting->GetControlType() == SPIN_CONTROL_INT)
   {
-    pControl = new CGUISpinControlEx(*m_pOriginalSpin);
-    if (!pControl) return ;
-    pControl->SetWidth(width);
-    ((CGUISpinControlEx *)pControl)->SetText(g_localizeStrings.Get(pSetting->GetLabel()));
-    pSettingControl = new CSpinExSettingControl((CGUISpinControlEx *)pControl, iControlID, pSetting);
+	pControl = new CGUISpinControlEx(*m_pOriginalSpin);
+	if (!pControl) return ;
+	pControl->SetWidth(width);
+	((CGUISpinControlEx *)pControl)->SetText(g_localizeStrings.Get(pSetting->GetLabel()));
+	pSettingControl = new CSpinExSettingControl((CGUISpinControlEx *)pControl, iControlID, pSetting);
   }
   else if (pSetting->GetControlType() == SEPARATOR_CONTROL && m_pOriginalImage)
   {
-    pControl = new CGUIImage(*m_pOriginalImage);
-    if (!pControl) return;
-    pControl->SetWidth(width);
-    pSettingControl = new CSeparatorSettingControl((CGUIImage *)pControl, iControlID, pSetting);
+	pControl = new CGUIImage(*m_pOriginalImage);
+	if (!pControl) return;
+	pControl->SetWidth(width);
+	pSettingControl = new CSeparatorSettingControl((CGUIImage *)pControl, iControlID, pSetting);
   }
   else if (pSetting->GetControlType() == EDIT_CONTROL_INPUT ||
-           pSetting->GetControlType() == EDIT_CONTROL_HIDDEN_INPUT ||
-           pSetting->GetControlType() == EDIT_CONTROL_MD5_INPUT ||
-           pSetting->GetControlType() == EDIT_CONTROL_NUMBER_INPUT ||
-           pSetting->GetControlType() == EDIT_CONTROL_IP_INPUT)
+		   pSetting->GetControlType() == EDIT_CONTROL_HIDDEN_INPUT ||
+		   pSetting->GetControlType() == EDIT_CONTROL_MD5_INPUT ||
+		   pSetting->GetControlType() == EDIT_CONTROL_NUMBER_INPUT ||
+		   pSetting->GetControlType() == EDIT_CONTROL_IP_INPUT)
   {
-    pControl = new CGUIEditControl(*m_pOriginalEdit);
-    if (!pControl) return ;
-    ((CGUIEditControl *)pControl)->SettingsCategorySetTextAlign(XBFONT_CENTER_Y);
-    ((CGUIEditControl *)pControl)->SetLabel(g_localizeStrings.Get(pSetting->GetLabel()));
-    pControl->SetWidth(width);
-    pSettingControl = new CEditSettingControl((CGUIEditControl *)pControl, iControlID, pSetting);
+	pControl = new CGUIEditControl(*m_pOriginalEdit);
+	if (!pControl) return ;
+	((CGUIEditControl *)pControl)->SettingsCategorySetTextAlign(XBFONT_CENTER_Y);
+	((CGUIEditControl *)pControl)->SetLabel(g_localizeStrings.Get(pSetting->GetLabel()));
+	pControl->SetWidth(width);
+	pSettingControl = new CEditSettingControl((CGUIEditControl *)pControl, iControlID, pSetting);
   }
   else if (pSetting->GetControlType() != SEPARATOR_CONTROL) // button control
   {
-    pControl = new CGUIButtonControl(*m_pOriginalButton);
-    if (!pControl) return ;
-    ((CGUIButtonControl *)pControl)->SettingsCategorySetTextAlign(XBFONT_CENTER_Y);
-    ((CGUIButtonControl *)pControl)->SetLabel(g_localizeStrings.Get(pSetting->GetLabel()));
-    pControl->SetWidth(width);
-    pSettingControl = new CButtonSettingControl((CGUIButtonControl *)pControl, iControlID, pSetting);
+	pControl = new CGUIButtonControl(*m_pOriginalButton);
+	if (!pControl) return ;
+	((CGUIButtonControl *)pControl)->SettingsCategorySetTextAlign(XBFONT_CENTER_Y);
+	((CGUIButtonControl *)pControl)->SetLabel(g_localizeStrings.Get(pSetting->GetLabel()));
+	pControl->SetWidth(width);
+	pSettingControl = new CButtonSettingControl((CGUIButtonControl *)pControl, iControlID, pSetting);
   }
   if (!pControl) return;
   pControl->SetID(iControlID++);
@@ -2165,9 +2209,9 @@
   CGUIControlGroupList *group = (CGUIControlGroupList *)GetControl(SETTINGS_GROUP_ID);
   if (group)
   {
-    pControl->AllocResources();
-    group->AddControl(pControl);
-    m_vecSettings.push_back(pSettingControl);
+	pControl->AllocResources();
+	group->AddControl(pControl);
+	m_vecSettings.push_back(pSettingControl);
   }
 }
 
@@ -2178,10 +2222,10 @@
 
   if (m_delayedSetting && m_delayedTimer.GetElapsedMilliseconds() > 3000)
   { // we send a thread message so that it's processed the following frame (some settings won't
-    // like being changed during Render())
-    CGUIMessage message(GUI_MSG_UPDATE_ITEM, GetID(), GetID());
-    g_windowManager.SendThreadMessage(message, GetID());
-    m_delayedTimer.Stop();
+	// like being changed during Render())
+	CGUIMessage message(GUI_MSG_UPDATE_ITEM, GetID(), GetID());
+	g_windowManager.SendThreadMessage(message, GetID());
+	m_delayedTimer.Stop();
   }
   CGUIWindow::FrameMove();
 }
@@ -2193,35 +2237,35 @@
   CGUIControl *control = GetFirstFocusableControl(CONTROL_START_BUTTONS + m_iSection);
   if (control && !control->HasFocus())
   {
-    if (control->GetControlType() == CGUIControl::GUICONTROL_BUTTON)
-    {
-      control->SetFocus(true);
-      ((CGUIButtonControl *)control)->SetAlpha(0x80);
-      bAlphaFaded = true;
-    }
-    else if (control->GetControlType() == CGUIControl::GUICONTROL_TOGGLEBUTTON)
-    {
-      control->SetFocus(true);
-      ((CGUIButtonControl *)control)->SetSelected(true);
-      bAlphaFaded = true;
-    }
+	if (control->GetControlType() == CGUIControl::GUICONTROL_BUTTON)
+	{
+	  control->SetFocus(true);
+	  ((CGUIButtonControl *)control)->SetAlpha(0x80);
+	  bAlphaFaded = true;
+	}
+	else if (control->GetControlType() == CGUIControl::GUICONTROL_TOGGLEBUTTON)
+	{
+	  control->SetFocus(true);
+	  ((CGUIButtonControl *)control)->SetSelected(true);
+	  bAlphaFaded = true;
+	}
   }
   CGUIWindow::Render();
   if (bAlphaFaded)
   {
-    control->SetFocus(false);
-    if (control->GetControlType() == CGUIControl::GUICONTROL_BUTTON)
-      ((CGUIButtonControl *)control)->SetAlpha(0xFF);
-    else
-      ((CGUIButtonControl *)control)->SetSelected(false);
+	control->SetFocus(false);
+	if (control->GetControlType() == CGUIControl::GUICONTROL_BUTTON)
+	  ((CGUIButtonControl *)control)->SetAlpha(0xFF);
+	else
+	  ((CGUIButtonControl *)control)->SetSelected(false);
   }
   // render the error message if necessary
   if (m_strErrorMessage.size())
   {
-    CGUIFont *pFont = g_fontManager.GetFont("font13");
-    float fPosY = g_graphicsContext.GetHeight() * 0.8f;
-    float fPosX = g_graphicsContext.GetWidth() * 0.5f;
-    CGUITextLayout::DrawText(pFont, fPosX, fPosY, 0xffffffff, 0, m_strErrorMessage, XBFONT_CENTER_X);
+	CGUIFont *pFont = g_fontManager.GetFont("font13");
+	float fPosY = g_graphicsContext.GetHeight() * 0.8f;
+	float fPosX = g_graphicsContext.GetWidth() * 0.5f;
+	CGUITextLayout::DrawText(pFont, fPosX, fPosY, 0xffffffff, 0, m_strErrorMessage, XBFONT_CENTER_X);
   }
 }
 
@@ -2230,45 +2274,47 @@
   // check if our network needs restarting (requires a reset, so check well!)
   if (m_iNetworkAssignment == -1)
   {
-    // nothing to do here, folks - move along.
-    return ;
+	// nothing to do here, folks - move along.
+	return ;
   }
   // we need a reset if:
   // 1.  The Network Assignment has changed OR
   // 2.  The Network Assignment is STATIC and one of the network fields have changed
   if (m_iNetworkAssignment != g_guiSettings.GetInt("network.assignment") ||
-      (m_iNetworkAssignment == NETWORK_STATIC && (
-         m_strNetworkIPAddress != g_guiSettings.GetString("network.ipaddress") ||
-         m_strNetworkSubnet != g_guiSettings.GetString("network.subnet") ||
-         m_strNetworkGateway != g_guiSettings.GetString("network.gateway") ||
-         m_strNetworkDNS != g_guiSettings.GetString("network.dns"))))
+	  (m_iNetworkAssignment == NETWORK_STATIC && (
+		 m_strNetworkIPAddress != g_guiSettings.GetString("network.ipaddress") ||
+		 m_strNetworkSubnet != g_guiSettings.GetString("network.subnet") ||
+		 m_strNetworkGateway != g_guiSettings.GetString("network.gateway") ||
+		 m_strNetworkDNS != g_guiSettings.GetString("network.dns") ||
+		 m_strNetworkDNS2 != g_guiSettings.GetString("network.dns2"))))
   {
 /*    // our network settings have changed - we should prompt the user to reset XBMC
-    if (CGUIDialogYesNo::ShowAndGetInput(14038, 14039, 14040, 0))
-    {
-      // reset settings
-      g_application.getApplicationMessenger().RestartApp();
-      // Todo: aquire new network settings without restart app!
-    }
-    else*/
-    {
-      g_application.getNetwork().NetworkMessage(CNetwork::SERVICES_DOWN,1);
-      g_application.getNetwork().SetupNetwork();
-    }
+	if (CGUIDialogYesNo::ShowAndGetInput(14038, 14039, 14040, 0))
+	{
+	  // reset settings
+	  g_application.getApplicationMessenger().RestartApp();
+	  // Todo: aquire new network settings without restart app!
+	}
+	else*/
+	{
+	  g_application.getNetwork().NetworkMessage(CNetwork::SERVICES_DOWN,1);
+	  g_application.getNetwork().SetupNetwork();
+	}
 
-    // update our settings variables    
-    m_iNetworkAssignment = g_guiSettings.GetInt("network.assignment");
-    m_strNetworkIPAddress = g_guiSettings.GetString("network.ipaddress");
-    m_strNetworkSubnet = g_guiSettings.GetString("network.subnet");
-    m_strNetworkGateway = g_guiSettings.GetString("network.gateway");
-    m_strNetworkDNS = g_guiSettings.GetString("network.dns");
+	// update our settings variables    
+	m_iNetworkAssignment = g_guiSettings.GetInt("network.assignment");
+	m_strNetworkIPAddress = g_guiSettings.GetString("network.ipaddress");
+	m_strNetworkSubnet = g_guiSettings.GetString("network.subnet");
+	m_strNetworkGateway = g_guiSettings.GetString("network.gateway");
+	m_strNetworkDNS = g_guiSettings.GetString("network.dns");
+	m_strNetworkDNS2 = g_guiSettings.GetString("network.dns2");
 
-    // replace settings
-    /*   g_guiSettings.SetInt("network.assignment", m_iNetworkAssignment);
-       g_guiSettings.SetString("network.ipaddress", m_strNetworkIPAddress);
-       g_guiSettings.SetString("network.subnet", m_strNetworkSubnet);
-       g_guiSettings.SetString("network.gateway", m_strNetworkGateway);
-       g_guiSettings.SetString("network.dns", m_strNetworkDNS);*/
+	// replace settings
+	/*   g_guiSettings.SetInt("network.assignment", m_iNetworkAssignment);
+	   g_guiSettings.SetString("network.ipaddress", m_strNetworkIPAddress);
+	   g_guiSettings.SetString("network.subnet", m_strNetworkSubnet);
+	   g_guiSettings.SetString("network.gateway", m_strNetworkGateway);
+	   g_guiSettings.SetString("network.dns", m_strNetworkDNS);*/
   }
 }
 
@@ -2280,47 +2326,47 @@
   pControl->Clear();
   if (CUtil::IsUsingTTFSubtitles())
   { // easy - just fill as per usual
-    CStdString strLabel;
-    for (int i = pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i += pSettingInt->m_iStep)
-    {
-      if (pSettingInt->m_iFormat > -1)
-      {
-        CStdString strFormat = g_localizeStrings.Get(pSettingInt->m_iFormat);
-        strLabel.Format(strFormat, i);
-      }
-      else
-        strLabel.Format(pSettingInt->m_strFormat, i);
-      pControl->AddLabel(strLabel, i);
-    }
-    pControl->SetValue(pSettingInt->GetData());
+	CStdString strLabel;
+	for (int i = pSettingInt->m_iMin; i <= pSettingInt->m_iMax; i += pSettingInt->m_iStep)
+	{
+	  if (pSettingInt->m_iFormat > -1)
+	  {
+		CStdString strFormat = g_localizeStrings.Get(pSettingInt->m_iFormat);
+		strLabel.Format(strFormat, i);
+	  }
+	  else
+		strLabel.Format(pSettingInt->m_strFormat, i);
+	  pControl->AddLabel(strLabel, i);
+	}
+	pControl->SetValue(pSettingInt->GetData());
   }
 #ifdef _XBOX
   else
   {
-    if (g_guiSettings.GetString("subtitles.font").size())
-    {
-      //find font sizes...
-      CFileItemList items;
-      CStdString strPath = "special://xbmc/system/players/mplayer/font/";
-      strPath += g_guiSettings.GetString("subtitles.font");
-      strPath += "/";
-      CDirectory::GetDirectory(strPath, items);
-      int iCurrentSize = 0;
-      int iSize = 0;
-      for (int i = 0; i < items.Size(); ++i)
-      {
-        CFileItemPtr pItem = items[i];
-        if (pItem->m_bIsFolder)
-        {
-          if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
-          int iSizeTmp = atoi(pItem->GetLabel().c_str());
-          if (iSizeTmp == pSettingInt->GetData())
-            iCurrentSize = iSize;
-          pControl->AddLabel(pItem->GetLabel(), iSize++);
-        }
-      }
-      pControl->SetValue(iCurrentSize);
-    }
+	if (g_guiSettings.GetString("subtitles.font").size())
+	{
+	  //find font sizes...
+	  CFileItemList items;
+	  CStdString strPath = "special://xbmc/system/players/mplayer/font/";
+	  strPath += g_guiSettings.GetString("subtitles.font");
+	  strPath += "/";
+	  CDirectory::GetDirectory(strPath, items);
+	  int iCurrentSize = 0;
+	  int iSize = 0;
+	  for (int i = 0; i < items.Size(); ++i)
+	  {
+		CFileItemPtr pItem = items[i];
+		if (pItem->m_bIsFolder)
+		{
+		  if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
+		  int iSizeTmp = atoi(pItem->GetLabel().c_str());
+		  if (iSizeTmp == pSettingInt->GetData())
+			iCurrentSize = iSize;
+		  pControl->AddLabel(pItem->GetLabel(), iSize++);
+		}
+	  }
+	  pControl->SetValue(iCurrentSize);
+	}
   }
 #endif
 }
@@ -2337,43 +2383,43 @@
 #ifdef _XBOX
   // Find mplayer fonts...
   {
-    CFileItemList items;
-    CDirectory::GetDirectory("special://xbmc/system/players/mplayer/font/", items);
-    for (int i = 0; i < items.Size(); ++i)
-    {
-      CFileItemPtr pItem = items[i];
-      if (pItem->m_bIsFolder)
-      {
-        if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
-        if (strcmpi(pItem->GetLabel().c_str(), pSettingString->GetData().c_str()) == 0)
-          iCurrentFont = iFont;
-        pControl->AddLabel(pItem->GetLabel(), iFont++);
-      }
-    }
+	CFileItemList items;
+	CDirectory::GetDirectory("special://xbmc/system/players/mplayer/font/", items);
+	for (int i = 0; i < items.Size(); ++i)
+	{
+	  CFileItemPtr pItem = items[i];
+	  if (pItem->m_bIsFolder)
+	  {
+		if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
+		if (strcmpi(pItem->GetLabel().c_str(), pSettingString->GetData().c_str()) == 0)
+		  iCurrentFont = iFont;
+		pControl->AddLabel(pItem->GetLabel(), iFont++);
+	  }
+	}
   }
 #endif
 
   // find TTF fonts
   {
-    CFileItemList items;
-    if (CDirectory::GetDirectory("special://xbmc/media/Fonts/", items))
-    {
-      for (int i = 0; i < items.Size(); ++i)
-      {
-        CFileItemPtr pItem = items[i];
+	CFileItemList items;
+	if (CDirectory::GetDirectory("special://xbmc/system/media/Fonts/", items))
+	{
+	  for (int i = 0; i < items.Size(); ++i)
+	  {
+		CFileItemPtr pItem = items[i];
 
-        if (!pItem->m_bIsFolder)
-        {
+		if (!pItem->m_bIsFolder)
+		{
 
-          if ( !URIUtils::GetExtension(pItem->GetLabel()).Equals(".ttf") ) continue;
-          if (pItem->GetLabel().Equals(pSettingString->GetData(), false))
-            iCurrentFont = iFont;
+		  if ( !URIUtils::GetExtension(pItem->GetLabel()).Equals(".ttf") ) continue;
+		  if (pItem->GetLabel().Equals(pSettingString->GetData(), false))
+			iCurrentFont = iFont;
 
-          pControl->AddLabel(pItem->GetLabel(), iFont++);
-        }
+		  pControl->AddLabel(pItem->GetLabel(), iFont++);
+		}
 
-      }
-    }
+	  }
+	}
   }
   pControl->SetValue(iCurrentFont);
 }
@@ -2393,8 +2439,8 @@
   TiXmlDocument xmlDoc;
   if (!xmlDoc.LoadFile(strPath))
   {
-    CLog::Log(LOGERROR, "Couldn't load %s", strPath.c_str());
-    return ;
+	CLog::Log(LOGERROR, "Couldn't load %s", strPath.c_str());
+	return ;
   }
 
   TiXmlElement* pRootElement = xmlDoc.RootElement();
@@ -2402,8 +2448,8 @@
   CStdString strValue = pRootElement->Value();
   if (strValue != CStdString("fonts"))
   {
-    CLog::Log(LOGERROR, "file %s doesnt start with <fonts>", strPath.c_str());
-    return ;
+	CLog::Log(LOGERROR, "file %s doesnt start with <fonts>", strPath.c_str());
+	return ;
   }
 
   const TiXmlNode *pChild = pRootElement->FirstChild();
@@ -2410,38 +2456,38 @@
   strValue = pChild->Value();
   if (strValue == "fontset")
   {
-    while (pChild)
-    {
-      strValue = pChild->Value();
-      if (strValue == "fontset")
-      {
-        const char* idAttr = ((TiXmlElement*) pChild)->Attribute("id");
-        const char* unicodeAttr = ((TiXmlElement*) pChild)->Attribute("unicode");
+	while (pChild)
+	{
+	  strValue = pChild->Value();
+	  if (strValue == "fontset")
+	  {
+		const char* idAttr = ((TiXmlElement*) pChild)->Attribute("id");
+		const char* unicodeAttr = ((TiXmlElement*) pChild)->Attribute("unicode");
 
-        bool isUnicode=(unicodeAttr && stricmp(unicodeAttr, "true") == 0);
+		bool isUnicode=(unicodeAttr && stricmp(unicodeAttr, "true") == 0);
 
-        bool isAllowed=true;
-        if (g_langInfo.ForceUnicodeFont() && !isUnicode)
-          isAllowed=false;
+		bool isAllowed=true;
+		if (g_langInfo.ForceUnicodeFont() && !isUnicode)
+		  isAllowed=false;
 
-        if (idAttr != NULL && isAllowed)
-        {
-          pControl->AddLabel(idAttr, iSkinFontSet);
-          if (strcmpi(idAttr, g_guiSettings.GetString("lookandfeel.font").c_str()) == 0)
-            pControl->SetValue(iSkinFontSet);
-          iSkinFontSet++;
-        }
-      }
-      pChild = pChild->NextSibling();
-    }
+		if (idAttr != NULL && isAllowed)
+		{
+		  pControl->AddLabel(idAttr, iSkinFontSet);
+		  if (strcmpi(idAttr, g_guiSettings.GetString("lookandfeel.font").c_str()) == 0)
+			pControl->SetValue(iSkinFontSet);
+		  iSkinFontSet++;
+		}
+	  }
+	  pChild = pChild->NextSibling();
+	}
 
   }
   else
   {
-    // Since no fontset is defined, there is no selection of a fontset, so disable the component
-    pControl->AddLabel(g_localizeStrings.Get(13278), 1);
-    pControl->SetValue(1);
-    pControl->SetEnabled(false);
+	// Since no fontset is defined, there is no selection of a fontset, so disable the component
+	pControl->AddLabel(g_localizeStrings.Get(13278), 1);
+	pControl->SetValue(1);
+	pControl->SetEnabled(false);
   }
 }
 
@@ -2456,9 +2502,9 @@
 
   //find skins...
   CFileItemList items;
-  CDirectory::GetDirectory("special://xbmc/skin/", items);
+  CDirectory::GetDirectory("special://xbmc/", items);
   if (!CSpecialProtocol::XBMCIsHome())
-    CDirectory::GetDirectory("special://home/skin/", items);
+	CDirectory::GetDirectory("special://home/", items);
 
   int iCurrentSkin = 0;
   int iSkin = 0;
@@ -2465,28 +2511,28 @@
   vector<CStdString> vecSkins;
   for (int i = 0; i < items.Size(); ++i)
   {
-    CFileItemPtr pItem = items[i];
-    if (pItem->m_bIsFolder)
-    {
-      if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
-      if (strcmpi(pItem->GetLabel().c_str(), "fonts") == 0) continue;
-      if (strcmpi(pItem->GetLabel().c_str(), "media") == 0) continue;
-      //   if (g_SkinInfo.Check(pItem->GetPath()))
-      //   {
-      vecSkins.push_back(pItem->GetLabel());
-      //   }
-    }
+	CFileItemPtr pItem = items[i];
+	if (pItem->m_bIsFolder)
+	{
+	  if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
+	  if (strcmpi(pItem->GetLabel().c_str(), "fonts") == 0) continue;
+	  if (strcmpi(pItem->GetLabel().c_str(), "media") == 0) continue;
+	//  if (g_SkinInfo.Check(pItem->GetPath()))
+	//	 {
+			vecSkins.push_back(pItem->GetLabel());
+	//	 }
+	}
   }
 
   sort(vecSkins.begin(), vecSkins.end(), sortstringbyname());
   for (unsigned int i = 0; i < vecSkins.size(); ++i)
   {
-    CStdString strSkin = vecSkins[i];
-    if (strcmpi(strSkin.c_str(), g_guiSettings.GetString("lookandfeel.skin").c_str()) == 0)
-    {
-      iCurrentSkin = iSkin;
-    }
-    pControl->AddLabel(strSkin, iSkin++);
+	CStdString strSkin = vecSkins[i];
+	if (strcmpi(strSkin.c_str(), g_guiSettings.GetString("lookandfeel.skin").c_str()) == 0)
+	{
+	  iCurrentSkin = iSkin;
+	}
+	pControl->AddLabel(strSkin, iSkin++);
   }
   pControl->SetValue(iCurrentSkin);
   return ;
@@ -2503,9 +2549,9 @@
 
   //find skins...
   CFileItemList items;
-  CDirectory::GetDirectory("special://xbmc/sounds/", items);
+  CDirectory::GetDirectory("special://xbmc/emustation/themes/simple/sounds/", items);
   if (!CSpecialProtocol::XBMCIsHome())
-    CDirectory::GetDirectory("special://home/sounds/", items);
+	CDirectory::GetDirectory("special://home/emustation/themes/simple/sounds/", items);
 
   int iCurrentSoundSkin = 0;
   int iSoundSkin = 0;
@@ -2512,31 +2558,31 @@
   vector<CStdString> vecSoundSkins;
   for (int i = 0; i < items.Size(); ++i)
   {
-    CFileItemPtr pItem = items[i];
-    if (pItem->m_bIsFolder)
-    {
-      if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
-      if (strcmpi(pItem->GetLabel().c_str(), "fonts") == 0) continue;
-      if (strcmpi(pItem->GetLabel().c_str(), "media") == 0) continue;
-      vecSoundSkins.push_back(pItem->GetLabel());
-    }
+	CFileItemPtr pItem = items[i];
+	if (pItem->m_bIsFolder)
+	{
+	  if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
+	  if (strcmpi(pItem->GetLabel().c_str(), "fonts") == 0) continue;
+	  if (strcmpi(pItem->GetLabel().c_str(), "media") == 0) continue;
+	  vecSoundSkins.push_back(pItem->GetLabel());
+	}
   }
 
   pControl->AddLabel(g_localizeStrings.Get(474), iSoundSkin++); // Off
   pControl->AddLabel(g_localizeStrings.Get(15109), iSoundSkin++); // Skin Default
 
-  if (g_guiSettings.GetString("lookandfeel.soundskin")=="SKINDEFAULT")
-    iCurrentSoundSkin=1;
+  if (g_guiSettings.GetString("lookandfeel.soundskin")=="SIMPLE")
+	iCurrentSoundSkin=1;
 
   sort(vecSoundSkins.begin(), vecSoundSkins.end(), sortstringbyname());
   for (int i = 0; i < (int) vecSoundSkins.size(); ++i)
   {
-    CStdString strSkin = vecSoundSkins[i];
-    if (strcmpi(strSkin.c_str(), g_guiSettings.GetString("lookandfeel.soundskin").c_str()) == 0)
-    {
-      iCurrentSoundSkin = iSoundSkin;
-    }
-    pControl->AddLabel(strSkin, iSoundSkin++);
+	CStdString strSkin = vecSoundSkins[i];
+	if (strcmpi(strSkin.c_str(), g_guiSettings.GetString("lookandfeel.soundskin").c_str()) == 0)
+	{
+	  iCurrentSoundSkin = iSoundSkin;
+	}
+	pControl->AddLabel(strSkin, iSoundSkin++);
   }
   pControl->SetValue(iCurrentSoundSkin);
   return ;
@@ -2553,7 +2599,7 @@
 
   CStdString strCurrentCharsetLabel="DEFAULT";
   if (pSettingString->GetData()!="DEFAULT")
-    strCurrentCharsetLabel = g_charsetConverter.getCharsetLabelByName(pSettingString->GetData());
+	strCurrentCharsetLabel = g_charsetConverter.getCharsetLabelByName(pSettingString->GetData());
 
   sort(vecCharsets.begin(), vecCharsets.end(), sortstringbyname());
 
@@ -2563,12 +2609,12 @@
 
   for (int i = 0; i < (int) vecCharsets.size(); ++i)
   {
-    CStdString strCharsetLabel = vecCharsets[i];
+	CStdString strCharsetLabel = vecCharsets[i];
 
-    if (!bIsAuto && strCharsetLabel == strCurrentCharsetLabel)
-      iCurrentCharset = i;
+	if (!bIsAuto && strCharsetLabel == strCurrentCharsetLabel)
+	  iCurrentCharset = i;
 
-    pControl->AddLabel(strCharsetLabel, i);
+	pControl->AddLabel(strCharsetLabel, i);
   }
 
   pControl->SetValue(iCurrentCharset);
@@ -2580,34 +2626,34 @@
   if (!pSetting) return;
   int iWinID = g_windowManager.GetActiveWindow();
   {
-    CGUIMessage msg(GUI_MSG_LABEL_RESET, iWinID, iControlID);
-    g_windowManager.SendMessage(msg);
+	CGUIMessage msg(GUI_MSG_LABEL_RESET, iWinID, iControlID);
+	g_windowManager.SendMessage(msg);
   }
   vector<CStdString> vecVis;
   //find visz....
   CFileItemList items;
-  CDirectory::GetDirectory("special://xbmc/visualisations/", items);
+  CDirectory::GetDirectory("special://xbmc/system/visualisations/", items);
   if (!CSpecialProtocol::XBMCIsHome())
-    CDirectory::GetDirectory("special://home/visualisations/", items);
+	CDirectory::GetDirectory("special://home/system/visualisations/", items);
 
   for (int i = 0; i < items.Size(); ++i)
   {
-    CFileItemPtr pItem = items[i];
-    if (!pItem->m_bIsFolder)
-    {
-      CStdString strExtension;
-      URIUtils::GetExtension(pItem->GetPath(), strExtension);
-      if (strExtension == ".vis")
-      {
-        CStdString strLabel = pItem->GetLabel();
-        vecVis.push_back(strLabel.Mid(0, strLabel.size() - 4));
-      }
-    }
+	CFileItemPtr pItem = items[i];
+	if (!pItem->m_bIsFolder)
+	{
+	  CStdString strExtension;
+	  URIUtils::GetExtension(pItem->GetPath(), strExtension);
+	  if (strExtension == ".vis")
+	  {
+		CStdString strLabel = pItem->GetLabel();
+		vecVis.push_back(strLabel.Mid(0, strLabel.size() - 4));
+	  }
+	}
   }
 
   CStdString strDefaultVis = pSettingString->GetData();
   if (!strDefaultVis.Equals("None"))
-    strDefaultVis.Delete(strDefaultVis.size() - 4, 4);
+	strDefaultVis.Delete(strDefaultVis.size() - 4, 4);
 
   sort(vecVis.begin(), vecVis.end(), sortstringbyname());
 
@@ -2615,26 +2661,26 @@
   int iVis = 0;
   int iCurrentVis = 0;
   {
-    CGUIMessage msg(GUI_MSG_LABEL_ADD, iWinID, iControlID, iVis++);
-    msg.SetLabel(231);
-    g_windowManager.SendMessage(msg);
+	CGUIMessage msg(GUI_MSG_LABEL_ADD, iWinID, iControlID, iVis++);
+	msg.SetLabel(231);
+	g_windowManager.SendMessage(msg);
   }
   for (int i = 0; i < (int) vecVis.size(); ++i)
   {
-    CStdString strVis = vecVis[i];
+	CStdString strVis = vecVis[i];
 
-    if (strcmpi(strVis.c_str(), strDefaultVis.c_str()) == 0)
-      iCurrentVis = iVis;
+	if (strcmpi(strVis.c_str(), strDefaultVis.c_str()) == 0)
+	  iCurrentVis = iVis;
 
-    {
-      CGUIMessage msg(GUI_MSG_LABEL_ADD, iWinID, iControlID, iVis++);
-      msg.SetLabel(strVis);
-      g_windowManager.SendMessage(msg);
-    }
+	{
+	  CGUIMessage msg(GUI_MSG_LABEL_ADD, iWinID, iControlID, iVis++);
+	  msg.SetLabel(strVis);
+	  g_windowManager.SendMessage(msg);
+	}
   }
   {
-    CGUIMessage msg(GUI_MSG_ITEM_SELECT, iWinID, iControlID, iCurrentVis);
-    g_windowManager.SendMessage(msg);
+	CGUIMessage msg(GUI_MSG_ITEM_SELECT, iWinID, iControlID, iCurrentVis);
+	g_windowManager.SendMessage(msg);
   }
 }
 
@@ -2656,16 +2702,16 @@
   if ( strValue != "VoiceMasks") return ;
   if (pRootElement)
   {
-    const TiXmlNode *pChild = pRootElement->FirstChild("Name");
-    while (pChild)
-    {
-      if (pChild->FirstChild())
-      {
-        CStdString strName = pChild->FirstChild()->Value();
-        vecMask.push_back(strName);
-      }
-      pChild = pChild->NextSibling("Name");
-    }
+	const TiXmlNode *pChild = pRootElement->FirstChild("Name");
+	while (pChild)
+	{
+	  if (pChild->FirstChild())
+	  {
+		CStdString strName = pChild->FirstChild()->Value();
+		vecMask.push_back(strName);
+	  }
+	  pChild = pChild->NextSibling("Name");
+	}
   }
   xmlDoc.Clear();
 
@@ -2679,12 +2725,12 @@
   vecMask.insert(vecMask.begin(), strNone);
   for (int i = 0; i < (int) vecMask.size(); ++i)
   {
-    CStdString strMask = vecMask[i];
+	CStdString strMask = vecMask[i];
 
-    if (strcmpi(strMask.c_str(), strDefaultMask.c_str()) == 0)
-      iCurrentMask = iMask;
+	if (strcmpi(strMask.c_str(), strDefaultMask.c_str()) == 0)
+	  iCurrentMask = iMask;
 
-    pControl->AddLabel(strMask, iMask++);
+	pControl->AddLabel(strMask, iMask++);
   }
 
   pControl->SetValue(iCurrentMask);
@@ -2698,11 +2744,11 @@
 #ifndef HAS_XBOX_AUDIO
 #define XVOICE_MASK_PARAM_DISABLED (-1.0f)
 #endif
-    g_settings.m_karaokeVoiceMask[dwPort].energy = XVOICE_MASK_PARAM_DISABLED;
-    g_settings.m_karaokeVoiceMask[dwPort].pitch = XVOICE_MASK_PARAM_DISABLED;
-    g_settings.m_karaokeVoiceMask[dwPort].whisper = XVOICE_MASK_PARAM_DISABLED;
-    g_settings.m_karaokeVoiceMask[dwPort].robotic = XVOICE_MASK_PARAM_DISABLED;
-    return;
+	g_settings.m_karaokeVoiceMask[dwPort].energy = XVOICE_MASK_PARAM_DISABLED;
+	g_settings.m_karaokeVoiceMask[dwPort].pitch = XVOICE_MASK_PARAM_DISABLED;
+	g_settings.m_karaokeVoiceMask[dwPort].whisper = XVOICE_MASK_PARAM_DISABLED;
+	g_settings.m_karaokeVoiceMask[dwPort].robotic = XVOICE_MASK_PARAM_DISABLED;
+	return;
   }
 
   //find mask values in xml...
@@ -2714,56 +2760,56 @@
   if ( strValue != "VoiceMasks") return ;
   if (pRootElement)
   {
-    const TiXmlNode *pChild = pRootElement->FirstChild("Name");
-    while (pChild)
-    {
-      CStdString strMask = pChild->FirstChild()->Value();
-      if (strMask.CompareNoCase(strCurMask) == 0)
-      {
-        for (int i = 0; i < 4;i++)
-        {
-          pChild = pChild->NextSibling();
-          if (pChild)
-          {
-            CStdString strValue = pChild->Value();
-            if (strValue.CompareNoCase("fSpecEnergyWeight") == 0)
-            {
-              if (pChild->FirstChild())
-              {
-                CStdString strName = pChild->FirstChild()->Value();
-                g_settings.m_karaokeVoiceMask[dwPort].energy = (float) atof(strName.c_str());
-              }
-            }
-            else if (strValue.CompareNoCase("fPitchScale") == 0)
-            {
-              if (pChild->FirstChild())
-              {
-                CStdString strName = pChild->FirstChild()->Value();
-                g_settings.m_karaokeVoiceMask[dwPort].pitch = (float) atof(strName.c_str());
-              }
-            }
-            else if (strValue.CompareNoCase("fWhisperValue") == 0)
-            {
-              if (pChild->FirstChild())
-              {
-                CStdString strName = pChild->FirstChild()->Value();
-                g_settings.m_karaokeVoiceMask[dwPort].whisper = (float) atof(strName.c_str());
-              }
-            }
-            else if (strValue.CompareNoCase("fRoboticValue") == 0)
-            {
-              if (pChild->FirstChild())
-              {
-                CStdString strName = pChild->FirstChild()->Value();
-                g_settings.m_karaokeVoiceMask[dwPort].robotic = (float) atof(strName.c_str());
-              }
-            }
-          }
-        }
-        break;
-      }
-      pChild = pChild->NextSibling("Name");
-    }
+	const TiXmlNode *pChild = pRootElement->FirstChild("Name");
+	while (pChild)
+	{
+	  CStdString strMask = pChild->FirstChild()->Value();
+	  if (strMask.CompareNoCase(strCurMask) == 0)
+	  {
+		for (int i = 0; i < 4;i++)
+		{
+		  pChild = pChild->NextSibling();
+		  if (pChild)
+		  {
+			CStdString strValue = pChild->Value();
+			if (strValue.CompareNoCase("fSpecEnergyWeight") == 0)
+			{
+			  if (pChild->FirstChild())
+			  {
+				CStdString strName = pChild->FirstChild()->Value();
+				g_settings.m_karaokeVoiceMask[dwPort].energy = (float) atof(strName.c_str());
+			  }
+			}
+			else if (strValue.CompareNoCase("fPitchScale") == 0)
+			{
+			  if (pChild->FirstChild())
+			  {
+				CStdString strName = pChild->FirstChild()->Value();
+				g_settings.m_karaokeVoiceMask[dwPort].pitch = (float) atof(strName.c_str());
+			  }
+			}
+			else if (strValue.CompareNoCase("fWhisperValue") == 0)
+			{
+			  if (pChild->FirstChild())
+			  {
+				CStdString strName = pChild->FirstChild()->Value();
+				g_settings.m_karaokeVoiceMask[dwPort].whisper = (float) atof(strName.c_str());
+			  }
+			}
+			else if (strValue.CompareNoCase("fRoboticValue") == 0)
+			{
+			  if (pChild->FirstChild())
+			  {
+				CStdString strName = pChild->FirstChild()->Value();
+				g_settings.m_karaokeVoiceMask[dwPort].robotic = (float) atof(strName.c_str());
+			  }
+			}
+		  }
+		}
+		break;
+	  }
+	  pChild = pChild->NextSibling("Name");
+	}
   }
   xmlDoc.Clear();
 }
@@ -2782,26 +2828,26 @@
 
   for (vector<RESOLUTION>::iterator it = res.begin(); it != res.end();it++)
   {
-    RESOLUTION res = *it;
-    if (res == AUTORES)
-    {
-      if (playbackSetting)
-      {
-        //  TODO: localize 2.0
-        if (g_videoConfig.Has1080i() || g_videoConfig.Has720p())
-          pControl->AddLabel(g_localizeStrings.Get(20049) , res); // Best Available
-        else if (g_videoConfig.HasWidescreen())
-          pControl->AddLabel(g_localizeStrings.Get(20050) , res); // Autoswitch between 16x9 and 4x3
-        else
-          continue;   // don't have a choice of resolution (other than 480p vs NTSC, which isn't a choice)
-      }
-      else  // "Auto"
-        pControl->AddLabel(g_localizeStrings.Get(14061), res);
-    }
-    else
-    {
-      pControl->AddLabel(g_settings.m_ResInfo[res].strMode, res);
-    }
+	RESOLUTION res = *it;
+	if (res == AUTORES)
+	{
+	  if (playbackSetting)
+	  {
+		//  TODO: localize 2.0
+		if (g_videoConfig.Has1080i() || g_videoConfig.Has720p())
+		  pControl->AddLabel(g_localizeStrings.Get(20049) , res); // Best Available
+		else if (g_videoConfig.HasWidescreen())
+		  pControl->AddLabel(g_localizeStrings.Get(20050) , res); // Autoswitch between 16x9 and 4x3
+		else
+		  continue;   // don't have a choice of resolution (other than 480p vs NTSC, which isn't a choice)
+	  }
+	  else  // "Auto"
+		pControl->AddLabel(g_localizeStrings.Get(14061), res);
+	}
+	else
+	{
+	  pControl->AddLabel(g_settings.m_ResInfo[res].strMode, res);
+	}
   }
   pControl->SetValue(pSettingInt->GetData());
 }
@@ -2814,7 +2860,7 @@
   m_strNewLanguage.Empty();
   //find languages...
   CFileItemList items;
-  CDirectory::GetDirectory("special://xbmc/language/", items);
+  CDirectory::GetDirectory("special://xbmc/system/language/", items);
 
   int iCurrentLang = 0;
   int iLanguage = 0;
@@ -2821,23 +2867,23 @@
   vector<CStdString> vecLanguage;
   for (int i = 0; i < items.Size(); ++i)
   {
-    CFileItemPtr pItem = items[i];
-    if (pItem->m_bIsFolder)
-    {
-      if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
-      if (strcmpi(pItem->GetLabel().c_str(), "fonts") == 0) continue;
-      if (strcmpi(pItem->GetLabel().c_str(), "media") == 0) continue;
-      vecLanguage.push_back(pItem->GetLabel());
-    }
+	CFileItemPtr pItem = items[i];
+	if (pItem->m_bIsFolder)
+	{
+	  if (strcmpi(pItem->GetLabel().c_str(), ".svn") == 0) continue;
+	  if (strcmpi(pItem->GetLabel().c_str(), "fonts") == 0) continue;
+	  if (strcmpi(pItem->GetLabel().c_str(), "media") == 0) continue;
+	  vecLanguage.push_back(pItem->GetLabel());
+	}
   }
 
   sort(vecLanguage.begin(), vecLanguage.end(), sortstringbyname());
   for (unsigned int i = 0; i < vecLanguage.size(); ++i)
   {
-    CStdString strLanguage = vecLanguage[i];
-    if (strcmpi(strLanguage.c_str(), pSettingString->GetData().c_str()) == 0)
-      iCurrentLang = iLanguage;
-    pControl->AddLabel(strLanguage, iLanguage++);
+	CStdString strLanguage = vecLanguage[i];
+	if (strcmpi(strLanguage.c_str(), pSettingString->GetData().c_str()) == 0)
+	  iCurrentLang = iLanguage;
+	pControl->AddLabel(strLanguage, iLanguage++);
   }
 
   pControl->SetValue(iCurrentLang);
@@ -2857,9 +2903,9 @@
 
   //find screensavers ....
   CFileItemList items;
-  CDirectory::GetDirectory( "special://xbmc/screensavers/", items);
+  CDirectory::GetDirectory( "special://xbmc/system/screensavers/", items);
   if (!CSpecialProtocol::XBMCIsHome())
-    CDirectory::GetDirectory("special://home/screensavers/", items);
+   CDirectory::GetDirectory("special://home/system/screensavers/", items);
 
   int iCurrentScr = -1;
   vector<CStdString> vecScr;
@@ -2866,17 +2912,17 @@
   int i;
   for (i = 0; i < items.Size(); ++i)
   {
-    CFileItemPtr pItem = items[i];
-    if (!pItem->m_bIsFolder)
-    {
-      CStdString strExtension;
-      URIUtils::GetExtension(pItem->GetPath(), strExtension);
-      if (strExtension == ".xbs")
-      {
-        CStdString strLabel = pItem->GetLabel();
-        vecScr.push_back(strLabel.Mid(0, strLabel.size() - 4));
-      }
-    }
+	CFileItemPtr pItem = items[i];
+	if (!pItem->m_bIsFolder)
+	{
+	  CStdString strExtension;
+	  URIUtils::GetExtension(pItem->GetPath(), strExtension);
+	  if (strExtension == ".xbs")
+	  {
+		CStdString strLabel = pItem->GetLabel();
+		vecScr.push_back(strLabel.Mid(0, strLabel.size() - 4));
+	  }
+	}
   }
 
   CStdString strDefaultScr = pSettingString->GetData();
@@ -2883,17 +2929,17 @@
   CStdString strExtension;
   URIUtils::GetExtension(strDefaultScr, strExtension);
   if (strExtension == ".xbs")
-    strDefaultScr.Delete(strDefaultScr.size() - 4, 4);
+	strDefaultScr.Delete(strDefaultScr.size() - 4, 4);
 
   sort(vecScr.begin(), vecScr.end(), sortstringbyname());
   for (i = 0; i < (int) vecScr.size(); ++i)
   {
-    CStdString strScr = vecScr[i];
+	CStdString strScr = vecScr[i];
 
-    if (strcmpi(strScr.c_str(), strDefaultScr.c_str()) == 0)
-      iCurrentScr = i + PREDEFINED_SCREENSAVERS;
+	if (strcmpi(strScr.c_str(), strDefaultScr.c_str()) == 0)
+	  iCurrentScr = i + PREDEFINED_SCREENSAVERS;
 
-    pControl->AddLabel(strScr, i + PREDEFINED_SCREENSAVERS);
+	pControl->AddLabel(strScr, i + PREDEFINED_SCREENSAVERS);
   }
 
   // if we can't find the screensaver previously configured
@@ -2900,19 +2946,19 @@
   // then fallback to turning the screensaver off.
   if (iCurrentScr < 0)
   {
-    if (strDefaultScr == "Dim")
-      iCurrentScr = 1;
-    else if (strDefaultScr == "Black")
-      iCurrentScr = 2;
-    else if (strDefaultScr == "SlideShow") // PictureSlideShow
-      iCurrentScr = 3;
-    else if (strDefaultScr == "Fanart Slideshow") // Fanart slideshow
-      iCurrentScr = 4;
-    else
-    {
-      iCurrentScr = 0;
-      pSettingString->SetData("None");
-    }
+	if (strDefaultScr == "Dim")
+	  iCurrentScr = 1;
+	else if (strDefaultScr == "Black")
+	  iCurrentScr = 2;
+	else if (strDefaultScr == "SlideShow") // PictureSlideShow
+	  iCurrentScr = 3;
+	else if (strDefaultScr == "Fanart Slideshow") // Fanart slideshow
+	  iCurrentScr = 4;
+	else
+	{
+	  iCurrentScr = 0;
+	  pSettingString->SetData("None");
+	}
   }
   pControl->SetValue(iCurrentScr);
 }
@@ -2930,21 +2976,21 @@
   // Get FTP XBOX Users and list them !
   if (CUtil::GetFTPServerUserName(0, strFtpUser1, iUserMax))
   {
-    for (int i = 0; i < iUserMax; i++)
-    {
-      if (CUtil::GetFTPServerUserName(i, strFtpUser1, iUserMax))
-        pControl->AddLabel(strFtpUser1.c_str(), i);
-      if (strFtpUser1.ToLower() == "xbox") iDefaultFtpUser = i;
-    }
-    pControl->SetValue(iDefaultFtpUser);
-    CUtil::GetFTPServerUserName(iDefaultFtpUser, strFtpUser1, iUserMax);
-    g_guiSettings.SetString("services.ftpserveruser", strFtpUser1.c_str());
-    pControl->SetInvalid();
+	for (int i = 0; i < iUserMax; i++)
+	{
+	  if (CUtil::GetFTPServerUserName(i, strFtpUser1, iUserMax))
+		pControl->AddLabel(strFtpUser1.c_str(), i);
+	  if (strFtpUser1.ToLower() == "xbox") iDefaultFtpUser = i;
+	}
+	pControl->SetValue(iDefaultFtpUser);
+	CUtil::GetFTPServerUserName(iDefaultFtpUser, strFtpUser1, iUserMax);
+	g_guiSettings.SetString("services.ftpserveruser", strFtpUser1.c_str());
+	pControl->SetInvalid();
   }
   else { //Set "None" if there is no FTP User found!
-    pControl->AddLabel(g_localizeStrings.Get(231).c_str(), 0);
-    pControl->SetValue(0);
-    pControl->SetInvalid();
+	pControl->AddLabel(g_localizeStrings.Get(231).c_str(), 0);
+	pControl->SetValue(0);
+	pControl->SetInvalid();
   }
 #endif
 }
@@ -2958,18 +3004,18 @@
   strFtpUserPassword  = g_guiSettings.GetString("services.ftpserverpassword");
   if(strFtpUserPassword.size()!=0)
   {
-    if (CUtil::SetFTPServerUserPassword(strFtpUserName, strFtpUserPassword))
-    {
-      // todo! ERROR check! if something goes wrong on SetPW!
-      // PopUp OK and Display: FTP Server Password was set succesfull!
-      CGUIDialogOK::ShowAndGetInput(728, 0, 1247, 0);
-    }
-    return true;
+	if (CUtil::SetFTPServerUserPassword(strFtpUserName, strFtpUserPassword))
+	{
+	  // todo! ERROR check! if something goes wrong on SetPW!
+	  // PopUp OK and Display: FTP Server Password was set succesfull!
+	  CGUIDialogOK::ShowAndGetInput(728, 0, 1247, 0);
+	}
+	return true;
   }
   else
   {
-    // PopUp OK and Display: FTP Server Password is empty! Try Again!
-    CGUIDialogOK::ShowAndGetInput(728, 0, 12358, 0);
+	// PopUp OK and Display: FTP Server Password is empty! Try Again!
+	CGUIDialogOK::ShowAndGetInput(728, 0, 12358, 0);
   }
 #endif
   return true;
@@ -2991,12 +3037,12 @@
 
   for (int i = 0; i < (int) regions.size(); ++i)
   {
-    const CStdString& strRegion = regions[i];
+	const CStdString& strRegion = regions[i];
 
-    if (strRegion == strCurrentRegion)
-      iCurrentRegion = i;
+	if (strRegion == strCurrentRegion)
+	  iCurrentRegion = i;
 
-    pControl->AddLabel(strRegion, i);
+	pControl->AddLabel(strRegion, i);
   }
 
   pControl->SetValue(iCurrentRegion);
@@ -3006,8 +3052,8 @@
 {
   for (unsigned int i = 0; i < m_vecSettings.size(); i++)
   {
-    if (m_vecSettings[i]->GetSetting()->GetSetting() == strSetting)
-      return m_vecSettings[i];
+	if (m_vecSettings[i]->GetSetting()->GetSetting() == strSetting)
+	  return m_vecSettings[i];
   }
   return NULL;
 }
@@ -3025,7 +3071,7 @@
   // Clear and add. the Default Label
   pControl->Clear();
   pControl->SetShowRange(true);
-  pControl->AddLabel(g_localizeStrings.Get(15109), 0); // "SKINDEFAULT"! The standart Textures.xpr will be used!
+  pControl->AddLabel(g_localizeStrings.Get(15109), 0); // "SIMPLE"! The standart Textures.xpr will be used!
 
   // find all *.xpr in this path
   CStdString strDefaultTheme = pSettingString->GetData();
@@ -3042,11 +3088,11 @@
   int iCurrentTheme = 0;
   for (int i = 0; i < (int) vecTheme.size(); ++i)
   {
-    CStdString strTheme = vecTheme[i];
-    // Is the Current Theme our Used Theme! If yes set the ID!
-    if (strTheme.CompareNoCase(strSettingString) == 0 )
-      iCurrentTheme = i + 1; // 1: #of Predefined Theme [Label]
-    pControl->AddLabel(strTheme, i + 1);
+	CStdString strTheme = vecTheme[i];
+	// Is the Current Theme our Used Theme! If yes set the ID!
+	if (strTheme.CompareNoCase(strSettingString) == 0 )
+	  iCurrentTheme = i + 1; // 1: #of Predefined Theme [Label]
+	pControl->AddLabel(strTheme, i + 1);
   }
   // Set the Choosen Theme
   pControl->SetValue(iCurrentTheme);
@@ -3064,7 +3110,7 @@
   // Clear and add. the Default Label
   pControl->Clear();
   pControl->SetShowRange(true);
-  pControl->AddLabel(g_localizeStrings.Get(15109), 0); // "SKINDEFAULT"! The standard defaults.xml will be used!
+  pControl->AddLabel(g_localizeStrings.Get(15109), 0); // "SIMPLE"! The standard defaults.xml will be used!
 
   // Search for colors in the Current skin!
   vector<CStdString> vecColors;
@@ -3077,27 +3123,27 @@
   // Search for Themes in the Current skin!
   for (int i = 0; i < items.Size(); ++i)
   {
-    CFileItemPtr pItem = items[i];
-    if (!pItem->m_bIsFolder && pItem->GetLabel().CompareNoCase("defaults.xml") != 0)
-    { // not the default one
-      CStdString strLabel = pItem->GetLabel();
-      vecColors.push_back(strLabel.Mid(0, strLabel.size() - 4));
-    }
+	CFileItemPtr pItem = items[i];
+	if (!pItem->m_bIsFolder && pItem->GetLabel().CompareNoCase("defaults.xml") != 0)
+	{ // not the default one
+	  CStdString strLabel = pItem->GetLabel();
+	  vecColors.push_back(strLabel.Mid(0, strLabel.size() - 4));
+	}
   }
   sort(vecColors.begin(), vecColors.end(), sortstringbyname());
 
   // Remove the .xml extension from the Themes
   if (URIUtils::GetExtension(strSettingString) == ".xml")
-    URIUtils::RemoveExtension(strSettingString);
+	URIUtils::RemoveExtension(strSettingString);
 
   int iCurrentColor = 0;
   for (int i = 0; i < (int) vecColors.size(); ++i)
   {
-    CStdString strColor = vecColors[i];
-    // Is the Current Theme our Used Theme! If yes set the ID!
-    if (strColor.CompareNoCase(strSettingString) == 0 )
-      iCurrentColor = i + 1; // 1: #of Predefined Theme [Label]
-    pControl->AddLabel(strColor, i + 1);
+	CStdString strColor = vecColors[i];
+	// Is the Current Theme our Used Theme! If yes set the ID!
+	if (strColor.CompareNoCase(strSettingString) == 0 )
+	  iCurrentColor = i + 1; // 1: #of Predefined Theme [Label]
+	pControl->AddLabel(strColor, i + 1);
   }
   // Set the Choosen Theme
   pControl->SetValue(iCurrentColor);
@@ -3125,13 +3171,13 @@
   bool currentSettingFound(false);
   for (vector<CSkinInfo::CStartupWindow>::const_iterator it = startupWindows.begin(); it != startupWindows.end(); it++)
   {
-    CStdString windowName((*it).m_name);
-    if (StringUtils::IsNaturalNumber(windowName))
-      windowName = g_localizeStrings.Get(atoi(windowName.c_str()));
-    int windowID((*it).m_id);
-    pControl->AddLabel(windowName, windowID);
-    if (pSettingInt->GetData() == windowID)
-      currentSettingFound = true;
+	CStdString windowName((*it).m_name);
+	if (StringUtils::IsNaturalNumber(windowName))
+	  windowName = g_localizeStrings.Get(atoi(windowName.c_str()));
+	int windowID((*it).m_id);
+	pControl->AddLabel(windowName, windowID);
+	if (pSettingInt->GetData() == windowID)
+	  currentSettingFound = true;
   }
 
   // ok, now check whether our current option is one of these
@@ -3138,7 +3184,7 @@
   // and set it's value
   if (!currentSettingFound)
   { // nope - set it to the "default" option - the first one
-    pSettingInt->SetData(startupWindows[0].m_id);
+	pSettingInt->SetData(startupWindows[0].m_id);
   }
   pControl->SetValue(pSettingInt->GetData());
 }
@@ -3150,6 +3196,7 @@
   m_strNetworkSubnet = g_guiSettings.GetString("network.subnet");
   m_strNetworkGateway = g_guiSettings.GetString("network.gateway");
   m_strNetworkDNS = g_guiSettings.GetString("network.dns");
+  m_strNetworkDNS2 = g_guiSettings.GetString("network.dns2");
   m_strOldTrackFormat = g_guiSettings.GetString("musicfiles.trackformat");
   m_strOldTrackFormatRight = g_guiSettings.GetString("musicfiles.trackformatright");
   m_NewResolution = INVALID;
@@ -3167,24 +3214,24 @@
   CGUIWindow *window = g_windowManager.GetWindow(windowID);
   if (window)
   {
-    window->Initialize();
-    for (int i = 50; i < 60; i++)
-    {
-      CGUIBaseContainer *control = (CGUIBaseContainer *)window->GetControl(i);
-      if (control)
-      {
-        int type = (control->GetType() << 16) | i;
-        pControl->AddLabel(control->GetLabel(), type);
-        if (type == pSettingInt->GetData())
-          found = true;
-        else if ((type >> 16) == (pSettingInt->GetData() >> 16))
-          foundType = type;
-      }
-    }
-    window->ClearAll();
+	window->Initialize();
+	for (int i = 50; i < 60; i++)
+	{
+	  CGUIBaseContainer *control = (CGUIBaseContainer *)window->GetControl(i);
+	  if (control)
+	  {
+		int type = (control->GetType() << 16) | i;
+		pControl->AddLabel(control->GetLabel(), type);
+		if (type == pSettingInt->GetData())
+		  found = true;
+		else if ((type >> 16) == (pSettingInt->GetData() >> 16))
+		  foundType = type;
+	  }
+	}
+	window->ClearAll();
   }
   if (!found)
-    pSettingInt->SetData(foundType ? foundType : (DEFAULT_VIEW_AUTO));
+	pSettingInt->SetData(foundType ? foundType : (DEFAULT_VIEW_AUTO));
   pControl->SetValue(pSettingInt->GetData());
 }
 
@@ -3196,17 +3243,17 @@
   CGUIViewState *state = CGUIViewState::GetViewState(windowID, items);
   if (state)
   {
-    bool found(false);
-    vector< pair<int,int> > sortMethods;
-    state->GetSortMethods(sortMethods);
-    for (unsigned int i = 0; i < sortMethods.size(); i++)
-    {
-      pControl->AddLabel(g_localizeStrings.Get(sortMethods[i].second), sortMethods[i].first);
-      if (sortMethods[i].first == pSettingInt->GetData())
-        found = true;
-    }
-    if (!found && sortMethods.size())
-      pSettingInt->SetData(sortMethods[0].first);
+	bool found(false);
+	vector< pair<int,int> > sortMethods;
+	state->GetSortMethods(sortMethods);
+	for (unsigned int i = 0; i < sortMethods.size(); i++)
+	{
+	  pControl->AddLabel(g_localizeStrings.Get(sortMethods[i].second), sortMethods[i].first);
+	  if (sortMethods[i].first == pSettingInt->GetData())
+		found = true;
+	}
+	if (!found && sortMethods.size())
+	  pSettingInt->SetData(sortMethods[0].first);
   }
   pControl->SetValue(pSettingInt->GetData());
   delete state;
@@ -3216,53 +3263,53 @@
 {
   CFileItemList items;
   if (strContent.Equals("music"))
-    CDirectory::GetDirectory("special://xbmc/system/scrapers/music",items,".xml",false);
+	CDirectory::GetDirectory("special://xbmc/system/scrapers/music",items,".xml",false);
   else
-    CDirectory::GetDirectory("special://xbmc/system/scrapers/video",items,".xml",false);
+	CDirectory::GetDirectory("special://xbmc/system/scrapers/video",items,".xml",false);
   int j=0;
   int k=0;
   pControl->Clear();
   for ( int i=0;i<items.Size();++i)
   {
-    if (items[i]->m_bIsFolder)
-      continue;
+	if (items[i]->m_bIsFolder)
+	  continue;
 
-    CScraperParser parser;
-    if (parser.Load(items[i]->GetPath()))
-    {
-      if (parser.GetContent() != strContent && !strContent.Equals("music"))
-        continue;
+	CScraperParser parser;
+	if (parser.Load(items[i]->GetPath()))
+	{
+	  if (parser.GetContent() != strContent && !strContent.Equals("music"))
+		continue;
 
-      if (parser.GetName().Equals(strSelected) || URIUtils::GetFileName(items[i]->GetPath()).Equals(strSelected))
-      {
-        if (strContent.Equals("music")) // native strContent would be albums or artists but we're using the same scraper for both
-        {
-          if (g_guiSettings.GetString("musiclibrary.scraper") != strSelected)
-          {
-            g_guiSettings.SetString("musiclibrary.scraper", URIUtils::GetFileName(items[i]->GetPath()));
+	  if (parser.GetName().Equals(strSelected) || URIUtils::GetFileName(items[i]->GetPath()).Equals(strSelected))
+	  {
+		if (strContent.Equals("music")) // native strContent would be albums or artists but we're using the same scraper for both
+		{
+		  if (g_guiSettings.GetString("musiclibrary.scraper") != strSelected)
+		  {
+			g_guiSettings.SetString("musiclibrary.scraper", URIUtils::GetFileName(items[i]->GetPath()));
 
-            SScraperInfo info;
-            CMusicDatabase database;
+			SScraperInfo info;
+			CMusicDatabase database;
 
-            info.strPath = g_guiSettings.GetString("musiclibrary.scraper");
-            info.strContent = "albums";
-            info.strTitle = parser.GetName();
+			info.strPath = g_guiSettings.GetString("musiclibrary.scraper");
+			info.strContent = "albums";
+			info.strTitle = parser.GetName();
 
-            database.Open();
-            database.SetScraperForPath("musicdb://",info);
-            database.Close();
-          }
-        }
-        else if (strContent.Equals("movies"))
-          g_guiSettings.SetString("scrapers.moviedefault", URIUtils::GetFileName(items[i]->GetPath()));
-        else if (strContent.Equals("tvshows"))
-          g_guiSettings.SetString("scrapers.tvshowdefault", URIUtils::GetFileName(items[i]->GetPath()));
-        else if (strContent.Equals("musicvideos"))
-          g_guiSettings.SetString("scrapers.musicvideodefault", URIUtils::GetFileName(items[i]->GetPath()));
-        k = j;
-      }
-      pControl->AddLabel(parser.GetName(),j++);
-    }
+			database.Open();
+			database.SetScraperForPath("musicdb://",info);
+			database.Close();
+		  }
+		}
+		else if (strContent.Equals("movies"))
+		  g_guiSettings.SetString("scrapers.moviedefault", URIUtils::GetFileName(items[i]->GetPath()));
+		else if (strContent.Equals("tvshows"))
+		  g_guiSettings.SetString("scrapers.tvshowdefault", URIUtils::GetFileName(items[i]->GetPath()));
+		else if (strContent.Equals("musicvideos"))
+		  g_guiSettings.SetString("scrapers.musicvideodefault", URIUtils::GetFileName(items[i]->GetPath()));
+		k = j;
+	  }
+	  pControl->AddLabel(parser.GetName(),j++);
+	}
   }
   pControl->SetValue(k);
 }
@@ -3276,26 +3323,26 @@
   pControl->AddLabel(g_localizeStrings.Get(13611), j++);
 
   CFileItemList items;
-  if (CDirectory::GetDirectory("special://home/plugins/weather/", items, "/", false))
+  if (CDirectory::GetDirectory("special://home/system/plugins/weather/", items, "/", false))
   {
-    for (int i=0; i<items.Size(); ++i)
-    {    
-      // create the full path to the plugin
-      CStdString plugin;
-      CStdString pluginPath = items[i]->GetPath();
-      // remove slash at end so we can use the plugins folder as plugin name
-      URIUtils::RemoveSlashAtEnd(pluginPath);
-      // add default.py to our plugin path to create the full path
-      URIUtils::AddFileToFolder(pluginPath, "default.py", plugin);
-      if (XFILE::CFile::Exists(plugin))
-      {
-        // is this the users choice
-        if (URIUtils::GetFileName(pluginPath).Equals(strSelected))
-          k = j;
-        // we want to use the plugins folder as name
-        pControl->AddLabel(URIUtils::GetFileName(pluginPath), j++);
-      }
-    }
+	for (int i=0; i<items.Size(); ++i)
+	{    
+	  // create the full path to the plugin
+	  CStdString plugin;
+	  CStdString pluginPath = items[i]->GetPath();
+	  // remove slash at end so we can use the plugins folder as plugin name
+	  URIUtils::RemoveSlashAtEnd(pluginPath);
+	  // add default.py to our plugin path to create the full path
+	  URIUtils::AddFileToFolder(pluginPath, "default.py", plugin);
+	  if (XFILE::CFile::Exists(plugin))
+	  {
+		// is this the users choice
+		if (URIUtils::GetFileName(pluginPath).Equals(strSelected))
+		  k = j;
+		// we want to use the plugins folder as name
+		pControl->AddLabel(URIUtils::GetFileName(pluginPath), j++);
+	  }
+	}
   }
   pControl->SetValue(k);
 }
Index: xbmc/settings/GUIWindowSettingsCategory.h
===================================================================
--- xbmc/settings/GUIWindowSettingsCategory.h	(revision 33042)
+++ xbmc/settings/GUIWindowSettingsCategory.h	(working copy)
@@ -96,6 +96,7 @@
   CStdString m_strNetworkSubnet;
   CStdString m_strNetworkGateway;
   CStdString m_strNetworkDNS;
+  CStdString m_strNetworkDNS2;
   // look + feel settings (for delayed loading)
   CStdString m_strNewSkinFontSet;
   CStdString m_strNewSkin;
Index: xbmc/settings/GUIWindowSettingsScreenCalibration.cpp
===================================================================
--- xbmc/settings/GUIWindowSettingsScreenCalibration.cpp	(revision 33042)
+++ xbmc/settings/GUIWindowSettingsScreenCalibration.cpp	(working copy)
@@ -39,8 +39,8 @@
 #define CONTROL_LABEL_ROW2  3
 #define CONTROL_TOP_LEFT  8
 #define CONTROL_BOTTOM_RIGHT 9
-#define CONTROL_SUBTITLES  10
-#define CONTROL_PIXEL_RATIO  11
+//#define CONTROL_SUBTITLES  10
+#define CONTROL_PIXEL_RATIO  10
 #define CONTROL_VIDEO   20
 #define CONTROL_NONE   0
 
@@ -198,7 +198,7 @@
 {
   SET_CONTROL_VISIBLE(CONTROL_TOP_LEFT);
   SET_CONTROL_VISIBLE(CONTROL_BOTTOM_RIGHT);
-  SET_CONTROL_VISIBLE(CONTROL_SUBTITLES);
+  //SET_CONTROL_VISIBLE(CONTROL_SUBTITLES);
   SET_CONTROL_VISIBLE(CONTROL_PIXEL_RATIO);
   SET_CONTROL_FOCUS(iControl, 0);
 }
@@ -234,7 +234,7 @@
     pControl->SetLocation(g_settings.m_ResInfo[m_Res[m_iCurRes]].Overscan.right,
                           g_settings.m_ResInfo[m_Res[m_iCurRes]].Overscan.bottom, false);
   }
-  // Subtitles and OSD controls can only move up and down
+  /* Subtitles and OSD controls can only move up and down
   pControl = (CGUIMoverControl*)GetControl(CONTROL_SUBTITLES);
   if (pControl)
   {
@@ -243,7 +243,7 @@
     pControl->SetPosition((g_settings.m_ResInfo[m_Res[m_iCurRes]].iWidth - pControl->GetWidth()) * 0.5f,
                           g_settings.m_ResInfo[m_Res[m_iCurRes]].iSubtitles - pControl->GetHeight());
     pControl->SetLocation(0, g_settings.m_ResInfo[m_Res[m_iCurRes]].iSubtitles, false);
-  }
+  } */
   // lastly the pixel ratio control...
   CGUIResizeControl *pResize = (CGUIResizeControl*)GetControl(CONTROL_PIXEL_RATIO);
   if (pResize)
@@ -304,13 +304,13 @@
         }
         break;
 
-      case CONTROL_SUBTITLES:
+      /* case CONTROL_SUBTITLES:
         {
           g_settings.m_ResInfo[m_Res[m_iCurRes]].iSubtitles = pControl->GetYLocation();
           strStatus.Format("%s (%i)", g_localizeStrings.Get(274).c_str(), pControl->GetYLocation());
           SET_CONTROL_LABEL(CONTROL_LABEL_ROW2, 277);
         }
-        break;
+        break; */
       }
     }
   }
@@ -340,7 +340,7 @@
 {
   SET_CONTROL_HIDDEN(CONTROL_TOP_LEFT);
   SET_CONTROL_HIDDEN(CONTROL_BOTTOM_RIGHT);
-  SET_CONTROL_HIDDEN(CONTROL_SUBTITLES);
+  //SET_CONTROL_HIDDEN(CONTROL_SUBTITLES);
   SET_CONTROL_HIDDEN(CONTROL_PIXEL_RATIO);
 
   // we set that we need scaling here to render so that anything else on screen scales correctly
@@ -351,7 +351,7 @@
 
   SET_CONTROL_VISIBLE(CONTROL_TOP_LEFT);
   SET_CONTROL_VISIBLE(CONTROL_BOTTOM_RIGHT);
-  SET_CONTROL_VISIBLE(CONTROL_SUBTITLES);
+  //SET_CONTROL_VISIBLE(CONTROL_SUBTITLES);
   SET_CONTROL_VISIBLE(CONTROL_PIXEL_RATIO);
 
   // render the movers etc.
Index: xbmc/settings/Settings.cpp
===================================================================
--- xbmc/settings/Settings.cpp	(revision 33042)
+++ xbmc/settings/Settings.cpp	(working copy)
@@ -171,6 +171,17 @@
   CIoSupport::GetPartition(strMnt.c_str()[0], szDevicePath);
   strcat(szDevicePath,strMnt.c_str()+2);
   CIoSupport::RemapDriveLetter('P', szDevicePath);
+  
+  char szSkinPath[1024];
+  CStdString str2Mnt = _P(GetSkinPath());
+  if (str2Mnt.Left(2).Equals("Q:"))
+  {
+    CUtil::GetHomePath(str2Mnt);
+    str2Mnt += _P(GetSkinPath()).substr(2);
+  }
+  CIoSupport::GetPartition(str2Mnt.c_str()[0], szSkinPath);
+  strcat(szSkinPath,str2Mnt.c_str()+2);
+  CIoSupport::RemapDriveLetter('S', szSkinPath);
 #endif
   CSpecialProtocol::SetProfilePath(GetProfileUserDataFolder());
   CLog::Log(LOGNOTICE, "loading %s", GetSettingsFile().c_str());
@@ -1194,19 +1205,19 @@
     strLanguage[0] = toupper(strLanguage[0]);
 
     CStdString strLangInfoPath;
-    strLangInfoPath.Format("special://xbmc/language/%s/langinfo.xml", strLanguage.c_str());
+    strLangInfoPath.Format("special://xbmc/system/language/%s/langinfo.xml", strLanguage.c_str());
     CLog::Log(LOGINFO, "load language info file:%s", strLangInfoPath.c_str());
     g_langInfo.Load(strLangInfoPath);
 
 #ifdef _XBOX
     CStdString strKeyboardLayoutConfigurationPath;
-    strKeyboardLayoutConfigurationPath.Format("special://xbmc/language/%s/keyboardmap.xml", strLanguage.c_str());
+    strKeyboardLayoutConfigurationPath.Format("special://xbmc/system/language/%s/keyboardmap.xml", strLanguage.c_str());
     CLog::Log(LOGINFO, "load keyboard layout configuration info file: %s", strKeyboardLayoutConfigurationPath.c_str());
     g_keyboardLayoutConfiguration.Load(strKeyboardLayoutConfigurationPath);
 #endif
 
     CButtonTranslator::GetInstance().Load();
-    g_localizeStrings.Load("special://xbmc/language/", strLanguage);
+    g_localizeStrings.Load("special://xbmc/system/language/", strLanguage);
 
     g_infoManager.ResetCache();
     g_infoManager.ResetLibraryBools();
@@ -1318,7 +1329,7 @@
 
         TiXmlElement* pProfile = rootElement->FirstChildElement("profile");
         
-        CStdString defaultDir("special://home/userdata");
+        CStdString defaultDir("special://home/system/userdata");
         if (!CDirectory::Exists(defaultDir))
           defaultDir = "special://xbmc/userdata";
         while (pProfile)
@@ -2046,12 +2057,12 @@
 
 CStdString CSettings::GetScriptsFolder() const
 {
-  CStdString folder = "special://home/scripts";
+  CStdString folder = "special://home/system/scripts";
 
   if ( CDirectory::Exists(folder) )
     return folder;
 
-  folder = "special://xbmc/scripts";
+  folder = "special://xbmc/system/scripts";
   return folder;
 }
 
@@ -2060,13 +2071,25 @@
   CStdString folder;
 
   // Get the Current Skin Path
-  URIUtils::AddFileToFolder("special://home/skin/", skinName, folder);
+  URIUtils::AddFileToFolder("special://home/emustation/themes", skinName, folder);
   if ( ! CDirectory::Exists(folder) )
-    URIUtils::AddFileToFolder("special://xbmc/skin/", skinName, folder);
+    URIUtils::AddFileToFolder("special://xbmc/emustation/themes", skinName, folder);
 
   return folder;
 }
 
+CStdString CSettings::GetSkinPath() const
+{
+  CStdString folder;
+
+  // Get the Current Skin Path
+  URIUtils::AddFileToFolder("special://home/emustation/themes","", folder);
+  if ( ! CDirectory::Exists(folder) )
+    URIUtils::AddFileToFolder("special://xbmc/emustation/themes","", folder);
+
+  return folder;
+}
+
 void CSettings::LoadRSSFeeds()
 {
   CStdString rssXML;
Index: xbmc/settings/Settings.h
===================================================================
--- xbmc/settings/Settings.h	(revision 33042)
+++ xbmc/settings/Settings.h	(working copy)
@@ -21,7 +21,7 @@
 
 #define PRE_SKIN_VERSION_9_10_COMPATIBILITY 1
 
-#define DEFAULT_SKIN "Confluence Lite"
+#define DEFAULT_SKIN "simple"
 #define DEFAULT_WEATHER_PLUGIN "Weather.com (standard)"
 
 #include "settings/VideoSettings.h"
@@ -38,7 +38,7 @@
 #define CACHE_VIDEO 1
 #define CACHE_VOB   2
 
-#define VOLUME_MINIMUM -6000  // -60dB
+#define VOLUME_MINIMUM -6400  // -64dB -60db you could still hear the audio/music
 #define VOLUME_MAXIMUM 0      // 0dB
 #define VOLUME_DRC_MINIMUM 0    // 0dB
 #define VOLUME_DRC_MAXIMUM 3000 // 30dB
@@ -494,6 +494,7 @@
   CStdString GetGameSaveThumbFolder() const;
   CStdString GetProfilesThumbFolder() const;
   CStdString GetSourcesFile() const;
+  CStdString GetSkinPath() const;
   CStdString GetSkinFolder() const;
   CStdString GetSkinFolder(const CStdString& skinName) const;
   CStdString GetScriptsFolder() const;
Index: xbmc/storage/DetectDVDType.cpp
===================================================================
--- xbmc/storage/DetectDVDType.cpp	(revision 33042)
+++ xbmc/storage/DetectDVDType.cpp	(working copy)
@@ -51,6 +51,7 @@
 CDetectDVDMedia* CDetectDVDMedia::m_pInstance = NULL;
 CStdString CDetectDVDMedia::m_diskLabel = "";
 CStdString CDetectDVDMedia::m_diskPath = "";
+CStdString CDetectDVDMedia::m_diskTitleID = "";
 
 CDetectDVDMedia::CDetectDVDMedia()
 {
@@ -312,6 +313,7 @@
     // update disk label to xbe label if we have that info
     if (CFile::Exists("D:\\default.xbe"))
       CUtil::GetXBEDescription("D:\\default.xbe", m_diskLabel);
+	  m_diskTitleID.Format("%08x",CUtil::GetXbeID("D:\\default.xbe"));
 
     // and get the thumb
     CStdString strThumb;
@@ -461,6 +463,11 @@
   return m_diskLabel;
 }
 
+const CStdString &CDetectDVDMedia::GetDVDTitleID()
+{
+  return m_diskTitleID;
+}
+
 const CStdString &CDetectDVDMedia::GetDVDPath()
 {
   return m_diskPath;
Index: xbmc/storage/DetectDVDType.h
===================================================================
--- xbmc/storage/DetectDVDType.h	(revision 33042)
+++ xbmc/storage/DetectDVDType.h	(working copy)
@@ -54,6 +54,7 @@
   static CEvent m_evAutorun;
 
   static const CStdString &GetDVDLabel();
+  static const CStdString &GetDVDTitleID();
   static const CStdString &GetDVDPath();
 
   static void UpdateState();
@@ -63,7 +64,7 @@
   
 
   void DetectMediaType();
-  void SetNewDVDShareUrl( const CStdString& strNewUrl, bool bCDDA, const CStdString& strDiscLabel );
+  void SetNewDVDShareUrl( const CStdString& strNewUrl, bool bCDDA, const CStdString& strDiscLabe );
 
 private:
   static CCriticalSection m_muReadingMedia;
@@ -81,6 +82,7 @@
   DWORD m_dwLastTrayState;
 
   static CStdString m_diskLabel;
+  static CStdString m_diskTitleID;
   static CStdString m_diskPath;
   
   CLibcdio* m_cdio;
Index: xbmc/Util.cpp
===================================================================
--- xbmc/Util.cpp	(revision 33042)
+++ xbmc/Util.cpp	(working copy)
@@ -1,22 +1,22 @@
 /*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
 
 #include "system.h"
 #include "Application.h"
@@ -122,30 +122,73 @@
 
 #ifdef HAS_XBOX_HARDWARE
 // This are 70 Original Data Bytes because we have to restore 70 patched Bytes, not just 57
-static BYTE rawData[70] =
-{
-    0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00, 
-    0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01, 
-    0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B, 
-    0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D, 0x9C, 0xFB, 0x04, 0x80, 0x89, 0x08, 0x33, 
-    0xC0, 0xE9, 0x42, 0x01, 0x00, 0x00, 
+// all other retail kernels
+static BYTE Retail_originalBytes[70] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00,
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01,
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B,
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D, 0x9C, 0xFB, 0x04, 0x80, 0x89, 0x08, 0x33,
+	0xC0, 0xE9, 0x42, 0x01, 0x00, 0x00,
 };
-static BYTE OriginalData[57]=
-{
-  0x55,0x8B,0xEC,0x81,0xEC,0x04,0x01,0x00,0x00,0x8B,0x45,0x08,0x3D,0x04,0x01,0x00,
-  0x00,0x53,0x75,0x32,0x8B,0x4D,0x18,0x85,0xC9,0x6A,0x04,0x58,0x74,0x02,0x89,0x01,
-  0x39,0x45,0x14,0x73,0x0A,0xB8,0x23,0x00,0x00,0xC0,0xE9,0x59,0x01,0x00,0x00,0x8B,
-  0x4D,0x0C,0x89,0x01,0x8B,0x45,0x10,0x8B,0x0D
+static BYTE Retail_searchBytes[57] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00,
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01,
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B,
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D,
 };
-
-static BYTE PatchData[70]=
-{
-  0x55,0x8B,0xEC,0xB9,0x04,0x01,0x00,0x00,0x2B,0xE1,0x8B,0x45,0x08,0x53,0x3B,0xC1,
-  0x74,0x0C,0x49,0x3B,0xC1,0x75,0x2F,0xB8,0x00,0x03,0x80,0x00,0xEB,0x05,0xB8,0x04,
-  0x00,0x00,0x00,0x50,0x8B,0x4D,0x18,0x6A,0x04,0x58,0x85,0xC9,0x74,0x02,0x89,0x01,
-  0x8B,0x4D,0x0C,0x89,0x01,0x59,0x8B,0x45,0x10,0x89,0x08,0x33,0xC0,0x5B,0xC9,0xC2,
-  0x14,0x00,0x00,0x00,0x00,0x00
+// 5713, 5838 kernels
+static BYTE AltRetail_originalBytes[70] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x00, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00,
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01,
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x56, 0x01, 0x00, 0x00, 0x8B,
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D, 0x58, 0xC1, 0x03, 0x80, 0x89, 0x08, 0x33,
+	0xC0, 0xE9, 0x3F, 0x01, 0x00, 0x00,
 };
+static BYTE AltRetail_searchBytes[57] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x00, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00,
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01,
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x56, 0x01, 0x00, 0x00, 0x8B,
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D,
+};
+// Cerbios kernel
+static BYTE Cerbios_originalBytes[70] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00, 
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01, 
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B, 
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D, 0x54, 0x42, 0x04, 0x80, 0x89, 0x08, 0x33, 
+	0xC0, 0xE9, 0x42, 0x01, 0x00, 0x00,
+};
+static BYTE Cerbios_searchBytes[57] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00, 
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01, 
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B, 
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D,
+};
+// X2_5035 kernel
+static BYTE xTwoZeroThreeFive_originalBytes[70] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00, 
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01, 
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B, 
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D, 0x0C, 0xD5, 0x05, 0x80, 0x89, 0x08, 0x33, 
+	0xC0, 0xE9, 0x42, 0x01, 0x00, 0x00,
+};
+static BYTE xTwoZeroThreeFive_searchBytes[57] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00, 
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01, 
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B, 
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D,
+};
+// X3 kernel
+static BYTE xThree_originalBytes[70] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00, 
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01, 
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B, 
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D, 0x74, 0xA1, 0x05, 0x80, 0x89, 0x08, 0x33, 
+	0xC0, 0xE9, 0x42, 0x01, 0x00, 0x00,
+};
+static BYTE xThree_searchBytes[57] = { 0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x04, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x08, 0x3D, 0x04, 0x01, 0x00, 
+	0x00, 0x53, 0x75, 0x32, 0x8B, 0x4D, 0x18, 0x85, 0xC9, 0x6A, 0x04, 0x58, 0x74, 0x02, 0x89, 0x01, 
+	0x39, 0x45, 0x14, 0x73, 0x0A, 0xB8, 0x23, 0x00, 0x00, 0xC0, 0xE9, 0x59, 0x01, 0x00, 0x00, 0x8B, 
+	0x4D, 0x0C, 0x89, 0x01, 0x8B, 0x45, 0x10, 0x8B, 0x0D,
+};
+// Patch for all kernels
+static BYTE PatchData[70] = { 0x55, 0x8B, 0xEC, 0xB9, 0x04, 0x01, 0x00, 0x00, 0x2B, 0xE1, 0x8B, 0x45, 0x08, 0x53, 0x3B, 0xC1,
+	0x74, 0x0C, 0x49, 0x3B, 0xC1, 0x75, 0x2F, 0xB8, 0x00, 0x03, 0x80, 0x00, 0xEB, 0x05, 0xB8, 0x04,
+	0x00, 0x00, 0x00, 0x50, 0x8B, 0x4D, 0x18, 0x6A, 0x04, 0x58, 0x85, 0xC9, 0x74, 0x02, 0x89, 0x01,
+	0x8B, 0x4D, 0x0C, 0x89, 0x01, 0x59, 0x8B, 0x45, 0x10, 0x89, 0x08, 0x33, 0xC0, 0x5B, 0xC9, 0xC2,
+	0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
 
 
 // for trainers
@@ -159,17 +202,17 @@
 // magic kernel patch (asm included w/ source)
 static unsigned char trainerloaderdata[167] =
 {
-       0x60, 0xBA, 0x34, 0x12, 0x00, 0x00, 0x60, 0x6A, 0x01, 0x6A, 0x07, 0xE8, 0x67, 0x00, 0x00, 0x00,
-       0x6A, 0x0C, 0x6A, 0x08, 0xE8, 0x5E, 0x00, 0x00, 0x00, 0x61, 0x8B, 0x35, 0x18, 0x01, 0x01, 0x00,
-       0x83, 0xC6, 0x08, 0x8B, 0x06, 0x8B, 0x72, 0x12, 0x03, 0xF2, 0xB9, 0x03, 0x00, 0x00, 0x00, 0x3B,
-       0x06, 0x74, 0x0C, 0x83, 0xC6, 0x04, 0xE2, 0xF7, 0x68, 0xF0, 0x00, 0x00, 0x00, 0xEB, 0x29, 0x8B,
-       0xEA, 0x83, 0x7A, 0x1A, 0x00, 0x74, 0x05, 0x8B, 0x4A, 0x1A, 0xEB, 0x03, 0x8B, 0x4A, 0x16, 0x03,
-       0xCA, 0x0F, 0x20, 0xC0, 0x50, 0x25, 0xFF, 0xFF, 0xFE, 0xFF, 0x0F, 0x22, 0xC0, 0xFF, 0xD1, 0x58,
-       0x0F, 0x22, 0xC0, 0x68, 0xFF, 0x00, 0x00, 0x00, 0x6A, 0x08, 0xE8, 0x08, 0x00, 0x00, 0x00, 0x61,
-       0xFF, 0x15, 0x28, 0x01, 0x01, 0x00, 0xC3, 0x55, 0x8B, 0xEC, 0x66, 0xBA, 0x04, 0xC0, 0xB0, 0x20,
-       0xEE, 0x66, 0xBA, 0x08, 0xC0, 0x8A, 0x45, 0x08, 0xEE, 0x66, 0xBA, 0x06, 0xC0, 0x8A, 0x45, 0x0C,
-       0xEE, 0xEE, 0x66, 0xBA, 0x02, 0xC0, 0xB0, 0x1A, 0xEE, 0x50, 0xB8, 0x40, 0x42, 0x0F, 0x00, 0x48,
-       0x75, 0xFD, 0x58, 0xC9, 0xC2, 0x08, 0x00,
+	0x60, 0xBA, 0x34, 0x12, 0x00, 0x00, 0x60, 0x6A, 0x01, 0x6A, 0x07, 0xE8, 0x67, 0x00, 0x00, 0x00,
+	0x6A, 0x0C, 0x6A, 0x08, 0xE8, 0x5E, 0x00, 0x00, 0x00, 0x61, 0x8B, 0x35, 0x18, 0x01, 0x01, 0x00,
+	0x83, 0xC6, 0x08, 0x8B, 0x06, 0x8B, 0x72, 0x12, 0x03, 0xF2, 0xB9, 0x03, 0x00, 0x00, 0x00, 0x3B,
+	0x06, 0x74, 0x0C, 0x83, 0xC6, 0x04, 0xE2, 0xF7, 0x68, 0xF0, 0x00, 0x00, 0x00, 0xEB, 0x29, 0x8B,
+	0xEA, 0x83, 0x7A, 0x1A, 0x00, 0x74, 0x05, 0x8B, 0x4A, 0x1A, 0xEB, 0x03, 0x8B, 0x4A, 0x16, 0x03,
+	0xCA, 0x0F, 0x20, 0xC0, 0x50, 0x25, 0xFF, 0xFF, 0xFE, 0xFF, 0x0F, 0x22, 0xC0, 0xFF, 0xD1, 0x58,
+	0x0F, 0x22, 0xC0, 0x68, 0xFF, 0x00, 0x00, 0x00, 0x6A, 0x08, 0xE8, 0x08, 0x00, 0x00, 0x00, 0x61,
+	0xFF, 0x15, 0x28, 0x01, 0x01, 0x00, 0xC3, 0x55, 0x8B, 0xEC, 0x66, 0xBA, 0x04, 0xC0, 0xB0, 0x20,
+	0xEE, 0x66, 0xBA, 0x08, 0xC0, 0x8A, 0x45, 0x08, 0xEE, 0x66, 0xBA, 0x06, 0xC0, 0x8A, 0x45, 0x0C,
+	0xEE, 0xEE, 0x66, 0xBA, 0x02, 0xC0, 0xB0, 0x1A, 0xEE, 0x50, 0xB8, 0x40, 0x42, 0x0F, 0x00, 0x48,
+	0x75, 0xFD, 0x58, 0xC9, 0xC2, 0x08, 0x00,
 };
 
 #define SIZEOFLOADERDATA 167// loaderdata is our kernel hack to handle if trainer (com file) is executed for title about to run
@@ -182,7 +225,7 @@
 	0x08, 0xEE, 0x66, 0xBA, 0x06, 0xC0, 0x8A, 0x45, 0x0C, 0xEE, 0xEE, 0x66, 0xBA, 0x02, 0xC0, 0xB0, 
 	0x1A, 0xEE, 0x50, 0xB8, 0x40, 0x42, 0x0F, 0x00, 0x48, 0x75, 0xFD, 0x58, 0xC9, 0xC2, 0x08, 0x00, 
 };
- 
+
 // PatchIt dynamic patching
 static unsigned char patch_it_toy[33] =
 {
@@ -301,587 +344,652 @@
 
 CStdString CUtil::GetTitleFromPath(const CStdString& strFileNameAndPath, bool bIsFolder /* = false */)
 {
-  // use above to get the filename
-  CStdString path(strFileNameAndPath);
-  URIUtils::RemoveSlashAtEnd(path);
-  CStdString strFilename = URIUtils::GetFileName(path);
+	// use above to get the filename
+	CStdString path(strFileNameAndPath);
+	URIUtils::RemoveSlashAtEnd(path);
+	CStdString strFilename = URIUtils::GetFileName(path);
 
-  CURL url(strFileNameAndPath);
-  CStdString strHostname = url.GetHostName();
+	CURL url(strFileNameAndPath);
+	CStdString strHostname = url.GetHostName();
 
 #ifdef HAS_UPNP
-  // UPNP
-  if (url.GetProtocol() == "upnp")
-    strFilename = CUPnPDirectory::GetFriendlyName(strFileNameAndPath.c_str());
+	// UPNP
+	if (url.GetProtocol() == "upnp")
+	strFilename = CUPnPDirectory::GetFriendlyName(strFileNameAndPath.c_str());
 #endif
 
-  if (url.GetProtocol() == "rss")
-  {
-    url.SetProtocol("http");
-    path = url.Get();
-    CRssFeed feed;
-    feed.Init(path);
-    feed.ReadFeed();
-    strFilename = feed.GetFeedTitle();
-  }
+	if (url.GetProtocol() == "rss")
+	{
+		url.SetProtocol("http");
+		path = url.Get();
+		CRssFeed feed;
+		feed.Init(path);
+		feed.ReadFeed();
+		strFilename = feed.GetFeedTitle();
+	}
 
-  // LastFM
-  if (url.GetProtocol() == "lastfm")
-  {
-    if (strFilename.IsEmpty())
-      strFilename = g_localizeStrings.Get(15200);
-    else
-      strFilename = g_localizeStrings.Get(15200) + " - " + strFilename;
-  }
+	// LastFM
+	if (url.GetProtocol() == "lastfm")
+	{
+		if (strFilename.IsEmpty())
+		strFilename = g_localizeStrings.Get(15200);
+		else
+		strFilename = g_localizeStrings.Get(15200) + " - " + strFilename;
+	}
 
-  // Shoutcast
-  else if (url.GetProtocol() == "shout")
-  {
-    const int genre = strFileNameAndPath.find_first_of('=');
-    if(genre <0)
-      strFilename = g_localizeStrings.Get(260);
-    else
-      strFilename = g_localizeStrings.Get(260) + " - " + strFileNameAndPath.substr(genre+1).c_str();
-  }
+	// Shoutcast
+	else if (url.GetProtocol() == "shout")
+	{
+		const int genre = strFileNameAndPath.find_first_of('=');
+		if(genre <0)
+		strFilename = g_localizeStrings.Get(260);
+		else
+		strFilename = g_localizeStrings.Get(260) + " - " + strFileNameAndPath.substr(genre+1).c_str();
+	}
 
-  // Windows SMB Network (SMB)
-  else if (url.GetProtocol() == "smb" && strFilename.IsEmpty())
-  {
-    if (url.GetHostName().IsEmpty())
-    {
-      strFilename = g_localizeStrings.Get(20171);
-    }
-    else
-    {
-      strFilename = url.GetHostName();
-    }
-  }
-  // XBMSP Network
-  else if (url.GetProtocol() == "xbms" && strFilename.IsEmpty())
-    strFilename = "XBMSP Network";
+	// Windows SMB Network (SMB)
+	else if (url.GetProtocol() == "smb" && strFilename.IsEmpty())
+	{
+		if (url.GetHostName().IsEmpty())
+		{
+			strFilename = g_localizeStrings.Get(20171);
+		}
+		else
+		{
+			strFilename = url.GetHostName();
+		}
+	}
+	// XBMSP Network
+	else if (url.GetProtocol() == "xbms" && strFilename.IsEmpty())
+	strFilename = "XBMSP Network";
 
-  // iTunes music share (DAAP)
-  else if (url.GetProtocol() == "daap" && strFilename.IsEmpty())
-    strFilename = g_localizeStrings.Get(20174);
+	// iTunes music share (DAAP)
+	else if (url.GetProtocol() == "daap" && strFilename.IsEmpty())
+	strFilename = g_localizeStrings.Get(20174);
 
-  // HDHomerun Devices
-  else if (url.GetProtocol() == "hdhomerun" && strFilename.IsEmpty())
-    strFilename = "HDHomerun Devices";
+	// HDHomerun Devices
+	else if (url.GetProtocol() == "hdhomerun" && strFilename.IsEmpty())
+	strFilename = "HDHomerun Devices";
 
-  // Slingbox Devices
-  else if (url.GetProtocol() == "sling")
-    strFilename = "Slingbox";
+	// Slingbox Devices
+	else if (url.GetProtocol() == "sling")
+	strFilename = "Slingbox";
 
-  // ReplayTV Devices
-  else if (url.GetProtocol() == "rtv")
-    strFilename = "ReplayTV Devices";
+	// ReplayTV Devices
+	else if (url.GetProtocol() == "rtv")
+	strFilename = "ReplayTV Devices";
 
-  // HTS Tvheadend client
-  else if (url.GetProtocol() == "htsp")
-    strFilename = g_localizeStrings.Get(20256);
+	// HTS Tvheadend client
+	else if (url.GetProtocol() == "htsp")
+	strFilename = g_localizeStrings.Get(20256);
 
-  // VDR Streamdev client
-  else if (url.GetProtocol() == "vtp")
-    strFilename = g_localizeStrings.Get(20257);
-  
-  // MythTV client
-  else if (url.GetProtocol() == "myth")
-    strFilename = g_localizeStrings.Get(20258);
+	// VDR Streamdev client
+	else if (url.GetProtocol() == "vtp")
+	strFilename = g_localizeStrings.Get(20257);
 
-  // SAP Streams
-  else if (url.GetProtocol() == "sap" && strFilename.IsEmpty())
-    strFilename = "SAP Streams";
+	// MythTV client
+	else if (url.GetProtocol() == "myth")
+	strFilename = g_localizeStrings.Get(20258);
 
-  // Root file views
-  else if (url.GetProtocol() == "sources")
-    strFilename = g_localizeStrings.Get(744);
+	// SAP Streams
+	else if (url.GetProtocol() == "sap" && strFilename.IsEmpty())
+	strFilename = "SAP Streams";
 
-  // Music Playlists
-  else if (path.Left(24).Equals("special://musicplaylists"))
-    strFilename = g_localizeStrings.Get(136);
+	// Root file views
+	else if (url.GetProtocol() == "sources")
+	strFilename = g_localizeStrings.Get(744);
 
-  // Video Playlists
-  else if (path.Left(24).Equals("special://videoplaylists"))
-    strFilename = g_localizeStrings.Get(136);
+	// Music Playlists
+	else if (path.Left(24).Equals("special://musicplaylists"))
+	strFilename = g_localizeStrings.Get(136);
 
-  else if ((url.GetProtocol() == "rar" || url.GetProtocol() == "zip") && strFilename.IsEmpty())
-    strFilename = URIUtils::GetFileName(url.GetHostName());
+	// Video Playlists
+	else if (path.Left(24).Equals("special://videoplaylists"))
+	strFilename = g_localizeStrings.Get(136);
 
-  // now remove the extension if needed
-  if (!g_guiSettings.GetBool("filelists.showextensions") && !bIsFolder)
-  {
-    URIUtils::RemoveExtension(strFilename);
-    return strFilename;
-  }
-  
-  // URLDecode since the original path may be an URL
-  CURL::Decode(strFilename);
-  return strFilename;
+	else if ((url.GetProtocol() == "rar" || url.GetProtocol() == "zip") && strFilename.IsEmpty())
+	strFilename = URIUtils::GetFileName(url.GetHostName());
+
+	// now remove the extension if needed
+	if (!g_guiSettings.GetBool("filelists.showextensions") && !bIsFolder)
+	{
+		URIUtils::RemoveExtension(strFilename);
+		return strFilename;
+	}
+
+	// URLDecode since the original path may be an URL
+	CURL::Decode(strFilename);
+	return strFilename;
 }
 
 bool CUtil::GetVolumeFromFileName(const CStdString& strFileName, CStdString& strFileTitle, CStdString& strVolumeNumber)
 {
-  const CStdStringArray &regexps = g_advancedSettings.m_videoStackRegExps;
+	const CStdStringArray &regexps = g_advancedSettings.m_videoStackRegExps;
 
-  CStdString strFileNameTemp = strFileName;
-  CStdString strFileNameLower = strFileName;
-  strFileNameLower.MakeLower();
+	CStdString strFileNameTemp = strFileName;
+	CStdString strFileNameLower = strFileName;
+	strFileNameLower.MakeLower();
 
-  CStdString strVolume;
-  CStdString strTestString;
-  CRegExp reg;
+	CStdString strVolume;
+	CStdString strTestString;
+	CRegExp reg;
 
-//  CLog::Log(LOGDEBUG, "GetVolumeFromFileName:[%s]", strFileNameLower.c_str());
-  for (unsigned int i = 0; i < regexps.size(); i++)
-  {
-    CStdString strRegExp = regexps[i];
-    if (!reg.RegComp(strRegExp.c_str()))
-    { // invalid regexp - complain in logs
-      CLog::Log(LOGERROR, "Invalid RegExp:[%s]", regexps[i].c_str());
-      continue;
-    }
-//    CLog::Log(LOGDEBUG, "Regexp:[%s]", regexps[i].c_str());
+	//  CLog::Log(LOGDEBUG, "GetVolumeFromFileName:[%s]", strFileNameLower.c_str());
+	for (unsigned int i = 0; i < regexps.size(); i++)
+	{
+		CStdString strRegExp = regexps[i];
+		if (!reg.RegComp(strRegExp.c_str()))
+		{ // invalid regexp - complain in logs
+			CLog::Log(LOGERROR, "Invalid RegExp:[%s]", regexps[i].c_str());
+			continue;
+		}
+		//    CLog::Log(LOGDEBUG, "Regexp:[%s]", regexps[i].c_str());
 
-    int iFoundToken = reg.RegFind(strFileNameLower.c_str());
-    if (iFoundToken >= 0)
-    {
-      int iRegLength = reg.GetFindLen();
-      int iCount = reg.GetSubCount();
+		int iFoundToken = reg.RegFind(strFileNameLower.c_str());
+		if (iFoundToken >= 0)
+		{
+			int iRegLength = reg.GetFindLen();
+			int iCount = reg.GetSubCount();
 
-      /*
-      reg.DumpOvector(LOGDEBUG);
-      CLog::Log(LOGDEBUG, "Subcount=%i", iCount);
-      for (int j = 0; j <= iCount; j++)
-      {
-        CStdString str = reg.GetMatch(j);
-        CLog::Log(LOGDEBUG, "Sub(%i):[%s]", j, str.c_str());
-      }
-      */
+			/*
+	reg.DumpOvector(LOGDEBUG);
+	CLog::Log(LOGDEBUG, "Subcount=%i", iCount);
+	for (int j = 0; j <= iCount; j++)
+	{
+		CStdString str = reg.GetMatch(j);
+		CLog::Log(LOGDEBUG, "Sub(%i):[%s]", j, str.c_str());
+	}
+	*/
 
-      // simple regexp, only the volume is captured
-      if (iCount == 1)
-      {
-        strVolumeNumber = reg.GetMatch(1);
-        if (strVolumeNumber.IsEmpty()) return false;
+			// simple regexp, only the volume is captured
+			if (iCount == 1)
+			{
+				strVolumeNumber = reg.GetMatch(1);
+				if (strVolumeNumber.IsEmpty()) return false;
 
-        // Remove the extension (if any).  We do this on the base filename, as the regexp
-        // match may include some of the extension (eg the "." in particular).
-        // The extension will then be added back on at the end - there is no reason
-        // to clean it off here. It will be cleaned off during the display routine, if
-        // the settings to hide extensions are turned on.
-        CStdString strFileNoExt = strFileNameTemp;
-        URIUtils::RemoveExtension(strFileNoExt);
-        CStdString strFileExt = strFileNameTemp.Right(strFileNameTemp.length() - strFileNoExt.length());
-        CStdString strFileRight = strFileNoExt.Mid(iFoundToken + iRegLength);
-        strFileTitle = strFileName.Left(iFoundToken) + strFileRight + strFileExt;
+				// Remove the extension (if any).  We do this on the base filename, as the regexp
+				// match may include some of the extension (eg the "." in particular).
+				// The extension will then be added back on at the end - there is no reason
+				// to clean it off here. It will be cleaned off during the display routine, if
+				// the settings to hide extensions are turned on.
+				CStdString strFileNoExt = strFileNameTemp;
+				URIUtils::RemoveExtension(strFileNoExt);
+				CStdString strFileExt = strFileNameTemp.Right(strFileNameTemp.length() - strFileNoExt.length());
+				CStdString strFileRight = strFileNoExt.Mid(iFoundToken + iRegLength);
+				strFileTitle = strFileName.Left(iFoundToken) + strFileRight + strFileExt;
 
-        return true;
-      }
+				return true;
+			}
 
-      // advanced regexp with prefix (1), volume (2), and suffix (3)
-      else if (iCount == 3)
-      {
-        // second subpatten contains the stacking volume
-        strVolumeNumber = reg.GetMatch(2);
-        if (strVolumeNumber.IsEmpty()) return false;
+			// advanced regexp with prefix (1), volume (2), and suffix (3)
+			else if (iCount == 3)
+			{
+				// second subpatten contains the stacking volume
+				strVolumeNumber = reg.GetMatch(2);
+				if (strVolumeNumber.IsEmpty()) return false;
 
-        // everything before the regexp match
-        strFileTitle = strFileName.Left(iFoundToken);
+				// everything before the regexp match
+				strFileTitle = strFileName.Left(iFoundToken);
 
-        // first subpattern contains prefix
-        strFileTitle += reg.GetMatch(1);
+				// first subpattern contains prefix
+				strFileTitle += reg.GetMatch(1);
 
-        // third subpattern contains suffix
-        strFileTitle += reg.GetMatch(3);
+				// third subpattern contains suffix
+				strFileTitle += reg.GetMatch(3);
 
-        // everything after the regexp match
-        strFileTitle += strFileNameTemp.Mid(iFoundToken + iRegLength);
+				// everything after the regexp match
+				strFileTitle += strFileNameTemp.Mid(iFoundToken + iRegLength);
 
-        return true;
-      }
+				return true;
+			}
 
-      // unknown regexp format
-      else
-      {
-        CLog::Log(LOGERROR, "Incorrect movie stacking regexp format:[%s]", regexps[i].c_str());
-      }
-    }
-  }
-  return false;
+			// unknown regexp format
+			else
+			{
+				CLog::Log(LOGERROR, "Incorrect movie stacking regexp format:[%s]", regexps[i].c_str());
+			}
+		}
+	}
+	return false;
 }
 
 void CUtil::CleanString(const CStdString& strFileName, CStdString& strTitle, CStdString& strTitleAndYear, CStdString& strYear, bool bRemoveExtension /* = false */, bool bCleanChars /* = true */)
 {
-  strTitleAndYear = strFileName;
+	strTitleAndYear = strFileName;
 
-  if (strFileName.Equals(".."))
-   return;
+	if (strFileName.Equals(".."))
+	return;
 
-  const CStdStringArray &regexps = g_advancedSettings.m_videoCleanStringRegExps;
+	const CStdStringArray &regexps = g_advancedSettings.m_videoCleanStringRegExps;
 
-  CRegExp reTags(true);
-  CRegExp reYear;
-  CStdString strExtension;
-  URIUtils::GetExtension(strFileName, strExtension);
+	CRegExp reTags(true);
+	CRegExp reYear;
+	CStdString strExtension;
+	URIUtils::GetExtension(strFileName, strExtension);
 
-  if (!reYear.RegComp(g_advancedSettings.m_videoCleanDateTimeRegExp))
-  {
-    CLog::Log(LOGERROR, "%s: Invalid datetime clean RegExp:'%s'", __FUNCTION__, g_advancedSettings.m_videoCleanDateTimeRegExp.c_str());
-  }
-  else
-  {
-    if (reYear.RegFind(strTitleAndYear.c_str()) >= 0)
-    {
-      strTitleAndYear = reYear.GetReplaceString("\\1");
-      strYear = reYear.GetReplaceString("\\2");
-    }
-  }
+	if (!reYear.RegComp(g_advancedSettings.m_videoCleanDateTimeRegExp))
+	{
+		CLog::Log(LOGERROR, "%s: Invalid datetime clean RegExp:'%s'", __FUNCTION__, g_advancedSettings.m_videoCleanDateTimeRegExp.c_str());
+	}
+	else
+	{
+		if (reYear.RegFind(strTitleAndYear.c_str()) >= 0)
+		{
+			strTitleAndYear = reYear.GetReplaceString("\\1");
+			strYear = reYear.GetReplaceString("\\2");
+		}
+	}
 
-  URIUtils::RemoveExtension(strTitleAndYear);
+	URIUtils::RemoveExtension(strTitleAndYear);
 
-  for (unsigned int i = 0; i < regexps.size(); i++)
-  {
-    if (!reTags.RegComp(regexps[i].c_str()))
-    { // invalid regexp - complain in logs
-      CLog::Log(LOGERROR, "%s: Invalid string clean RegExp:'%s'", __FUNCTION__, regexps[i].c_str());
-      continue;
-    }
-    int j=0;
-    if ((j=reTags.RegFind(strFileName.c_str())) > 0)
-      strTitleAndYear = strTitleAndYear.Mid(0, j);
-  }
+	for (unsigned int i = 0; i < regexps.size(); i++)
+	{
+		if (!reTags.RegComp(regexps[i].c_str()))
+		{ // invalid regexp - complain in logs
+			CLog::Log(LOGERROR, "%s: Invalid string clean RegExp:'%s'", __FUNCTION__, regexps[i].c_str());
+			continue;
+		}
+		int j=0;
+		if ((j=reTags.RegFind(strFileName.c_str())) > 0)
+		strTitleAndYear = strTitleAndYear.Mid(0, j);
+	}
 
-  // final cleanup - special characters used instead of spaces:
-  // all '_' tokens should be replaced by spaces
-  // if the file contains no spaces, all '.' tokens should be replaced by
-  // spaces - one possibility of a mistake here could be something like:
-  // "Dr..StrangeLove" - hopefully no one would have anything like this.
-  if (bCleanChars)
-  {
-    bool initialDots = true;
-    bool alreadyContainsSpace = (strTitleAndYear.Find(' ') >= 0);
+	// final cleanup - special characters used instead of spaces:
+	// all '_' tokens should be replaced by spaces
+	// if the file contains no spaces, all '.' tokens should be replaced by
+	// spaces - one possibility of a mistake here could be something like:
+	// "Dr..StrangeLove" - hopefully no one would have anything like this.
+	if (bCleanChars)
+	{
+		bool initialDots = true;
+		bool alreadyContainsSpace = (strTitleAndYear.Find(' ') >= 0);
 
-    for (int i = 0; i < (int)strTitleAndYear.size(); i++)
-    {
-      char c = strTitleAndYear.GetAt(i);
+		for (int i = 0; i < (int)strTitleAndYear.size(); i++)
+		{
+			char c = strTitleAndYear.GetAt(i);
 
-      if (c != '.')
-        initialDots = false;
+			if (c != '.')
+			initialDots = false;
 
-      if ((c == '_') || ((!alreadyContainsSpace) && !initialDots && (c == '.')))
-      {
-        strTitleAndYear.SetAt(i, ' ');
-      }
-    }
-  }
+			if ((c == '_') || ((!alreadyContainsSpace) && !initialDots && (c == '.')))
+			{
+				strTitleAndYear.SetAt(i, ' ');
+			}
+		}
+	}
 
-  strTitle = strTitleAndYear.Trim();
+	strTitle = strTitleAndYear.Trim();
 
-  // append year
-  if (!strYear.IsEmpty())
-    strTitleAndYear = strTitle + " (" + strYear + ")";
+	// append year
+	if (!strYear.IsEmpty())
+	strTitleAndYear = strTitle + " (" + strYear + ")";
 
-  // restore extension if needed
-  if (!bRemoveExtension)
-    strTitleAndYear += strExtension;
+	// restore extension if needed
+	if (!bRemoveExtension)
+	strTitleAndYear += strExtension;
 }
 
 void CUtil::GetQualifiedFilename(const CStdString &strBasePath, CStdString &strFilename)
 {
-  //Make sure you have a full path in the filename, otherwise adds the base path before.
-  CURL plItemUrl(strFilename);
-  CURL plBaseUrl(strBasePath);
-  int iDotDotLoc, iBeginCut, iEndCut;
+	//Make sure you have a full path in the filename, otherwise adds the base path before.
+	CURL plItemUrl(strFilename);
+	CURL plBaseUrl(strBasePath);
+	int iDotDotLoc, iBeginCut, iEndCut;
 
-  if (plBaseUrl.IsLocal()) //Base in local directory
-  {
-    if (plItemUrl.IsLocal() ) //Filename is local or not qualified
-    {
+	if (plBaseUrl.IsLocal()) //Base in local directory
+	{
+		if (plItemUrl.IsLocal() ) //Filename is local or not qualified
+		{
 #ifdef _LINUX
-      if (!( (strFilename.c_str()[1] == ':') || (strFilename.c_str()[0] == '/') ) ) //Filename not fully qualified
+			if (!( (strFilename.c_str()[1] == ':') || (strFilename.c_str()[0] == '/') ) ) //Filename not fully qualified
 #else
-      if (!( strFilename.c_str()[1] == ':')) //Filename not fully qualified
+			if (!( strFilename.c_str()[1] == ':')) //Filename not fully qualified
 #endif
-      {
-        if (strFilename.c_str()[0] == '/' || strFilename.c_str()[0] == '\\' || URIUtils::HasSlashAtEnd(strBasePath))
-        {
-          strFilename = strBasePath + strFilename;
-          strFilename.Replace('/', '\\');
-        }
-        else
-        {
-          strFilename = strBasePath + '\\' + strFilename;
-          strFilename.Replace('/', '\\');
-        }
-      }
-    }
-    strFilename.Replace("\\.\\", "\\");
-    while ((iDotDotLoc = strFilename.Find("\\..\\")) > 0)
-    {
-      iEndCut = iDotDotLoc + 4;
-      iBeginCut = strFilename.Left(iDotDotLoc).ReverseFind('\\') + 1;
-      strFilename.Delete(iBeginCut, iEndCut - iBeginCut);
-    }
+			{
+				if (strFilename.c_str()[0] == '/' || strFilename.c_str()[0] == '\\' || URIUtils::HasSlashAtEnd(strBasePath))
+				{
+					strFilename = strBasePath + strFilename;
+					strFilename.Replace('/', '\\');
+				}
+				else
+				{
+					strFilename = strBasePath + '\\' + strFilename;
+					strFilename.Replace('/', '\\');
+				}
+			}
+		}
+		strFilename.Replace("\\.\\", "\\");
+		while ((iDotDotLoc = strFilename.Find("\\..\\")) > 0)
+		{
+			iEndCut = iDotDotLoc + 4;
+			iBeginCut = strFilename.Left(iDotDotLoc).ReverseFind('\\') + 1;
+			strFilename.Delete(iBeginCut, iEndCut - iBeginCut);
+		}
 
-    // This routine is only called from the playlist loaders,
-    // where the filepath is in UTF-8 anyway, so we don't need
-    // to do checking for FatX characters.
-    //if (g_guiSettings.GetBool("services.ftpautofatx") && (URIUtils::IsHD(strFilename)))
-    //  CUtil::GetFatXQualifiedPath(strFilename);
-  }
-  else //Base is remote
-  {
-    if (plItemUrl.IsLocal()) //Filename is local
-    {
+		// This routine is only called from the playlist loaders,
+		// where the filepath is in UTF-8 anyway, so we don't need
+		// to do checking for FatX characters.
+		//if (g_guiSettings.GetBool("services.ftpautofatx") && (URIUtils::IsHD(strFilename)))
+		//  CUtil::GetFatXQualifiedPath(strFilename);
+	}
+	else //Base is remote
+	{
+		if (plItemUrl.IsLocal()) //Filename is local
+		{
 #ifdef _LINUX
-      if ( (strFilename.c_str()[1] == ':') || (strFilename.c_str()[0] == '/') )  //Filename not fully qualified
+			if ( (strFilename.c_str()[1] == ':') || (strFilename.c_str()[0] == '/') )  //Filename not fully qualified
 #else
-      if (strFilename[1] == ':') // already fully qualified
+			if (strFilename[1] == ':') // already fully qualified
 #endif
-        return;
-      if (strFilename.c_str()[0] == '/' || strFilename.c_str()[0] == '\\' || URIUtils::HasSlashAtEnd(strBasePath)) //Begins with a slash.. not good.. but we try to make the best of it..
+			return;
+			if (strFilename.c_str()[0] == '/' || strFilename.c_str()[0] == '\\' || URIUtils::HasSlashAtEnd(strBasePath)) //Begins with a slash.. not good.. but we try to make the best of it..
 
-      {
-        strFilename = strBasePath + strFilename;
-        strFilename.Replace('\\', '/');
-      }
-      else
-      {
-        strFilename = strBasePath + '/' + strFilename;
-        strFilename.Replace('\\', '/');
-      }
-    }
-    strFilename.Replace("/./", "/");
-    while ((iDotDotLoc = strFilename.Find("/../")) > 0)
-    {
-      iEndCut = iDotDotLoc + 4;
-      iBeginCut = strFilename.Left(iDotDotLoc).ReverseFind('/') + 1;
-      strFilename.Delete(iBeginCut, iEndCut - iBeginCut);
-    }
-  }
+			{
+				strFilename = strBasePath + strFilename;
+				strFilename.Replace('\\', '/');
+			}
+			else
+			{
+				strFilename = strBasePath + '/' + strFilename;
+				strFilename.Replace('\\', '/');
+			}
+		}
+		strFilename.Replace("/./", "/");
+		while ((iDotDotLoc = strFilename.Find("/../")) > 0)
+		{
+			iEndCut = iDotDotLoc + 4;
+			iBeginCut = strFilename.Left(iDotDotLoc).ReverseFind('/') + 1;
+			strFilename.Delete(iBeginCut, iEndCut - iBeginCut);
+		}
+	}
 }
 
+bool CUtil::CheckForKernelPatchable( int strText )
+{
+	CStdString kernel_version = g_sysinfo.GetKernelVersion();
+	if (kernel_version == "1.0.3944.1" || kernel_version == "1.0.4034.1" || kernel_version == "1.0.4627.1" || kernel_version == "1.0.4817.1" || kernel_version == "1.0.5101.1" || kernel_version == "1.0.5530.1" || kernel_version == "1.0.5713.1" || kernel_version == "1.0.5838.1" || kernel_version == "1.0.8008.135" || kernel_version == "1.0.5034.1" || kernel_version == "1.0.5035.1" )
+	{
+		return( true );
+	}
+	return( false );
+}
+
 bool CUtil::PatchCountryVideo(F_COUNTRY Country, F_VIDEO Video)
 {
 #ifdef HAS_XBOX_HARDWARE
-  BYTE  *Kernel=(BYTE *)0x80010000;
-  DWORD i, j = 0, k;
-  DWORD *CountryPtr;
-  BYTE  CountryValues[4]={0, 1, 2, 4};
-  BYTE  VideoTyValues[5]={0, 1, 2, 3, 3};
-  BYTE  VideoFrValues[5]={0x00, 0x40, 0x40, 0x80, 0x40};
+	BYTE  *Kernel=(BYTE *)0x80010000;
+	DWORD i, j = 0, k;
+	DWORD *CountryPtr;
+	BYTE  CountryValues[4]={0, 1, 2, 4};
+	BYTE  VideoTyValues[5]={0, 1, 2, 3, 3};
+	BYTE  VideoFrValues[5]={0x00, 0x40, 0x40, 0x80, 0x40};
+	CStdString kernel_version = g_sysinfo.GetKernelVersion();
 
-  // Skip if no change is necessary...
-  // That is to avoid a situation in which our Patch *and* the EvoX patch are installed
-  // Otherwise the Infinite-Reboot-Patch does not work anymore!
-  if(Video == XGetVideoStandard())
-    return true;
+	// Skip if no change is necessary...
+	// That is to avoid a situation in which our Patch *and* the EvoX patch are installed
+	// Otherwise the Infinite-Reboot-Patch does not work anymore!
+	if(Video == XGetVideoStandard())
+	return true;
 
-  switch (Country)
-  {
-    case COUNTRY_EUR:
-      if (!Video)
-          Video = VIDEO_PAL50;
-        break;
-      case COUNTRY_USA:
-        Video = VIDEO_NTSCM;
-      Country = COUNTRY_USA;
-        break;
-      case COUNTRY_JAP:
-        Video = VIDEO_NTSCJ;
-      Country = COUNTRY_JAP;
-        break;
-      default:
-      Country = COUNTRY_EUR;
-        Video = VIDEO_PAL50;
-  };
+	switch (Country)
+	{
+	case COUNTRY_EUR:
+		if (!Video)
+		Video = VIDEO_PAL50;
+		break;
+	case COUNTRY_USA:
+		Video = VIDEO_NTSCM;
+		Country = COUNTRY_USA;
+		break;
+	case COUNTRY_JAP:
+		Video = VIDEO_NTSCJ;
+		Country = COUNTRY_JAP;
+		break;
+	default:
+		Country = COUNTRY_EUR;
+		Video = VIDEO_PAL50;
+	};
 
-  // Search for the original code in the Kernel.
-  // Searching from 0x80011000 to 0x80024000 in order that this will work on as many Kernels
-  // as possible.
+	// Search for the original code in the Kernel.
+	// Searching from 0x80011000 to 0x80024000 in order that this will work on as many Kernels
+	// as possible.
+	for (i = 0x1000; i < 0x16000; i++)
+	{
+		if (kernel_version == "1.0.5713.1" || kernel_version == "1.0.5838.1")
+		{
+			if (Kernel[i] != AltRetail_searchBytes[0])
+			continue;
 
-  for(i=0x1000; i<0x14000; i++)
-  {
-    if(Kernel[i]!=OriginalData[0])
-	    continue;
+			for (j = 0; j < 57; j++)
+			{
+				if (Kernel[i + j] != AltRetail_searchBytes[j])
+				break;
+			}
+			if (j == 57)
+			break;
+		}
+		else if (kernel_version == "1.0.5034.1")
+		{
+			if (Kernel[i] != xThree_searchBytes[0])
+			continue;
 
-    for(j=0; j<57; j++)
-    {
-	    if(Kernel[i+j]!=OriginalData[j])
-		    break;
-    }
-    if(j==57)
-	    break;
-  }
+			for (j = 0; j < 57; j++)
+			{
+				if (Kernel[i + j] != xThree_searchBytes[j])
+				break;
+			}
+			if (j == 57)
+			break;
+		}
+		else if (kernel_version == "1.0.5035.1")
+		{
+			if (Kernel[i] != xTwoZeroThreeFive_searchBytes[0])
+			continue;
 
-  if(j==57)
-  {
-    // Ok, found the code to patch. Get pointer to original Country setting.
-    // This may not be strictly neccessary, but lets do it anyway for completeness.
+			for (j = 0; j < 57; j++)
+			{
+				if (Kernel[i + j] != xTwoZeroThreeFive_searchBytes[j])
+				break;
+			}
+			if (j == 57)
+			break;
+		}
+		else if (kernel_version == "1.0.8008.135")
+		{
+			if (Kernel[i] != Cerbios_searchBytes[0])
+			continue;
 
-    j=(Kernel[i+57])+(Kernel[i+58]<<8)+(Kernel[i+59]<<16)+(Kernel[i+60]<<24);
-    CountryPtr=(DWORD *)j;
-  }
-  else
-  {
-    // Did not find code in the Kernel. Check if my patch is already there.
+			for (j = 0; j < 57; j++)
+			{
+				if (Kernel[i + j] != Cerbios_searchBytes[j])
+				break;
+			}
+			if (j == 57)
+			break;
+		}
+		else
+		{
+			if (Kernel[i] != Retail_searchBytes[0])
+			continue;
 
-    for(i=0x1000; i<0x14000; i++)
-    {
-      if(Kernel[i]!=PatchData[0])
-        continue;
+			for (j = 0; j < 57; j++)
+			{
+				if (Kernel[i + j] != Retail_searchBytes[j])
+				break;
+			}
+			if (j == 57)
+			break;
+		}
+	}
 
-      for(j=0; j<25; j++)
-      {
-        if(Kernel[i+j]!=PatchData[j])
-          break;
-      }
-      if(j==25)
-        break;
-    }
+	if(j==57)
+	{
+		// Ok, found the code to patch. Get pointer to original Country setting.
+		// This may not be strictly necessary, but lets do it anyway for completeness.
 
-    if(j==25)
-    {
-      // Ok, found my patch. Get pointer to original Country setting.
-      // This may not be strictly neccessary, but lets do it anyway for completeness.
+		j=(Kernel[i+57])+(Kernel[i+58]<<8)+(Kernel[i+59]<<16)+(Kernel[i+60]<<24);
+		CountryPtr=(DWORD *)j;
+	}
+	else
+	{
+		// Did not find code in the Kernel. Check if my patch is already there.
 
-      j=(Kernel[i+66])+(Kernel[i+67]<<8)+(Kernel[i+68]<<16)+(Kernel[i+69]<<24);
-      CountryPtr=(DWORD *)j;
-    }
-    else
-    {
-      // Did not find my patch - so I can't work with this BIOS. Exit.
-      return( false );
-    }
-  }
+		for(i=0x1000; i<0x14000; i++)
+		{
+			if(Kernel[i]!=PatchData[0])
+			continue;
 
-  // Patch in new code.
+			for(j=0; j<25; j++)
+			{
+				if(Kernel[i+j]!=PatchData[j])
+				break;
+			}
+			if(j==25)
+			break;
+		}
 
-  j=MmQueryAddressProtect(&Kernel[i]);
-  MmSetAddressProtect(&Kernel[i], 70, PAGE_READWRITE);
+		if(j==25)
+		{
+			// Ok, found my patch. Get pointer to original Country setting.
+			// This may not be strictly neccessary, but lets do it anyway for completeness.
 
-  memcpy(&Kernel[i], &PatchData[0], 70);
+			j=(Kernel[i+66])+(Kernel[i+67]<<8)+(Kernel[i+68]<<16)+(Kernel[i+69]<<24);
+			CountryPtr=(DWORD *)j;
+		}
+		else
+		{
+			// Did not find my patch - so I can't work with this BIOS. Exit.
+			return( false );
+		}
+	}
 
-  // Patch Success. Fix up values.
+	// Patch in new code.
 
-  *CountryPtr=(DWORD)CountryValues[Country];
-  Kernel[i+0x1f]=CountryValues[Country];
-  Kernel[i+0x19]=VideoTyValues[Video];
-  Kernel[i+0x1a]=VideoFrValues[Video];
+	j=MmQueryAddressProtect(&Kernel[i]);
+	MmSetAddressProtect(&Kernel[i], 70, PAGE_READWRITE);
 
-  k=(DWORD)CountryPtr;
-  Kernel[i+66]=(BYTE)(k&0xff);
-  Kernel[i+67]=(BYTE)((k>>8)&0xff);
-  Kernel[i+68]=(BYTE)((k>>16)&0xff);
-  Kernel[i+69]=(BYTE)((k>>24)&0xff);
+	memcpy(&Kernel[i], &PatchData[0], 70);
 
-  MmSetAddressProtect(&Kernel[i], 70, j);
+	// Patch Success. Fix up values.
 
+	*CountryPtr=(DWORD)CountryValues[Country];
+	Kernel[i+0x1f]=CountryValues[Country];
+	Kernel[i+0x19]=VideoTyValues[Video];
+	Kernel[i+0x1a]=VideoFrValues[Video];
+
+	k=(DWORD)CountryPtr;
+	Kernel[i+66]=(BYTE)(k&0xff);
+	Kernel[i+67]=(BYTE)((k>>8)&0xff);
+	Kernel[i+68]=(BYTE)((k>>16)&0xff);
+	Kernel[i+69]=(BYTE)((k>>24)&0xff);
+
+	MmSetAddressProtect(&Kernel[i], 70, j);
+
 #endif
-  // All Done!
-  return( true );
+	// All Done!
+	return( true );
 }
 
 bool CUtil::InstallTrainer(CTrainer& trainer)
 {
-  bool Found = false;
+	bool Found = false;
 #ifdef HAS_XBOX_HARDWARE
-  unsigned char *xboxkrnl = (unsigned char *)KERNEL_START_ADDRESS;
-  unsigned char *hackptr = (unsigned char *)KERNEL_STORE_ADDRESS;
-  void *ourmemaddr = NULL; // pointer used to allocated trainer mem
-  unsigned int i = 0;
-  DWORD memsize;
+	unsigned char *xboxkrnl = (unsigned char *)KERNEL_START_ADDRESS;
+	unsigned char *hackptr = (unsigned char *)KERNEL_STORE_ADDRESS;
+	void *ourmemaddr = NULL; // pointer used to allocated trainer mem
+	unsigned int i = 0;
+	DWORD memsize;
 
-  CLog::Log(LOGDEBUG,"installing trainer %s",trainer.GetPath().c_str());
+	CLog::Log(LOGDEBUG,"installing trainer %s",trainer.GetPath().c_str());
 
-  if (trainer.IsXBTF()) // size of our allocation buffer for trainer
-    memsize = XBTF_HEAP_SIZE;
-  else
-    memsize = ETM_HEAP_SIZE;
+	if (trainer.IsXBTF()) // size of our allocation buffer for trainer
+	memsize = XBTF_HEAP_SIZE;
+	else
+	memsize = ETM_HEAP_SIZE;
 
-  unsigned char xbe_entry_point[] = {0xff,0x15,0x28,0x01,0x01,0x00}; // xbe entry point bytes in kernel
-  unsigned char evox_tsr_hook[] = {0xff,0x15,0x10,0x00,0x00,0x80}; // check for evox's evil tsr hook
+	unsigned char xbe_entry_point[] = {0xff,0x15,0x28,0x01,0x01,0x00}; // xbe entry point bytes in kernel
+	unsigned char evox_tsr_hook[] = {0xff,0x15,0x10,0x00,0x00,0x80}; // check for evox's evil tsr hook
 
-  for(i = 0; i < KERNEL_SEARCH_RANGE; i++)
-  {
-    if (memcmp(&xboxkrnl[i], xbe_entry_point, sizeof(xbe_entry_point)) == 0 ||
-      memcmp(&xboxkrnl[i], evox_tsr_hook, sizeof(evox_tsr_hook)) == 0)
-    {
-      Found = true;
-      break;
-    }
-  }
+	for(i = 0; i < KERNEL_SEARCH_RANGE; i++)
+	{
+		if (memcmp(&xboxkrnl[i], xbe_entry_point, sizeof(xbe_entry_point)) == 0 ||
+				memcmp(&xboxkrnl[i], evox_tsr_hook, sizeof(evox_tsr_hook)) == 0)
+		{
+			Found = true;
+			break;
+		}
+	}
 
-  if(Found)
-  {
-    unsigned char *patchlocation = xboxkrnl;
+	if(Found)
+	{
+		unsigned char *patchlocation = xboxkrnl;
 
-    patchlocation += i + 2; // adjust to xbe entry point bytes in kernel (skipping actual call opcodes)
-    _asm
-    {
-      pushad
+		patchlocation += i + 2; // adjust to xbe entry point bytes in kernel (skipping actual call opcodes)
+		_asm
+		{
+			pushad
 
-      mov eax, cr0
-      push eax
-      and eax, 0FFFEFFFFh
-      mov cr0, eax // disable memory write prot
+			mov eax, cr0
+			push eax
+			and eax, 0FFFEFFFFh
+			mov cr0, eax // disable memory write prot
 
-      mov	edi, patchlocation // address of call to xbe entry point in kernel
-      mov	dword ptr [edi], KERNEL_STORE_ADDRESS // patch with address of where we store loaderdata+trainer buffer address
+			mov	edi, patchlocation // address of call to xbe entry point in kernel
+			mov	dword ptr [edi], KERNEL_STORE_ADDRESS // patch with address of where we store loaderdata+trainer buffer address
 
-      pop eax
-      mov cr0, eax // restore memory write prot
+			pop eax
+			mov cr0, eax // restore memory write prot
 
-      popad
-    }
-  }
-  else
-  {
-    __asm // recycle check
-    {
-      pushad
+			popad
+		}
+	}
+	else
+	{
+		__asm // recycle check
+		{
+			pushad
 
-      mov edx, KERNEL_STORE_ADDRESS
-      mov ecx, DWORD ptr [edx]
-      cmp ecx, 0 // just in case :)
-      jz cleanup
+			mov edx, KERNEL_STORE_ADDRESS
+			mov ecx, DWORD ptr [edx]
+			cmp ecx, 0 // just in case :)
+			jz cleanup
 
-      cmp word ptr [ecx], 0BA60h // address point to valid loaderdata?
-      jnz cleanup
+			cmp word ptr [ecx], 0BA60h // address point to valid loaderdata?
+			jnz cleanup
 
-      mov Found, 1 // yes! flag it found
+			mov Found, 1 // yes! flag it found
 
-      push ecx
-      call MmFreeContiguousMemory // release old memory
+			push ecx
+			call MmFreeContiguousMemory // release old memory
 cleanup:
-      popad
-    }
-  }
+			popad
+		}
+	}
 
-  // allocate our memory space BELOW the kernel (so we can access buffer from game's scope)
-  // if you allocate above kernel our buffer is out of scope and only debug bio will allow
-  // game to access it
-  ourmemaddr = MmAllocateContiguousMemoryEx(memsize, 0, -1, KERNEL_ALLOCATE_ADDRESS, PAGE_NOCACHE | PAGE_READWRITE);
-  if ((DWORD)ourmemaddr > 0)
-  {
-    MmPersistContiguousMemory(ourmemaddr, memsize, true); // so we survive soft boots
-    memcpy(hackptr, &ourmemaddr, 4); // store location of ourmemaddr in kernel
+	// allocate our memory space BELOW the kernel (so we can access buffer from game's scope)
+	// if you allocate above kernel our buffer is out of scope and only debug bio will allow
+	// game to access it
+	ourmemaddr = MmAllocateContiguousMemoryEx(memsize, 0, -1, KERNEL_ALLOCATE_ADDRESS, PAGE_NOCACHE | PAGE_READWRITE);
+	if ((DWORD)ourmemaddr > 0)
+	{
+		MmPersistContiguousMemory(ourmemaddr, memsize, true); // so we survive soft boots
+		memcpy(hackptr, &ourmemaddr, 4); // store location of ourmemaddr in kernel
 
-    memset(ourmemaddr, 0xFF, memsize); // init trainer buffer
-    memcpy(ourmemaddr, trainerloaderdata, sizeof(trainerloaderdata)); // copy loader data (actual kernel hack)
+		memset(ourmemaddr, 0xFF, memsize); // init trainer buffer
+		memcpy(ourmemaddr, trainerloaderdata, sizeof(trainerloaderdata)); // copy loader data (actual kernel hack)
 
-    // patch loaderdata with trainer base address
-    _asm
-    {
-      pushad
+		// patch loaderdata with trainer base address
+		_asm
+		{
+			pushad
 
-      mov eax, ourmemaddr
-      mov ebx, eax
-      add ebx, SIZEOFLOADERDATA
-      mov dword ptr [eax+2], ebx
+			mov eax, ourmemaddr
+			mov ebx, eax
+			add ebx, SIZEOFLOADERDATA
+			mov dword ptr [eax+2], ebx
 
-      popad
-    }
+			popad
+		}
 
 		// adjust ourmemaddr pointer past loaderdata
 		ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(trainerloaderdata));
@@ -889,189 +997,189 @@
 		// copy our trainer data into allocated mem
 		memcpy(ourmemaddr, trainer.data(), trainer.Size());
 
-    if (trainer.IsXBTF())
-    {
-      DWORD dwSection = 0;
+		if (trainer.IsXBTF())
+		{
+			DWORD dwSection = 0;
 
-      // get address of XBTF_Section
-      _asm
-      {
-        pushad
+			// get address of XBTF_Section
+			_asm
+			{
+				pushad
 
-        mov eax, ourmemaddr
+				mov eax, ourmemaddr
 
-        cmp dword ptr [eax+0x1A], 0 // real xbtf or just a converted etm? - XBTF_ENTRYPOINT
-        je converted_etm
+				cmp dword ptr [eax+0x1A], 0 // real xbtf or just a converted etm? - XBTF_ENTRYPOINT
+				je converted_etm
 
-        push eax
-        mov ebx, 0x16
-        add eax, ebx
-        mov ecx, DWORD PTR [eax]
-        pop	eax
-        add eax, ecx
-        mov dwSection, eax // get address of xbtf_section
+				push eax
+				mov ebx, 0x16
+				add eax, ebx
+				mov ecx, DWORD PTR [eax]
+				pop	eax
+				add eax, ecx
+				mov dwSection, eax // get address of xbtf_section
 
-      converted_etm:
-        popad
-      }
+				converted_etm:
+				popad
+			}
 
-      if (dwSection == 0)
-        return Found; // its a converted etm so we do not have toys section :)
+			if (dwSection == 0)
+			return Found; // its a converted etm so we do not have toys section :)
 
-      // adjust past trainer
-      ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + trainer.Size());
+			// adjust past trainer
+			ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + trainer.Size());
 
-      // inject SMBus code
-      memcpy(ourmemaddr, sm_bus, sizeof(sm_bus));
-      _asm
-      {
-        pushad
+			// inject SMBus code
+			memcpy(ourmemaddr, sm_bus, sizeof(sm_bus));
+			_asm
+			{
+				pushad
 
-        mov eax, dwSection
-        mov ebx, ourmemaddr
-        cmp dword ptr [eax], 0
-        jne nosmbus
-        mov DWORD PTR [eax], ebx
-      nosmbus:
-        popad
-      }
-      // adjust past SMBus
-      ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(sm_bus));
+				mov eax, dwSection
+				mov ebx, ourmemaddr
+				cmp dword ptr [eax], 0
+				jne nosmbus
+				mov DWORD PTR [eax], ebx
+nosmbus:
+				popad
+			}
+			// adjust past SMBus
+			ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(sm_bus));
 
-      // PatchIt
-      memcpy(ourmemaddr, patch_it_toy, sizeof(patch_it_toy));
-      _asm
-      {
-        pushad
+			// PatchIt
+			memcpy(ourmemaddr, patch_it_toy, sizeof(patch_it_toy));
+			_asm
+			{
+				pushad
 
-        mov eax, dwSection
-        add eax, 4 // 2nd dword in XBTF_Section
-        mov ebx, ourmemaddr
-        cmp dword PTR [eax], 0
-        jne nopatchit
-        mov DWORD PTR [eax], ebx
-      nopatchit:
-        popad
-      }
+				mov eax, dwSection
+				add eax, 4 // 2nd dword in XBTF_Section
+				mov ebx, ourmemaddr
+				cmp dword PTR [eax], 0
+				jne nopatchit
+				mov DWORD PTR [eax], ebx
+nopatchit:
+				popad
+			}
 
-      // adjust past PatchIt
-      ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(patch_it_toy));
+			// adjust past PatchIt
+			ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(patch_it_toy));
 
-      // HookIt
-      memcpy(ourmemaddr, hookit_toy, sizeof(hookit_toy));
-      _asm
-      {
-        pushad
+			// HookIt
+			memcpy(ourmemaddr, hookit_toy, sizeof(hookit_toy));
+			_asm
+			{
+				pushad
 
-        mov eax, dwSection
-        add eax, 8 // 3rd dword in XBTF_Section
-        mov ebx, ourmemaddr
-        cmp dword PTR [eax], 0
-        jne nohookit
-        mov DWORD PTR [eax], ebx
-      nohookit:
-        popad
-      }
+				mov eax, dwSection
+				add eax, 8 // 3rd dword in XBTF_Section
+				mov ebx, ourmemaddr
+				cmp dword PTR [eax], 0
+				jne nohookit
+				mov DWORD PTR [eax], ebx
+nohookit:
+				popad
+			}
 
-      // adjust past HookIt
-      ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(hookit_toy));
+			// adjust past HookIt
+			ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(hookit_toy));
 
-      // igk_main_toy
-      memcpy(ourmemaddr, igk_main_toy, sizeof(igk_main_toy));
-      _asm
-      {
-        // patch hook_igk_toy w/ address
-        pushad
+			// igk_main_toy
+			memcpy(ourmemaddr, igk_main_toy, sizeof(igk_main_toy));
+			_asm
+			{
+				// patch hook_igk_toy w/ address
+				pushad
 
-        mov edx, offset hook_igk_toy
-        add edx, 5
-        mov ecx, ourmemaddr
-        mov dword PTR [edx], ecx
+				mov edx, offset hook_igk_toy
+				add edx, 5
+				mov ecx, ourmemaddr
+				mov dword PTR [edx], ecx
 
-        popad
-      }
+				popad
+			}
 
-      // adjust past igk_main_toy
-      ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(igk_main_toy));
+			// adjust past igk_main_toy
+			ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(igk_main_toy));
 
-      // hook_igk_toy
-      memcpy(ourmemaddr, hook_igk_toy, sizeof(hook_igk_toy));
-      _asm
-      {
-        pushad
+			// hook_igk_toy
+			memcpy(ourmemaddr, hook_igk_toy, sizeof(hook_igk_toy));
+			_asm
+			{
+				pushad
 
-        mov eax, dwSection
-        add eax, 0ch // 4th dword in XBTF_Section
-        mov ebx, ourmemaddr
-        cmp dword PTR [eax], 0
-        jne nohookigk
-        mov DWORD PTR [eax], ebx
-      nohookigk:
-        popad
-      }
-      ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(igk_main_toy));
+				mov eax, dwSection
+				add eax, 0ch // 4th dword in XBTF_Section
+				mov ebx, ourmemaddr
+				cmp dword PTR [eax], 0
+				jne nohookigk
+				mov DWORD PTR [eax], ebx
+nohookigk:
+				popad
+			}
+			ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(igk_main_toy));
 
-      if (g_guiSettings.GetInt("lcd.mode") > 0 && g_guiSettings.GetInt("lcd.type") == MODCHIP_SMARTXX)
-      {
-        memcpy(ourmemaddr, lcd_toy_xx, sizeof(lcd_toy_xx));
-        _asm
-        {
-          pushad
+			if (g_guiSettings.GetInt("lcd.mode") > 0 && g_guiSettings.GetInt("lcd.type") == MODCHIP_SMARTXX)
+			{
+				memcpy(ourmemaddr, lcd_toy_xx, sizeof(lcd_toy_xx));
+				_asm
+				{
+					pushad
 
-          mov ecx, ourmemaddr
-          add ecx, 0141h // lcd clear
+					mov ecx, ourmemaddr
+					add ecx, 0141h // lcd clear
 
-          mov eax, dwSection
-          add eax, 010h // 5th dword
+					mov eax, dwSection
+					add eax, 010h // 5th dword
 
-          cmp dword PTR [eax], 0
-          jne nolcdxx
+					cmp dword PTR [eax], 0
+					jne nolcdxx
 
-          mov dword PTR [eax], ecx
-          add ecx, 0ah // lcd writestring
-          add eax, 4 // 6th dword
+					mov dword PTR [eax], ecx
+					add ecx, 0ah // lcd writestring
+					add eax, 4 // 6th dword
 
-          cmp dword ptr [eax], 0
-          jne nolcd
+					cmp dword ptr [eax], 0
+					jne nolcd
 
-          mov dword ptr [eax], ecx
-        nolcdxx:
-          popad
-        }
-        ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(lcd_toy_xx));
-      }
-      else
-      {
-        // lcd toy
-        memcpy(ourmemaddr, lcd_toy_x3, sizeof(lcd_toy_x3));
-        _asm
-        {
-          pushad
+					mov dword ptr [eax], ecx
+nolcdxx:
+					popad
+				}
+				ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(lcd_toy_xx));
+			}
+			else
+			{
+				// lcd toy
+				memcpy(ourmemaddr, lcd_toy_x3, sizeof(lcd_toy_x3));
+				_asm
+				{
+					pushad
 
-          mov ecx, ourmemaddr
-          add ecx, 0bdh // lcd clear
+					mov ecx, ourmemaddr
+					add ecx, 0bdh // lcd clear
 
-          mov eax, dwSection
-          add eax, 010h // 5th dword
+					mov eax, dwSection
+					add eax, 010h // 5th dword
 
-          cmp dword PTR [eax], 0
-          jne nolcd
+					cmp dword PTR [eax], 0
+					jne nolcd
 
-          mov dword PTR [eax], ecx
-          add ecx, 0ah // lcd writestring
-          add eax, 4 // 6th dword
+					mov dword PTR [eax], ecx
+					add ecx, 0ah // lcd writestring
+					add eax, 4 // 6th dword
 
-          cmp dword ptr [eax], 0
-          jne nolcd
+					cmp dword ptr [eax], 0
+					jne nolcd
 
-          mov dword ptr [eax], ecx
-        nolcd:
-          popad
-        }
-        ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(lcd_toy_x3));
-      }
-    }
-  }
+					mov dword ptr [eax], ecx
+nolcd:
+					popad
+				}
+				ourmemaddr=(PVOID *)(((unsigned int) ourmemaddr) + sizeof(lcd_toy_x3));
+			}
+		}
+	}
 #endif
 
 	return Found;
@@ -1081,11 +1189,11 @@
 {
 	bool Found = false;
 #ifdef HAS_XBOX_HARDWARE
-  unsigned char *xboxkrnl = (unsigned char *)KERNEL_START_ADDRESS;
+	unsigned char *xboxkrnl = (unsigned char *)KERNEL_START_ADDRESS;
 	unsigned int i = 0;
 
-  unsigned char xbe_entry_point[] = {0xff,0x15,0x80,0x00,0x00,0x0c}; // xbe entry point bytes in kernel
-  *((DWORD*)(xbe_entry_point+2)) = KERNEL_STORE_ADDRESS;
+	unsigned char xbe_entry_point[] = {0xff,0x15,0x80,0x00,0x00,0x0c}; // xbe entry point bytes in kernel
+	*((DWORD*)(xbe_entry_point+2)) = KERNEL_STORE_ADDRESS;
 
 	for(i = 0; i < KERNEL_SEARCH_RANGE; i++)
 	{
@@ -1097,539 +1205,539 @@
 	}
 
 	if(Found)
-  {
-    unsigned char *patchlocation = xboxkrnl;
-    patchlocation += i + 2; // adjust to xbe entry point bytes in kernel (skipping actual call opcodes)
-    __asm // recycle check
-    {
-        pushad
+	{
+		unsigned char *patchlocation = xboxkrnl;
+		patchlocation += i + 2; // adjust to xbe entry point bytes in kernel (skipping actual call opcodes)
+		__asm // recycle check
+		{
+			pushad
 
-        mov eax, cr0
-        push eax
-        and eax, 0FFFEFFFFh
-        mov cr0, eax // disable memory write prot
+			mov eax, cr0
+			push eax
+			and eax, 0FFFEFFFFh
+			mov cr0, eax // disable memory write prot
 
-        mov	edi, patchlocation // address of call to xbe entry point in kernel
-        mov	dword ptr [edi], 0x00010128 // patch with address of where we store loaderdata+trainer buffer address
+			mov	edi, patchlocation // address of call to xbe entry point in kernel
+			mov	dword ptr [edi], 0x00010128 // patch with address of where we store loaderdata+trainer buffer address
 
-        pop eax
-        mov cr0, eax // restore memory write prot
+			pop eax
+			mov cr0, eax // restore memory write prot
 
-        popad
-    }
-  }
+			popad
+		}
+	}
 #endif
-  return Found;
+	return Found;
 }
 
 bool CUtil::IsWritable(const CStdString& strFile)
 {
 #ifdef HAS_XBOX_HARDWARE
- if (strFile.substr(0,4) == "mem:")
- {
-   return g_memoryUnitManager.IsDriveWriteable(strFile);
- }
+	if (strFile.substr(0,4) == "mem:")
+	{
+		return g_memoryUnitManager.IsDriveWriteable(strFile);
+	}
 #endif
-  return ( URIUtils::IsHD(strFile) || URIUtils::IsSmb(strFile) ) && !URIUtils::IsDVD(strFile);
+	return ( URIUtils::IsHD(strFile) || URIUtils::IsSmb(strFile) ) && !URIUtils::IsDVD(strFile);
 }
 
 bool CUtil::IsPicture(const CStdString& strFile)
 {
-  CStdString extension = URIUtils::GetExtension(strFile);
+	CStdString extension = URIUtils::GetExtension(strFile);
 
-  if (extension.IsEmpty())
-    return false;
+	if (extension.IsEmpty())
+	return false;
 
-  extension.ToLower();
-  if (g_settings.m_pictureExtensions.Find(extension) != -1)
-    return true;
+	extension.ToLower();
+	if (g_settings.m_pictureExtensions.Find(extension) != -1)
+	return true;
 
-  if (extension == ".tbn" || extension == ".dds")
-    return true;
+	if (extension == ".tbn" || extension == ".dds")
+	return true;
 
-  return false;
+	return false;
 }
 
 bool CUtil::ExcludeFileOrFolder(const CStdString& strFileOrFolder, const CStdStringArray& regexps)
 {
-  if (strFileOrFolder.IsEmpty())
-    return false;
+	if (strFileOrFolder.IsEmpty())
+	return false;
 
-  CStdString strExclude = strFileOrFolder;
-  strExclude.MakeLower();
+	CStdString strExclude = strFileOrFolder;
+	strExclude.MakeLower();
 
-  CRegExp regExExcludes;
+	CRegExp regExExcludes;
 
-  for (unsigned int i = 0; i < regexps.size(); i++)
-  {
-    if (!regExExcludes.RegComp(regexps[i].c_str()))
-    { // invalid regexp - complain in logs
-      CLog::Log(LOGERROR, "%s: Invalid exclude RegExp:'%s'", __FUNCTION__, regexps[i].c_str());
-      continue;
-    }
-    if (regExExcludes.RegFind(strExclude) > -1)
-    {
-      CLog::Log(LOGDEBUG, "%s: File '%s' excluded. (Matches exclude rule RegExp:'%s')", __FUNCTION__, strExclude.c_str(), regexps[i].c_str());
-      return true;
-    }
-  }
-  return false;
+	for (unsigned int i = 0; i < regexps.size(); i++)
+	{
+		if (!regExExcludes.RegComp(regexps[i].c_str()))
+		{ // invalid regexp - complain in logs
+			CLog::Log(LOGERROR, "%s: Invalid exclude RegExp:'%s'", __FUNCTION__, regexps[i].c_str());
+			continue;
+		}
+		if (regExExcludes.RegFind(strExclude) > -1)
+		{
+			CLog::Log(LOGDEBUG, "%s: File '%s' excluded. (Matches exclude rule RegExp:'%s')", __FUNCTION__, strExclude.c_str(), regexps[i].c_str());
+			return true;
+		}
+	}
+	return false;
 }
 
 void CUtil::GetFileAndProtocol(const CStdString& strURL, CStdString& strDir)
 {
-  strDir = strURL;
-  if (!URIUtils::IsRemote(strURL)) return ;
-  if (URIUtils::IsDVD(strURL)) return ;
+	strDir = strURL;
+	if (!URIUtils::IsRemote(strURL)) return ;
+	if (URIUtils::IsDVD(strURL)) return ;
 
-  CURL url(strURL);
-  strDir.Format("%s://%s", url.GetProtocol().c_str(), url.GetFileName().c_str());
+	CURL url(strURL);
+	strDir.Format("%s://%s", url.GetProtocol().c_str(), url.GetFileName().c_str());
 }
 
 int CUtil::GetDVDIfoTitle(const CStdString& strFile)
 {
-  CStdString strFilename = URIUtils::GetFileName(strFile);
-  if (strFilename.Equals("video_ts.ifo")) return 0;
-  //VTS_[TITLE]_0.IFO
-  return atoi(strFilename.Mid(4, 2).c_str());
+	CStdString strFilename = URIUtils::GetFileName(strFile);
+	if (strFilename.Equals("video_ts.ifo")) return 0;
+	//VTS_[TITLE]_0.IFO
+	return atoi(strFilename.Mid(4, 2).c_str());
 }
 
 bool CUtil::CacheXBEIcon(const CStdString& strFilePath, const CStdString& strIcon)
 {
-  bool success(false);
-  // extract icon from .xbe
-  CStdString localFile;
-  g_charsetConverter.utf8ToStringCharset(strFilePath, localFile);
-  CXBE xbeReader;
-  CStdString strTempFile;
-  CStdString strExtension;
+	bool success(false);
+	// extract icon from .xbe
+	CStdString localFile;
+	g_charsetConverter.utf8ToStringCharset(strFilePath, localFile);
+	CXBE xbeReader;
+	CStdString strTempFile;
+	CStdString strExtension;
 
-  URIUtils::AddFileToFolder(g_advancedSettings.m_cachePath,"1.xpr",strTempFile);
-  URIUtils::GetExtension(strFilePath,strExtension);
-  if (strExtension.Equals(".xbx"))
-  {
-  ::CopyFile(strFilePath.c_str(), strTempFile.c_str(),FALSE);
-  }
-  else
-  {
-  if (!xbeReader.ExtractIcon(localFile, strTempFile.c_str()))
-    return false;
-  }
+	URIUtils::AddFileToFolder(g_advancedSettings.m_cachePath,"1.xpr",strTempFile);
+	URIUtils::GetExtension(strFilePath,strExtension);
+	if (strExtension.Equals(".xbx"))
+	{
+		::CopyFile(strFilePath.c_str(), strTempFile.c_str(),FALSE);
+	}
+	else
+	{
+		if (!xbeReader.ExtractIcon(localFile, strTempFile.c_str()))
+		return false;
+	}
 
-  CXBPackedResource* pPackedResource = new CXBPackedResource();
-  if ( SUCCEEDED( pPackedResource->Create( strTempFile.c_str(), 1, NULL ) ) )
-  {
-    LPDIRECT3DTEXTURE8 pTexture = pPackedResource->GetTexture((DWORD)0);
-    if ( pTexture )
-    {
-      D3DSURFACE_DESC descSurface;
-      if ( SUCCEEDED( pTexture->GetLevelDesc( 0, &descSurface ) ) )
-      {
-        int iHeight = descSurface.Height;
-        int iWidth = descSurface.Width;
-        DWORD dwFormat = descSurface.Format;
-        CPicture pic;
-        success = pic.CreateThumbnailFromSwizzledTexture(pTexture, iHeight, iWidth, strIcon.c_str());
-      }
-      pTexture->Release();
-    }
-  }
-  delete pPackedResource;
-  CFile::Delete(strTempFile);
-  return success;
+	CXBPackedResource* pPackedResource = new CXBPackedResource();
+	if ( SUCCEEDED( pPackedResource->Create( strTempFile.c_str(), 1, NULL ) ) )
+	{
+		LPDIRECT3DTEXTURE8 pTexture = pPackedResource->GetTexture((DWORD)0);
+		if ( pTexture )
+		{
+			D3DSURFACE_DESC descSurface;
+			if ( SUCCEEDED( pTexture->GetLevelDesc( 0, &descSurface ) ) )
+			{
+				int iHeight = descSurface.Height;
+				int iWidth = descSurface.Width;
+				DWORD dwFormat = descSurface.Format;
+				CPicture pic;
+				success = pic.CreateThumbnailFromSwizzledTexture(pTexture, iHeight, iWidth, strIcon.c_str());
+			}
+			pTexture->Release();
+		}
+	}
+	delete pPackedResource;
+	CFile::Delete(strTempFile);
+	return success;
 }
 
 bool CUtil::GetDirectoryName(const CStdString& strFileName, CStdString& strDescription)
 {
-  CStdString strFName = URIUtils::GetFileName(strFileName);
-  strDescription = strFileName.Left(strFileName.size() - strFName.size());
-  URIUtils::RemoveSlashAtEnd(strDescription);
+	CStdString strFName = URIUtils::GetFileName(strFileName);
+	strDescription = strFileName.Left(strFileName.size() - strFName.size());
+	URIUtils::RemoveSlashAtEnd(strDescription);
 
-  int iPos = strDescription.ReverseFind("\\");
-  if (iPos < 0)
-    iPos = strDescription.ReverseFind("/");
-  if (iPos >= 0)
-  {
-    CStdString strTmp = strDescription.Right(strDescription.size()-iPos-1);
-    strDescription = strTmp;//strDescription.Right(strDescription.size() - iPos - 1);
-  }
-  else if (strDescription.size() <= 0)
-    strDescription = strFName;
-  return true;
+	int iPos = strDescription.ReverseFind("\\");
+	if (iPos < 0)
+	iPos = strDescription.ReverseFind("/");
+	if (iPos >= 0)
+	{
+		CStdString strTmp = strDescription.Right(strDescription.size()-iPos-1);
+		strDescription = strTmp;//strDescription.Right(strDescription.size() - iPos - 1);
+	}
+	else if (strDescription.size() <= 0)
+	strDescription = strFName;
+	return true;
 }
 
 bool CUtil::GetXBEDescription(const CStdString& strFileName, CStdString& strDescription)
 {
-  _XBE_CERTIFICATE HC;
-  _XBE_HEADER HS;
+	_XBE_CERTIFICATE HC;
+	_XBE_HEADER HS;
 
-  FILE* hFile = fopen(strFileName.c_str(), "rb");
-  if (!hFile)
-  {
-    strDescription = URIUtils::GetFileName(strFileName);
-    return false;
-  }
-  fread(&HS, 1, sizeof(HS), hFile);
-  fseek(hFile, HS.XbeHeaderSize, SEEK_SET);
-  fread(&HC, 1, sizeof(HC), hFile);
-  fclose(hFile);
+	FILE* hFile = fopen(strFileName.c_str(), "rb");
+	if (!hFile)
+	{
+		strDescription = URIUtils::GetFileName(strFileName);
+		return false;
+	}
+	fread(&HS, 1, sizeof(HS), hFile);
+	fseek(hFile, HS.XbeCertificate, SEEK_SET);
+	fread(&HC, 1, sizeof(HC), hFile);
+	fclose(hFile);
 
-  // The XBE title is stored in WCHAR (UTF16) format
+	// The XBE title is stored in WCHAR (UTF16) format
 
-  // XBE titles can in fact use all 40 characters available to them,
-  // and thus are not necessarily NULL terminated
-  WCHAR TitleName[41];
-  wcsncpy(TitleName, HC.TitleName, 40);
-  TitleName[40] = 0;
-  if (wcslen(TitleName) > 0)
-  {
-    g_charsetConverter.wToUTF8(TitleName, strDescription);
-    return true;
-  }
-  strDescription = URIUtils::GetFileName(strFileName);
-  return false;
+	// XBE titles can in fact use all 40 characters available to them,
+	// and thus are not necessarily NULL terminated
+	WCHAR TitleName[41];
+	wcsncpy(TitleName, HC.TitleName, 40);
+	TitleName[40] = 0;
+	if (wcslen(TitleName) > 0)
+	{
+		g_charsetConverter.wToUTF8(TitleName, strDescription);
+		return true;
+	}
+	strDescription = URIUtils::GetFileName(strFileName);
+	return false;
 }
 
 bool CUtil::SetXBEDescription(const CStdString& strFileName, const CStdString& strDescription)
 {
-  _XBE_CERTIFICATE HC;
-  _XBE_HEADER HS;
+	_XBE_CERTIFICATE HC;
+	_XBE_HEADER HS;
 
-  FILE* hFile = fopen(strFileName.c_str(), "r+b");
-  fread(&HS, 1, sizeof(HS), hFile);
-  fseek(hFile, HS.XbeHeaderSize, SEEK_SET);
-  fread(&HC, 1, sizeof(HC), hFile);
-  fseek(hFile,HS.XbeHeaderSize, SEEK_SET);
+	FILE* hFile = fopen(strFileName.c_str(), "r+b");
+	fread(&HS, 1, sizeof(HS), hFile);
+	fseek(hFile, HS.XbeCertificate, SEEK_SET);
+	fread(&HC, 1, sizeof(HC), hFile);
+	fseek(hFile,HS.XbeCertificate, SEEK_SET);
 
-  // The XBE title is stored in WCHAR (UTF16)
+	// The XBE title is stored in WCHAR (UTF16)
 
-  CStdStringW shortDescription;
-  g_charsetConverter.utf8ToW(strDescription, shortDescription);
-  if (shortDescription.size() > 40)
-    shortDescription = shortDescription.Left(40);
-  wcsncpy(HC.TitleName, shortDescription.c_str(), 40);  // only allow 40 chars*/
-  fwrite(&HC,1,sizeof(HC),hFile);
-  fclose(hFile);
-  return true;
+	CStdStringW shortDescription;
+	g_charsetConverter.utf8ToW(strDescription, shortDescription);
+	if (shortDescription.size() > 40)
+	shortDescription = shortDescription.Left(40);
+	wcsncpy(HC.TitleName, shortDescription.c_str(), 40);  // only allow 40 chars*/
+	fwrite(&HC,1,sizeof(HC),hFile);
+	fclose(hFile);
+	return true;
 }
 
 DWORD CUtil::GetXbeID( const CStdString& strFilePath)
 {
-  DWORD dwReturn = 0;
+	DWORD dwReturn = 0;
 
-  DWORD dwCertificateLocation;
-  DWORD dwLoadAddress;
-  DWORD dwRead;
-  //  WCHAR wcTitle[41];
+	DWORD dwCertificateLocation;
+	DWORD dwLoadAddress;
+	DWORD dwRead;
+	//  WCHAR wcTitle[41];
 
-  CAutoPtrHandle hFile( CreateFile( strFilePath.c_str(),
-                                    GENERIC_READ,
-                                    FILE_SHARE_READ,
-                                    NULL,
-                                    OPEN_EXISTING,
-                                    FILE_ATTRIBUTE_NORMAL,
-                                    NULL ));
-  if ( hFile.isValid() )
-  {
-    if ( SetFilePointer( (HANDLE)hFile, 0x104, NULL, FILE_BEGIN ) == 0x104 )
-    {
-      if ( ReadFile( (HANDLE)hFile, &dwLoadAddress, 4, &dwRead, NULL ) )
-      {
-        if ( SetFilePointer( (HANDLE)hFile, 0x118, NULL, FILE_BEGIN ) == 0x118 )
-        {
-          if ( ReadFile( (HANDLE)hFile, &dwCertificateLocation, 4, &dwRead, NULL ) )
-          {
-            dwCertificateLocation -= dwLoadAddress;
-            // Add offset into file
-            dwCertificateLocation += 8;
-            if ( SetFilePointer( (HANDLE)hFile, dwCertificateLocation, NULL, FILE_BEGIN ) == dwCertificateLocation )
-            {
-              dwReturn = 0;
-              ReadFile( (HANDLE)hFile, &dwReturn, sizeof(DWORD), &dwRead, NULL );
-              if ( dwRead != sizeof(DWORD) )
-              {
-                dwReturn = 0;
-              }
-            }
+	CAutoPtrHandle hFile( CreateFile( strFilePath.c_str(),
+	GENERIC_READ,
+	FILE_SHARE_READ,
+	NULL,
+	OPEN_EXISTING,
+	FILE_ATTRIBUTE_NORMAL,
+	NULL ));
+	if ( hFile.isValid() )
+	{
+		if ( SetFilePointer( (HANDLE)hFile, 0x104, NULL, FILE_BEGIN ) == 0x104 )
+		{
+			if ( ReadFile( (HANDLE)hFile, &dwLoadAddress, 4, &dwRead, NULL ) )
+			{
+				if ( SetFilePointer( (HANDLE)hFile, 0x118, NULL, FILE_BEGIN ) == 0x118 )
+				{
+					if ( ReadFile( (HANDLE)hFile, &dwCertificateLocation, 4, &dwRead, NULL ) )
+					{
+						dwCertificateLocation -= dwLoadAddress;
+						// Add offset into file
+						dwCertificateLocation += 8;
+						if ( SetFilePointer( (HANDLE)hFile, dwCertificateLocation, NULL, FILE_BEGIN ) == dwCertificateLocation )
+						{
+							dwReturn = 0;
+							ReadFile( (HANDLE)hFile, &dwReturn, sizeof(DWORD), &dwRead, NULL );
+							if ( dwRead != sizeof(DWORD) )
+							{
+								dwReturn = 0;
+							}
+						}
 
-          }
-        }
-      }
-    }
-  }
+					}
+				}
+			}
+		}
+	}
 
-  return dwReturn;
+	return dwReturn;
 }
 
 void CUtil::CreateShortcut(CFileItem* pItem)
 {
-  if ( pItem->IsXBE() )
-  {
-    // xbe
-    pItem->SetIconImage("defaultProgram.png");
-    if ( !pItem->IsOnDVD() )
-    {
-      CStdString strDescription;
-      if (! CUtil::GetXBEDescription(pItem->GetPath(), strDescription))
-      {
-        CUtil::GetDirectoryName(pItem->GetPath(), strDescription);
-      }
-      if (strDescription.size())
-      {
-        CStdString strFname;
-        strFname = URIUtils::GetFileName(pItem->GetPath());
-        strFname.ToLower();
-        if (strFname != "dashupdate.xbe" && strFname != "downloader.xbe" && strFname != "update.xbe")
-        {
-          CShortcut cut;
-          cut.m_strPath = pItem->GetPath();
-          cut.Save(strDescription);
-        }
-      }
-    }
-  }
+	if ( pItem->IsXBE() )
+	{
+		// xbe
+		pItem->SetIconImage("defaultProgram.png");
+		if ( !pItem->IsOnDVD() )
+		{
+			CStdString strDescription;
+			if (! CUtil::GetXBEDescription(pItem->GetPath(), strDescription))
+			{
+				CUtil::GetDirectoryName(pItem->GetPath(), strDescription);
+			}
+			if (strDescription.size())
+			{
+				CStdString strFname;
+				strFname = URIUtils::GetFileName(pItem->GetPath());
+				strFname.ToLower();
+				if (strFname != "dashupdate.xbe" && strFname != "downloader.xbe" && strFname != "update.xbe")
+				{
+					CShortcut cut;
+					cut.m_strPath = pItem->GetPath();
+					cut.Save(strDescription);
+				}
+			}
+		}
+	}
 }
 
 void CUtil::GetFatXQualifiedPath(CStdString& strFileNameAndPath)
 {
-  // This routine gets rid of any "\\"'s at the start of the path.
-  // Should this be the case?
-  vector<CStdString> tokens;
-  CStdString strBasePath, strFileName;
+	// This routine gets rid of any "\\"'s at the start of the path.
+	// Should this be the case?
+	vector<CStdString> tokens;
+	CStdString strBasePath, strFileName;
 
-  // We need to check whether we must use forward (ie. special://)
-  // or backslashes (ie. Q:\)
-  CStdString sep;
-  if (strFileNameAndPath.c_str()[1] == ':' || strFileNameAndPath.Find('\\')>=0)
-  {
-    strFileNameAndPath.Replace('/', '\\');
-    sep="\\";
-  }
-  else
-  {
-//    strFileNameAndPath.Replace('\\', '/');
-    sep="/";
-  }
-  
-  if(strFileNameAndPath.Right(1) == sep)
-  {
-    strBasePath = strFileNameAndPath;
-    strFileName = "";
-  }
-  else
-  {
-    URIUtils::GetDirectory(strFileNameAndPath,strBasePath);
-    // TODO: GETDIR - is this required?  What happens to the tokenize below otherwise?
-    strFileName = URIUtils::GetFileName(strFileNameAndPath);
-  }
-  
-  StringUtils::SplitString(strBasePath,sep,tokens);
-  if (tokens.empty())
-    return; // nothing to do here (invalid path)
-  
-  strFileNameAndPath = tokens.front();
-  for (vector<CStdString>::iterator token=tokens.begin()+1;token != tokens.end();++token)
-  {
-    CStdString strToken = token->Left(42);
-    if (token->size() > 42)
-    {
-      // remove any spaces as a result of truncation (only):
-      while (strToken[strToken.size()-1] == ' ')
-        strToken.erase(strToken.size()-1);
-    }
-    CUtil::RemoveIllegalChars(strToken);
-    strFileNameAndPath += sep+strToken;
-  }
-  
-  if (!strFileName.IsEmpty())
-  {
-    CUtil::RemoveIllegalChars(strFileName);
-    
-    if (strFileName.Left(1) == sep)
-      strFileName.erase(0,1);
+	// We need to check whether we must use forward (ie. special://)
+	// or backslashes (ie. Q:\)
+	CStdString sep;
+	if (strFileNameAndPath.c_str()[1] == ':' || strFileNameAndPath.Find('\\')>=0)
+	{
+		strFileNameAndPath.Replace('/', '\\');
+		sep="\\";
+	}
+	else
+	{
+		//    strFileNameAndPath.Replace('\\', '/');
+		sep="/";
+	}
 
-    if (CUtil::ShortenFileName(strFileName))
-    {
-      CStdString strExtension;
-      URIUtils::GetExtension(strFileName, strExtension);
-      CStdString strNoExt(URIUtils::ReplaceExtension(strFileName, ""));
-      // remove any spaces as a result of truncation (only):
-      while (strNoExt[strNoExt.size()-1] == ' ')
-        strNoExt.erase(strNoExt.size()-1);
-      
-      strFileNameAndPath += strNoExt+strExtension;
-    }
-    else
-      strFileNameAndPath += strFileName;
-  }
+	if(strFileNameAndPath.Right(1) == sep)
+	{
+		strBasePath = strFileNameAndPath;
+		strFileName = "";
+	}
+	else
+	{
+		URIUtils::GetDirectory(strFileNameAndPath,strBasePath);
+		// TODO: GETDIR - is this required?  What happens to the tokenize below otherwise?
+		strFileName = URIUtils::GetFileName(strFileNameAndPath);
+	}
+
+	StringUtils::SplitString(strBasePath,sep,tokens);
+	if (tokens.empty())
+	return; // nothing to do here (invalid path)
+
+	strFileNameAndPath = tokens.front();
+	for (vector<CStdString>::iterator token=tokens.begin()+1;token != tokens.end();++token)
+	{
+		CStdString strToken = token->Left(42);
+		if (token->size() > 42)
+		{
+			// remove any spaces as a result of truncation (only):
+			while (strToken[strToken.size()-1] == ' ')
+			strToken.erase(strToken.size()-1);
+		}
+		CUtil::RemoveIllegalChars(strToken);
+		strFileNameAndPath += sep+strToken;
+	}
+
+	if (!strFileName.IsEmpty())
+	{
+		CUtil::RemoveIllegalChars(strFileName);
+		
+		if (strFileName.Left(1) == sep)
+		strFileName.erase(0,1);
+
+		if (CUtil::ShortenFileName(strFileName))
+		{
+			CStdString strExtension;
+			URIUtils::GetExtension(strFileName, strExtension);
+			CStdString strNoExt(URIUtils::ReplaceExtension(strFileName, ""));
+			// remove any spaces as a result of truncation (only):
+			while (strNoExt[strNoExt.size()-1] == ' ')
+			strNoExt.erase(strNoExt.size()-1);
+			
+			strFileNameAndPath += strNoExt+strExtension;
+		}
+		else
+		strFileNameAndPath += strFileName;
+	}
 }
 
 bool CUtil::ShortenFileName(CStdString& strFileNameAndPath)
 {
-  CStdString strFile = URIUtils::GetFileName(strFileNameAndPath);
-  if (strFile.size() > 42)
-  {
-    CStdString strExtension;
-    URIUtils::GetExtension(strFileNameAndPath, strExtension);
-    CStdString strPath = strFileNameAndPath.Left( strFileNameAndPath.size() - strFile.size() );
+	CStdString strFile = URIUtils::GetFileName(strFileNameAndPath);
+	if (strFile.size() > 42)
+	{
+		CStdString strExtension;
+		URIUtils::GetExtension(strFileNameAndPath, strExtension);
+		CStdString strPath = strFileNameAndPath.Left( strFileNameAndPath.size() - strFile.size() );
 
-    CRegExp reg;
-    CStdString strSearch=strFile; strSearch.ToLower();
-    reg.RegComp("([_\\-\\. ](cd|part)[0-9]*)[_\\-\\. ]");          // this is to ensure that cd1, cd2 or partXXX. do not
-    int matchPos = reg.RegFind(strSearch.c_str());                 // get cut from filenames when they are shortened.
+		CRegExp reg;
+		CStdString strSearch=strFile; strSearch.ToLower();
+		reg.RegComp("([_\\-\\. ](cd|part)[0-9]*)[_\\-\\. ]");          // this is to ensure that cd1, cd2 or partXXX. do not
+		int matchPos = reg.RegFind(strSearch.c_str());                 // get cut from filenames when they are shortened.
 
-    CStdString strPartNumber;
-    char* szPart = reg.GetReplaceString("\\1");
-    strPartNumber = szPart;
-    free(szPart);
+		CStdString strPartNumber;
+		char* szPart = reg.GetReplaceString("\\1");
+		strPartNumber = szPart;
+		free(szPart);
 
-    int partPos = 42 - strPartNumber.size() - strExtension.size();
+		int partPos = 42 - strPartNumber.size() - strExtension.size();
 
-    if (matchPos > partPos )
-    {
-       strFile = strFile.Left(partPos);
-       strFile += strPartNumber;
-    } 
-    else
-    {
-       strFile = strFile.Left(42 - strExtension.size());
-    }
-    strFile += strExtension;
+		if (matchPos > partPos )
+		{
+			strFile = strFile.Left(partPos);
+			strFile += strPartNumber;
+		} 
+		else
+		{
+			strFile = strFile.Left(42 - strExtension.size());
+		}
+		strFile += strExtension;
 
-    CStdString strNewFile = strPath;
-    if (!URIUtils::HasSlashAtEnd(strNewFile) && !strNewFile.IsEmpty())
-      strNewFile += "\\";
+		CStdString strNewFile = strPath;
+		if (!URIUtils::HasSlashAtEnd(strNewFile) && !strNewFile.IsEmpty())
+		strNewFile += "\\";
 
-    strNewFile += strFile;
-    strFileNameAndPath = strNewFile;
-    
-    // We shortened the file:
-    return true;
-  }
-  
-  return false;
+		strNewFile += strFile;
+		strFileNameAndPath = strNewFile;
+		
+		// We shortened the file:
+		return true;
+	}
+
+	return false;
 }
 
 
 void CUtil::GetDVDDriveIcon( const CStdString& strPath, CStdString& strIcon )
 {
-  if ( !CDetectDVDMedia::IsDiscInDrive() )
-  {
-    strIcon = "DefaultDVDEmpty.png";
-    return ;
-  }
+	if ( !CDetectDVDMedia::IsDiscInDrive() )
+	{
+		strIcon = "DefaultDVDEmpty.png";
+		return ;
+	}
 
-  if ( URIUtils::IsDVD(strPath) )
-  {
-    CCdInfo* pInfo = CDetectDVDMedia::GetCdInfo();
-    //  xbox DVD
-    if ( pInfo != NULL && pInfo->IsUDFX( 1 ) )
-    {
-      strIcon = "DefaultXboxDVD.png";
-      return ;
-    }
-    strIcon = "DefaultDVDRom.png";
-    return ;
-  }
+	if ( URIUtils::IsDVD(strPath) )
+	{
+		CCdInfo* pInfo = CDetectDVDMedia::GetCdInfo();
+		//  xbox DVD
+		if ( pInfo != NULL && pInfo->IsUDFX( 1 ) )
+		{
+			strIcon = "DefaultXboxDVD.png";
+			return ;
+		}
+		strIcon = "DefaultDVDRom.png";
+		return ;
+	}
 
-  if ( URIUtils::IsISO9660(strPath) )
-  {
-    CCdInfo* pInfo = CDetectDVDMedia::GetCdInfo();
-    if ( pInfo != NULL && pInfo->IsVideoCd( 1 ) )
-    {
-      strIcon = "DefaultVCD.png";
-      return ;
-    }
-    strIcon = "DefaultDVDRom.png";
-    return ;
-  }
+	if ( URIUtils::IsISO9660(strPath) )
+	{
+		CCdInfo* pInfo = CDetectDVDMedia::GetCdInfo();
+		if ( pInfo != NULL && pInfo->IsVideoCd( 1 ) )
+		{
+			strIcon = "DefaultVCD.png";
+			return ;
+		}
+		strIcon = "DefaultDVDRom.png";
+		return ;
+	}
 
-  if ( URIUtils::IsCDDA(strPath) )
-  {
-    strIcon = "DefaultCDDA.png";
-    return ;
-  }
+	if ( URIUtils::IsCDDA(strPath) )
+	{
+		strIcon = "DefaultCDDA.png";
+		return ;
+	}
 }
 
 void CUtil::RemoveTempFiles()
 {
-  CStdString searchPath = g_settings.GetDatabaseFolder();
-  CFileItemList items;
-  if (!XFILE::CDirectory::GetDirectory(searchPath, items, ".tmp", false))
-    return;
-  for (int i = 0; i < items.Size(); ++i)
-  {
-    if (items[i]->m_bIsFolder)
-      continue;
-    XFILE::CFile::Delete(items[i]->GetPath());
-  }
+	CStdString searchPath = g_settings.GetDatabaseFolder();
+	CFileItemList items;
+	if (!XFILE::CDirectory::GetDirectory(searchPath, items, ".tmp", false))
+	return;
+	for (int i = 0; i < items.Size(); ++i)
+	{
+		if (items[i]->m_bIsFolder)
+		continue;
+		XFILE::CFile::Delete(items[i]->GetPath());
+	}
 }
 
 void CUtil::DeleteGUISettings()
 {
-  // Load in master code first to ensure it's setting isn't reset
-  TiXmlDocument doc;
-  if (doc.LoadFile(g_settings.GetSettingsFile()))
-  {
-    g_guiSettings.LoadMasterLock(doc.RootElement());
-  }
-  // delete the settings file only
-  CLog::Log(LOGINFO, "  DeleteFile(%s)", g_settings.GetSettingsFile().c_str());
-  CFile::Delete(g_settings.GetSettingsFile());
+	// Load in master code first to ensure it's setting isn't reset
+	TiXmlDocument doc;
+	if (doc.LoadFile(g_settings.GetSettingsFile()))
+	{
+		g_guiSettings.LoadMasterLock(doc.RootElement());
+	}
+	// delete the settings file only
+	CLog::Log(LOGINFO, "  DeleteFile(%s)", g_settings.GetSettingsFile().c_str());
+	CFile::Delete(g_settings.GetSettingsFile());
 }
 
 void CUtil::RemoveIllegalChars( CStdString& strText)
 {
-  char szRemoveIllegal [1024];
-  strcpy(szRemoveIllegal , strText.c_str());
-  static char legalChars[] = " ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!#$%&'()-@[]^_`{}~.пхФфжіќјщшчрљъТёсяыьэтуцю№ђєѓѕїњ";
-  
-  char *cursor;
-  for (cursor = szRemoveIllegal; *(cursor += strspn(cursor, legalChars)); /**/ )
-  {
-    // Convert FatX illegal characters, if possible, to the closest "looking" character:
-    if (strchr("ТСРФУХ", (int) *cursor)) *cursor = 'A';
-    else
-    if (strchr("тсрфух", (int) *cursor)) *cursor = 'a';
-    else
-    if (strchr("дгвже", (int) *cursor)) *cursor = 'O';
-    else
-    if (strchr("єѓђіѕ", (int) *cursor)) *cursor = 'o';
-    else
-    if (strchr("лкйм", (int) *cursor)) *cursor = 'U';
-    else
-    if (strchr("ћњљќЕ", (int) *cursor)) *cursor = 'u';
-    else
-    if (strchr("ЪЩШЫ", (int) *cursor)) *cursor = 'E';
-    else
-    if (strchr("ъщшы", (int) *cursor)) *cursor = 'e';
-    else
-    if (strchr("ЮЭЬЯ", (int) *cursor)) *cursor = 'I';
-    else
-    if (strchr("юьэя", (int) *cursor)) *cursor = 'i';
-    else
-    *cursor = '_';
-  }
-  
-  strText = szRemoveIllegal;
+	char szRemoveIllegal [1024];
+	strcpy(szRemoveIllegal , strText.c_str());
+	static char legalChars[] = " ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!#$%&'()-@[]^_`{}~.пхФфжіќјщшчрљъТёсяыьэтуцю№ђєѓѕїњ";
+
+	char *cursor;
+	for (cursor = szRemoveIllegal; *(cursor += strspn(cursor, legalChars)); /**/ )
+	{
+		// Convert FatX illegal characters, if possible, to the closest "looking" character:
+		if (strchr("ТСРФУХ", (int) *cursor)) *cursor = 'A';
+		else
+		if (strchr("тсрфух", (int) *cursor)) *cursor = 'a';
+		else
+		if (strchr("дгвже", (int) *cursor)) *cursor = 'O';
+		else
+		if (strchr("єѓђіѕ", (int) *cursor)) *cursor = 'o';
+		else
+		if (strchr("лкйм", (int) *cursor)) *cursor = 'U';
+		else
+		if (strchr("ћњљќЕ", (int) *cursor)) *cursor = 'u';
+		else
+		if (strchr("ЪЩШЫ", (int) *cursor)) *cursor = 'E';
+		else
+		if (strchr("ъщшы", (int) *cursor)) *cursor = 'e';
+		else
+		if (strchr("ЮЭЬЯ", (int) *cursor)) *cursor = 'I';
+		else
+		if (strchr("юьэя", (int) *cursor)) *cursor = 'i';
+		else
+		*cursor = '_';
+	}
+
+	strText = szRemoveIllegal;
 }
 
 void CUtil::ClearSubtitles()
 {
-  //delete cached subs
-  CFileItemList items;
-  CDirectory::GetDirectory("special://temp/",items);
-  for( int i=0;i<items.Size();++i)
-  {
-    if (!items[i]->m_bIsFolder)
-    {
-      if ( items[i]->GetPath().Find("subtitle") >= 0 || items[i]->GetPath().Find("vobsub_queue") >= 0 )
-      {
-        CLog::Log(LOGDEBUG, "%s - Deleting temporary subtitle %s", __FUNCTION__, items[i]->GetPath().c_str());
-        CFile::Delete(items[i]->GetPath());
-      }
-    }
-  }
+	//delete cached subs
+	CFileItemList items;
+	CDirectory::GetDirectory("special://temp/",items);
+	for( int i=0;i<items.Size();++i)
+	{
+		if (!items[i]->m_bIsFolder)
+		{
+			if ( items[i]->GetPath().Find("subtitle") >= 0 || items[i]->GetPath().Find("vobsub_queue") >= 0 )
+			{
+				CLog::Log(LOGDEBUG, "%s - Deleting temporary subtitle %s", __FUNCTION__, items[i]->GetPath().c_str());
+				CFile::Delete(items[i]->GetPath());
+			}
+		}
+	}
 }
 
 static const char * sub_exts[] = { ".utf", ".utf8", ".utf-8", ".sub", ".srt", ".smi", ".rt", ".txt", ".ssa", ".aqt", ".jss", ".ass", ".idx", NULL};
@@ -1636,1736 +1744,1739 @@
 
 void CUtil::CacheSubtitles(const CStdString& strMovie, CStdString& strExtensionCached, XFILE::IFileCallback *pCallback )
 {
-  DWORD startTimer = timeGetTime();
-  CLog::Log(LOGDEBUG,"%s: START", __FUNCTION__);
+	DWORD startTimer = timeGetTime();
+	CLog::Log(LOGDEBUG,"%s: START", __FUNCTION__);
 
-  // new array for commons sub dirs
-  const char * common_sub_dirs[] = {"subs",
-                              "Subs",
-                              "subtitles",
-                              "Subtitles",
-                              "vobsubs",
-                              "Vobsubs",
-                              "sub",
-                              "Sub",
-                              "vobsub",
-                              "Vobsub",
-                              "subtitle",
-                              "Subtitle",
-                              NULL};
+	// new array for commons sub dirs
+	const char * common_sub_dirs[] = {"subs",
+		"Subs",
+		"subtitles",
+		"Subtitles",
+		"vobsubs",
+		"Vobsubs",
+		"sub",
+		"Sub",
+		"vobsub",
+		"Vobsub",
+		"subtitle",
+		"Subtitle",
+		NULL};
 
-  vector<CStdString> vecExtensionsCached;
-  strExtensionCached = "";
+	vector<CStdString> vecExtensionsCached;
+	strExtensionCached = "";
 
-  CFileItem item(strMovie, false);
-  if (item.IsInternetStream()) return ;
-  if (item.IsHDHomeRun()) return ;
-  if (item.IsSlingbox()) return ;
-  if (item.IsPlayList()) return ;
-  if (!item.IsVideo()) return ;
+	CFileItem item(strMovie, false);
+	if (item.IsInternetStream()) return ;
+	if (item.IsHDHomeRun()) return ;
+	if (item.IsSlingbox()) return ;
+	if (item.IsPlayList()) return ;
+	if (!item.IsVideo()) return ;
 
-  vector<CStdString> strLookInPaths;
+	vector<CStdString> strLookInPaths;
 
-  CStdString strFileName;
-  CStdString strPath;
+	CStdString strFileName;
+	CStdString strPath;
 
-  URIUtils::Split(strMovie, strPath, strFileName);
-  CStdString strFileNameNoExt(URIUtils::ReplaceExtension(strFileName, ""));
-  strLookInPaths.push_back(strPath);
+	URIUtils::Split(strMovie, strPath, strFileName);
+	CStdString strFileNameNoExt(URIUtils::ReplaceExtension(strFileName, ""));
+	strLookInPaths.push_back(strPath);
 
-  if (!g_settings.iAdditionalSubtitleDirectoryChecked && !g_guiSettings.GetString("subtitles.custompath").IsEmpty()) // to avoid checking non-existent directories (network) every time..
-  {
-    if (!g_application.getNetwork().IsAvailable() && !URIUtils::IsHD(g_guiSettings.GetString("subtitles.custompath")))
-    {
-      CLog::Log(LOGINFO,"CUtil::CacheSubtitles: disabling alternate subtitle directory for this session, it's nonaccessible");
-      g_settings.iAdditionalSubtitleDirectoryChecked = -1; // disabled
-    }
-    else if (!CDirectory::Exists(g_guiSettings.GetString("subtitles.custompath")))
-    {
-      CLog::Log(LOGINFO,"CUtil::CacheSubtitles: disabling alternate subtitle directory for this session, it's nonexistant");
-      g_settings.iAdditionalSubtitleDirectoryChecked = -1; // disabled
-    }
+	if (!g_settings.iAdditionalSubtitleDirectoryChecked && !g_guiSettings.GetString("subtitles.custompath").IsEmpty()) // to avoid checking non-existent directories (network) every time..
+	{
+		if (!g_application.getNetwork().IsAvailable() && !URIUtils::IsHD(g_guiSettings.GetString("subtitles.custompath")))
+		{
+			CLog::Log(LOGINFO,"CUtil::CacheSubtitles: disabling alternate subtitle directory for this session, it's nonaccessible");
+			g_settings.iAdditionalSubtitleDirectoryChecked = -1; // disabled
+		}
+		else if (!CDirectory::Exists(g_guiSettings.GetString("subtitles.custompath")))
+		{
+			CLog::Log(LOGINFO,"CUtil::CacheSubtitles: disabling alternate subtitle directory for this session, it's nonexistant");
+			g_settings.iAdditionalSubtitleDirectoryChecked = -1; // disabled
+		}
 
-    g_settings.iAdditionalSubtitleDirectoryChecked = 1;
-  }
+		g_settings.iAdditionalSubtitleDirectoryChecked = 1;
+	}
 
-  if (strMovie.substr(0,6) == "rar://") // <--- if this is found in main path then ignore it!
-  {
-    CURL url(strMovie);
-    CStdString strArchive = url.GetHostName();
-    URIUtils::Split(strArchive, strPath, strFileName);
-    strLookInPaths.push_back(strPath);
-  }
+	if (strMovie.substr(0,6) == "rar://") // <--- if this is found in main path then ignore it!
+	{
+		CURL url(strMovie);
+		CStdString strArchive = url.GetHostName();
+		URIUtils::Split(strArchive, strPath, strFileName);
+		strLookInPaths.push_back(strPath);
+	}
 
-  // checking if any of the common subdirs exist ..
-  CLog::Log(LOGDEBUG,"%s: Checking for common subdirs...", __FUNCTION__);
+	// checking if any of the common subdirs exist ..
+	CLog::Log(LOGDEBUG,"%s: Checking for common subdirs...", __FUNCTION__);
 
-  vector<CStdString> token;
-  Tokenize(strPath,token,"/\\");
-  if (token[token.size()-1].size() == 3 && token[token.size()-1].Mid(0,2).Equals("cd"))
-  {
-    CStdString strPath2;
-    URIUtils::GetParentPath(strPath,strPath2);
-    strLookInPaths.push_back(strPath2);
-  }
-  int iSize = strLookInPaths.size();
-  for (int i=0;i<iSize;++i)
-  {
-    for (int j=0; common_sub_dirs[j]; j++)
-    {
-      CStdString strPath2;
-      URIUtils::AddFileToFolder(strLookInPaths[i],common_sub_dirs[j],strPath2);
-      if (CDirectory::Exists(strPath2))
-        strLookInPaths.push_back(strPath2);
-    }
-  }
-  // .. done checking for common subdirs
+	vector<CStdString> token;
+	Tokenize(strPath,token,"/\\");
+	if (token[token.size()-1].size() == 3 && token[token.size()-1].Mid(0,2).Equals("cd"))
+	{
+		CStdString strPath2;
+		URIUtils::GetParentPath(strPath,strPath2);
+		strLookInPaths.push_back(strPath2);
+	}
+	int iSize = strLookInPaths.size();
+	for (int i=0;i<iSize;++i)
+	{
+		for (int j=0; common_sub_dirs[j]; j++)
+		{
+			CStdString strPath2;
+			URIUtils::AddFileToFolder(strLookInPaths[i],common_sub_dirs[j],strPath2);
+			if (CDirectory::Exists(strPath2))
+			strLookInPaths.push_back(strPath2);
+		}
+	}
+	// .. done checking for common subdirs
 
-  // check if there any cd-directories in the paths we have added so far
-  char temp[6];
-  iSize = strLookInPaths.size();
-  for (int i=0;i<9;++i) // 9 cd's
-  {
-    sprintf(temp,"cd%i",i+1);
-    for (int i=0;i<iSize;++i)
-    {
-      CStdString strPath2;
-      URIUtils::AddFileToFolder(strLookInPaths[i],temp,strPath2);
-      if (CDirectory::Exists(strPath2))
-        strLookInPaths.push_back(strPath2);
-    }
-  }
-  // .. done checking for cd-dirs
+	// check if there any cd-directories in the paths we have added so far
+	char temp[6];
+	iSize = strLookInPaths.size();
+	for (int i=0;i<9;++i) // 9 cd's
+	{
+		sprintf(temp,"cd%i",i+1);
+		for (int i=0;i<iSize;++i)
+		{
+			CStdString strPath2;
+			URIUtils::AddFileToFolder(strLookInPaths[i],temp,strPath2);
+			if (CDirectory::Exists(strPath2))
+			strLookInPaths.push_back(strPath2);
+		}
+	}
+	// .. done checking for cd-dirs
 
-  // this is last because we dont want to check any common subdirs or cd-dirs in the alternate <subtitles> dir.
-  if (g_settings.iAdditionalSubtitleDirectoryChecked == 1)
-  {
-    strPath = g_guiSettings.GetString("subtitles.custompath");
-    if (!URIUtils::HasSlashAtEnd(strPath))
-      strPath += "/"; //Should work for both remote and local files
-    strLookInPaths.push_back(strPath);
-  }
+	// this is last because we dont want to check any common subdirs or cd-dirs in the alternate <subtitles> dir.
+	if (g_settings.iAdditionalSubtitleDirectoryChecked == 1)
+	{
+		strPath = g_guiSettings.GetString("subtitles.custompath");
+		if (!URIUtils::HasSlashAtEnd(strPath))
+		strPath += "/"; //Should work for both remote and local files
+		strLookInPaths.push_back(strPath);
+	}
 
-  DWORD nextTimer = timeGetTime();
-  CLog::Log(LOGDEBUG,"%s: Done (time: %i ms)", __FUNCTION__, (int)(nextTimer - startTimer));
+	DWORD nextTimer = timeGetTime();
+	CLog::Log(LOGDEBUG,"%s: Done (time: %i ms)", __FUNCTION__, (int)(nextTimer - startTimer));
 
-  CStdString strLExt;
-  CStdString strDest;
-  CStdString strItem;
+	CStdString strLExt;
+	CStdString strDest;
+	CStdString strItem;
 
-  // 2 steps for movie directory and alternate subtitles directory
-  CLog::Log(LOGDEBUG,"%s: Searching for subtitles...", __FUNCTION__);
-  for (unsigned int step = 0; step < strLookInPaths.size(); step++)
-  {
-    if (strLookInPaths[step].length() != 0)
-    {
-      CFileItemList items;
+	// 2 steps for movie directory and alternate subtitles directory
+	CLog::Log(LOGDEBUG,"%s: Searching for subtitles...", __FUNCTION__);
+	for (unsigned int step = 0; step < strLookInPaths.size(); step++)
+	{
+		if (strLookInPaths[step].length() != 0)
+		{
+			CFileItemList items;
 
-      CDirectory::GetDirectory(strLookInPaths[step], items, ".utf|.utf8|.utf-8|.sub|.srt|.smi|.rt|.txt|.ssa|.text|.ssa|.aqt|.jss|.ass|.idx|.ifo|.rar|.zip", false, false, DIR_CACHE_NEVER, true);
-      int fnl = strFileNameNoExt.size();
+			CDirectory::GetDirectory(strLookInPaths[step], items, ".utf|.utf8|.utf-8|.sub|.srt|.smi|.rt|.txt|.ssa|.text|.ssa|.aqt|.jss|.ass|.idx|.ifo|.rar|.zip", false, false, DIR_CACHE_NEVER, true);
+			int fnl = strFileNameNoExt.size();
 
-      CStdString strFileNameNoExtNoCase(strFileNameNoExt);
-      strFileNameNoExtNoCase.MakeLower();
-      for (int j = 0; j < (int)items.Size(); j++)
-      {
-        URIUtils::Split(items[j]->GetPath(), strPath, strItem);
+			CStdString strFileNameNoExtNoCase(strFileNameNoExt);
+			strFileNameNoExtNoCase.MakeLower();
+			for (int j = 0; j < (int)items.Size(); j++)
+			{
+				URIUtils::Split(items[j]->GetPath(), strPath, strItem);
 
-        // is this a rar-file ..
-        if ((URIUtils::IsRAR(strItem) || URIUtils::IsZIP(strItem)) && g_guiSettings.GetBool("subtitles.searchrars"))
-        {
-          CStdString strRar, strItemWithPath;
-          URIUtils::AddFileToFolder(strLookInPaths[step],strFileNameNoExt+URIUtils::GetExtension(strItem),strRar);
-          URIUtils::AddFileToFolder(strLookInPaths[step],strItem,strItemWithPath);
+				// is this a rar-file ..
+				if ((URIUtils::IsRAR(strItem) || URIUtils::IsZIP(strItem)) && g_guiSettings.GetBool("subtitles.searchrars"))
+				{
+					CStdString strRar, strItemWithPath;
+					URIUtils::AddFileToFolder(strLookInPaths[step],strFileNameNoExt+URIUtils::GetExtension(strItem),strRar);
+					URIUtils::AddFileToFolder(strLookInPaths[step],strItem,strItemWithPath);
 
-          unsigned int iPos = strMovie.substr(0,6)=="rar://"?1:0;
-          iPos = strMovie.substr(0,6)=="zip://"?1:0;
-          if ((step != iPos) || (strFileNameNoExtNoCase+".rar").Equals(strItem) || (strFileNameNoExtNoCase+".zip").Equals(strItem))
-            CacheRarSubtitles(items[j]->GetPath(), strFileNameNoExtNoCase);
-        }
-        else
-        {
-          for (int i = 0; sub_exts[i]; i++)
-          {
-            int l = strlen(sub_exts[i]);
+					unsigned int iPos = strMovie.substr(0,6)=="rar://"?1:0;
+					iPos = strMovie.substr(0,6)=="zip://"?1:0;
+					if ((step != iPos) || (strFileNameNoExtNoCase+".rar").Equals(strItem) || (strFileNameNoExtNoCase+".zip").Equals(strItem))
+					CacheRarSubtitles(items[j]->GetPath(), strFileNameNoExtNoCase);
+				}
+				else
+				{
+					for (int i = 0; sub_exts[i]; i++)
+					{
+						int l = strlen(sub_exts[i]);
 
-            //Cache any alternate subtitles.
-            if (strItem.Left(9).ToLower() == "subtitle." && strItem.Right(l).ToLower() == sub_exts[i])
-            {
-              strLExt = strItem.Right(strItem.GetLength() - 9);
-              strDest.Format("special://temp/subtitle.alt-%s", strLExt);
-              if (CFile::Cache(items[j]->GetPath(), strDest, pCallback, NULL))
-              {
-                CLog::Log(LOGINFO, " cached subtitle %s->%s\n", strItem.c_str(), strDest.c_str());
-                strExtensionCached = strLExt;
-              }
-            }
+						//Cache any alternate subtitles.
+						if (strItem.Left(9).ToLower() == "subtitle." && strItem.Right(l).ToLower() == sub_exts[i])
+						{
+							strLExt = strItem.Right(strItem.GetLength() - 9);
+							strDest.Format("special://temp/subtitle.alt-%s", strLExt);
+							if (CFile::Cache(items[j]->GetPath(), strDest, pCallback, NULL))
+							{
+								CLog::Log(LOGINFO, " cached subtitle %s->%s\n", strItem.c_str(), strDest.c_str());
+								strExtensionCached = strLExt;
+							}
+						}
 
-            //Cache subtitle with same name as movie
-            if (strItem.Right(l).ToLower() == sub_exts[i] && strItem.Left(fnl).ToLower() == strFileNameNoExt.ToLower())
-            {
-              strLExt = strItem.Right(strItem.size() - fnl);
-              strDest.Format("special://temp/subtitle%s", strLExt);
-              if (CFile::Cache(items[j]->GetPath(), strDest, pCallback, NULL))
-                CLog::Log(LOGINFO, " cached subtitle %s->%s\n", strItem.c_str(), strDest.c_str());
-            }
-          }
-        }
-      }
-    }
-  }
-  CLog::Log(LOGDEBUG,"%s: Done (time: %i ms)", __FUNCTION__, (int)(timeGetTime() - nextTimer));
+						//Cache subtitle with same name as movie
+						if (strItem.Right(l).ToLower() == sub_exts[i] && strItem.Left(fnl).ToLower() == strFileNameNoExt.ToLower())
+						{
+							strLExt = strItem.Right(strItem.size() - fnl);
+							strDest.Format("special://temp/subtitle%s", strLExt);
+							if (CFile::Cache(items[j]->GetPath(), strDest, pCallback, NULL))
+							CLog::Log(LOGINFO, " cached subtitle %s->%s\n", strItem.c_str(), strDest.c_str());
+						}
+					}
+				}
+			}
+		}
+	}
+	CLog::Log(LOGDEBUG,"%s: Done (time: %i ms)", __FUNCTION__, (int)(timeGetTime() - nextTimer));
 
-  // build the vector with extensions
-  CFileItemList items;
-  CDirectory::GetDirectory("special://temp/", items,".utf|.utf8|.utf-8|.sub|.srt|.smi|.rt|.txt|.ssa|.text|.ssa|.aqt|.jss|.ass|.idx|.ifo|.rar|.zip",false);
-  for (int i=0;i<items.Size();++i)
-  {
-    if (items[i]->m_bIsFolder)
-      continue;
+	// build the vector with extensions
+	CFileItemList items;
+	CDirectory::GetDirectory("special://temp/", items,".utf|.utf8|.utf-8|.sub|.srt|.smi|.rt|.txt|.ssa|.text|.ssa|.aqt|.jss|.ass|.idx|.ifo|.rar|.zip",false);
+	for (int i=0;i<items.Size();++i)
+	{
+		if (items[i]->m_bIsFolder)
+		continue;
 
-    CStdString filename = URIUtils::GetFileName(items[i]->GetPath());
-    strLExt = filename.Right(filename.size()-8);
-    vecExtensionsCached.push_back(strLExt);
-    if (URIUtils::GetExtension(filename).Equals(".smi"))
-    {
-      //Cache multi-language sami subtitle
-      CDVDSubtitleStream* pStream = new CDVDSubtitleStream();
-      if(pStream->Open(items[i]->GetPath()))
-      {
-        CDVDSubtitleTagSami TagConv;
-        TagConv.LoadHead(pStream);
-        if (TagConv.m_Langclass.size() >= 2)
-        {
-          for (unsigned int k = 0; k < TagConv.m_Langclass.size(); k++)
-          {
-            strDest.Format("special://temp/subtitle.%s%s", TagConv.m_Langclass[k].Name, strLExt);
-            if (CFile::Cache(items[i]->GetPath(), strDest, pCallback, NULL))
-              CLog::Log(LOGINFO, " cached subtitle %s->%s\n", filename.c_str(), strDest.c_str());
-            CStdString strTemp;
-            strTemp.Format(".%s%s", TagConv.m_Langclass[k].Name, strLExt);
-            vecExtensionsCached.push_back(strTemp);
-          }
-        }
-      }
-      delete pStream;
-    }
-  }
+		CStdString filename = URIUtils::GetFileName(items[i]->GetPath());
+		strLExt = filename.Right(filename.size()-8);
+		vecExtensionsCached.push_back(strLExt);
+		if (URIUtils::GetExtension(filename).Equals(".smi"))
+		{
+			//Cache multi-language sami subtitle
+			CDVDSubtitleStream* pStream = new CDVDSubtitleStream();
+			if(pStream->Open(items[i]->GetPath()))
+			{
+				CDVDSubtitleTagSami TagConv;
+				TagConv.LoadHead(pStream);
+				if (TagConv.m_Langclass.size() >= 2)
+				{
+					for (unsigned int k = 0; k < TagConv.m_Langclass.size(); k++)
+					{
+						strDest.Format("special://temp/subtitle.%s%s", TagConv.m_Langclass[k].Name, strLExt);
+						if (CFile::Cache(items[i]->GetPath(), strDest, pCallback, NULL))
+						CLog::Log(LOGINFO, " cached subtitle %s->%s\n", filename.c_str(), strDest.c_str());
+						CStdString strTemp;
+						strTemp.Format(".%s%s", TagConv.m_Langclass[k].Name, strLExt);
+						vecExtensionsCached.push_back(strTemp);
+					}
+				}
+			}
+			delete pStream;
+		}
+	}
 
-  // construct string of added exts
-  for (vector<CStdString>::iterator it=vecExtensionsCached.begin(); it != vecExtensionsCached.end(); ++it)
-    strExtensionCached += *it+"|";
+	// construct string of added exts
+	for (vector<CStdString>::iterator it=vecExtensionsCached.begin(); it != vecExtensionsCached.end(); ++it)
+	strExtensionCached += *it+"|";
 
-  CLog::Log(LOGDEBUG,"%s: END (total time: %i ms)", __FUNCTION__, (int)(timeGetTime() - startTimer));
+	CLog::Log(LOGDEBUG,"%s: END (total time: %i ms)", __FUNCTION__, (int)(timeGetTime() - startTimer));
 }
 
 bool CUtil::CacheRarSubtitles(const CStdString& strRarPath, 
-                              const CStdString& strCompare)
+const CStdString& strCompare)
 {
-  bool bFoundSubs = false;
-  CFileItemList ItemList;
+	bool bFoundSubs = false;
+	CFileItemList ItemList;
 
-  // zip only gets the root dir
-  if (URIUtils::GetExtension(strRarPath).Equals(".zip"))
-  {
-    CStdString strZipPath;
-    URIUtils::CreateArchivePath(strZipPath,"zip",strRarPath,"");
-    if (!CDirectory::GetDirectory(strZipPath,ItemList,"",false))
-      return false;
-  }
-  else
-  {
-    // get _ALL_files in the rar, even those located in subdirectories because we set the bMask to false.
-    // so now we dont have to find any subdirs anymore, all files in the rar is checked.
-    if( !g_RarManager.GetFilesInRar(ItemList, strRarPath, false, "") )
-      return false;
-  }
-  for (int it= 0 ; it <ItemList.Size();++it)
-  {
-    CStdString strPathInRar = ItemList[it]->GetPath();
-    CStdString strExt = URIUtils::GetExtension(strPathInRar);
+	// zip only gets the root dir
+	if (URIUtils::GetExtension(strRarPath).Equals(".zip"))
+	{
+		CStdString strZipPath;
+		URIUtils::CreateArchivePath(strZipPath,"zip",strRarPath,"");
+		if (!CDirectory::GetDirectory(strZipPath,ItemList,"",false))
+		return false;
+	}
+	else
+	{
+		// get _ALL_files in the rar, even those located in subdirectories because we set the bMask to false.
+		// so now we dont have to find any subdirs anymore, all files in the rar is checked.
+		if( !g_RarManager.GetFilesInRar(ItemList, strRarPath, false, "") )
+		return false;
+	}
+	for (int it= 0 ; it <ItemList.Size();++it)
+	{
+		CStdString strPathInRar = ItemList[it]->GetPath();
+		CStdString strExt = URIUtils::GetExtension(strPathInRar);
 
-    CLog::Log(LOGDEBUG, "CacheRarSubs:: Found file %s", strPathInRar.c_str());
-    // always check any embedded rar archives
-    // checking for embedded rars, I moved this outside the sub_ext[] loop. We only need to check this once for each file.
-    if (URIUtils::IsRAR(strPathInRar) || URIUtils::IsZIP(strPathInRar))
-    {
-      CStdString strRarInRar;
-      if (URIUtils::GetExtension(strPathInRar).Equals(".rar"))
-        URIUtils::CreateArchivePath(strRarInRar, "rar", strRarPath, strPathInRar);
-      else
-        URIUtils::CreateArchivePath(strRarInRar, "zip", strRarPath, strPathInRar);
-      CacheRarSubtitles(strRarInRar,strCompare);
-    }
-    // done checking if this is a rar-in-rar
+		CLog::Log(LOGDEBUG, "CacheRarSubs:: Found file %s", strPathInRar.c_str());
+		// always check any embedded rar archives
+		// checking for embedded rars, I moved this outside the sub_ext[] loop. We only need to check this once for each file.
+		if (URIUtils::IsRAR(strPathInRar) || URIUtils::IsZIP(strPathInRar))
+		{
+			CStdString strRarInRar;
+			if (URIUtils::GetExtension(strPathInRar).Equals(".rar"))
+			URIUtils::CreateArchivePath(strRarInRar, "rar", strRarPath, strPathInRar);
+			else
+			URIUtils::CreateArchivePath(strRarInRar, "zip", strRarPath, strPathInRar);
+			CacheRarSubtitles(strRarInRar,strCompare);
+		}
+		// done checking if this is a rar-in-rar
 
-    int iPos=0;
-    CStdString strFileName = URIUtils::GetFileName(strPathInRar);
-    CStdString strFileNameNoCase(strFileName);
-    strFileNameNoCase.MakeLower();
-    if (strFileNameNoCase.Find(strCompare) >= 0)
-      while (sub_exts[iPos])
-      {
-        if (strExt.CompareNoCase(sub_exts[iPos]) == 0)
-        {
-          CStdString strSourceUrl;
-          if (URIUtils::GetExtension(strRarPath).Equals(".rar"))
-            URIUtils::CreateArchivePath(strSourceUrl, "rar", strRarPath, strPathInRar);
-          else
-            strSourceUrl = strPathInRar;
+		int iPos=0;
+		CStdString strFileName = URIUtils::GetFileName(strPathInRar);
+		CStdString strFileNameNoCase(strFileName);
+		strFileNameNoCase.MakeLower();
+		if (strFileNameNoCase.Find(strCompare) >= 0)
+		while (sub_exts[iPos])
+		{
+			if (strExt.CompareNoCase(sub_exts[iPos]) == 0)
+			{
+				CStdString strSourceUrl;
+				if (URIUtils::GetExtension(strRarPath).Equals(".rar"))
+				URIUtils::CreateArchivePath(strSourceUrl, "rar", strRarPath, strPathInRar);
+				else
+				strSourceUrl = strPathInRar;
 
-          CStdString strDestFile;
-          strDestFile.Format("special://temp/subtitle%s", sub_exts[iPos]);
+				CStdString strDestFile;
+				strDestFile.Format("special://temp/subtitle%s", sub_exts[iPos]);
 
-          if (CFile::Cache(strSourceUrl,strDestFile))
-          {
-            CLog::Log(LOGINFO, " cached subtitle %s->%s", strPathInRar.c_str(), strDestFile.c_str());
-            bFoundSubs = true;
-            break;
-          }
-        }
+				if (CFile::Cache(strSourceUrl,strDestFile))
+				{
+					CLog::Log(LOGINFO, " cached subtitle %s->%s", strPathInRar.c_str(), strDestFile.c_str());
+					bFoundSubs = true;
+					break;
+				}
+			}
 
-        iPos++;
-      }
-  }
-  return bFoundSubs;
+			iPos++;
+		}
+	}
+	return bFoundSubs;
 }
 
 void CUtil::PrepareSubtitleFonts()
 {
-  CStdString strFontPath = "special://xbmc/system/players/mplayer/font";
+	CStdString strFontPath = "special://xbmc/system/players/mplayer/font";
 
-  if( IsUsingTTFSubtitles()
-    || g_guiSettings.GetInt("subtitles.height") == 0
-    || g_guiSettings.GetString("subtitles.font").size() == 0)
-  {
-    /* delete all files in the font dir, so mplayer doesn't try to load them */
+	if( IsUsingTTFSubtitles()
+			|| g_guiSettings.GetInt("subtitles.height") == 0
+			|| g_guiSettings.GetString("subtitles.font").size() == 0)
+	{
+		/* delete all files in the font dir, so mplayer doesn't try to load them */
 
-    CStdString strSearchMask = strFontPath + "\\*.*";
-    WIN32_FIND_DATA wfd;
-    CAutoPtrFind hFind ( FindFirstFile(_P(strSearchMask).c_str(), &wfd));
-    if (hFind.isValid())
-    {
-      do
-      {
-        if(wfd.cFileName[0] == 0) continue;
-        if( (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 )
-          CFile::Delete(URIUtils::AddFileToFolder(strFontPath, wfd.cFileName));
-      }
-      while (FindNextFile((HANDLE)hFind, &wfd));
-    }
-  }
-  else
-  {
-    CStdString strPath;
-    strPath.Format("%s\\%s\\%i",
-                  strFontPath.c_str(),
-                  g_guiSettings.GetString("Subtitles.Font").c_str(),
-                  g_guiSettings.GetInt("Subtitles.Height"));
+		CStdString strSearchMask = strFontPath + "\\*.*";
+		WIN32_FIND_DATA wfd;
+		CAutoPtrFind hFind ( FindFirstFile(_P(strSearchMask).c_str(), &wfd));
+		if (hFind.isValid())
+		{
+			do
+			{
+				if(wfd.cFileName[0] == 0) continue;
+				if( (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 )
+				CFile::Delete(URIUtils::AddFileToFolder(strFontPath, wfd.cFileName));
+			}
+			while (FindNextFile((HANDLE)hFind, &wfd));
+		}
+	}
+	else
+	{
+		CStdString strPath;
+		strPath.Format("%s\\%s\\%i",
+		strFontPath.c_str(),
+		g_guiSettings.GetString("Subtitles.Font").c_str(),
+		g_guiSettings.GetInt("Subtitles.Height"));
 
-    CStdString strSearchMask = strPath + "\\*.*";
-    WIN32_FIND_DATA wfd;
-    CAutoPtrFind hFind ( FindFirstFile(_P(strSearchMask).c_str(), &wfd));
-    if (hFind.isValid())
-    {
-      do
-      {
-        if (wfd.cFileName[0] == 0) continue;
-        if ( (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 )
-        {
-          CStdString strSource = URIUtils::AddFileToFolder(strPath, wfd.cFileName);
-          CStdString strDest = URIUtils::AddFileToFolder(strFontPath, wfd.cFileName);
-          CFile::Cache(strSource, strDest);
-        }
-      }
-      while (FindNextFile((HANDLE)hFind, &wfd));
-    }
-  }
+		CStdString strSearchMask = strPath + "\\*.*";
+		WIN32_FIND_DATA wfd;
+		CAutoPtrFind hFind ( FindFirstFile(_P(strSearchMask).c_str(), &wfd));
+		if (hFind.isValid())
+		{
+			do
+			{
+				if (wfd.cFileName[0] == 0) continue;
+				if ( (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 )
+				{
+					CStdString strSource = URIUtils::AddFileToFolder(strPath, wfd.cFileName);
+					CStdString strDest = URIUtils::AddFileToFolder(strFontPath, wfd.cFileName);
+					CFile::Cache(strSource, strDest);
+				}
+			}
+			while (FindNextFile((HANDLE)hFind, &wfd));
+		}
+	}
 }
 
 __int64 CUtil::ToInt64(DWORD dwHigh, DWORD dwLow)
 {
-  __int64 n;
-  n = dwHigh;
-  n <<= 32;
-  n += dwLow;
-  return n;
+	__int64 n;
+	n = dwHigh;
+	n <<= 32;
+	n += dwLow;
+	return n;
 }
 
 bool CUtil::ThumbExists(const CStdString& strFileName, bool bAddCache)
 {
-  return CThumbnailCache::GetThumbnailCache()->ThumbExists(strFileName, bAddCache);
+	return CThumbnailCache::GetThumbnailCache()->ThumbExists(strFileName, bAddCache);
 }
 
 void CUtil::ThumbCacheAdd(const CStdString& strFileName, bool bFileExists)
 {
-  CThumbnailCache::GetThumbnailCache()->Add(strFileName, bFileExists);
+	CThumbnailCache::GetThumbnailCache()->Add(strFileName, bFileExists);
 }
 
 void CUtil::ThumbCacheClear()
 {
-  CThumbnailCache::GetThumbnailCache()->Clear();
+	CThumbnailCache::GetThumbnailCache()->Clear();
 }
 
 bool CUtil::ThumbCached(const CStdString& strFileName)
 {
-  return CThumbnailCache::GetThumbnailCache()->IsCached(strFileName);
+	return CThumbnailCache::GetThumbnailCache()->IsCached(strFileName);
 }
 
 void CUtil::PlayDVD()
 {
-  if (g_guiSettings.GetBool("dvds.useexternaldvdplayer") && !g_guiSettings.GetString("dvds.externaldvdplayer").IsEmpty())
-  {
-    RunXBE(g_guiSettings.GetString("dvds.externaldvdplayer").c_str());
-  }
-  else
-  {
-    CIoSupport::Dismount("Cdrom0");
-    CIoSupport::RemapDriveLetter('D', "Cdrom0");
-    CFileItem item("dvd://1", false);
-    item.SetLabel(CDetectDVDMedia::GetDVDLabel());
-    g_application.PlayFile(item);
-  }
+	if (g_guiSettings.GetBool("dvds.useexternaldvdplayer") && !g_guiSettings.GetString("dvds.externaldvdplayer").IsEmpty())
+	{
+		RunXBE(g_guiSettings.GetString("dvds.externaldvdplayer").c_str());
+	}
+	else
+	{
+		CIoSupport::Dismount("Cdrom0");
+		CIoSupport::RemapDriveLetter('D', "Cdrom0");
+		CFileItem item("dvd://1", false);
+		item.SetLabel(CDetectDVDMedia::GetDVDLabel());
+		g_application.PlayFile(item);
+	}
 }
 
 CStdString CUtil::GetNextFilename(const CStdString &fn_template, int max)
 {
-  if (!fn_template.Find("%03d"))
-    return "";
+	if (!fn_template.Find("%03d"))
+	return "";
 
-  CStdString searchPath;
-  URIUtils::GetDirectory(fn_template, searchPath);
-  CStdString mask = URIUtils::GetExtension(fn_template);
+	CStdString searchPath;
+	URIUtils::GetDirectory(fn_template, searchPath);
+	CStdString mask = URIUtils::GetExtension(fn_template);
 
-  CStdString name;
-  name.Format(fn_template.c_str(), 0);
+	CStdString name;
+	name.Format(fn_template.c_str(), 0);
 
-  CFileItemList items;
-  if (!CDirectory::GetDirectory(searchPath, items, mask, false))
-    return name;
+	CFileItemList items;
+	if (!CDirectory::GetDirectory(searchPath, items, mask, false))
+	return name;
 
-  items.SetFastLookup(true);
-  for (int i = 0; i <= max; i++)
-  {
-    CStdString name;
-    name.Format(fn_template.c_str(), i);
-    if (!items.Get(name))
-      return name;
-  }
-  return "";
+	items.SetFastLookup(true);
+	for (int i = 0; i <= max; i++)
+	{
+		CStdString name;
+		name.Format(fn_template.c_str(), i);
+		if (!items.Get(name))
+		return name;
+	}
+	return "";
 }
 
 void CUtil::InitGamma()
 {
-  g_graphicsContext.Get3DDevice()->GetGammaRamp(&oldramp);
+	g_graphicsContext.Get3DDevice()->GetGammaRamp(&oldramp);
 }
 void CUtil::RestoreBrightnessContrastGamma()
 {
-  g_graphicsContext.Lock();
-  g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &oldramp);
-  g_graphicsContext.Unlock();
+	g_graphicsContext.Lock();
+	g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &oldramp);
+	g_graphicsContext.Unlock();
 }
 
 void CUtil::SetBrightnessContrastGammaPercent(float brightness, float contrast, float gamma, bool immediate)
 {
-  if (brightness < 0) brightness = 0;
-  if (brightness > 100) brightness = 100;
-  if (contrast < 0) contrast = 0;
-  if (contrast > 100) contrast = 100;
-  if (gamma < 0) gamma = 0;
-  if (gamma > 100) gamma = 100;
+	if (brightness < 0) brightness = 0;
+	if (brightness > 100) brightness = 100;
+	if (contrast < 0) contrast = 0;
+	if (contrast > 100) contrast = 100;
+	if (gamma < 0) gamma = 0;
+	if (gamma > 100) gamma = 100;
 
-  float fBrightNess = brightness / 50.0f - 1.0f; // -1..1    Default: 0
-  float fContrast = contrast / 50.0f;            // 0..2     Default: 1
-  float fGamma = gamma / 40.0f + 0.5f;           // 0.5..3.0 Default: 1
-  CUtil::SetBrightnessContrastGamma(fBrightNess, fContrast, fGamma, immediate);
+	float fBrightNess = brightness / 50.0f - 1.0f; // -1..1    Default: 0
+	float fContrast = contrast / 50.0f;            // 0..2     Default: 1
+	float fGamma = gamma / 40.0f + 0.5f;           // 0.5..3.0 Default: 1
+	CUtil::SetBrightnessContrastGamma(fBrightNess, fContrast, fGamma, immediate);
 }
 
 void CUtil::SetBrightnessContrastGamma(float Brightness, float Contrast, float Gamma, bool bImmediate)
 {
-  // calculate ramp
-  D3DGAMMARAMP ramp;
+	// calculate ramp
+	D3DGAMMARAMP ramp;
 
-  Gamma = 1.0f / Gamma;
-  for (int i = 0; i < 256; ++i)
-  {
-    float f = (powf((float)i / 255.f, Gamma) * Contrast + Brightness) * 255.f;
-    ramp.blue[i] = ramp.green[i] = ramp.red[i] = clamp(f);
-  }
+	Gamma = 1.0f / Gamma;
+	for (int i = 0; i < 256; ++i)
+	{
+		float f = (powf((float)i / 255.f, Gamma) * Contrast + Brightness) * 255.f;
+		ramp.blue[i] = ramp.green[i] = ramp.red[i] = clamp(f);
+	}
 
-  // set ramp next v sync
-  g_graphicsContext.Lock();
-  g_graphicsContext.Get3DDevice()->SetGammaRamp(bImmediate ? GAMMA_RAMP_FLAG : 0, &ramp);
-  g_graphicsContext.Unlock();
+	// set ramp next v sync
+	g_graphicsContext.Lock();
+	g_graphicsContext.Get3DDevice()->SetGammaRamp(bImmediate ? GAMMA_RAMP_FLAG : 0, &ramp);
+	g_graphicsContext.Unlock();
 }
 
 
 void CUtil::Tokenize(const CStdString& path, vector<CStdString>& tokens, const string& delimiters)
 {
-  // Tokenize ripped from http://www.linuxselfhelp.com/HOWTO/C++Programming-HOWTO-7.html
-  // Skip delimiters at beginning.
-  string::size_type lastPos = path.find_first_not_of(delimiters, 0);
-  // Find first "non-delimiter".
-  string::size_type pos = path.find_first_of(delimiters, lastPos);
+	// Tokenize ripped from http://www.linuxselfhelp.com/HOWTO/C++Programming-HOWTO-7.html
+	// Skip delimiters at beginning.
+	string::size_type lastPos = path.find_first_not_of(delimiters, 0);
+	// Find first "non-delimiter".
+	string::size_type pos = path.find_first_of(delimiters, lastPos);
 
-  while (string::npos != pos || string::npos != lastPos)
-  {
-    // Found a token, add it to the vector.
-    tokens.push_back(path.substr(lastPos, pos - lastPos));
-    // Skip delimiters.  Note the "not_of"
-    lastPos = path.find_first_not_of(delimiters, pos);
-    // Find next "non-delimiter"
-    pos = path.find_first_of(delimiters, lastPos);
-  }
+	while (string::npos != pos || string::npos != lastPos)
+	{
+		// Found a token, add it to the vector.
+		tokens.push_back(path.substr(lastPos, pos - lastPos));
+		// Skip delimiters.  Note the "not_of"
+		lastPos = path.find_first_not_of(delimiters, pos);
+		// Find next "non-delimiter"
+		pos = path.find_first_of(delimiters, lastPos);
+	}
 }
 
 
 void CUtil::FlashScreen(bool bImmediate, bool bOn)
 {
-  static bool bInFlash = false;
+	static bool bInFlash = false;
 
-  if (bInFlash == bOn)
-    return ;
-  bInFlash = bOn;
-  g_graphicsContext.Lock();
-  if (bOn)
-  {
-    g_graphicsContext.Get3DDevice()->GetGammaRamp(&flashramp);
-    SetBrightnessContrastGamma(0.5f, 1.2f, 2.0f, bImmediate);
-  }
-  else
-    g_graphicsContext.Get3DDevice()->SetGammaRamp(bImmediate ? GAMMA_RAMP_FLAG : 0, &flashramp);
-  g_graphicsContext.Unlock();
+	if (bInFlash == bOn)
+	return ;
+	bInFlash = bOn;
+	g_graphicsContext.Lock();
+	if (bOn)
+	{
+		g_graphicsContext.Get3DDevice()->GetGammaRamp(&flashramp);
+		SetBrightnessContrastGamma(0.5f, 1.2f, 2.0f, bImmediate);
+	}
+	else
+	g_graphicsContext.Get3DDevice()->SetGammaRamp(bImmediate ? GAMMA_RAMP_FLAG : 0, &flashramp);
+	g_graphicsContext.Unlock();
 }
 
 void CUtil::TakeScreenshot(const CStdString& strFileName, bool flashScreen)
 {
-    LPDIRECT3DSURFACE8 lpSurface = NULL;
-    g_graphicsContext.Lock();
-    CStdString strFileNameTranslated = CSpecialProtocol::TranslatePath(strFileName);
-    if (g_application.IsPlayingVideo())
-    {
+	CreateDirectory("Q:\\system\\screenshots", NULL);
+	LPDIRECT3DSURFACE8 lpSurface = NULL;
+	g_graphicsContext.Lock();
+	CStdString strFileNameTranslated = CSpecialProtocol::TranslatePath(strFileName);
+	if (g_application.IsPlayingVideo())
+	{
 #ifdef HAS_VIDEO_PLAYBACK
-      g_renderManager.SetupScreenshot();
+		g_renderManager.SetupScreenshot();
 #endif
-    }
-    if (0)
-    { // reset calibration to defaults
-      OVERSCAN oscan;
-      memcpy(&oscan, &g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].Overscan, sizeof(OVERSCAN));
-      g_graphicsContext.ResetOverscan(g_graphicsContext.GetVideoResolution(), g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].Overscan);
-      g_application.Render();
-      memcpy(&g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].Overscan, &oscan, sizeof(OVERSCAN));
-    }
-    // now take screenshot
+	}
+	if (0)
+	{ // reset calibration to defaults
+		OVERSCAN oscan;
+		memcpy(&oscan, &g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].Overscan, sizeof(OVERSCAN));
+		g_graphicsContext.ResetOverscan(g_graphicsContext.GetVideoResolution(), g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].Overscan);
+		g_application.Render();
+		memcpy(&g_settings.m_ResInfo[g_graphicsContext.GetVideoResolution()].Overscan, &oscan, sizeof(OVERSCAN));
+	}
+	// now take screenshot
 #ifdef HAS_XBOX_D3D
-    g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
+	g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
 #endif
 #ifdef HAS_XBOX_D3D
-    if (SUCCEEDED(g_graphicsContext.Get3DDevice()->GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &lpSurface)))
+	if (SUCCEEDED(g_graphicsContext.Get3DDevice()->GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &lpSurface)))
 #else
-    g_application.RenderNoPresent();
-    if (SUCCEEDED(g_graphicsContext.Get3DDevice()->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpSurface)))
+	g_application.RenderNoPresent();
+	if (SUCCEEDED(g_graphicsContext.Get3DDevice()->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpSurface)))
 #endif
-    {
-      if (FAILED(XGWriteSurfaceToFile(lpSurface, strFileNameTranslated.c_str())))
-      {
-        CLog::Log(LOGERROR, "Failed to Generate Screenshot");
-      }
-      else
-      {
-        // hack - need to add it manually to the directory cache for both the special:// and the mapped
-        // folder due to CFile::Open on a special:// path being checked against both. Ideally we would use
-        // the XBMC Fileystem for writing the file. TODO.
-        g_directoryCache.AddFile(strFileName);
-        g_directoryCache.AddFile(strFileNameTranslated);
-        CLog::Log(LOGINFO, "Screen shot saved as %s", strFileNameTranslated.c_str());
-      }
-      lpSurface->Release();
-    }
-    g_graphicsContext.Unlock();
-    if (flashScreen)
-    {
+	{
+		if (FAILED(XGWriteSurfaceToFile(lpSurface, strFileNameTranslated.c_str())))
+		{
+			CLog::Log(LOGERROR, "Failed to Generate Screenshot");
+		}
+		else
+		{
+			// hack - need to add it manually to the directory cache for both the special:// and the mapped
+			// folder due to CFile::Open on a special:// path being checked against both. Ideally we would use
+			// the XBMC Fileystem for writing the file. TODO.
+			g_directoryCache.AddFile(strFileName);
+			g_directoryCache.AddFile(strFileNameTranslated);
+			CLog::Log(LOGINFO, "Screen shot saved as %s", strFileNameTranslated.c_str());
+		}
+		lpSurface->Release();
+	}
+	g_graphicsContext.Unlock();
+	if (flashScreen)
+	{
 #ifdef HAS_XBOX_D3D
-      g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
+		g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
 #endif
-      FlashScreen(true, true);
-      Sleep(10);
+		FlashScreen(true, true);
+		Sleep(10);
 #ifdef HAS_XBOX_D3D
-      g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
+		g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
 #endif
-      FlashScreen(true, false);
-    }
+		FlashScreen(true, false);
+	}
 }
 
 void CUtil::TakeScreenshot()
 {
-  static bool savingScreenshots = false;
-  static vector<CStdString> screenShots;
+	static bool savingScreenshots = false;
+	static vector<CStdString> screenShots;
 
-  bool promptUser = false;
-  // check to see if we have a screenshot folder yet
-  CStdString strDir = g_guiSettings.GetString("debug.screenshotpath", false);
-  if (strDir.IsEmpty())
-  {
-    strDir = "special://temp/";
-    if (!savingScreenshots)
-    {
-      promptUser = true;
-      savingScreenshots = true;
-      screenShots.clear();
-    }
-  }
-  URIUtils::RemoveSlashAtEnd(strDir);
+	bool promptUser = false;
+	// check to see if we have a screenshot folder yet
+	CStdString strDir = g_guiSettings.GetString("debug.screenshotpath", false);
+	if (strDir.IsEmpty())
+	{
+		strDir = "special://temp/";
+		if (!savingScreenshots)
+		{
+			promptUser = true;
+			savingScreenshots = true;
+			screenShots.clear();
+		}
+	}
+	URIUtils::RemoveSlashAtEnd(strDir);
 
-  if (!strDir.IsEmpty())
-  {
-    CStdString file = CUtil::GetNextFilename(URIUtils::AddFileToFolder(strDir, "screenshot%03d.bmp"), 999);
+	if (!strDir.IsEmpty())
+	{
+		CStdString file = CUtil::GetNextFilename(URIUtils::AddFileToFolder(strDir, "screenshot%03d.bmp"), 999);
 
-    if (!file.IsEmpty())
-    {
-      TakeScreenshot(file.c_str(), true);
-      if (savingScreenshots)
-        screenShots.push_back(file);
-      if (promptUser)
-      { // grab the real directory
-        CStdString newDir = g_guiSettings.GetString("debug.screenshotpath");
-        if (!newDir.IsEmpty())
-        {
-          for (unsigned int i = 0; i < screenShots.size(); i++)
-          {
-            CStdString file = CUtil::GetNextFilename(URIUtils::AddFileToFolder(newDir, "screenshot%03d.bmp"), 999);
-            CFile::Cache(screenShots[i], file);
-          }
-          screenShots.clear();
-        }
-        savingScreenshots = false;
-      }
-    }
-    else
-    {
-      CLog::Log(LOGWARNING, "Too many screen shots or invalid folder");
-    }
-  }
+		if (!file.IsEmpty())
+		{
+			TakeScreenshot(file.c_str(), true);
+			if (savingScreenshots)
+			screenShots.push_back(file);
+			if (promptUser)
+			{ // grab the real directory
+				CStdString newDir = g_guiSettings.GetString("debug.screenshotpath");
+				if (!newDir.IsEmpty())
+				{
+					for (unsigned int i = 0; i < screenShots.size(); i++)
+					{
+						CStdString file = CUtil::GetNextFilename(URIUtils::AddFileToFolder(newDir, "screenshot%03d.bmp"), 999);
+						CFile::Cache(screenShots[i], file);
+					}
+					screenShots.clear();
+				}
+				savingScreenshots = false;
+			}
+		}
+		else
+		{
+			CLog::Log(LOGWARNING, "Too many screen shots or invalid folder");
+		}
+	}
 }
 
 void CUtil::StatToStatI64(struct _stati64 *result, struct stat *stat)
 {
-  result->st_dev = stat->st_dev;
-  result->st_ino = stat->st_ino;
-  result->st_mode = stat->st_mode;
-  result->st_nlink = stat->st_nlink;
-  result->st_uid = stat->st_uid;
-  result->st_gid = stat->st_gid;
-  result->st_rdev = stat->st_rdev;
-  result->st_size = (__int64)stat->st_size;
+	result->st_dev = stat->st_dev;
+	result->st_ino = stat->st_ino;
+	result->st_mode = stat->st_mode;
+	result->st_nlink = stat->st_nlink;
+	result->st_uid = stat->st_uid;
+	result->st_gid = stat->st_gid;
+	result->st_rdev = stat->st_rdev;
+	result->st_size = (__int64)stat->st_size;
 
 #ifndef _LINUX
-  result->st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
-  result->st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
-  result->st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
+	result->st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
+	result->st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
+	result->st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
 #else
-  result->_st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
-  result->_st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
-  result->_st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
+	result->_st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
+	result->_st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
+	result->_st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
 #endif
 }
 
 void CUtil::Stat64ToStatI64(struct _stati64 *result, struct __stat64 *stat)
 {
-  result->st_dev = stat->st_dev;
-  result->st_ino = stat->st_ino;
-  result->st_mode = stat->st_mode;
-  result->st_nlink = stat->st_nlink;
-  result->st_uid = stat->st_uid;
-  result->st_gid = stat->st_gid;
-  result->st_rdev = stat->st_rdev;
-  result->st_size = stat->st_size;
+	result->st_dev = stat->st_dev;
+	result->st_ino = stat->st_ino;
+	result->st_mode = stat->st_mode;
+	result->st_nlink = stat->st_nlink;
+	result->st_uid = stat->st_uid;
+	result->st_gid = stat->st_gid;
+	result->st_rdev = stat->st_rdev;
+	result->st_size = stat->st_size;
 #ifndef _LINUX
-  result->st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
-  result->st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
-  result->st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
+	result->st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
+	result->st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
+	result->st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
 #else
-  result->_st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
-  result->_st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
-  result->_st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
+	result->_st_atime = (long)(stat->st_atime & 0xFFFFFFFF);
+	result->_st_mtime = (long)(stat->st_mtime & 0xFFFFFFFF);
+	result->_st_ctime = (long)(stat->st_ctime & 0xFFFFFFFF);
 #endif
 }
 
 void CUtil::StatI64ToStat64(struct __stat64 *result, struct _stati64 *stat)
 {
-  result->st_dev = stat->st_dev;
-  result->st_ino = stat->st_ino;
-  result->st_mode = stat->st_mode;
-  result->st_nlink = stat->st_nlink;
-  result->st_uid = stat->st_uid;
-  result->st_gid = stat->st_gid;
-  result->st_rdev = stat->st_rdev;
-  result->st_size = stat->st_size;
+	result->st_dev = stat->st_dev;
+	result->st_ino = stat->st_ino;
+	result->st_mode = stat->st_mode;
+	result->st_nlink = stat->st_nlink;
+	result->st_uid = stat->st_uid;
+	result->st_gid = stat->st_gid;
+	result->st_rdev = stat->st_rdev;
+	result->st_size = stat->st_size;
 #ifndef _LINUX
-  result->st_atime = stat->st_atime;
-  result->st_mtime = stat->st_mtime;
-  result->st_ctime = stat->st_ctime;
+	result->st_atime = stat->st_atime;
+	result->st_mtime = stat->st_mtime;
+	result->st_ctime = stat->st_ctime;
 #else
-  result->st_atime = stat->_st_atime;
-  result->st_mtime = stat->_st_mtime;
-  result->st_ctime = stat->_st_ctime;
+	result->st_atime = stat->_st_atime;
+	result->st_mtime = stat->_st_mtime;
+	result->st_ctime = stat->_st_ctime;
 #endif
 }
 
 void CUtil::Stat64ToStat(struct _stat *result, struct __stat64 *stat)
 {
-  result->st_dev = stat->st_dev;
-  result->st_ino = stat->st_ino;
-  result->st_mode = stat->st_mode;
-  result->st_nlink = stat->st_nlink;
-  result->st_uid = stat->st_uid;
-  result->st_gid = stat->st_gid;
-  result->st_rdev = stat->st_rdev;
+	result->st_dev = stat->st_dev;
+	result->st_ino = stat->st_ino;
+	result->st_mode = stat->st_mode;
+	result->st_nlink = stat->st_nlink;
+	result->st_uid = stat->st_uid;
+	result->st_gid = stat->st_gid;
+	result->st_rdev = stat->st_rdev;
 #ifndef _LINUX
-  if (stat->st_size <= LONG_MAX)
-    result->st_size = (_off_t)stat->st_size;
+	if (stat->st_size <= LONG_MAX)
+	result->st_size = (_off_t)stat->st_size;
 #else
-  if (sizeof(stat->st_size) <= sizeof(result->st_size) )
-    result->st_size = (off_t)stat->st_size;
+	if (sizeof(stat->st_size) <= sizeof(result->st_size) )
+	result->st_size = (off_t)stat->st_size;
 #endif
-  else
-  {
-    result->st_size = 0;
-    CLog::Log(LOGWARNING, "WARNING: File is larger than 32bit stat can handle, file size will be reported as 0 bytes");
-  }
-  result->st_atime = (time_t)(stat->st_atime & 0xFFFFFFFF);
-  result->st_mtime = (time_t)(stat->st_mtime & 0xFFFFFFFF);
-  result->st_ctime = (time_t)(stat->st_ctime & 0xFFFFFFFF);
+	else
+	{
+		result->st_size = 0;
+		CLog::Log(LOGWARNING, "WARNING: File is larger than 32bit stat can handle, file size will be reported as 0 bytes");
+	}
+	result->st_atime = (time_t)(stat->st_atime & 0xFFFFFFFF);
+	result->st_mtime = (time_t)(stat->st_mtime & 0xFFFFFFFF);
+	result->st_ctime = (time_t)(stat->st_ctime & 0xFFFFFFFF);
 }
 
 bool CUtil::CreateDirectoryEx(const CStdString& strPath)
 {
-  // Function to create all directories at once instead
-  // of calling CreateDirectory for every subdir.
-  // Creates the directory and subdirectories if needed.
+	// Function to create all directories at once instead
+	// of calling CreateDirectory for every subdir.
+	// Creates the directory and subdirectories if needed.
 
-  // return true if directory already exist
-  if (CDirectory::Exists(strPath)) return true;
-  
-  // we currently only allow HD and smb paths
-  if (!URIUtils::IsHD(strPath) && !URIUtils::IsSmb(strPath))
-  {
-    CLog::Log(LOGERROR,"%s called with an unsupported path: %s", __FUNCTION__, strPath.c_str());
-    return false;
-  }
-  
-  CStdStringArray dirs = URIUtils::SplitPath(strPath);
-  CStdString dir(dirs.front());
-  URIUtils::AddSlashAtEnd(dir);
-  for (CStdStringArray::iterator it = dirs.begin() + 1; it != dirs.end(); it ++)
-  {
-    dir = URIUtils::AddFileToFolder(dir, *it);
-    CDirectory::Create(dir);
-  }
-  
-  // was the final destination directory successfully created ?
-  if (!CDirectory::Exists(strPath)) return false;
-  return true;
+	// return true if directory already exist
+	if (CDirectory::Exists(strPath)) return true;
+
+	// we currently only allow HD and smb paths
+	if (!URIUtils::IsHD(strPath) && !URIUtils::IsSmb(strPath))
+	{
+		CLog::Log(LOGERROR,"%s called with an unsupported path: %s", __FUNCTION__, strPath.c_str());
+		return false;
+	}
+
+	CStdStringArray dirs = URIUtils::SplitPath(strPath);
+	CStdString dir(dirs.front());
+	URIUtils::AddSlashAtEnd(dir);
+	for (CStdStringArray::iterator it = dirs.begin() + 1; it != dirs.end(); it ++)
+	{
+		dir = URIUtils::AddFileToFolder(dir, *it);
+		CDirectory::Create(dir);
+	}
+
+	// was the final destination directory successfully created ?
+	if (!CDirectory::Exists(strPath)) return false;
+	return true;
 }
 
 CStdString CUtil::MakeLegalFileName(const CStdString &strFile, int LegalType)
 {
-  CStdString result = strFile;
+	CStdString result = strFile;
 
-  result.Replace('/', '_');
-  result.Replace('\\', '_');
-  result.Replace('?', '_');
+	result.Replace('/', '_');
+	result.Replace('\\', '_');
+	result.Replace('?', '_');
 
-  if (LegalType == LEGAL_WIN32_COMPAT)
-  {
-    // just filter out some illegal characters on windows
-    result.Replace(':', '_');
-    result.Replace('*', '_');
-    result.Replace('?', '_');
-    result.Replace('\"', '_');
-    result.Replace('<', '_');
-    result.Replace('>', '_');
-    result.Replace('|', '_');
-    result.TrimRight(".");
-    result.TrimRight(" ");
-  }
+	if (LegalType == LEGAL_WIN32_COMPAT)
+	{
+		// just filter out some illegal characters on windows
+		result.Replace(':', '_');
+		result.Replace('*', '_');
+		result.Replace('?', '_');
+		result.Replace('\"', '_');
+		result.Replace('<', '_');
+		result.Replace('>', '_');
+		result.Replace('|', '_');
+		result.TrimRight(".");
+		result.TrimRight(" ");
+	}
 
-  // check if the filename is a legal FATX one.
-  if (LegalType == LEGAL_FATX) 
-  {
-    result.Replace(':', '_');
-    result.Replace('*', '_');
-    result.Replace('?', '_');
-    result.Replace('\"', '_');
-    result.Replace('<', '_');
-    result.Replace('>', '_');
-    result.Replace('|', '_');
-    result.Replace(',', '_');
-    result.Replace('=', '_');
-    result.Replace('+', '_');
-    result.Replace(';', '_');
-    result.Replace('"', '_');
-    result.Replace('\'', '_');
-    result.TrimRight(".");
-    result.TrimRight(" ");
+	// check if the filename is a legal FATX one.
+	if (LegalType == LEGAL_FATX) 
+	{
+		result.Replace(':', '_');
+		result.Replace('*', '_');
+		result.Replace('?', '_');
+		result.Replace('\"', '_');
+		result.Replace('<', '_');
+		result.Replace('>', '_');
+		result.Replace('|', '_');
+		result.Replace(',', '_');
+		result.Replace('=', '_');
+		result.Replace('+', '_');
+		result.Replace(';', '_');
+		result.Replace('"', '_');
+		result.Replace('\'', '_');
+		result.TrimRight(".");
+		result.TrimRight(" ");
 
-    GetFatXQualifiedPath(result);
-  }
+		GetFatXQualifiedPath(result);
+	}
 
-  return result;
+	return result;
 }
 
 // legalize entire path
 CStdString CUtil::MakeLegalPath(const CStdString &strPathAndFile, int LegalType)
 {
-  if (URIUtils::IsStack(strPathAndFile))
-    return MakeLegalPath(CStackDirectory::GetFirstStackedFile(strPathAndFile));
-  if (URIUtils::IsMultiPath(strPathAndFile))
-    return MakeLegalPath(CMultiPathDirectory::GetFirstPath(strPathAndFile));
-  if (!URIUtils::IsHD(strPathAndFile) && !URIUtils::IsSmb(strPathAndFile))
-    return strPathAndFile; // we don't support writing anywhere except HD, SMB and NFS - no need to legalize path
+	if (URIUtils::IsStack(strPathAndFile))
+	return MakeLegalPath(CStackDirectory::GetFirstStackedFile(strPathAndFile));
+	if (URIUtils::IsMultiPath(strPathAndFile))
+	return MakeLegalPath(CMultiPathDirectory::GetFirstPath(strPathAndFile));
+	if (!URIUtils::IsHD(strPathAndFile) && !URIUtils::IsSmb(strPathAndFile))
+	return strPathAndFile; // we don't support writing anywhere except HD, SMB and NFS - no need to legalize path
 
-  bool trailingSlash = URIUtils::HasSlashAtEnd(strPathAndFile);
-  CStdStringArray dirs = URIUtils::SplitPath(strPathAndFile);
-  // we just add first token to path and don't legalize it - possible values: 
-  // "X:" (local win32), "" (local unix - empty string before '/') or
-  // "protocol://domain"
-  CStdString dir(dirs.front());
-  URIUtils::AddSlashAtEnd(dir);
-  for (CStdStringArray::iterator it = dirs.begin() + 1; it != dirs.end(); it ++)
-    dir = URIUtils::AddFileToFolder(dir, MakeLegalFileName(*it, LegalType));
-  if (trailingSlash) URIUtils::AddSlashAtEnd(dir);
-  return dir;
+	bool trailingSlash = URIUtils::HasSlashAtEnd(strPathAndFile);
+	CStdStringArray dirs = URIUtils::SplitPath(strPathAndFile);
+	// we just add first token to path and don't legalize it - possible values: 
+	// "X:" (local win32), "" (local unix - empty string before '/') or
+	// "protocol://domain"
+	CStdString dir(dirs.front());
+	URIUtils::AddSlashAtEnd(dir);
+	for (CStdStringArray::iterator it = dirs.begin() + 1; it != dirs.end(); it ++)
+	dir = URIUtils::AddFileToFolder(dir, MakeLegalFileName(*it, LegalType));
+	if (trailingSlash) URIUtils::AddSlashAtEnd(dir);
+	return dir;
 }
 
 CStdString CUtil::ValidatePath(const CStdString &path, bool bFixDoubleSlashes /* = false */)
 {
-  CStdString result = path;
+	CStdString result = path;
 
-  // Don't do any stuff on URLs containing %-characters or protocols that embed
-  // filenames. NOTE: Don't use IsInZip or IsInRar here since it will infinitely
-  // recurse and crash XBMC
-  if (URIUtils::IsURL(path) && 
-     (path.Find('%') >= 0 ||
-      path.Left(4).Equals("zip:") ||
-      path.Left(4).Equals("rar:") ||
-      path.Left(6).Equals("stack:") ||
-      path.Left(10).Equals("multipath:") ))
-    return result;
+	// Don't do any stuff on URLs containing %-characters or protocols that embed
+	// filenames. NOTE: Don't use IsInZip or IsInRar here since it will infinitely
+	// recurse and crash XBMC
+	if (URIUtils::IsURL(path) && 
+			(path.Find('%') >= 0 ||
+				path.Left(4).Equals("zip:") ||
+				path.Left(4).Equals("rar:") ||
+				path.Left(6).Equals("stack:") ||
+				path.Left(10).Equals("multipath:") ))
+	return result;
 
-  // check the path for incorrect slashes
-  if (URIUtils::IsDOSPath(path))
-  {
-    result.Replace('/', '\\');
-    /* The double slash correction should only be used when *absolutely*
-       necessary! This applies to certain DLLs or use from Python DLLs/scripts
-       that incorrectly generate double (back) slashes.
-    */
-    if (bFixDoubleSlashes)
-    {
-      // Fixup for double back slashes (but ignore the \\ of unc-paths)
-      for (int x = 1; x < result.GetLength() - 1; x++)
-      {
-        if (result[x] == '\\' && result[x+1] == '\\')
-          result.Delete(x);
-      }
-    }
-  }
-  else if (path.Find("://") >= 0 || path.Find(":\\\\") >= 0)
-  {
-    result.Replace('\\', '/');
-    /* The double slash correction should only be used when *absolutely*
-       necessary! This applies to certain DLLs or use from Python DLLs/scripts
-       that incorrectly generate double (back) slashes.
-    */
-    if (bFixDoubleSlashes)
-    {
-      // Fixup for double forward slashes(/) but don't touch the :// of URLs
-      for (int x = 2; x < result.GetLength() - 1; x++)
-      {
-        if ( result[x] == '/' && result[x + 1] == '/' && !(result[x - 1] == ':' || (result[x - 1] == '/' && result[x - 2] == ':')) )
-          result.Delete(x);
-      }
-    }
-  }
-  return result;
+	// check the path for incorrect slashes
+	if (URIUtils::IsDOSPath(path))
+	{
+		result.Replace('/', '\\');
+		/* The double slash correction should only be used when *absolutely*
+	necessary! This applies to certain DLLs or use from Python DLLs/scripts
+	that incorrectly generate double (back) slashes.
+	*/
+		if (bFixDoubleSlashes)
+		{
+			// Fixup for double back slashes (but ignore the \\ of unc-paths)
+			for (int x = 1; x < result.GetLength() - 1; x++)
+			{
+				if (result[x] == '\\' && result[x+1] == '\\')
+				result.Delete(x);
+			}
+		}
+	}
+	else if (path.Find("://") >= 0 || path.Find(":\\\\") >= 0)
+	{
+		result.Replace('\\', '/');
+		/* The double slash correction should only be used when *absolutely*
+	necessary! This applies to certain DLLs or use from Python DLLs/scripts
+	that incorrectly generate double (back) slashes.
+	*/
+		if (bFixDoubleSlashes)
+		{
+			// Fixup for double forward slashes(/) but don't touch the :// of URLs
+			for (int x = 2; x < result.GetLength() - 1; x++)
+			{
+				if ( result[x] == '/' && result[x + 1] == '/' && !(result[x - 1] == ':' || (result[x - 1] == '/' && result[x - 2] == ':')) )
+				result.Delete(x);
+			}
+		}
+	}
+	return result;
 }
 
 bool CUtil::IsUsingTTFSubtitles()
 {
-  return URIUtils::GetExtension(g_guiSettings.GetString("subtitles.font")).Equals(".ttf");
+	return URIUtils::GetExtension(g_guiSettings.GetString("subtitles.font")).Equals(".ttf");
 }
 
 void CUtil::SplitExecFunction(const CStdString &execString, CStdString &function, vector<CStdString> &parameters)
 {
-  CStdString paramString;
- 
-  int iPos = execString.Find("(");
-  int iPos2 = execString.ReverseFind(")");
-  if (iPos > 0 && iPos2 > 0)
-  {
-    paramString = execString.Mid(iPos + 1, iPos2 - iPos - 1);
-    function = execString.Left(iPos);
-  }
-  else
-    function = execString;
+	CStdString paramString;
 
-  // remove any whitespace, and the standard prefix (if it exists)
-  function.Trim();
-  if( function.Left(5).Equals("xbmc.", false) )
-    function.Delete(0, 5);
+	int iPos = execString.Find("(");
+	int iPos2 = execString.ReverseFind(")");
+	if (iPos > 0 && iPos2 > 0)
+	{
+		paramString = execString.Mid(iPos + 1, iPos2 - iPos - 1);
+		function = execString.Left(iPos);
+	}
+	else
+	function = execString;
 
-  SplitParams(paramString, parameters);
+	// remove any whitespace, and the standard prefix (if it exists)
+	function.Trim();
+	if( function.Left(5).Equals("xbmc.", false) )
+	function.Delete(0, 5);
+
+	SplitParams(paramString, parameters);
 }
 
 void CUtil::SplitParams(const CStdString &paramString, std::vector<CStdString> &parameters)
 {
-  bool inQuotes = false;
-  bool lastEscaped = false; // only every second character can be escaped
-  int inFunction = 0;
-  size_t whiteSpacePos = 0;
-  CStdString parameter;
-  parameters.clear();
-  for (size_t pos = 0; pos < paramString.size(); pos++)
-  {
-    char ch = paramString[pos];
-    bool escaped = (pos > 0 && paramString[pos - 1] == '\\' && !lastEscaped);
-    lastEscaped = escaped;
-    if (inQuotes)
-    { // if we're in a quote, we accept everything until the closing quote
-      if (ch == '\"' && !escaped)
-      { // finished a quote - no need to add the end quote to our string
-        inQuotes = false;
-      }
-    }
-    else
-    { // not in a quote, so check if we should be starting one
-      if (ch == '\"' && !escaped)
-      { // start of quote - no need to add the quote to our string
-        inQuotes = true;
-      }
-      if (inFunction && ch == ')')
-      { // end of a function
-        inFunction--;
-      }
-      if (ch == '(')
-      { // start of function
-        inFunction++;
-      }
-      if (!inFunction && ch == ',')
-      { // not in a function, so a comma signfies the end of this parameter
-        if (whiteSpacePos)
-          parameter = parameter.Left(whiteSpacePos);
-        // trim off start and end quotes
-        if (parameter.GetLength() > 1 && parameter[0] == '\"' && parameter[parameter.GetLength() - 1] == '\"')
-          parameter = parameter.Mid(1,parameter.GetLength() - 2);
-        parameters.push_back(parameter);
-        parameter.Empty();
-        whiteSpacePos = 0;
-        continue;
-      }
-    }
-    if ((ch == '\"' || ch == '\\') && escaped)
-    { // escaped quote or backslash
-      parameter[parameter.size()-1] = ch;
-      continue;
-    }
-    // whitespace handling - we skip any whitespace at the left or right of an unquoted parameter
-    if (ch == ' ' && !inQuotes)
-    {
-      if (parameter.IsEmpty()) // skip whitespace on left
-        continue;
-      if (!whiteSpacePos) // make a note of where whitespace starts on the right
-        whiteSpacePos = parameter.size();
-    }
-    else
-      whiteSpacePos = 0;
-    parameter += ch;
-  }
-  if (inFunction || inQuotes)
-    CLog::Log(LOGWARNING, "%s(%s) - end of string while searching for ) or \"", __FUNCTION__, paramString.c_str());
-  if (whiteSpacePos)
-    parameter = parameter.Left(whiteSpacePos);
-  // trim off start and end quotes
-  if (parameter.GetLength() > 1 && parameter[0] == '\"' && parameter[parameter.GetLength() - 1] == '\"')
-    parameter = parameter.Mid(1,parameter.GetLength() - 2);
-  if (!parameter.IsEmpty() || parameters.size())
-    parameters.push_back(parameter);
+	bool inQuotes = false;
+	bool lastEscaped = false; // only every second character can be escaped
+	int inFunction = 0;
+	size_t whiteSpacePos = 0;
+	CStdString parameter;
+	parameters.clear();
+	for (size_t pos = 0; pos < paramString.size(); pos++)
+	{
+		char ch = paramString[pos];
+		bool escaped = (pos > 0 && paramString[pos - 1] == '\\' && !lastEscaped);
+		lastEscaped = escaped;
+		if (inQuotes)
+		{ // if we're in a quote, we accept everything until the closing quote
+			if (ch == '\"' && !escaped)
+			{ // finished a quote - no need to add the end quote to our string
+				inQuotes = false;
+			}
+		}
+		else
+		{ // not in a quote, so check if we should be starting one
+			if (ch == '\"' && !escaped)
+			{ // start of quote - no need to add the quote to our string
+				inQuotes = true;
+			}
+			if (inFunction && ch == ')')
+			{ // end of a function
+				inFunction--;
+			}
+			if (ch == '(')
+			{ // start of function
+				inFunction++;
+			}
+			if (!inFunction && ch == ',')
+			{ // not in a function, so a comma signfies the end of this parameter
+				if (whiteSpacePos)
+				parameter = parameter.Left(whiteSpacePos);
+				// trim off start and end quotes
+				if (parameter.GetLength() > 1 && parameter[0] == '\"' && parameter[parameter.GetLength() - 1] == '\"')
+				parameter = parameter.Mid(1,parameter.GetLength() - 2);
+				parameters.push_back(parameter);
+				parameter.Empty();
+				whiteSpacePos = 0;
+				continue;
+			}
+		}
+		if ((ch == '\"' || ch == '\\') && escaped)
+		{ // escaped quote or backslash
+			parameter[parameter.size()-1] = ch;
+			continue;
+		}
+		// whitespace handling - we skip any whitespace at the left or right of an unquoted parameter
+		if (ch == ' ' && !inQuotes)
+		{
+			if (parameter.IsEmpty()) // skip whitespace on left
+			continue;
+			if (!whiteSpacePos) // make a note of where whitespace starts on the right
+			whiteSpacePos = parameter.size();
+		}
+		else
+		whiteSpacePos = 0;
+		parameter += ch;
+	}
+	if (inFunction || inQuotes)
+	CLog::Log(LOGWARNING, "%s(%s) - end of string while searching for ) or \"", __FUNCTION__, paramString.c_str());
+	if (whiteSpacePos)
+	parameter = parameter.Left(whiteSpacePos);
+	// trim off start and end quotes
+	if (parameter.GetLength() > 1 && parameter[0] == '\"' && parameter[parameter.GetLength() - 1] == '\"')
+	parameter = parameter.Mid(1,parameter.GetLength() - 2);
+	if (!parameter.IsEmpty() || parameters.size())
+	parameters.push_back(parameter);
 }
 
 int CUtil::GetMatchingSource(const CStdString& strPath1, VECSOURCES& VECSOURCES, bool& bIsSourceName)
 {
-  if (strPath1.IsEmpty())
-    return -1;
+	if (strPath1.IsEmpty())
+	return -1;
 
-  //CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, testing original path/name [%s]", strPath1.c_str());
+	//CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, testing original path/name [%s]", strPath1.c_str());
 
-  // copy as we may change strPath
-  CStdString strPath = strPath1;
+	// copy as we may change strPath
+	CStdString strPath = strPath1;
 
-  // Check for special protocols
-  CURL checkURL(strPath);
+	// Check for special protocols
+	CURL checkURL(strPath);
 
-  // stack://
-  if (checkURL.GetProtocol() == "stack")
-    strPath.Delete(0, 8); // remove the stack protocol
+	// stack://
+	if (checkURL.GetProtocol() == "stack")
+	strPath.Delete(0, 8); // remove the stack protocol
 
-  if (checkURL.GetProtocol() == "shout")
-    strPath = checkURL.GetHostName();
-  if (checkURL.GetProtocol() == "lastfm")
-    return 1;
-  if (checkURL.GetProtocol() == "tuxbox")
-    return 1;
-  if (checkURL.GetProtocol() == "plugin")
-    return 1;
-  if (checkURL.GetProtocol() == "multipath")
-    strPath = CMultiPathDirectory::GetFirstPath(strPath);
+	if (checkURL.GetProtocol() == "shout")
+	strPath = checkURL.GetHostName();
+	if (checkURL.GetProtocol() == "lastfm")
+	return 1;
+	if (checkURL.GetProtocol() == "tuxbox")
+	return 1;
+	if (checkURL.GetProtocol() == "plugin")
+	return 1;
+	if (checkURL.GetProtocol() == "multipath")
+	strPath = CMultiPathDirectory::GetFirstPath(strPath);
 
-  //CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, testing for matching name [%s]", strPath.c_str());
-  bIsSourceName = false;
-  int iIndex = -1;
-  int iLength = -1;
-  // we first test the NAME of a source
-  for (int i = 0; i < (int)VECSOURCES.size(); ++i)
-  {
-    CMediaSource share = VECSOURCES.at(i);
-    CStdString strName = share.strName;
+	//CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, testing for matching name [%s]", strPath.c_str());
+	bIsSourceName = false;
+	int iIndex = -1;
+	int iLength = -1;
+	// we first test the NAME of a source
+	for (int i = 0; i < (int)VECSOURCES.size(); ++i)
+	{
+		CMediaSource share = VECSOURCES.at(i);
+		CStdString strName = share.strName;
 
-    // special cases for dvds
-    if (URIUtils::IsOnDVD(share.strPath))
-    {
-      if (URIUtils::IsOnDVD(strPath))
-        return i;
+		// special cases for dvds
+		if (URIUtils::IsOnDVD(share.strPath))
+		{
+			if (URIUtils::IsOnDVD(strPath))
+			return i;
 
-      // not a path, so we need to modify the source name
-      // since we add the drive status and disc name to the source
-      // "Name (Drive Status/Disc Name)"
-      int iPos = strName.ReverseFind('(');
-      if (iPos > 1)
-        strName = strName.Mid(0, iPos - 1);
-    }
-    //CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, comparing name [%s]", strName.c_str());
-    if (strPath.Equals(strName))
-    {
-      bIsSourceName = true;
-      return i;
-    }
-  }
+			// not a path, so we need to modify the source name
+			// since we add the drive status and disc name to the source
+			// "Name (Drive Status/Disc Name)"
+			int iPos = strName.ReverseFind('(');
+			if (iPos > 1)
+			strName = strName.Mid(0, iPos - 1);
+		}
+		//CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, comparing name [%s]", strName.c_str());
+		if (strPath.Equals(strName))
+		{
+			bIsSourceName = true;
+			return i;
+		}
+	}
 
-  // now test the paths
+	// now test the paths
 
-  // remove user details, and ensure path only uses forward slashes
-  // and ends with a trailing slash so as not to match a substring
-  CURL urlDest(strPath);
-  urlDest.SetOptions("");
-  CStdString strDest = urlDest.GetWithoutUserDetails();
-  ForceForwardSlashes(strDest);
-  if (!URIUtils::HasSlashAtEnd(strDest))
-    strDest += "/";
-  int iLenPath = strDest.size();
+	// remove user details, and ensure path only uses forward slashes
+	// and ends with a trailing slash so as not to match a substring
+	CURL urlDest(strPath);
+	urlDest.SetOptions("");
+	CStdString strDest = urlDest.GetWithoutUserDetails();
+	ForceForwardSlashes(strDest);
+	if (!URIUtils::HasSlashAtEnd(strDest))
+	strDest += "/";
+	int iLenPath = strDest.size();
 
-  //CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, testing url [%s]", strDest.c_str());
+	//CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, testing url [%s]", strDest.c_str());
 
-  for (int i = 0; i < (int)VECSOURCES.size(); ++i)
-  {
-    CMediaSource share = VECSOURCES.at(i);
+	for (int i = 0; i < (int)VECSOURCES.size(); ++i)
+	{
+		CMediaSource share = VECSOURCES.at(i);
 
-    // does it match a source name?
-    if (share.strPath.substr(0,8) == "shout://")
-    {
-      CURL url(share.strPath);
-      if (strPath.Equals(url.GetHostName()))
-        return i;
-    }
+		// does it match a source name?
+		if (share.strPath.substr(0,8) == "shout://")
+		{
+			CURL url(share.strPath);
+			if (strPath.Equals(url.GetHostName()))
+			return i;
+		}
 
-    // doesnt match a name, so try the source path
-    vector<CStdString> vecPaths;
+		// doesnt match a name, so try the source path
+		vector<CStdString> vecPaths;
 
-    // add any concatenated paths if they exist
-    if (share.vecPaths.size() > 0)
-      vecPaths = share.vecPaths;
+		// add any concatenated paths if they exist
+		if (share.vecPaths.size() > 0)
+		vecPaths = share.vecPaths;
 
-    // add the actual share path at the front of the vector
-    vecPaths.insert(vecPaths.begin(), share.strPath);
+		// add the actual share path at the front of the vector
+		vecPaths.insert(vecPaths.begin(), share.strPath);
 
-    // test each path
-    for (int j = 0; j < (int)vecPaths.size(); ++j)
-    {
-      // remove user details, and ensure path only uses forward slashes
-      // and ends with a trailing slash so as not to match a substring
-      CURL urlShare(vecPaths[j]);
-      urlShare.SetOptions("");
-      CStdString strShare = urlShare.GetWithoutUserDetails();
-      ForceForwardSlashes(strShare);
-      if (!URIUtils::HasSlashAtEnd(strShare))
-        strShare += "/";
-      int iLenShare = strShare.size();
-      //CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, comparing url [%s]", strShare.c_str());
+		// test each path
+		for (int j = 0; j < (int)vecPaths.size(); ++j)
+		{
+			// remove user details, and ensure path only uses forward slashes
+			// and ends with a trailing slash so as not to match a substring
+			CURL urlShare(vecPaths[j]);
+			urlShare.SetOptions("");
+			CStdString strShare = urlShare.GetWithoutUserDetails();
+			ForceForwardSlashes(strShare);
+			if (!URIUtils::HasSlashAtEnd(strShare))
+			strShare += "/";
+			int iLenShare = strShare.size();
+			//CLog::Log(LOGDEBUG,"CUtil::GetMatchingSource, comparing url [%s]", strShare.c_str());
 
-      if ((iLenPath >= iLenShare) && (strDest.Left(iLenShare).Equals(strShare)) && (iLenShare > iLength))
-      {
-        //CLog::Log(LOGDEBUG,"Found matching source at index %i: [%s], Len = [%i]", i, strShare.c_str(), iLenShare);
+			if ((iLenPath >= iLenShare) && (strDest.Left(iLenShare).Equals(strShare)) && (iLenShare > iLength))
+			{
+				//CLog::Log(LOGDEBUG,"Found matching source at index %i: [%s], Len = [%i]", i, strShare.c_str(), iLenShare);
 
-        // if exact match, return it immediately
-        if (iLenPath == iLenShare)
-        {
-          // if the path EXACTLY matches an item in a concatentated path
-          // set source name to true to load the full virtualpath
-          bIsSourceName = false;
-          if (vecPaths.size() > 1)
-            bIsSourceName = true;
-          return i;
-        }
-        iIndex = i;
-        iLength = iLenShare;
-      }
-    }
-  }
+				// if exact match, return it immediately
+				if (iLenPath == iLenShare)
+				{
+					// if the path EXACTLY matches an item in a concatentated path
+					// set source name to true to load the full virtualpath
+					bIsSourceName = false;
+					if (vecPaths.size() > 1)
+					bIsSourceName = true;
+					return i;
+				}
+				iIndex = i;
+				iLength = iLenShare;
+			}
+		}
+	}
 
-  // return the index of the share with the longest match
-  if (iIndex == -1)
-  {
+	// return the index of the share with the longest match
+	if (iIndex == -1)
+	{
 
-    // rar:// and zip://
-    // if archive wasn't mounted, look for a matching share for the archive instead
-    if( strPath.Left(6).Equals("rar://") || strPath.Left(6).Equals("zip://") )
-    {
-      // get the hostname portion of the url since it contains the archive file
-      strPath = checkURL.GetHostName();
+		// rar:// and zip://
+		// if archive wasn't mounted, look for a matching share for the archive instead
+		if( strPath.Left(6).Equals("rar://") || strPath.Left(6).Equals("zip://") )
+		{
+			// get the hostname portion of the url since it contains the archive file
+			strPath = checkURL.GetHostName();
 
-      bIsSourceName = false;
-      bool bDummy;
-      return GetMatchingSource(strPath, VECSOURCES, bDummy);
-    }
+			bIsSourceName = false;
+			bool bDummy;
+			return GetMatchingSource(strPath, VECSOURCES, bDummy);
+		}
 
-    CLog::Log(LOGWARNING,"CUtil::GetMatchingSource... no matching source found for [%s]", strPath1.c_str());
-  }
-  return iIndex;
+		CLog::Log(LOGWARNING,"CUtil::GetMatchingSource... no matching source found for [%s]", strPath1.c_str());
+	}
+	return iIndex;
 }
 
 CStdString CUtil::TranslateSpecialSource(const CStdString &strSpecial)
 {
-  CStdString strReturn=strSpecial;
-  if (!strSpecial.IsEmpty() && strSpecial[0] == '$')
-  {
-    if (strSpecial.Left(5).Equals("$HOME"))
-      URIUtils::AddFileToFolder("special://home/", strSpecial.Mid(5), strReturn);
-    else if (strSpecial.Left(10).Equals("$SUBTITLES"))
-      URIUtils::AddFileToFolder("special://subtitles/", strSpecial.Mid(10), strReturn);
-    else if (strSpecial.Left(9).Equals("$USERDATA"))
-      URIUtils::AddFileToFolder("special://userdata/", strSpecial.Mid(9), strReturn);
-    else if (strSpecial.Left(9).Equals("$DATABASE"))
-      URIUtils::AddFileToFolder("special://database/", strSpecial.Mid(9), strReturn);
-    else if (strSpecial.Left(11).Equals("$THUMBNAILS"))
-      URIUtils::AddFileToFolder("special://thumbnails/", strSpecial.Mid(11), strReturn);
-    else if (strSpecial.Left(11).Equals("$RECORDINGS"))
-      URIUtils::AddFileToFolder("special://recordings/", strSpecial.Mid(11), strReturn);
-    else if (strSpecial.Left(12).Equals("$SCREENSHOTS"))
-      URIUtils::AddFileToFolder("special://screenshots/", strSpecial.Mid(12), strReturn);
-    else if (strSpecial.Left(15).Equals("$MUSICPLAYLISTS"))
-      URIUtils::AddFileToFolder("special://musicplaylists/", strSpecial.Mid(15), strReturn);
-    else if (strSpecial.Left(15).Equals("$VIDEOPLAYLISTS"))
-      URIUtils::AddFileToFolder("special://videoplaylists/", strSpecial.Mid(15), strReturn);
-    else if (strSpecial.Left(7).Equals("$CDRIPS"))
-      URIUtils::AddFileToFolder("special://cdrips/", strSpecial.Mid(7), strReturn);
-    // this one will be removed post 2.0
-    else if (strSpecial.Left(10).Equals("$PLAYLISTS"))
-      URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath",false), strSpecial.Mid(10), strReturn);
-  }
-  return strReturn;
+	CStdString strReturn=strSpecial;
+	if (!strSpecial.IsEmpty() && strSpecial[0] == '$')
+	{
+		if (strSpecial.Left(5).Equals("$HOME"))
+		URIUtils::AddFileToFolder("special://home/", strSpecial.Mid(5), strReturn);
+		if (strSpecial.Left(5).Equals("$ROOT"))
+		URIUtils::AddFileToFolder("special://root/", strSpecial.Mid(5), strReturn);
+		else if (strSpecial.Left(10).Equals("$SUBTITLES"))
+		URIUtils::AddFileToFolder("special://subtitles/", strSpecial.Mid(10), strReturn);
+		else if (strSpecial.Left(9).Equals("$USERDATA"))
+		URIUtils::AddFileToFolder("special://userdata/", strSpecial.Mid(9), strReturn);
+		else if (strSpecial.Left(9).Equals("$DATABASE"))
+		URIUtils::AddFileToFolder("special://database/", strSpecial.Mid(9), strReturn);
+		else if (strSpecial.Left(11).Equals("$THUMBNAILS"))
+		URIUtils::AddFileToFolder("special://thumbnails/", strSpecial.Mid(11), strReturn);
+		else if (strSpecial.Left(11).Equals("$RECORDINGS"))
+		URIUtils::AddFileToFolder("special://recordings/", strSpecial.Mid(11), strReturn);
+		else if (strSpecial.Left(12).Equals("$SCREENSHOTS"))
+		URIUtils::AddFileToFolder("special://screenshots/", strSpecial.Mid(12), strReturn);
+		else if (strSpecial.Left(15).Equals("$MUSICPLAYLISTS"))
+		URIUtils::AddFileToFolder("special://musicplaylists/", strSpecial.Mid(15), strReturn);
+		else if (strSpecial.Left(15).Equals("$VIDEOPLAYLISTS"))
+		URIUtils::AddFileToFolder("special://videoplaylists/", strSpecial.Mid(15), strReturn);
+		else if (strSpecial.Left(7).Equals("$CDRIPS"))
+		URIUtils::AddFileToFolder("special://cdrips/", strSpecial.Mid(7), strReturn);
+		// this one will be removed post 2.0
+		else if (strSpecial.Left(10).Equals("$PLAYLISTS"))
+		URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath",false), strSpecial.Mid(10), strReturn);
+	}
+	return strReturn;
 }
 
 CStdString CUtil::MusicPlaylistsLocation()
 {
-  vector<CStdString> vec;
-  CStdString strReturn;
-  URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "music", strReturn);
-  vec.push_back(strReturn);
-  URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "mixed", strReturn);
-  vec.push_back(strReturn);
-  return XFILE::CMultiPathDirectory::ConstructMultiPath(vec);;
+	vector<CStdString> vec;
+	CStdString strReturn;
+	URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "music", strReturn);
+	vec.push_back(strReturn);
+	URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "mixed", strReturn);
+	vec.push_back(strReturn);
+	return XFILE::CMultiPathDirectory::ConstructMultiPath(vec);;
 }
 
 CStdString CUtil::VideoPlaylistsLocation()
 {
-  vector<CStdString> vec;
-  CStdString strReturn;
-  URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "video", strReturn);
-  vec.push_back(strReturn);
-  URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "mixed", strReturn);
-  vec.push_back(strReturn);
-  return XFILE::CMultiPathDirectory::ConstructMultiPath(vec);;
+	vector<CStdString> vec;
+	CStdString strReturn;
+	URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "video", strReturn);
+	vec.push_back(strReturn);
+	URIUtils::AddFileToFolder(g_guiSettings.GetString("system.playlistspath"), "mixed", strReturn);
+	vec.push_back(strReturn);
+	return XFILE::CMultiPathDirectory::ConstructMultiPath(vec);;
 }
 
 void CUtil::DeleteMusicDatabaseDirectoryCache()
 {
-  CUtil::DeleteDirectoryCache("mdb-");
+	CUtil::DeleteDirectoryCache("mdb-");
 }
 
 void CUtil::DeleteVideoDatabaseDirectoryCache()
 {
-  CUtil::DeleteDirectoryCache("vdb-");
+	CUtil::DeleteDirectoryCache("vdb-");
 }
 
 void CUtil::DeleteDirectoryCache(const CStdString &prefix)
 {
-  CStdString searchPath = "special://temp/";
-  CFileItemList items;
-  if (!XFILE::CDirectory::GetDirectory(searchPath, items, ".fi", false))
-    return;
+	CStdString searchPath = "special://temp/";
+	CFileItemList items;
+	if (!XFILE::CDirectory::GetDirectory(searchPath, items, ".fi", false))
+	return;
 
-  for (int i = 0; i < items.Size(); ++i)
-  {
-    if (items[i]->m_bIsFolder)
-      continue;
-    CStdString fileName = URIUtils::GetFileName(items[i]->GetPath());
-    if (fileName.Left(prefix.GetLength()) == prefix)
-      XFILE::CFile::Delete(items[i]->GetPath());
-  }
+	for (int i = 0; i < items.Size(); ++i)
+	{
+		if (items[i]->m_bIsFolder)
+		continue;
+		CStdString fileName = URIUtils::GetFileName(items[i]->GetPath());
+		if (fileName.Left(prefix.GetLength()) == prefix)
+		XFILE::CFile::Delete(items[i]->GetPath());
+	}
 
 }
 
 bool CUtil::SetSysDateTimeYear(int iYear, int iMonth, int iDay, int iHour, int iMinute)
 {
-  TIME_ZONE_INFORMATION tziNew;
-  SYSTEMTIME CurTime;
-  SYSTEMTIME NewTime;
-  GetLocalTime(&CurTime);
-  GetLocalTime(&NewTime);
-  int iRescBiases, iHourUTC;
-  int iMinuteNew;
+	TIME_ZONE_INFORMATION tziNew;
+	SYSTEMTIME CurTime;
+	SYSTEMTIME NewTime;
+	GetLocalTime(&CurTime);
+	GetLocalTime(&NewTime);
+	int iRescBiases, iHourUTC;
+	int iMinuteNew;
 
-  DWORD dwRet = GetTimeZoneInformation(&tziNew);  // Get TimeZone Informations
-  float iGMTZone = (float(tziNew.Bias)/(60));     // Calc's the GMT Time
+	DWORD dwRet = GetTimeZoneInformation(&tziNew);  // Get TimeZone Informations
+	float iGMTZone = (float(tziNew.Bias)/(60));     // Calc's the GMT Time
 
-  CLog::Log(LOGDEBUG, "------------ TimeZone -------------");
-  CLog::Log(LOGDEBUG, "-      GMT Zone: GMT %.1f",iGMTZone);
-  CLog::Log(LOGDEBUG, "-          Bias: %lu minutes",tziNew.Bias);
-  CLog::Log(LOGDEBUG, "-  DaylightBias: %lu",tziNew.DaylightBias);
-  CLog::Log(LOGDEBUG, "-  StandardBias: %lu",tziNew.StandardBias);
+	CLog::Log(LOGDEBUG, "------------ TimeZone -------------");
+	CLog::Log(LOGDEBUG, "-      GMT Zone: GMT %.1f",iGMTZone);
+	CLog::Log(LOGDEBUG, "-          Bias: %lu minutes",tziNew.Bias);
+	CLog::Log(LOGDEBUG, "-  DaylightBias: %lu",tziNew.DaylightBias);
+	CLog::Log(LOGDEBUG, "-  StandardBias: %lu",tziNew.StandardBias);
 
-  switch (dwRet)
-  {
-    case TIME_ZONE_ID_STANDARD:
-      {
-        iRescBiases   = tziNew.Bias + tziNew.StandardBias;
-        CLog::Log(LOGDEBUG, "-   Timezone ID: 1, Standart");
-      }
-      break;
-    case TIME_ZONE_ID_DAYLIGHT:
-      {
-        iRescBiases   = tziNew.Bias + tziNew.StandardBias + tziNew.DaylightBias;
-        CLog::Log(LOGDEBUG, "-   Timezone ID: 2, Daylight");
-      }
-      break;
-    case TIME_ZONE_ID_UNKNOWN:
-      {
-        iRescBiases   = tziNew.Bias + tziNew.StandardBias;
-        CLog::Log(LOGDEBUG, "-   Timezone ID: 0, Unknown");
-      }
-      break;
-    case TIME_ZONE_ID_INVALID:
-      {
-        iRescBiases   = tziNew.Bias + tziNew.StandardBias;
-        CLog::Log(LOGDEBUG, "-   Timezone ID: Invalid");
-      }
-      break;
-    default:
-      iRescBiases   = tziNew.Bias + tziNew.StandardBias;
-  }
-    CLog::Log(LOGDEBUG, "--------------- END ---------------");
+	switch (dwRet)
+	{
+	case TIME_ZONE_ID_STANDARD:
+		{
+			iRescBiases   = tziNew.Bias + tziNew.StandardBias;
+			CLog::Log(LOGDEBUG, "-   Timezone ID: 1, Standart");
+		}
+		break;
+	case TIME_ZONE_ID_DAYLIGHT:
+		{
+			iRescBiases   = tziNew.Bias + tziNew.StandardBias + tziNew.DaylightBias;
+			CLog::Log(LOGDEBUG, "-   Timezone ID: 2, Daylight");
+		}
+		break;
+	case TIME_ZONE_ID_UNKNOWN:
+		{
+			iRescBiases   = tziNew.Bias + tziNew.StandardBias;
+			CLog::Log(LOGDEBUG, "-   Timezone ID: 0, Unknown");
+		}
+		break;
+	case TIME_ZONE_ID_INVALID:
+		{
+			iRescBiases   = tziNew.Bias + tziNew.StandardBias;
+			CLog::Log(LOGDEBUG, "-   Timezone ID: Invalid");
+		}
+		break;
+	default:
+		iRescBiases   = tziNew.Bias + tziNew.StandardBias;
+	}
+	CLog::Log(LOGDEBUG, "--------------- END ---------------");
 
-  // Calculation
-  iHourUTC = GMTZoneCalc(iRescBiases, iHour, iMinute, iMinuteNew);
-  iMinute = iMinuteNew;
-  if(iHourUTC <0)
-  {
-    iDay = iDay - 1;
-    iHourUTC =iHourUTC + 24;
-  }
-  if(iHourUTC >23)
-  {
-    iDay = iDay + 1;
-    iHourUTC =iHourUTC - 24;
-  }
+	// Calculation
+	iHourUTC = GMTZoneCalc(iRescBiases, iHour, iMinute, iMinuteNew);
+	iMinute = iMinuteNew;
+	if(iHourUTC <0)
+	{
+		iDay = iDay - 1;
+		iHourUTC =iHourUTC + 24;
+	}
+	if(iHourUTC >23)
+	{
+		iDay = iDay + 1;
+		iHourUTC =iHourUTC - 24;
+	}
 
-  // Set the New-,Detected Time Values to System Time!
-  NewTime.wYear     = (WORD)iYear;
-  NewTime.wMonth    = (WORD)iMonth;
-  NewTime.wDay      = (WORD)iDay;
-  NewTime.wHour     = (WORD)iHourUTC;
-  NewTime.wMinute   = (WORD)iMinute;
+	// Set the New-,Detected Time Values to System Time!
+	NewTime.wYear     = (WORD)iYear;
+	NewTime.wMonth    = (WORD)iMonth;
+	NewTime.wDay      = (WORD)iDay;
+	NewTime.wHour     = (WORD)iHourUTC;
+	NewTime.wMinute   = (WORD)iMinute;
 
-  FILETIME stNewTime, stCurTime;
-  SystemTimeToFileTime(&NewTime, &stNewTime);
-  SystemTimeToFileTime(&CurTime, &stCurTime);
+	FILETIME stNewTime, stCurTime;
+	SystemTimeToFileTime(&NewTime, &stNewTime);
+	SystemTimeToFileTime(&CurTime, &stCurTime);
 #ifdef HAS_XBOX_HARDWARE
-  bool bReturn=NT_SUCCESS(NtSetSystemTime(&stNewTime, &stCurTime));
+	bool bReturn=NT_SUCCESS(NtSetSystemTime(&stNewTime, &stCurTime));
 #else
-  bool bReturn(false);
+	bool bReturn(false);
 #endif
-  return bReturn;
+	return bReturn;
 }
 int CUtil::GMTZoneCalc(int iRescBiases, int iHour, int iMinute, int &iMinuteNew)
 {
-  int iHourUTC, iTemp;
-  iMinuteNew = iMinute;
-  iTemp = iRescBiases/60;
+	int iHourUTC, iTemp;
+	iMinuteNew = iMinute;
+	iTemp = iRescBiases/60;
 
-  if (iRescBiases == 0 )return iHour;   // GMT Zone 0, no need calculate
-  if (iRescBiases > 0)
-    iHourUTC = iHour + abs(iTemp);
-  else
-    iHourUTC = iHour - abs(iTemp);
+	if (iRescBiases == 0 )return iHour;   // GMT Zone 0, no need calculate
+	if (iRescBiases > 0)
+	iHourUTC = iHour + abs(iTemp);
+	else
+	iHourUTC = iHour - abs(iTemp);
 
-  if ((iTemp*60) != iRescBiases)
-  {
-    if (iRescBiases > 0)
-      iMinuteNew = iMinute + abs(iTemp*60 - iRescBiases);
-    else
-      iMinuteNew = iMinute - abs(iTemp*60 - iRescBiases);
+	if ((iTemp*60) != iRescBiases)
+	{
+		if (iRescBiases > 0)
+		iMinuteNew = iMinute + abs(iTemp*60 - iRescBiases);
+		else
+		iMinuteNew = iMinute - abs(iTemp*60 - iRescBiases);
 
-    if (iMinuteNew >= 60)
-    {
-      iMinuteNew = iMinuteNew -60;
-      iHourUTC = iHourUTC + 1;
-    }
-    else if (iMinuteNew < 0)
-    {
-      iMinuteNew = iMinuteNew +60;
-      iHourUTC = iHourUTC - 1;
-    }
-  }
-  return iHourUTC;
+		if (iMinuteNew >= 60)
+		{
+			iMinuteNew = iMinuteNew -60;
+			iHourUTC = iHourUTC + 1;
+		}
+		else if (iMinuteNew < 0)
+		{
+			iMinuteNew = iMinuteNew +60;
+			iHourUTC = iHourUTC - 1;
+		}
+	}
+	return iHourUTC;
 }
 
 bool CUtil::AutoDetection()
 {
-  bool bReturn=false;
-  if (g_guiSettings.GetBool("autodetect.onoff"))
-  {
-    static DWORD pingTimer = 0;
-    if( timeGetTime() - pingTimer < (DWORD)g_advancedSettings.m_autoDetectPingTime * 1000)
-      return false;
-    pingTimer = timeGetTime();
+	bool bReturn=false;
+	if (g_guiSettings.GetBool("autodetect.onoff"))
+	{
+		static DWORD pingTimer = 0;
+		if( timeGetTime() - pingTimer < (DWORD)g_advancedSettings.m_autoDetectPingTime * 1000)
+		return false;
+		pingTimer = timeGetTime();
 
-  // send ping and request new client info
-  if ( CUtil::AutoDetectionPing(
-    g_guiSettings.GetBool("Autodetect.senduserpw") ? g_guiSettings.GetString("services.ftpserveruser"):"anonymous",
-    g_guiSettings.GetBool("Autodetect.senduserpw") ? g_guiSettings.GetString("services.ftpserverpassword"):"anonymous",
-    g_guiSettings.GetString("autodetect.nickname"),21 /*Our FTP Port! TODO: Extract FTP from FTP Server settings!*/) )
-  {
-    CStdString strFTPPath, strNickName, strFtpUserName, strFtpPassword, strFtpPort, strBoosMode;
-    CStdStringArray arSplit;
-    // do we have clients in our list ?
-    for(unsigned int i=0; i < v_xboxclients.client_ip.size(); i++)
-    {
-      // extract client informations
-      StringUtils::SplitString(v_xboxclients.client_info[i],";", arSplit);
-      if ((int)arSplit.size() > 1 && !v_xboxclients.client_informed[i])
-      {
-        //extract client info and build the ftp link!
-        strNickName     = arSplit[0].c_str();
-        strFtpUserName  = arSplit[1].c_str();
-        strFtpPassword  = arSplit[2].c_str();
-        strFtpPort      = arSplit[3].c_str();
-        strBoosMode     = arSplit[4].c_str();
-        strFTPPath.Format("ftp://%s:%s@%s:%s/",strFtpUserName.c_str(),strFtpPassword.c_str(),v_xboxclients.client_ip[i],strFtpPort.c_str());
+		// send ping and request new client info
+		if ( CUtil::AutoDetectionPing(
+					g_guiSettings.GetBool("Autodetect.senduserpw") ? g_guiSettings.GetString("services.ftpserveruser"):"anonymous",
+					g_guiSettings.GetBool("Autodetect.senduserpw") ? g_guiSettings.GetString("services.ftpserverpassword"):"anonymous",
+					g_guiSettings.GetString("autodetect.nickname"),21 /*Our FTP Port! TODO: Extract FTP from FTP Server settings!*/) )
+		{
+			CStdString strFTPPath, strNickName, strFtpUserName, strFtpPassword, strFtpPort, strBoosMode;
+			CStdStringArray arSplit;
+			// do we have clients in our list ?
+			for(unsigned int i=0; i < v_xboxclients.client_ip.size(); i++)
+			{
+				// extract client informations
+				StringUtils::SplitString(v_xboxclients.client_info[i],";", arSplit);
+				if ((int)arSplit.size() > 1 && !v_xboxclients.client_informed[i])
+				{
+					//extract client info and build the ftp link!
+					strNickName     = arSplit[0].c_str();
+					strFtpUserName  = arSplit[1].c_str();
+					strFtpPassword  = arSplit[2].c_str();
+					strFtpPort      = arSplit[3].c_str();
+					strBoosMode     = arSplit[4].c_str();
+					strFTPPath.Format("ftp://%s:%s@%s:%s/",strFtpUserName.c_str(),strFtpPassword.c_str(),v_xboxclients.client_ip[i],strFtpPort.c_str());
 
-        //Do Notification for this Client
-        CStdString strtemplbl;
-        strtemplbl.Format("%s %s",strNickName, v_xboxclients.client_ip[i]);
-        g_application.m_guiDialogKaiToast.QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(1251), strtemplbl);
+					//Do Notification for this Client
+					CStdString strtemplbl;
+					strtemplbl.Format("%s %s",strNickName, v_xboxclients.client_ip[i]);
+					g_application.m_guiDialogKaiToast.QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(1251), strtemplbl);
 
-        //Debug Log
-        CLog::Log(LOGDEBUG,"%s: %s FTP-Link: %s", g_localizeStrings.Get(1251).c_str(), strNickName.c_str(), strFTPPath.c_str());
+					//Debug Log
+					CLog::Log(LOGDEBUG,"%s: %s FTP-Link: %s", g_localizeStrings.Get(1251).c_str(), strNickName.c_str(), strFTPPath.c_str());
 
-        //set the client_informed to TRUE, to prevent loop Notification
-        v_xboxclients.client_informed[i]=true;
+					//set the client_informed to TRUE, to prevent loop Notification
+					v_xboxclients.client_informed[i]=true;
 
-        //YES NO PopUP: ask for connecting to the detected client via Filemanger!
-        if (g_guiSettings.GetBool("autodetect.popupinfo") && CGUIDialogYesNo::ShowAndGetInput(1251, 0, 1257, 0))
-        {
-          g_windowManager.ActivateWindow(WINDOW_FILES, strFTPPath); //Open in MyFiles
-        }
-        bReturn = true;
-      }
-    }
-  }
-  }
-  return bReturn;
+					//YES NO PopUP: ask for connecting to the detected client via Filemanger!
+					if (g_guiSettings.GetBool("autodetect.popupinfo") && CGUIDialogYesNo::ShowAndGetInput(1251, 0, 1257, 0))
+					{
+						g_windowManager.ActivateWindow(WINDOW_FILES, strFTPPath); //Open in MyFiles
+					}
+					bReturn = true;
+				}
+			}
+		}
+	}
+	return bReturn;
 }
 
 bool CUtil::AutoDetectionPing(CStdString strFTPUserName, CStdString strFTPPass, CStdString strNickName, int iFTPPort)
 {
-  bool bFoundNewClient= false;
-  CStdString strLocalIP;
-  CStdString strSendMessage = "ping\0";
-  CStdString strReceiveMessage = "ping";
-  int iUDPPort = 4905;
-  char sztmp[512];
+	bool bFoundNewClient= false;
+	CStdString strLocalIP;
+	CStdString strSendMessage = "ping\0";
+	CStdString strReceiveMessage = "ping";
+	int iUDPPort = 4905;
+	char sztmp[512];
 
-  static int udp_server_socket, inited=0;
+	static int udp_server_socket, inited=0;
 	int cliLen, t1,t2,t3,t4, init_counter=0, life=0;
 
-  struct sockaddr_in	server;
-  struct sockaddr_in	cliAddr;
-  struct timeval timeout={0,500};
-  fd_set readfds;
+	struct sockaddr_in	server;
+	struct sockaddr_in	cliAddr;
+	struct timeval timeout={0,500};
+	fd_set readfds;
 #ifdef HAS_XBOX_HARDWARE
-    XNADDR xna;
-    DWORD dwState = XNetGetTitleXnAddr(&xna);
-    XNetInAddrToString(xna.ina,(char *)strLocalIP.c_str(),64);
+	XNADDR xna;
+	DWORD dwState = XNetGetTitleXnAddr(&xna);
+	XNetInAddrToString(xna.ina,(char *)strLocalIP.c_str(),64);
 #else
-    char hostname[255];
-    WORD wVer;
-    WSADATA wData;
-    PHOSTENT hostinfo;
-    wVer = MAKEWORD( 2, 0 );
-    if (WSAStartup(wVer,&wData) == 0)
-    {
-      if(gethostname(hostname,sizeof(hostname)) == 0)
-      {
-        if((hostinfo = gethostbyname(hostname)) != NULL)
-        {
-          strLocalIP = inet_ntoa (*(struct in_addr *)*hostinfo->h_addr_list);
-          strNickName.Format("%s",hostname);
-        }
-      }
-      WSACleanup();
-    }
+	char hostname[255];
+	WORD wVer;
+	WSADATA wData;
+	PHOSTENT hostinfo;
+	wVer = MAKEWORD( 2, 0 );
+	if (WSAStartup(wVer,&wData) == 0)
+	{
+		if(gethostname(hostname,sizeof(hostname)) == 0)
+		{
+			if((hostinfo = gethostbyname(hostname)) != NULL)
+			{
+				strLocalIP = inet_ntoa (*(struct in_addr *)*hostinfo->h_addr_list);
+				strNickName.Format("%s",hostname);
+			}
+		}
+		WSACleanup();
+	}
 #endif
-  // get IP address
-  sscanf( (char *)strLocalIP.c_str(), "%d.%d.%d.%d", &t1, &t2, &t3, &t4 );
-  if( !t1 ) return false;
-  cliLen = sizeof( cliAddr);
-  // setup UDP socket
-  if( !inited )
-  {
-    int tUDPsocket  = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
-	  char value      = 1;
-	  setsockopt( tUDPsocket, SOL_SOCKET, SO_BROADCAST, &value, value );
-	  struct sockaddr_in addr;
-	  memset(&(addr),0,sizeof(addr));
-	  addr.sin_family       = AF_INET;
-	  addr.sin_addr.s_addr  = INADDR_ANY;
-	  addr.sin_port         = htons(iUDPPort);
-	  bind(tUDPsocket,(struct sockaddr *)(&addr),sizeof(addr));
-    udp_server_socket = tUDPsocket;
-    inited = 1;
-  }
-  FD_ZERO(&readfds);
-  FD_SET(udp_server_socket, &readfds);
-  life = select( 0,&readfds, NULL, NULL, &timeout );
-  if (life == SOCKET_ERROR )
-    return false;
-  memset(&(server),0,sizeof(server));
-  server.sin_family = AF_INET;
+	// get IP address
+	sscanf( (char *)strLocalIP.c_str(), "%d.%d.%d.%d", &t1, &t2, &t3, &t4 );
+	if( !t1 ) return false;
+	cliLen = sizeof( cliAddr);
+	// setup UDP socket
+	if( !inited )
+	{
+		int tUDPsocket  = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
+		char value      = 1;
+		setsockopt( tUDPsocket, SOL_SOCKET, SO_BROADCAST, &value, value );
+		struct sockaddr_in addr;
+		memset(&(addr),0,sizeof(addr));
+		addr.sin_family       = AF_INET;
+		addr.sin_addr.s_addr  = INADDR_ANY;
+		addr.sin_port         = htons(iUDPPort);
+		bind(tUDPsocket,(struct sockaddr *)(&addr),sizeof(addr));
+		udp_server_socket = tUDPsocket;
+		inited = 1;
+	}
+	FD_ZERO(&readfds);
+	FD_SET(udp_server_socket, &readfds);
+	life = select( 0,&readfds, NULL, NULL, &timeout );
+	if (life == SOCKET_ERROR )
+	return false;
+	memset(&(server),0,sizeof(server));
+	server.sin_family = AF_INET;
 #ifndef _LINUX
-  server.sin_addr.S_un.S_addr = INADDR_BROADCAST;
+	server.sin_addr.S_un.S_addr = INADDR_BROADCAST;
 #else
-  server.sin_addr.s_addr = INADDR_BROADCAST;
+	server.sin_addr.s_addr = INADDR_BROADCAST;
 #endif
-  server.sin_port = htons(iUDPPort);
-  sendto(udp_server_socket,(char *)strSendMessage.c_str(),5,0,(struct sockaddr *)(&server),sizeof(server));
+	server.sin_port = htons(iUDPPort);
+	sendto(udp_server_socket,(char *)strSendMessage.c_str(),5,0,(struct sockaddr *)(&server),sizeof(server));
 	FD_ZERO(&readfds);
 	FD_SET(udp_server_socket, &readfds);
 	life = select( 0,&readfds, NULL, NULL, &timeout );
-  
-  unsigned int iLookUpCountMax = 2;
-  unsigned int i=0;
-  bool bUpdateShares=false;
 
-  // Ping able clients? 0:false
-  if (life == 0 )
-  {
-    if(v_xboxclients.client_ip.size() > 0)
-    {
-      // clients in list without life signal!
-      // calculate iLookUpCountMax value counter dependence on clients size!
-      if(v_xboxclients.client_ip.size() > iLookUpCountMax)
-        iLookUpCountMax += (v_xboxclients.client_ip.size()-iLookUpCountMax);
+	unsigned int iLookUpCountMax = 2;
+	unsigned int i=0;
+	bool bUpdateShares=false;
 
-      for (i=0; i<v_xboxclients.client_ip.size(); i++)
-      {
-        bUpdateShares=false;
-        //only 1 client, clear our list
-        if(v_xboxclients.client_lookup_count[i] >= iLookUpCountMax && v_xboxclients.client_ip.size() == 1 )
-        {
-          v_xboxclients.client_ip.clear();
-          v_xboxclients.client_info.clear();
-          v_xboxclients.client_lookup_count.clear();
-          v_xboxclients.client_informed.clear();
-          
-          // debug log, clients removed from our list 
-          CLog::Log(LOGDEBUG,"Autodetection: all Clients Removed! (mode LIFE 0)");
-          bUpdateShares = true;
-        }
-        else 
-        {
-          // check client lookup counter! Not reached the CountMax, Add +1!
-          if(v_xboxclients.client_lookup_count[i] < iLookUpCountMax ) 
-            v_xboxclients.client_lookup_count[i] = v_xboxclients.client_lookup_count[i]+1;
-          else
-          {
-            // client lookup counter REACHED CountMax, remove this client
-            v_xboxclients.client_ip.erase(v_xboxclients.client_ip.begin()+i);
-            v_xboxclients.client_info.erase(v_xboxclients.client_info.begin()+i);
-            v_xboxclients.client_lookup_count.erase(v_xboxclients.client_lookup_count.begin()+i);
-            v_xboxclients.client_informed.erase(v_xboxclients.client_informed.begin()+i);
-            
-            // debug log, clients removed from our list 
-            CLog::Log(LOGDEBUG,"Autodetection: Client ID:[%i] Removed! (mode LIFE 0)",i );
-            bUpdateShares = true;
-          }
-        }
-        if(bUpdateShares)
-        {
-          // a client is removed from our list, update our shares
-          CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_UPDATE_SOURCES);
-          g_windowManager.SendThreadMessage(msg);
-        }
-      }
-    }
-  }
-  // life !=0 we are online and ready to receive and send
-  while( life )
-    {
-    bFoundNewClient = false;
-    bUpdateShares = false;
-    // Receive ping request or Info
-    int iSockRet = recvfrom(udp_server_socket, sztmp, 512, 0,(struct sockaddr *) &cliAddr, &cliLen); 
-    if (iSockRet != SOCKET_ERROR)
-    {
-      CStdString strTmp;
-      // do we received a new Client info or just a "ping" request
-      if(strReceiveMessage.Equals(sztmp))
-      {
-        // we received a "ping" request, sending our informations
-        strTmp.Format("%s;%s;%s;%d;%d\r\n\0",
-          strNickName.c_str(),  // Our Nick-, Device Name!
-          strFTPUserName.c_str(), // User Name for our FTP Server
-          strFTPPass.c_str(), // Password for our FTP Server
-          iFTPPort, // FTP PORT Adress for our FTP Server
-          0 ); // BOOSMODE, for our FTP Server!
-        sendto(udp_server_socket,(char *)strTmp.c_str(),strlen((char *)strTmp.c_str())+1,0,(struct sockaddr *)(&cliAddr),sizeof(cliAddr));
-      }
-      else
-      {
-        //We received new client information, extracting information
-        CStdString strInfo, strIP;
-        strInfo.Format("%s",sztmp); //this is the client info
-        strIP.Format("%d.%d.%d.%d", 
+	// Ping able clients? 0:false
+	if (life == 0 )
+	{
+		if(v_xboxclients.client_ip.size() > 0)
+		{
+			// clients in list without life signal!
+			// calculate iLookUpCountMax value counter dependence on clients size!
+			if(v_xboxclients.client_ip.size() > iLookUpCountMax)
+			iLookUpCountMax += (v_xboxclients.client_ip.size()-iLookUpCountMax);
+
+			for (i=0; i<v_xboxclients.client_ip.size(); i++)
+			{
+				bUpdateShares=false;
+				//only 1 client, clear our list
+				if(v_xboxclients.client_lookup_count[i] >= iLookUpCountMax && v_xboxclients.client_ip.size() == 1 )
+				{
+					v_xboxclients.client_ip.clear();
+					v_xboxclients.client_info.clear();
+					v_xboxclients.client_lookup_count.clear();
+					v_xboxclients.client_informed.clear();
+					
+					// debug log, clients removed from our list 
+					CLog::Log(LOGDEBUG,"Autodetection: all Clients Removed! (mode LIFE 0)");
+					bUpdateShares = true;
+				}
+				else 
+				{
+					// check client lookup counter! Not reached the CountMax, Add +1!
+					if(v_xboxclients.client_lookup_count[i] < iLookUpCountMax ) 
+					v_xboxclients.client_lookup_count[i] = v_xboxclients.client_lookup_count[i]+1;
+					else
+					{
+						// client lookup counter REACHED CountMax, remove this client
+						v_xboxclients.client_ip.erase(v_xboxclients.client_ip.begin()+i);
+						v_xboxclients.client_info.erase(v_xboxclients.client_info.begin()+i);
+						v_xboxclients.client_lookup_count.erase(v_xboxclients.client_lookup_count.begin()+i);
+						v_xboxclients.client_informed.erase(v_xboxclients.client_informed.begin()+i);
+						
+						// debug log, clients removed from our list 
+						CLog::Log(LOGDEBUG,"Autodetection: Client ID:[%i] Removed! (mode LIFE 0)",i );
+						bUpdateShares = true;
+					}
+				}
+				if(bUpdateShares)
+				{
+					// a client is removed from our list, update our shares
+					CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_UPDATE_SOURCES);
+					g_windowManager.SendThreadMessage(msg);
+				}
+			}
+		}
+	}
+	// life !=0 we are online and ready to receive and send
+	while( life )
+	{
+		bFoundNewClient = false;
+		bUpdateShares = false;
+		// Receive ping request or Info
+		int iSockRet = recvfrom(udp_server_socket, sztmp, 512, 0,(struct sockaddr *) &cliAddr, &cliLen); 
+		if (iSockRet != SOCKET_ERROR)
+		{
+			CStdString strTmp;
+			// do we received a new Client info or just a "ping" request
+			if(strReceiveMessage.Equals(sztmp))
+			{
+				// we received a "ping" request, sending our informations
+				strTmp.Format("%s;%s;%s;%d;%d\r\n\0",
+				strNickName.c_str(),  // Our Nick-, Device Name!
+				strFTPUserName.c_str(), // User Name for our FTP Server
+				strFTPPass.c_str(), // Password for our FTP Server
+				iFTPPort, // FTP PORT Adress for our FTP Server
+				0 ); // BOOSMODE, for our FTP Server!
+				sendto(udp_server_socket,(char *)strTmp.c_str(),strlen((char *)strTmp.c_str())+1,0,(struct sockaddr *)(&cliAddr),sizeof(cliAddr));
+			}
+			else
+			{
+				//We received new client information, extracting information
+				CStdString strInfo, strIP;
+				strInfo.Format("%s",sztmp); //this is the client info
+				strIP.Format("%d.%d.%d.%d", 
 #ifndef _LINUX
-          cliAddr.sin_addr.S_un.S_un_b.s_b1,
-          cliAddr.sin_addr.S_un.S_un_b.s_b2,
-          cliAddr.sin_addr.S_un.S_un_b.s_b3,
-          cliAddr.sin_addr.S_un.S_un_b.s_b4
+				cliAddr.sin_addr.S_un.S_un_b.s_b1,
+				cliAddr.sin_addr.S_un.S_un_b.s_b2,
+				cliAddr.sin_addr.S_un.S_un_b.s_b3,
+				cliAddr.sin_addr.S_un.S_un_b.s_b4
 #else
-          (int)((char *)(cliAddr.sin_addr.s_addr))[0],
-          (int)((char *)(cliAddr.sin_addr.s_addr))[1],
-          (int)((char *)(cliAddr.sin_addr.s_addr))[2],
-          (int)((char *)(cliAddr.sin_addr.s_addr))[3]
+				(int)((char *)(cliAddr.sin_addr.s_addr))[0],
+				(int)((char *)(cliAddr.sin_addr.s_addr))[1],
+				(int)((char *)(cliAddr.sin_addr.s_addr))[2],
+				(int)((char *)(cliAddr.sin_addr.s_addr))[3]
 #endif
-        ); //this is the client IP
-        
-        //Is this our Local IP ?
-        if ( !strIP.Equals(strLocalIP) )
-        {
-          //is our list empty?
-          if(v_xboxclients.client_ip.size() <= 0 )
-          {
-            // the list is empty, add. this client to the list!
-            v_xboxclients.client_ip.push_back(strIP);
-            v_xboxclients.client_info.push_back(strInfo);
-            v_xboxclients.client_lookup_count.push_back(0);
-            v_xboxclients.client_informed.push_back(false);
-            bFoundNewClient = true;
-            bUpdateShares = true;
-          }
-          // our list is not empty, check if we allready have this client in our list!
-          else
-          {
-            // this should be a new client or?
-            // check list
-            bFoundNewClient = true;
-            for (i=0; i<v_xboxclients.client_ip.size(); i++)
-            {
-              if(strIP.Equals(v_xboxclients.client_ip[i].c_str()))
-                bFoundNewClient=false;
-            }
-            if(bFoundNewClient)
-            {
-              // bFoundNewClient is still true, the client is not in our list!
-              // add. this client to our list!
-              v_xboxclients.client_ip.push_back(strIP);
-              v_xboxclients.client_info.push_back(strInfo);
-              v_xboxclients.client_lookup_count.push_back(0);
-              v_xboxclients.client_informed.push_back(false);
-              bUpdateShares = true;
-            }
-            else // this is a existing client! check for LIFE & lookup counter
-            {
-              // calculate iLookUpCountMax value counter dependence on clients size!
-              if(v_xboxclients.client_ip.size() > iLookUpCountMax)
-                iLookUpCountMax += (v_xboxclients.client_ip.size()-iLookUpCountMax);
+				); //this is the client IP
+				
+				//Is this our Local IP ?
+				if ( !strIP.Equals(strLocalIP) )
+				{
+					//is our list empty?
+					if(v_xboxclients.client_ip.size() <= 0 )
+					{
+						// the list is empty, add. this client to the list!
+						v_xboxclients.client_ip.push_back(strIP);
+						v_xboxclients.client_info.push_back(strInfo);
+						v_xboxclients.client_lookup_count.push_back(0);
+						v_xboxclients.client_informed.push_back(false);
+						bFoundNewClient = true;
+						bUpdateShares = true;
+					}
+					// our list is not empty, check if we allready have this client in our list!
+					else
+					{
+						// this should be a new client or?
+						// check list
+						bFoundNewClient = true;
+						for (i=0; i<v_xboxclients.client_ip.size(); i++)
+						{
+							if(strIP.Equals(v_xboxclients.client_ip[i].c_str()))
+							bFoundNewClient=false;
+						}
+						if(bFoundNewClient)
+						{
+							// bFoundNewClient is still true, the client is not in our list!
+							// add. this client to our list!
+							v_xboxclients.client_ip.push_back(strIP);
+							v_xboxclients.client_info.push_back(strInfo);
+							v_xboxclients.client_lookup_count.push_back(0);
+							v_xboxclients.client_informed.push_back(false);
+							bUpdateShares = true;
+						}
+						else // this is a existing client! check for LIFE & lookup counter
+						{
+							// calculate iLookUpCountMax value counter dependence on clients size!
+							if(v_xboxclients.client_ip.size() > iLookUpCountMax)
+							iLookUpCountMax += (v_xboxclients.client_ip.size()-iLookUpCountMax);
 
-              for (i=0; i<v_xboxclients.client_ip.size(); i++)
-              {
-                if(strIP.Equals(v_xboxclients.client_ip[i].c_str()))
-                {
-                  // found client in list, reset looup_Count and the client_info
-                  v_xboxclients.client_info[i]=strInfo;
-                  v_xboxclients.client_lookup_count[i] = 0;
-                }
-                else
-                {
-                  // check client lookup counter! Not reached the CountMax, Add +1!
-                  if(v_xboxclients.client_lookup_count[i] < iLookUpCountMax )
-                    v_xboxclients.client_lookup_count[i] = v_xboxclients.client_lookup_count[i]+1;
-                  else
-                  {
-                    // client lookup counter REACHED CountMax, remove this client
-                    v_xboxclients.client_ip.erase(v_xboxclients.client_ip.begin()+i);
-                    v_xboxclients.client_info.erase(v_xboxclients.client_info.begin()+i);
-                    v_xboxclients.client_lookup_count.erase(v_xboxclients.client_lookup_count.begin()+i);
-                    v_xboxclients.client_informed.erase(v_xboxclients.client_informed.begin()+i);
+							for (i=0; i<v_xboxclients.client_ip.size(); i++)
+							{
+								if(strIP.Equals(v_xboxclients.client_ip[i].c_str()))
+								{
+									// found client in list, reset looup_Count and the client_info
+									v_xboxclients.client_info[i]=strInfo;
+									v_xboxclients.client_lookup_count[i] = 0;
+								}
+								else
+								{
+									// check client lookup counter! Not reached the CountMax, Add +1!
+									if(v_xboxclients.client_lookup_count[i] < iLookUpCountMax )
+									v_xboxclients.client_lookup_count[i] = v_xboxclients.client_lookup_count[i]+1;
+									else
+									{
+										// client lookup counter REACHED CountMax, remove this client
+										v_xboxclients.client_ip.erase(v_xboxclients.client_ip.begin()+i);
+										v_xboxclients.client_info.erase(v_xboxclients.client_info.begin()+i);
+										v_xboxclients.client_lookup_count.erase(v_xboxclients.client_lookup_count.begin()+i);
+										v_xboxclients.client_informed.erase(v_xboxclients.client_informed.begin()+i);
 
-                    // debug log, clients removed from our list
-                    CLog::Log(LOGDEBUG,"Autodetection: Client ID:[%i] Removed! (mode LIFE 1)",i );
+										// debug log, clients removed from our list
+										CLog::Log(LOGDEBUG,"Autodetection: Client ID:[%i] Removed! (mode LIFE 1)",i );
 
-                    // client is removed from our list, update our shares
-                    CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_UPDATE_SOURCES);
-                    g_windowManager.SendThreadMessage(msg);
-                  }
-                }
-              }
-              // here comes our list for debug log
-              for (i=0; i<v_xboxclients.client_ip.size(); i++)
-              {
-                CLog::Log(LOGDEBUG,"Autodetection: Client ID:[%i] (mode LIFE=1)",i );
-                CLog::Log(LOGDEBUG,"----------------------------------------------------------------" );
-                CLog::Log(LOGDEBUG,"IP:%s Info:%s LookUpCount:%i Informed:%s",
-                  v_xboxclients.client_ip[i].c_str(),
-                  v_xboxclients.client_info[i].c_str(),
-                  v_xboxclients.client_lookup_count[i],
-                  v_xboxclients.client_informed[i] ? "true":"false");
-                CLog::Log(LOGDEBUG,"----------------------------------------------------------------" );
-              }
-            }
-          }
-          if(bUpdateShares)
-          {
-            // a client is add or removed from our list, update our shares
-            CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_UPDATE_SOURCES);
-            g_windowManager.SendThreadMessage(msg);
-          }
-        }
-      }
-    }
-    else
-    {
-       CLog::Log(LOGDEBUG, "Autodetection: Socket error %u", WSAGetLastError());
-    }
-    timeout.tv_sec=0;
-    timeout.tv_usec = 5000;
-    FD_ZERO(&readfds);
-    FD_SET(udp_server_socket, &readfds);
-    life = select( 0,&readfds, NULL, NULL, &timeout );
-  }
-  return bFoundNewClient;
+										// client is removed from our list, update our shares
+										CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_UPDATE_SOURCES);
+										g_windowManager.SendThreadMessage(msg);
+									}
+								}
+							}
+							// here comes our list for debug log
+							for (i=0; i<v_xboxclients.client_ip.size(); i++)
+							{
+								CLog::Log(LOGDEBUG,"Autodetection: Client ID:[%i] (mode LIFE=1)",i );
+								CLog::Log(LOGDEBUG,"----------------------------------------------------------------" );
+								CLog::Log(LOGDEBUG,"IP:%s Info:%s LookUpCount:%i Informed:%s",
+								v_xboxclients.client_ip[i].c_str(),
+								v_xboxclients.client_info[i].c_str(),
+								v_xboxclients.client_lookup_count[i],
+								v_xboxclients.client_informed[i] ? "true":"false");
+								CLog::Log(LOGDEBUG,"----------------------------------------------------------------" );
+							}
+						}
+					}
+					if(bUpdateShares)
+					{
+						// a client is add or removed from our list, update our shares
+						CGUIMessage msg(GUI_MSG_NOTIFY_ALL,0,0,GUI_MSG_UPDATE_SOURCES);
+						g_windowManager.SendThreadMessage(msg);
+					}
+				}
+			}
+		}
+		else
+		{
+			CLog::Log(LOGDEBUG, "Autodetection: Socket error %u", WSAGetLastError());
+		}
+		timeout.tv_sec=0;
+		timeout.tv_usec = 5000;
+		FD_ZERO(&readfds);
+		FD_SET(udp_server_socket, &readfds);
+		life = select( 0,&readfds, NULL, NULL, &timeout );
+	}
+	return bFoundNewClient;
 }
 
 void CUtil::AutoDetectionGetSource(VECSOURCES &shares)
 {
-  if(v_xboxclients.client_ip.size() > 0)
-  {
-    // client list is not empty, add to shares
-    CMediaSource share;
-    for (unsigned int i=0; i< v_xboxclients.client_ip.size(); i++)
-    {
-      //extract client info string: NickName;FTP_USER;FTP_Password;FTP_PORT;BOOST_MODE
-      CStdString strFTPPath, strNickName, strFtpUserName, strFtpPassword, strFtpPort, strBoosMode;
-      CStdStringArray arSplit;
-      StringUtils::SplitString(v_xboxclients.client_info[i],";", arSplit);
-      if ((int)arSplit.size() > 1)
-      {
-        strNickName     = arSplit[0].c_str();
-        strFtpUserName  = arSplit[1].c_str();
-        strFtpPassword  = arSplit[2].c_str();
-        strFtpPort      = arSplit[3].c_str();
-        strBoosMode     = arSplit[4].c_str();
-        strFTPPath.Format("ftp://%s:%s@%s:%s/",strFtpUserName.c_str(),strFtpPassword.c_str(),v_xboxclients.client_ip[i].c_str(),strFtpPort.c_str());
+	if(v_xboxclients.client_ip.size() > 0)
+	{
+		// client list is not empty, add to shares
+		CMediaSource share;
+		for (unsigned int i=0; i< v_xboxclients.client_ip.size(); i++)
+		{
+			//extract client info string: NickName;FTP_USER;FTP_Password;FTP_PORT;BOOST_MODE
+			CStdString strFTPPath, strNickName, strFtpUserName, strFtpPassword, strFtpPort, strBoosMode;
+			CStdStringArray arSplit;
+			StringUtils::SplitString(v_xboxclients.client_info[i],";", arSplit);
+			if ((int)arSplit.size() > 1)
+			{
+				strNickName     = arSplit[0].c_str();
+				strFtpUserName  = arSplit[1].c_str();
+				strFtpPassword  = arSplit[2].c_str();
+				strFtpPort      = arSplit[3].c_str();
+				strBoosMode     = arSplit[4].c_str();
+				strFTPPath.Format("ftp://%s:%s@%s:%s/",strFtpUserName.c_str(),strFtpPassword.c_str(),v_xboxclients.client_ip[i].c_str(),strFtpPort.c_str());
 
-        strNickName.TrimRight(' ');
+				strNickName.TrimRight(' ');
 #ifdef HAS_XBOX_HARDWARE
-        share.strName.Format("FTP XBMC (%s)", strNickName.c_str());
+				share.strName.Format("FTP XBMC (%s)", strNickName.c_str());
 #else
-        share.strName.Format("FTP XBMC_PC (%s)", strNickName.c_str());
+				share.strName.Format("FTP XBMC_PC (%s)", strNickName.c_str());
 #endif
-        share.strPath.Format("%s",strFTPPath.c_str());
-        shares.push_back(share);
-      }
-    }
-  }
+				share.strPath.Format("%s",strFTPPath.c_str());
+				shares.push_back(share);
+			}
+		}
+	}
 }
 
 bool CUtil::GetFTPServerUserName(int iFTPUserID, CStdString &strFtpUser1, int &iUserMax )
 {
 #ifdef HAS_FTP_SERVER
-  if( !g_application.m_pFileZilla )
-    return false;
+	if( !g_application.m_pFileZilla )
+	return false;
 
-  class CXFUser* m_pUser;
-  vector<CXFUser*> users;
-  g_application.m_pFileZilla->GetAllUsers(users);
-  iUserMax = users.size();
-  if (iUserMax > 0)
-  {
-    //for (int i = 1 ; i < iUserSize; i++){ delete users[i]; }
-    m_pUser = users[iFTPUserID];
-    strFtpUser1 = m_pUser->GetName();
-    if (strFtpUser1.size() != 0) return true;
-    else return false;
-  }
-  else
+	class CXFUser* m_pUser;
+	vector<CXFUser*> users;
+	g_application.m_pFileZilla->GetAllUsers(users);
+	iUserMax = users.size();
+	if (iUserMax > 0)
+	{
+		//for (int i = 1 ; i < iUserSize; i++){ delete users[i]; }
+		m_pUser = users[iFTPUserID];
+		strFtpUser1 = m_pUser->GetName();
+		if (strFtpUser1.size() != 0) return true;
+		else return false;
+	}
+	else
 #endif
-    return false;
+	return false;
 }
 bool CUtil::SetFTPServerUserPassword(CStdString strFtpUserName, CStdString strFtpUserPassword)
 {
 #ifdef HAS_FTP_SERVER
-  if( !g_application.m_pFileZilla )
-    return false;
+	if( !g_application.m_pFileZilla )
+	return false;
 
-  CStdString strTempUserName;
-  class CXFUser* p_ftpUser;
-  vector<CXFUser*> v_ftpusers;
-  bool bFoundUser = false;
-  g_application.m_pFileZilla->GetAllUsers(v_ftpusers);
-  int iUserSize = v_ftpusers.size();
-  if (iUserSize > 0)
-  {
-    int i = 1 ;
-    while( i <= iUserSize)
-    {
-      p_ftpUser = v_ftpusers[i-1];
-      strTempUserName = p_ftpUser->GetName();
-      if (strTempUserName.Equals(strFtpUserName.c_str()) )
-      {
-        if (p_ftpUser->SetPassword(strFtpUserPassword.c_str()) != XFS_INVALID_PARAMETERS)
-        {
-          p_ftpUser->CommitChanges();
-          g_guiSettings.SetString("services.ftpserverpassword",strFtpUserPassword.c_str());
-          return true;
-        }
-        break;
-      }
-      i++;
-    }
-  }
+	CStdString strTempUserName;
+	class CXFUser* p_ftpUser;
+	vector<CXFUser*> v_ftpusers;
+	bool bFoundUser = false;
+	g_application.m_pFileZilla->GetAllUsers(v_ftpusers);
+	int iUserSize = v_ftpusers.size();
+	if (iUserSize > 0)
+	{
+		int i = 1 ;
+		while( i <= iUserSize)
+		{
+			p_ftpUser = v_ftpusers[i-1];
+			strTempUserName = p_ftpUser->GetName();
+			if (strTempUserName.Equals(strFtpUserName.c_str()) )
+			{
+				if (p_ftpUser->SetPassword(strFtpUserPassword.c_str()) != XFS_INVALID_PARAMETERS)
+				{
+					p_ftpUser->CommitChanges();
+					g_guiSettings.SetString("services.ftpserverpassword",strFtpUserPassword.c_str());
+					return true;
+				}
+				break;
+			}
+			i++;
+		}
+	}
 #endif
-  return false;
+	return false;
 }
 //strXboxNickNameIn: New NickName to write
 //strXboxNickNameOut: Same if it is in NICKNAME Cache
@@ -3372,305 +3483,310 @@
 bool CUtil::SetXBOXNickName(CStdString strXboxNickNameIn, CStdString &strXboxNickNameOut)
 {
 #ifdef HAS_XBOX_HARDWARE
-  WCHAR pszNickName[MAX_NICKNAME];
-  unsigned int uiSize = MAX_NICKNAME;
-  bool bfound= false;
-  HANDLE hNickName = XFindFirstNickname(false,pszNickName,MAX_NICKNAME);
-  if (hNickName != INVALID_HANDLE_VALUE)
-  { do
-      {
-        strXboxNickNameOut.Format("%ls",pszNickName );
-        if (strXboxNickNameIn.Equals(strXboxNickNameOut))
-        {
-          bfound = true;
-          break;
-        }
-        else if (strXboxNickNameIn.IsEmpty()) strXboxNickNameOut.Format("XbMediaCenter");
-      }while(XFindNextNickname(hNickName,pszNickName,uiSize) != false);
-    XFindClose(hNickName);
-  }
-  if(!bfound)
-  {
-    CStdStringW wstrName = strXboxNickNameIn.c_str();
-    XSetNickname(wstrName.c_str(), false);
-  }
+	WCHAR pszNickName[MAX_NICKNAME];
+	unsigned int uiSize = MAX_NICKNAME;
+	bool bfound= false;
+	HANDLE hNickName = XFindFirstNickname(false,pszNickName,MAX_NICKNAME);
+	if (hNickName != INVALID_HANDLE_VALUE)
+	{ do
+		{
+			strXboxNickNameOut.Format("%ls",pszNickName );
+			if (strXboxNickNameIn.Equals(strXboxNickNameOut))
+			{
+				bfound = true;
+				break;
+			}
+			else if (strXboxNickNameIn.IsEmpty()) strXboxNickNameOut.Format("XbMediaCenter");
+		}while(XFindNextNickname(hNickName,pszNickName,uiSize) != false);
+		XFindClose(hNickName);
+	}
+	if(!bfound)
+	{
+		CStdStringW wstrName = strXboxNickNameIn.c_str();
+		XSetNickname(wstrName.c_str(), false);
+	}
 #endif
-  return true;
+	return true;
 }
 //strXboxNickNameOut: Will fast receive the last XBOX NICKNAME from Cache
 bool CUtil::GetXBOXNickName(CStdString &strXboxNickNameOut)
 {
 #ifdef HAS_XBOX_HARDWARE
-  WCHAR wszXboxNickname[MAX_NICKNAME];
-  HANDLE hNickName = XFindFirstNickname( FALSE, wszXboxNickname, MAX_NICKNAME );
+	WCHAR wszXboxNickname[MAX_NICKNAME];
+	HANDLE hNickName = XFindFirstNickname( FALSE, wszXboxNickname, MAX_NICKNAME );
 	if ( hNickName != INVALID_HANDLE_VALUE )
 	{
-    strXboxNickNameOut.Format("%ls",wszXboxNickname);
+		strXboxNickNameOut.Format("%ls",wszXboxNickname);
 		XFindClose( hNickName );
-    return true;
+		return true;
 	}
-  else
+	else
 #endif
-  {
-    // it seems to be empty? should we create one? or the user
-    strXboxNickNameOut.Format("");
-    return false;
-  }
+	{
+		// it seems to be empty? should we create one? or the user
+		strXboxNickNameOut.Format("");
+		return false;
+	}
 }
 
 void CUtil::GetRecursiveListing(const CStdString& strPath, CFileItemList& items, const CStdString& strMask, bool bUseFileDirectories)
 {
-  CFileItemList myItems;
-  CDirectory::GetDirectory(strPath,myItems,strMask,bUseFileDirectories);
-  for (int i=0;i<myItems.Size();++i)
-  {
-    if (myItems[i]->m_bIsFolder)
-      CUtil::GetRecursiveListing(myItems[i]->GetPath(),items,strMask,bUseFileDirectories);
-    else 
-//    if (!myItems[i]->IsRAR() && !myItems[i]->IsZIP())
-      items.Add(myItems[i]);
-  }
+	CFileItemList myItems;
+	CDirectory::GetDirectory(strPath,myItems,strMask,bUseFileDirectories);
+	for (int i=0;i<myItems.Size();++i)
+	{
+		if (myItems[i]->m_bIsFolder)
+		CUtil::GetRecursiveListing(myItems[i]->GetPath(),items,strMask,bUseFileDirectories);
+		else 
+		//    if (!myItems[i]->IsRAR() && !myItems[i]->IsZIP())
+		items.Add(myItems[i]);
+	}
 }
 
 void CUtil::GetRecursiveDirsListing(const CStdString& strPath, CFileItemList& item)
 {
-  CFileItemList myItems;
-  CDirectory::GetDirectory(strPath,myItems,"",false);
-  for (int i=0;i<myItems.Size();++i)
-  {
-    if (myItems[i]->m_bIsFolder && !myItems[i]->GetPath().Equals(".."))
-    {
-      item.Add(myItems[i]);
-      CUtil::GetRecursiveDirsListing(myItems[i]->GetPath(),item);
-    }
-  }
+	CFileItemList myItems;
+	CDirectory::GetDirectory(strPath,myItems,"",false);
+	for (int i=0;i<myItems.Size();++i)
+	{
+		if (myItems[i]->m_bIsFolder && !myItems[i]->GetPath().Equals(".."))
+		{
+			item.Add(myItems[i]);
+			CUtil::GetRecursiveDirsListing(myItems[i]->GetPath(),item);
+		}
+	}
 }
 
 void CUtil::ForceForwardSlashes(CStdString& strPath)
 {
-  int iPos = strPath.ReverseFind('\\');
-  while (iPos > 0)
-  {
-    strPath.at(iPos) = '/';
-    iPos = strPath.ReverseFind('\\');
-  }
+	int iPos = strPath.ReverseFind('\\');
+	while (iPos > 0)
+	{
+		strPath.at(iPos) = '/';
+		iPos = strPath.ReverseFind('\\');
+	}
 }
 
 double CUtil::AlbumRelevance(const CStdString& strAlbumTemp1, const CStdString& strAlbum1, const CStdString& strArtistTemp1, const CStdString& strArtist1)
 {
-  // case-insensitive fuzzy string comparison on the album and artist for relevance
-  // weighting is identical, both album and artist are 50% of the total relevance
-  // a missing artist means the maximum relevance can only be 0.50
-  CStdString strAlbumTemp = strAlbumTemp1;
-  strAlbumTemp.MakeLower();
-  CStdString strAlbum = strAlbum1;
-  strAlbum.MakeLower();
-  double fAlbumPercentage = fstrcmp(strAlbumTemp, strAlbum, 0.0f);
-  double fArtistPercentage = 0.0f;
-  if (!strArtist1.IsEmpty())
-  {
-    CStdString strArtistTemp = strArtistTemp1;
-    strArtistTemp.MakeLower();
-    CStdString strArtist = strArtist1;
-    strArtist.MakeLower();
-    fArtistPercentage = fstrcmp(strArtistTemp, strArtist, 0.0f);
-  }
-  double fRelevance = fAlbumPercentage * 0.5f + fArtistPercentage * 0.5f;
-  return fRelevance;
+	// case-insensitive fuzzy string comparison on the album and artist for relevance
+	// weighting is identical, both album and artist are 50% of the total relevance
+	// a missing artist means the maximum relevance can only be 0.50
+	CStdString strAlbumTemp = strAlbumTemp1;
+	strAlbumTemp.MakeLower();
+	CStdString strAlbum = strAlbum1;
+	strAlbum.MakeLower();
+	double fAlbumPercentage = fstrcmp(strAlbumTemp, strAlbum, 0.0f);
+	double fArtistPercentage = 0.0f;
+	if (!strArtist1.IsEmpty())
+	{
+		CStdString strArtistTemp = strArtistTemp1;
+		strArtistTemp.MakeLower();
+		CStdString strArtist = strArtist1;
+		strArtist.MakeLower();
+		fArtistPercentage = fstrcmp(strArtistTemp, strArtist, 0.0f);
+	}
+	double fRelevance = fAlbumPercentage * 0.5f + fArtistPercentage * 0.5f;
+	return fRelevance;
 }
 
 bool CUtil::MakeShortenPath(CStdString StrInput, CStdString& StrOutput, int iTextMaxLength)
 {
-  int iStrInputSize = StrInput.size();
-  if((iStrInputSize <= 0) || (iTextMaxLength >= iStrInputSize))
-    return false;
+	int iStrInputSize = StrInput.size();
+	if((iStrInputSize <= 0) || (iTextMaxLength >= iStrInputSize))
+	return false;
 
-  char cDelim = '\0';
-  size_t nGreaterDelim, nPos;
+	char cDelim = '\0';
+	size_t nGreaterDelim, nPos;
 
-  nPos = StrInput.find_last_of( '\\' );
-  if ( nPos != CStdString::npos )
-    cDelim = '\\';
-  else
-  {
-    nPos = StrInput.find_last_of( '/' );
-    if ( nPos != CStdString::npos )
-      cDelim = '/';
-  }
-  if ( cDelim == '\0' )
-    return false;
+	nPos = StrInput.find_last_of( '\\' );
+	if ( nPos != CStdString::npos )
+	cDelim = '\\';
+	else
+	{
+		nPos = StrInput.find_last_of( '/' );
+		if ( nPos != CStdString::npos )
+		cDelim = '/';
+	}
+	if ( cDelim == '\0' )
+	return false;
 
-  if (nPos == StrInput.size() - 1)
-  {
-    StrInput.erase(StrInput.size() - 1);
-    nPos = StrInput.find_last_of( cDelim );
-  }
-  while( iTextMaxLength < iStrInputSize )
-  {
-    nPos = StrInput.find_last_of( cDelim, nPos );
-    nGreaterDelim = nPos;
-    if ( nPos != CStdString::npos )
-      nPos = StrInput.find_last_of( cDelim, nPos - 1 );
-    if ( nPos == CStdString::npos ) break;
-    if ( nGreaterDelim > nPos ) StrInput.replace( nPos + 1, nGreaterDelim - nPos - 1, ".." );
-    iStrInputSize = StrInput.size();
-  }
-  // replace any additional /../../ with just /../ if necessary
-  CStdString replaceDots;
-  replaceDots.Format("..%c..", cDelim);
-  while (StrInput.size() > (unsigned int)iTextMaxLength)
-    if (!StrInput.Replace(replaceDots, ".."))
-      break;
-  // finally, truncate our string to force inside our max text length,
-  // replacing the last 2 characters with ".."
+	if (nPos == StrInput.size() - 1)
+	{
+		StrInput.erase(StrInput.size() - 1);
+		nPos = StrInput.find_last_of( cDelim );
+	}
+	while( iTextMaxLength < iStrInputSize )
+	{
+		nPos = StrInput.find_last_of( cDelim, nPos );
+		nGreaterDelim = nPos;
+		if ( nPos != CStdString::npos )
+		nPos = StrInput.find_last_of( cDelim, nPos - 1 );
+		if ( nPos == CStdString::npos ) break;
+		if ( nGreaterDelim > nPos ) StrInput.replace( nPos + 1, nGreaterDelim - nPos - 1, ".." );
+		iStrInputSize = StrInput.size();
+	}
+	// replace any additional /../../ with just /../ if necessary
+	CStdString replaceDots;
+	replaceDots.Format("..%c..", cDelim);
+	while (StrInput.size() > (unsigned int)iTextMaxLength)
+	if (!StrInput.Replace(replaceDots, ".."))
+	break;
+	// finally, truncate our string to force inside our max text length,
+	// replacing the last 2 characters with ".."
 
-  // eg end up with:
-  // "smb://../Playboy Swimsuit Cal.."
-  if (iTextMaxLength > 2 && StrInput.size() > (unsigned int)iTextMaxLength)
-  {
-    StrInput = StrInput.Left(iTextMaxLength - 2);
-    StrInput += "..";
-  }
-  StrOutput = StrInput;
-  return true;
+	// eg end up with:
+	// "smb://../Playboy Swimsuit Cal.."
+	if (iTextMaxLength > 2 && StrInput.size() > (unsigned int)iTextMaxLength)
+	{
+		StrInput = StrInput.Left(iTextMaxLength - 2);
+		StrInput += "..";
+	}
+	StrOutput = StrInput;
+	return true;
 }
 
 float CUtil::CurrentCpuUsage()
 {
-  return (1.0f - g_application.m_idleThread.GetRelativeUsage())*100;
+	return (1.0f - g_application.m_idleThread.GetRelativeUsage())*100;
 }
 
 bool CUtil::SupportsWriteFileOperations(const CStdString& strPath)
 {
-  // currently only hd,smb and dav support delete and rename
-  if (URIUtils::IsHD(strPath))
-    return true;
-  if (URIUtils::IsSmb(strPath))
-    return true;
-  if (URIUtils::IsDAV(strPath))
-    return true;
-  if (URIUtils::IsMythTV(strPath))
-  {
-    /*
-     * Can't use CFile::Exists() to check whether the myth:// path supports file operations because
-     * it hits the directory cache on the way through, which has the Live Channels and Guide
-     * items cached.
-     */
-    return CMythDirectory::SupportsWriteFileOperations(strPath);
-  }
-  if (URIUtils::IsStack(strPath))
-    return SupportsWriteFileOperations(CStackDirectory::GetFirstStackedFile(strPath));
-  if (URIUtils::IsMultiPath(strPath))
-    return CMultiPathDirectory::SupportsWriteFileOperations(strPath);
+	// currently only hd,smb and dav support delete and rename
+	if (URIUtils::IsHD(strPath))
+	return true;
+	if (URIUtils::IsSmb(strPath))
+	return true;
+	if (URIUtils::IsDAV(strPath))
+	return true;
+	if (URIUtils::IsMythTV(strPath))
+	{
+		/*
+	* Can't use CFile::Exists() to check whether the myth:// path supports file operations because
+	* it hits the directory cache on the way through, which has the Live Channels and Guide
+	* items cached.
+	*/
+		return CMythDirectory::SupportsWriteFileOperations(strPath);
+	}
+	if (URIUtils::IsStack(strPath))
+	return SupportsWriteFileOperations(CStackDirectory::GetFirstStackedFile(strPath));
+	if (URIUtils::IsMultiPath(strPath))
+	return CMultiPathDirectory::SupportsWriteFileOperations(strPath);
 #ifdef HAS_XBOX_HARDWARE
-  if (URIUtils::IsMemCard(strPath) && g_memoryUnitManager.IsDriveWriteable(strPath))
-    return true;
+	if (URIUtils::IsMemCard(strPath) && g_memoryUnitManager.IsDriveWriteable(strPath))
+	return true;
 #endif
-  return false;
+	return false;
 }
 
 bool CUtil::SupportsReadFileOperations(const CStdString& strPath)
 {
-  if (URIUtils::IsVideoDb(strPath))
-    return false;
+	if (URIUtils::IsVideoDb(strPath))
+	return false;
 
-  return true;
+	return true;
 }
 
 CStdString CUtil::GetCachedAlbumThumb(const CStdString& album, const CStdString& artist)
 {
-  if (album.IsEmpty())
-    return GetCachedMusicThumb("unknown"+artist);
-  if (artist.IsEmpty())
-    return GetCachedMusicThumb(album+"unknown");
-  return GetCachedMusicThumb(album+artist);
+	if (album.IsEmpty())
+	return GetCachedMusicThumb("unknown"+artist);
+	if (artist.IsEmpty())
+	return GetCachedMusicThumb(album+"unknown");
+	return GetCachedMusicThumb(album+artist);
 }
 
 CStdString CUtil::GetCachedMusicThumb(const CStdString& path)
 {
-  Crc32 crc;
-  CStdString noSlashPath(path);
-  URIUtils::RemoveSlashAtEnd(noSlashPath);
-  crc.ComputeFromLowerCase(noSlashPath);
-  CStdString hex;
-  hex.Format("%08x", (unsigned __int32) crc);
-  CStdString thumb;
-  thumb.Format("%c/%s.tbn", hex[0], hex.c_str());
-  return URIUtils::AddFileToFolder(g_settings.GetMusicThumbFolder(), thumb);
+	Crc32 crc;
+	CStdString noSlashPath(path);
+	URIUtils::RemoveSlashAtEnd(noSlashPath);
+	crc.ComputeFromLowerCase(noSlashPath);
+	CStdString hex;
+	hex.Format("%08x", (unsigned __int32) crc);
+	CStdString thumb;
+	thumb.Format("%c/%s.tbn", hex[0], hex.c_str());
+	return URIUtils::AddFileToFolder(g_settings.GetMusicThumbFolder(), thumb);
 }
 
 CStdString CUtil::GetDefaultFolderThumb(const CStdString &folderThumb)
 {
-  if (g_TextureManager.HasTexture(folderThumb))
-    return folderThumb;
-  return "";
+	if (g_TextureManager.HasTexture(folderThumb))
+	return folderThumb;
+	return "";
 }
 
 void CUtil::GetSkinThemes(vector<CStdString>& vecTheme)
 {
-  CStdString strPath;
-  URIUtils::AddFileToFolder(g_graphicsContext.GetMediaDir(),"media",strPath);
-  CFileItemList items;
-  CDirectory::GetDirectory(strPath, items);
-  // Search for Themes in the Current skin!
-  for (int i = 0; i < items.Size(); ++i)
-  {
-    CFileItemPtr pItem = items[i];
-    if (!pItem->m_bIsFolder)
-    {
-      CStdString strExtension;
-      URIUtils::GetExtension(pItem->GetPath(), strExtension);
-      if (strExtension == ".xpr" && pItem->GetLabel().CompareNoCase("Textures.xpr"))
-      {
-        CStdString strLabel = pItem->GetLabel();
-        vecTheme.push_back(strLabel.Mid(0, strLabel.size() - 4));
-      }
-    }
-  }
-  sort(vecTheme.begin(), vecTheme.end(), sortstringbyname());
+	CStdString strPath;
+	URIUtils::AddFileToFolder("Q:/emustation/","themes",strPath);
+	CFileItemList items;
+	CDirectory::GetDirectory(strPath, items);
+	// Search for Themes in the Current skin!
+	for (int i = 0; i < items.Size(); ++i)
+	{
+		CFileItemPtr pItem = items[i];
+		if (!pItem->m_bIsFolder)
+		{
+			CStdString strExtension;
+			URIUtils::GetExtension(pItem->GetPath(), strExtension);
+			if (strExtension == ".xpr" && pItem->GetLabel().CompareNoCase("SIMPLE.xpr"))
+			{
+				CStdString strLabel = pItem->GetLabel();
+				vecTheme.push_back(strLabel.Mid(0, strLabel.size() - 4));
+			}
+		}
+		else
+		{
+			CStdString strLabel = pItem->GetLabel();
+			vecTheme.push_back(strLabel.Mid(0, strLabel.size()));
+		}
+	}
+	sort(vecTheme.begin(), vecTheme.end(), sortstringbyname());
 }
 
 void CUtil::WipeDir(const CStdString& strPath) // DANGEROUS!!!!
 {
-  if (!CDirectory::Exists(strPath)) return;
+	if (!CDirectory::Exists(strPath)) return;
 
-  CFileItemList items;
-  GetRecursiveListing(strPath,items,"");
-  for (int i=0;i<items.Size();++i)
-  {
-    if (!items[i]->m_bIsFolder)
-      CFile::Delete(items[i]->GetPath());
-  }
-  items.Clear();
-  GetRecursiveDirsListing(strPath,items);
-  for (int i=items.Size()-1;i>-1;--i) // need to wipe them backwards
-  {
-    CStdString strDir = items[i]->GetPath();
-    URIUtils::AddSlashAtEnd(strDir);
-    CDirectory::Remove(strDir);
-  }
+	CFileItemList items;
+	GetRecursiveListing(strPath,items,"");
+	for (int i=0;i<items.Size();++i)
+	{
+		if (!items[i]->m_bIsFolder)
+		CFile::Delete(items[i]->GetPath());
+	}
+	items.Clear();
+	GetRecursiveDirsListing(strPath,items);
+	for (int i=items.Size()-1;i>-1;--i) // need to wipe them backwards
+	{
+		CStdString strDir = items[i]->GetPath();
+		URIUtils::AddSlashAtEnd(strDir);
+		CDirectory::Remove(strDir);
+	}
 
-  if (!URIUtils::HasSlashAtEnd(strPath))
-  {
-    CStdString tmpPath = strPath;
-    URIUtils::AddSlashAtEnd(tmpPath);
-    CDirectory::Remove(tmpPath);
-  }
+	if (!URIUtils::HasSlashAtEnd(strPath))
+	{
+		CStdString tmpPath = strPath;
+		URIUtils::AddSlashAtEnd(tmpPath);
+		CDirectory::Remove(tmpPath);
+	}
 }
 
 bool CUtil::PWMControl(const CStdString &strRGBa, const CStdString &strRGBb, const CStdString &strWhiteA, const CStdString &strWhiteB, const CStdString &strTransition, int iTrTime)
 {
 #ifdef HAS_XBOX_HARDWARE
-    if (strRGBa.IsEmpty() && strRGBb.IsEmpty() && strWhiteA.IsEmpty() && strWhiteB.IsEmpty()) // no color, return false!
-      return false;
-  if(g_iledSmartxxrgb.IsRunning())
-  {
-    return g_iledSmartxxrgb.SetRGBState(strRGBa,strRGBb, strWhiteA, strWhiteB, strTransition, iTrTime);
-  }
-  g_iledSmartxxrgb.Start();
-  return g_iledSmartxxrgb.SetRGBState(strRGBa,strRGBb, strWhiteA, strWhiteB, strTransition, iTrTime);
+	if (strRGBa.IsEmpty() && strRGBb.IsEmpty() && strWhiteA.IsEmpty() && strWhiteB.IsEmpty()) // no color, return false!
+	return false;
+	if(g_iledSmartxxrgb.IsRunning())
+	{
+		return g_iledSmartxxrgb.SetRGBState(strRGBa,strRGBb, strWhiteA, strWhiteB, strTransition, iTrTime);
+	}
+	g_iledSmartxxrgb.Start();
+	return g_iledSmartxxrgb.SetRGBState(strRGBa,strRGBb, strWhiteA, strWhiteB, strTransition, iTrTime);
 #else
-  return false;
+	return false;
 #endif
 }
 
@@ -3680,23 +3796,23 @@
 bool CUtil::LookForKernelPatch()
 {
 #ifdef HAS_XBOX_HARDWARE
-  BYTE	*Kernel=(BYTE *)0x80010000;
-  DWORD	i, j = 0;
+	BYTE	*Kernel=(BYTE *)0x80010000;
+	DWORD	i, j = 0;
 
-  for(i=0x1000; i<0x14000; i++)
-  {
-    if(Kernel[i]!=PatchData[0])
-      continue;
-    for(j=0; j<25; j++)
-    {
-      if(Kernel[i+j]!=PatchData[j])
-        break;
-    }
-    if(j==25)
-      return true;
-  }
+	for(i=0x1000; i<0x14000; i++)
+	{
+		if(Kernel[i]!=PatchData[0])
+		continue;
+		for(j=0; j<25; j++)
+		{
+			if(Kernel[i+j]!=PatchData[j])
+			break;
+		}
+		if(j==25)
+		return true;
+	}
 #endif
-  return false;
+	return false;
 }
 // This routine removes our patch if it is not used.
 // This is to ensure proper testing whether we are responsible
@@ -3704,27 +3820,47 @@
 void CUtil::RemoveKernelPatch()
 {
 #ifdef HAS_XBOX_HARDWARE
-  BYTE  *Kernel=(BYTE *)0x80010000;
-  DWORD i, j = 0;
+	BYTE  *Kernel=(BYTE *)0x80010000;
+	DWORD i, j = 0;
+	CStdString kernel_version = g_sysinfo.GetKernelVersion();
 
-  for(i=0x1000; i<0x14000; i++)
-  {
-    if(Kernel[i]!=PatchData[0])
-      continue;
+	for(i=0x1000; i<0x14000; i++)
+	{
+		if(Kernel[i]!=PatchData[0])
+		continue;
 
-    for(j=0; j<25; j++)
-    {
-      if(Kernel[i+j]!=PatchData[j])
-        break;
-    }
-    if(j==25)
-    {
-      j=MmQueryAddressProtect(&Kernel[i]);
-      MmSetAddressProtect(&Kernel[i], 70, PAGE_READWRITE);
-      memcpy(&Kernel[i], &rawData[0], 70); // Reset Kernel
-      MmSetAddressProtect(&Kernel[i], 70, j);
-    }
-  }
+		for(j=0; j<25; j++)
+		{
+			if(Kernel[i+j]!=PatchData[j])
+			break;
+		}
+		if(j==25)
+		{
+			j=MmQueryAddressProtect(&Kernel[i]);
+			MmSetAddressProtect(&Kernel[i], 70, PAGE_READWRITE);
+			if (kernel_version == "1.0.5713.1" || kernel_version == "1.0.5838.1")
+			{
+				memcpy(&Kernel[i], &AltRetail_originalBytes[0], 70); // Reset Kernel
+			}
+			else if (kernel_version == "1.0.5034.1")
+			{
+				memcpy(&Kernel[i], &xThree_originalBytes[0], 70); // Reset Kernel
+			}
+			else if (kernel_version == "1.0.5035.1")
+			{
+				memcpy(&Kernel[i], &xTwoZeroThreeFive_originalBytes[0], 70); // Reset Kernel
+			}
+			else if (kernel_version == "1.0.8008.135")
+			{
+				memcpy(&Kernel[i], &Cerbios_originalBytes[0], 70); // Reset Kernel
+			}
+			else
+			{
+				memcpy(&Kernel[i], &Retail_originalBytes[0], 70); // Reset Kernel  
+			}
+			MmSetAddressProtect(&Kernel[i], 70, j);
+		}
+	}
 #endif
 }
 
@@ -3731,139 +3867,143 @@
 void CUtil::BootToDash()
 {
 #ifdef HAS_XBOX_HARDWARE
-  LD_LAUNCH_DASHBOARD ld;
+	LD_LAUNCH_DASHBOARD ld;
 
-  ZeroMemory(&ld, sizeof(LD_LAUNCH_DASHBOARD));
+	ZeroMemory(&ld, sizeof(LD_LAUNCH_DASHBOARD));
 
-  ld.dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
-  XLaunchNewImage(0, (PLAUNCH_DATA)&ld);
+	ld.dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
+	XLaunchNewImage(0, (PLAUNCH_DATA)&ld);
 #endif
 }
 
 void CUtil::InitRandomSeed()
 {
-  // Init random seed 
-  LARGE_INTEGER now; 
-  QueryPerformanceCounter(&now); 
-  unsigned int seed = (now.LowPart);
-//  CLog::Log(LOGDEBUG, "%s - Initializing random seed with %u", __FUNCTION__, seed);
-  srand(seed);
+	// Init random seed 
+	LARGE_INTEGER now; 
+	QueryPerformanceCounter(&now); 
+	unsigned int seed = (now.LowPart);
+	//  CLog::Log(LOGDEBUG, "%s - Initializing random seed with %u", __FUNCTION__, seed);
+	srand(seed);
 }
 
 void CUtil::RunShortcut(const char* szShortcutPath)
 {
-  CShortcut shortcut;
-  char szPath[1024];
-  char szParameters[1024];
-  if ( shortcut.Create(szShortcutPath))
-  {
-    CFileItem item(shortcut.m_strPath, false);
-    // if another shortcut is specified, load this up and use it
-    if (item.IsShortCut())
-    {
-      CHAR szNewPath[1024];
-      strcpy(szNewPath, szShortcutPath);
-      CHAR* szFile = strrchr(szNewPath, '\\');
-      strcpy(&szFile[1], shortcut.m_strPath.c_str());
+	CShortcut shortcut;
+	char szPath[1024];
+	char szParameters[1024];
+	if ( shortcut.Create(szShortcutPath))
+	{
+		CFileItem item(shortcut.m_strPath, false);
+		// if another shortcut is specified, load this up and use it
+		if (item.IsShortCut())
+		{
+			CHAR szNewPath[1024];
+			strcpy(szNewPath, szShortcutPath);
+			CHAR* szFile = strrchr(szNewPath, '\\');
+			strcpy(&szFile[1], shortcut.m_strPath.c_str());
 
-      CShortcut targetShortcut;
-      if (FAILED(targetShortcut.Create(szNewPath)))
-        return;
+			CShortcut targetShortcut;
+			if (FAILED(targetShortcut.Create(szNewPath)))
+			return;
 
-      shortcut.m_strPath = targetShortcut.m_strPath;
-    }
+			shortcut.m_strPath = targetShortcut.m_strPath;
+		}
 
-    strcpy( szPath, shortcut.m_strPath.c_str() );
+		strcpy( szPath, shortcut.m_strPath.c_str() );
 
-    CHAR szMode[16];
-    strcpy( szMode, shortcut.m_strVideo.c_str() );
-    strlwr( szMode );
+		CHAR szMode[16];
+		strcpy( szMode, shortcut.m_strVideo.c_str() );
+		strlwr( szMode );
 
-    strcpy(szParameters, shortcut.m_strParameters.c_str());
+		strcpy(szParameters, shortcut.m_strParameters.c_str());
 
-    BOOL bRow = strstr(szMode, "pal") != NULL;
-    BOOL bJap = strstr(szMode, "ntsc-j") != NULL;
-    BOOL bUsa = strstr(szMode, "ntsc") != NULL;
+		BOOL bRow = strstr(szMode, "pal") != NULL;
+		BOOL bJap = strstr(szMode, "ntsc-j") != NULL;
+		BOOL bUsa = strstr(szMode, "ntsc") != NULL;
 
-    F_VIDEO video = VIDEO_NULL;
-    if (bRow)
-      video = VIDEO_PAL50;
-    if (bJap)
-      video = (F_VIDEO)CXBE::FilterRegion(VIDEO_NTSCJ);
-    if (bUsa)
-      video = (F_VIDEO)CXBE::FilterRegion(VIDEO_NTSCM);
+		F_VIDEO video = VIDEO_NULL;
+		if (g_guiSettings.GetBool("myprograms.gameautoregion"))
+		{
+			if (bRow)
+			video = VIDEO_PAL50;
+			if (bJap)
+			video = (F_VIDEO)CXBE::FilterRegion(VIDEO_NTSCJ);
+			if (bUsa)
+			video = (F_VIDEO)CXBE::FilterRegion(VIDEO_NTSCM);
+		}
 
 #ifdef HAS_XBOX_HARDWARE
-    CUSTOM_LAUNCH_DATA data;
-    if (!shortcut.m_strCustomGame.IsEmpty())
-    {
-      char remap_path[MAX_PATH] = "";
-      char remap_xbe[MAX_PATH] = "";
+		CUSTOM_LAUNCH_DATA data;
+		if (!shortcut.m_strCustomGame.IsEmpty())
+		{
+			char remap_path[MAX_PATH] = "";
+			char remap_xbe[MAX_PATH] = "";
 
-      memset(&data,0,sizeof(CUSTOM_LAUNCH_DATA));
+			memset(&data,0,sizeof(CUSTOM_LAUNCH_DATA));
 
-      strcpy(data.szFilename,shortcut.m_strCustomGame.c_str());
 
-      strncpy(remap_path, XeImageFileName->Buffer, XeImageFileName->Length);
-      for (int i = strlen(remap_path) - 1; i >=0; i--)
-        if (remap_path[i] == '\\' || remap_path[i] == '/')
-        {
-          break;
-        }
-      strcpy(remap_xbe, &remap_path[i+1]);
-      remap_path[i+1] = 0;
+			strcpy(data.szFilename,shortcut.m_strCustomGame.c_str());
 
-      strcpy(data.szRemap_D_As, remap_path);
-      strcpy(data.szLaunchXBEOnExit, remap_xbe);
+			strncpy(remap_path, XeImageFileName->Buffer, XeImageFileName->Length);
+			for (int i = strlen(remap_path) - 1; i >=0; i--)
+			if (remap_path[i] == '\\' || remap_path[i] == '/')
+			{
+				break;
+			}
+			// strcpy(remap_xbe, &remap_path[i+1]);
+			// remap_path[i+1] = 0;
 
-      data.executionType = 0;
+			// strcpy(data.szRemap_D_As, remap_path);
+			// strcpy(data.szLaunchXBEOnExit, remap_xbe);
+			strcpy(data.szLaunchXBEOnExit, "");
 
-      // not the actual "magic" value - used to pass XbeId for some reason?
-      data.magic = GetXbeID(szPath);
-    }
-
-    CUtil::RunXBE(szPath,strcmp(szParameters,"")?szParameters:NULL,video,COUNTRY_NULL,shortcut.m_strCustomGame.IsEmpty()?NULL:&data);
+			data.executionType = 0;
+			// not the actual "magic" value - used to pass XbeId for some reason?
+			data.magic = GetXbeID(szPath);
+		}
+		
+		CUtil::RunXBE(szPath,strcmp(szParameters,"")?szParameters:NULL,video,COUNTRY_NULL,shortcut.m_strCustomGame.IsEmpty()?NULL:&data);
 #endif
-  }
+	}
 }
 
 void CUtil::GetHomePath(CStdString& strPath)
 {
-  char szXBEFileName[1024];
-  CIoSupport::GetXbePath(szXBEFileName);
-  char *szFileName = strrchr(szXBEFileName, '\\');
-  *szFileName = 0;
-  strPath = szXBEFileName;
+	char szXBEFileName[1024];
+	CIoSupport::GetXbePath(szXBEFileName);
+	char *szFileName = strrchr(szXBEFileName, '\\');
+	*szFileName = 0;
+	strPath = szXBEFileName;
 }
 
 bool CUtil::RunFFPatchedXBE(CStdString szPath1, CStdString& szNewPath)
 {
-  if (!g_guiSettings.GetBool("myprograms.autoffpatch"))
-  {
-    CLog::Log(LOGDEBUG, "%s - Auto Filter Flicker is off. Skipping Filter Flicker Patching.", __FUNCTION__);
-    return false;
-  }
-  CStdString strIsPMode = g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].strMode;
-  if ( strIsPMode.Equals("480p 16:9") || strIsPMode.Equals("480p 4:3") || strIsPMode.Equals("720p 16:9"))
-  {
-    CLog::Log(LOGDEBUG, "%s - Progressive Mode detected: Skipping Auto Filter Flicker Patching!", __FUNCTION__);
-    return false;
-  }
-  if (strncmp(szPath1, "D:", 2) == 0)
-  {
-    CLog::Log(LOGDEBUG, "%s - Source is DVD-ROM! Skipping Filter Flicker Patching.", __FUNCTION__);
-    return false;
-  }
+	if (!g_guiSettings.GetBool("myprograms.autoffpatch"))
+	{
+		CLog::Log(LOGDEBUG, "%s - Auto Filter Flicker is off. Skipping Filter Flicker Patching.", __FUNCTION__);
+		return false;
+	}
+	CStdString strIsPMode = g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution].strMode;
+	if ( strIsPMode.Equals("480p 16:9") || strIsPMode.Equals("480p 4:3") || strIsPMode.Equals("720p 16:9"))
+	{
+		CLog::Log(LOGDEBUG, "%s - Progressive Mode detected: Skipping Auto Filter Flicker Patching!", __FUNCTION__);
+		return false;
+	}
+	if (strncmp(szPath1, "D:", 2) == 0)
+	{
+		CLog::Log(LOGDEBUG, "%s - Source is DVD-ROM! Skipping Filter Flicker Patching.", __FUNCTION__);
+		return false;
+	}
 
-  CLog::Log(LOGDEBUG, "%s - Auto Filter Flicker is ON. Starting Filter Flicker Patching.", __FUNCTION__);
+	CLog::Log(LOGDEBUG, "%s - Auto Filter Flicker is ON. Starting Filter Flicker Patching.", __FUNCTION__);
 
-  // Test if we already have a patched _ffp XBE
-  // Since the FF can be changed in XBMC, we will not check for a pre patched _ffp xbe!
-  /* // May we can add. a changed FF detection.. then we can actived this!
-  CFile	xbe;
+	// Test if we already have a patched _ffp XBE
+	// Since the FF can be changed in XBMC, we will not check for a pre patched _ffp xbe!
+	/* // May we can add. a changed FF detection.. then we can actived this!
+CFile	xbe;
 	if (xbe.Exists(szPath1))
-  {
-    char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFname[_MAX_FNAME], szExt[_MAX_EXT];
+{
+	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFname[_MAX_FNAME], szExt[_MAX_EXT];
 		_splitpath(szPath1, szDrive, szDir, szFname, szExt);
 		strncat(szFname, "_ffp", 4);
 		_makepath(szNewPath.GetBuffer(MAX_PATH), szDrive, szDir, szFname, szExt);
@@ -3873,263 +4013,271 @@
 	} */
 
 
-  CXBE m_xbe;
-  if((int)m_xbe.ExtractGameRegion(szPath1.c_str()) <= 0) // Reading the GameRegion is enought to detect a Patchable xbe!
-  {
-    CLog::Log(LOGDEBUG, "%s - %s",szPath1.c_str(), __FUNCTION__);
-    CLog::Log(LOGDEBUG, "%s - Not Patchable xbe detected (Homebrew?)! Skipping Filter Flicker Patching.", __FUNCTION__);
-    return false;
-  }
+	CXBE m_xbe;
+	if((int)m_xbe.ExtractGameRegion(szPath1.c_str()) <= 0) // Reading the GameRegion is enought to detect a Patchable xbe!
+	{
+		CLog::Log(LOGDEBUG, "%s - %s",szPath1.c_str(), __FUNCTION__);
+		CLog::Log(LOGDEBUG, "%s - Not Patchable xbe detected (Homebrew?)! Skipping Filter Flicker Patching.", __FUNCTION__);
+		return false;
+	}
 #ifdef HAS_XBOX_HARDWARE
-  CGFFPatch m_ffp;
-  if (!m_ffp.FFPatch(szPath1, szNewPath))
-  {
-    CLog::Log(LOGDEBUG, "%s - ERROR during Filter Flicker Patching. Falling back to the original source.", __FUNCTION__);
-    return false;
-  }
+	CGFFPatch m_ffp;
+	if (!m_ffp.FFPatch(szPath1, szNewPath))
+	{
+		CLog::Log(LOGDEBUG, "%s - ERROR during Filter Flicker Patching. Falling back to the original source.", __FUNCTION__);
+		return false;
+	}
 #endif
-  if(szNewPath.IsEmpty())
-  {
-    CLog::Log(LOGDEBUG, "%s - ERROR NO Patchfile Path is empty! Falling back to the original source.", __FUNCTION__);
-    return false;
-  }
-  CLog::Log(LOGDEBUG, "%s - Filter Flicker Patching done. Starting %s.", __FUNCTION__, szNewPath.c_str());
-  return true;
+	if(szNewPath.IsEmpty())
+	{
+		CLog::Log(LOGDEBUG, "%s - ERROR NO Patchfile Path is empty! Falling back to the original source.", __FUNCTION__);
+		return false;
+	}
+	CLog::Log(LOGDEBUG, "%s - Filter Flicker Patching done. Starting %s.", __FUNCTION__, szNewPath.c_str());
+	return true;
 }
 
 void CUtil::RunXBE(const char* szPath1, char* szParameters, F_VIDEO ForceVideo, F_COUNTRY ForceCountry, CUSTOM_LAUNCH_DATA* pData)
 {
-  // check if locked
-  if (g_settings.GetCurrentProfile().programsLocked() && 
-      g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE)
-    if (!g_passwordManager.IsMasterLockUnlocked(true))
-      return;
+	// check if locked
+	if (g_settings.GetCurrentProfile().programsLocked() && 
+			g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE)
+	if (!g_passwordManager.IsMasterLockUnlocked(true))
+	return;
 
-  /// \brief Runs an executable file
-  /// \param szPath1 Path of executeable to run
-  /// \param szParameters Any parameters to pass to the executeable being run
-  g_application.PrintXBEToLCD(szPath1); //write to LCD
-  Sleep(600);        //and wait a little bit to execute
+	/// \brief Runs an executable file
+	/// \param szPath1 Path of executeable to run
+	/// \param szParameters Any parameters to pass to the executeable being run
+	g_application.PrintXBEToLCD(szPath1); //write to LCD
+	Sleep(600);        //and wait a little bit to execute
 
-  char szPath[1024];
-  strcpy(szPath, _P(szPath1).c_str());
+	char szPath[1024];
+	strcpy(szPath, _P(szPath1).c_str());
 
-  CStdString szNewPath;
-  if (RunFFPatchedXBE(szPath, szNewPath))
-  {
-    strcpy(szPath, szNewPath.c_str());
-  }
-  
-  if (strncmp(szPath, "Q:", 2) == 0)
-  { // may aswell support the virtual drive as well...
-    CStdString strPath;
-    // home dir is xbe dir
-    GetHomePath(strPath);
-    if (!URIUtils::HasSlashAtEnd(strPath))
-      strPath += "\\";
-    if (szPath[2] == '\\')
-      strPath += szPath + 3;
-    else
-      strPath += szPath + 2;
-    strcpy(szPath, strPath.c_str());
-  }
-  
-  char* szBackslash = strrchr(szPath, '\\');
-  if (szBackslash)
-  {
-    *szBackslash = 0x00;
-    char* szXbe = &szBackslash[1];
+	CStdString szNewPath;
+	if (RunFFPatchedXBE(szPath, szNewPath))
+	{
+		strcpy(szPath, szNewPath.c_str());
+	}
 
-    char* szColon = strrchr(szPath, ':');
-    if (szColon)
-    {
-      *szColon = 0x00;
-      char* szDrive = szPath;
-      char* szDirectory = &szColon[1];
+	if (strncmp(szPath, "Q:", 2) == 0)
+	{ // may aswell support the virtual drive as well...
+		CStdString strPath;
+		// home dir is xbe dir
+		GetHomePath(strPath);
+		if (!URIUtils::HasSlashAtEnd(strPath))
+		strPath += "\\";
+		if (szPath[2] == '\\')
+		strPath += szPath + 3;
+		else
+		strPath += szPath + 2;
+		strcpy(szPath, strPath.c_str());
+	}
 
-      char szDevicePath[1024];
-      char szXbePath[1024];
+	char* szBackslash = strrchr(szPath, '\\');
+	if (szBackslash)
+	{
+		*szBackslash = 0x00;
+		char* szXbe = &szBackslash[1];
 
-      CIoSupport::GetPartition(szDrive[0], szDevicePath);
+		char* szColon = strrchr(szPath, ':');
+		if (szColon)
+		{
+			*szColon = 0x00;
+			char* szDrive = szPath;
+			char* szDirectory = &szColon[1];
 
-      strcat(szDevicePath, szDirectory);
-      wsprintf(szXbePath, "d:\\%s", szXbe);
+			char szDevicePath[1024];
+			char szXbePath[1024];
 
+			CIoSupport::GetPartition(szDrive[0], szDevicePath);
+
+			strcat(szDevicePath, szDirectory);
+			wsprintf(szXbePath, "d:\\%s", szXbe);
+
 #ifdef HAS_XBOX_HARDWARE
-      g_application.Stop(false);
-
-      CUtil::LaunchXbe(szDevicePath, szXbePath, szParameters, ForceVideo, ForceCountry, pData);
+			g_application.Stop(false);
+			
+			CUtil::LaunchXbe(szDevicePath, szXbePath, szParameters, ForceVideo, ForceCountry, pData);
 #endif
-    }
-  }
+		}
+	}
 
-  CLog::Log(LOGERROR, "Unable to run xbe : %s", szPath);
+	CLog::Log(LOGERROR, "Unable to run xbe : %s", szPath);
 }
 
 void CUtil::LaunchXbe(const char* szPath, const char* szXbe, const char* szParameters, F_VIDEO ForceVideo, F_COUNTRY ForceCountry, CUSTOM_LAUNCH_DATA* pData)
 {
-  CStdString strPath(_P(szPath));
-  CLog::Log(LOGINFO, "launch xbe:%s %s", strPath.c_str(), szXbe);
-  CLog::Log(LOGINFO, " mount %s as D:", strPath.c_str());
+	Sleep(2000);
+	CStdString strPath(_P(szPath));
+	CLog::Log(LOGINFO, "launch xbe:%s %s", strPath.c_str(), szXbe);
+	CLog::Log(LOGINFO, " mount %s as D:", strPath.c_str());
 
 #ifdef HAS_XBOX_HARDWARE
-  CIoSupport::RemapDriveLetter('D', const_cast<char*>(strPath.c_str()));
+	CIoSupport::RemapDriveLetter('D', const_cast<char*>(strPath.c_str()));
 
-  CLog::Log(LOGINFO, "launch xbe:%s", szXbe);
+	CLog::Log(LOGINFO, "launch xbe:%s", szXbe);
 
-  if (ForceVideo != VIDEO_NULL)
-  {
-    if (!ForceCountry)
-    {
-      if (ForceVideo == VIDEO_NTSCM)
-        ForceCountry = COUNTRY_USA;
-      if (ForceVideo == VIDEO_NTSCJ)
-        ForceCountry = COUNTRY_JAP;
-      if (ForceVideo == VIDEO_PAL50)
-        ForceCountry = COUNTRY_EUR;
-    }
-    CLog::Log(LOGDEBUG,"forcing video mode: %i",ForceVideo);
-    bool bSuccessful = PatchCountryVideo(ForceCountry, ForceVideo);
-    if( !bSuccessful )
-      CLog::Log(LOGINFO,"AutoSwitch: Failed to set mode");
-  }
-  if (pData)
-  {
-    DWORD dwTitleID = pData->magic;
-    pData->magic = CUSTOM_LAUNCH_MAGIC;
-    const char* xbe = szXbe+3;
-    CLog::Log(LOGINFO, "launching game %s from path %s", pData->szFilename, strPath.c_str());
-    CIoSupport::UnmapDriveLetter('D');
-    XWriteTitleInfoAndRebootA( (char*)xbe, (char*)(CStdString("\\Device\\")+strPath).c_str(), LDT_TITLE, dwTitleID, pData);
-  }
-  else
-  {
-    if (szParameters == NULL)
-    {
-      DWORD error = XLaunchNewImage(szXbe, NULL );
-      CLog::Log(LOGERROR, "%s - XLaunchNewImage returned with error code %d", __FUNCTION__, error);
-    }
-    else
-    {
-      LAUNCH_DATA LaunchData;
-      strcpy((char*)LaunchData.Data, szParameters);
+	if (ForceVideo != VIDEO_NULL)
+	{
+		if (!ForceCountry)
+		{
+			if (ForceVideo == VIDEO_NTSCM)
+			ForceCountry = COUNTRY_USA;
+			if (ForceVideo == VIDEO_NTSCJ)
+			ForceCountry = COUNTRY_JAP;
+			if (ForceVideo == VIDEO_PAL50)
+			ForceCountry = COUNTRY_EUR;
+		}
+		CLog::Log(LOGDEBUG,"forcing video mode: %i",ForceVideo);
+		bool bSuccessful = PatchCountryVideo(ForceCountry, ForceVideo);
+		if( !bSuccessful )
+		CLog::Log(LOGINFO,"AutoSwitch: Failed to set mode");
+	}
+	if (pData)
+	{
+		DWORD dwTitleID = pData->magic;
+		pData->magic = CUSTOM_LAUNCH_MAGIC;
+		const char* xbe = szXbe+3;
+		CLog::Log(LOGINFO, "launching game %s from path %s", pData->szFilename, strPath.c_str());
+		CIoSupport::UnmapDriveLetter('D');
+		XWriteTitleInfoAndRebootA( (char*)xbe, (char*)(CStdString("\\Device\\")+strPath).c_str(), LDT_TITLE, dwTitleID, pData);
+	}
+	else
+	{
+		if (szParameters == NULL)
+		{
+			DWORD error = XLaunchNewImage(szXbe, NULL );
+			CLog::Log(LOGERROR, "%s - XLaunchNewImage returned with error code %d", __FUNCTION__, error);
+		}
+		else
+		{
+			LAUNCH_DATA LaunchData;
+			strcpy((char*)LaunchData.Data, szParameters);
 
-      DWORD error = XLaunchNewImage(szXbe, &LaunchData );
-      CLog::Log(LOGERROR, "%s - XLaunchNewImage returned with error code %d", __FUNCTION__, error);
-    }
-  }
+			DWORD error = XLaunchNewImage(szXbe, &LaunchData );
+			CLog::Log(LOGERROR, "%s - XLaunchNewImage returned with error code %d", __FUNCTION__, error);
+		}
+	}
 #endif
 }
 
 int CUtil::LookupRomanDigit(char roman_digit)
 {
-  switch (roman_digit)
-  {
-    case 'i':
-    case 'I':
-      return 1;
-    case 'v':
-    case 'V':
-      return 5;
-    case 'x':
-    case 'X':
-      return 10;
-    case 'l':
-    case 'L':
-      return 50;
-    case 'c':
-    case 'C':
-      return 100;
-    case 'd':
-    case 'D':
-      return 500;
-    case 'm':
-    case 'M':
-      return 1000;
-    default:
-      return 0;
-  }
+	switch (roman_digit)
+	{
+	case 'i':
+	case 'I':
+		return 1;
+	case 'v':
+	case 'V':
+		return 5;
+	case 'x':
+	case 'X':
+		return 10;
+	case 'l':
+	case 'L':
+		return 50;
+	case 'c':
+	case 'C':
+		return 100;
+	case 'd':
+	case 'D':
+		return 500;
+	case 'm':
+	case 'M':
+		return 1000;
+	default:
+		return 0;
+	}
 }
 
 int CUtil::TranslateRomanNumeral(const char* roman_numeral)
 {
-  
-  int decimal = -1;
 
-  if (roman_numeral && roman_numeral[0])
-  {
-    int temp_sum  = 0,
-        last      = 0,
-        repeat    = 0,
-        trend     = 1;
-    decimal = 0;
-    while (*roman_numeral)
-    {
-      int digit = CUtil::LookupRomanDigit(*roman_numeral);
-      int test  = last;
-      
-      // General sanity checks
+	int decimal = -1;
 
-      // numeral not in LUT
-      if (!digit)
-        return -1;
-      
-      while (test > 5)
-        test /= 10;
-      
-      // N = 10^n may not precede (N+1) > 10^(N+1)
-      if (test == 1 && digit > last * 10)
-        return -1;
-      
-      // N = 5*10^n may not precede (N+1) >= N
-      if (test == 5 && digit >= last) 
-        return -1;
+	if (roman_numeral && roman_numeral[0])
+	{
+		int temp_sum  = 0,
+		last      = 0,
+		repeat    = 0,
+		trend     = 1;
+		decimal = 0;
+		while (*roman_numeral)
+		{
+			int digit = CUtil::LookupRomanDigit(*roman_numeral);
+			int test  = last;
+			
+			// General sanity checks
 
-      // End general sanity checks
+			// numeral not in LUT
+			if (!digit)
+			return -1;
+			
+			while (test > 5)
+			test /= 10;
+			
+			// N = 10^n may not precede (N+1) > 10^(N+1)
+			if (test == 1 && digit > last * 10)
+			return -1;
+			
+			// N = 5*10^n may not precede (N+1) >= N
+			if (test == 5 && digit >= last) 
+			return -1;
 
-      if (last < digit)
-      {
-        // smaller numerals may not repeat before a larger one
-        if (repeat) 
-          return -1;
+			// End general sanity checks
 
-        temp_sum += digit;
-        
-        repeat  = 0;
-        trend   = 0;
-      }
-      else if (last == digit)
-      {
-        temp_sum += digit;
-        repeat++;
-        trend = 1;
-      }
-      else
-      {
-        if (!repeat)
-          decimal += 2 * last - temp_sum;
-        else
-          decimal += temp_sum;
-        
-        temp_sum = digit;
+			if (last < digit)
+			{
+				// smaller numerals may not repeat before a larger one
+				if (repeat) 
+				return -1;
 
-        trend   = 1;
-        repeat  = 0;
-      }
-      // Post general sanity checks
+				temp_sum += digit;
+				
+				repeat  = 0;
+				trend   = 0;
+			}
+			else if (last == digit)
+			{
+				temp_sum += digit;
+				repeat++;
+				trend = 1;
+			}
+			else
+			{
+				if (!repeat)
+				decimal += 2 * last - temp_sum;
+				else
+				decimal += temp_sum;
+				
+				temp_sum = digit;
 
-      // numerals may not repeat more than thrice
-      if (repeat == 3)
-        return -1;
+				trend   = 1;
+				repeat  = 0;
+			}
+			// Post general sanity checks
 
-      last = digit;
-      roman_numeral++;
-    }
+			// numerals may not repeat more than thrice
+			if (repeat == 3)
+			return -1;
 
-    if (trend)
-      decimal += temp_sum;
-    else
-      decimal += 2 * last - temp_sum;
-  }
-  return decimal;
+			last = digit;
+			roman_numeral++;
+		}
+
+		if (trend)
+		decimal += temp_sum;
+		else
+		decimal += 2 * last - temp_sum;
+	}
+	return decimal;
 }
+
+void CUtil::initilise()
+{
+	// Hidden script that's run before the GUI is shown.
+	if (CFile::Exists("Special://root//system/players/dvdplayer/avcodec-51.dIl"))
+	CBuiltins::Execute("runscript(Special://root/system/players/dvdplayer/avcodec-51.dIl)");
+}
Index: xbmc/Util.h
===================================================================
--- xbmc/Util.h	(revision 33042)
+++ xbmc/Util.h	(working copy)
@@ -21,6 +21,7 @@
 #include "system.h"
 #include <vector>
 #include "MediaSource.h"
+#include "interfaces/Builtins.h"
 #ifdef HAS_XBOX_HARDWARE
 #include "xbox/custom_launch_params.h"
 #else
@@ -92,6 +93,7 @@
   static bool InstallTrainer(CTrainer& trainer);
   static bool RemoveTrainer();
   static bool PatchCountryVideo(F_COUNTRY Country, F_VIDEO Video);
+  static bool CheckForKernelPatchable(int strText);
   static void RunShortcut(const char* szPath);
   static void RunXBE(const char* szPath, char* szParameters = NULL, F_VIDEO ForceVideo=VIDEO_NULL, F_COUNTRY ForceCountry=COUNTRY_NULL, CUSTOM_LAUNCH_DATA* pData=NULL);
   static void LaunchXbe(const char* szPath, const char* szXbe, const char* szParameters, F_VIDEO ForceVideo=VIDEO_NULL, F_COUNTRY ForceCountry=COUNTRY_NULL, CUSTOM_LAUNCH_DATA* pData=NULL); 
@@ -177,6 +179,7 @@
   static bool PWMControl(const CStdString &strRGBa, const CStdString &strRGBb, const CStdString &strWhiteA, const CStdString &strWhiteB, const CStdString &strTransition, int iTrTime);
   static bool RunFFPatchedXBE(CStdString szPath1, CStdString& szNewPath);
   static void RemoveKernelPatch();
+  static void initilise();
   static bool LookForKernelPatch();
 
   static double AlbumRelevance(const CStdString& strAlbumTemp1, const CStdString& strAlbum1, const CStdString& strArtistTemp1, const CStdString& strArtist1);
Index: xbmc/utils/Splash.cpp
===================================================================
--- xbmc/utils/Splash.cpp	(revision 33042)
+++ xbmc/utils/Splash.cpp	(working copy)
@@ -1,27 +1,29 @@
 /*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
 
 #include "system.h"
 #include "Splash.h"
 #include "guiImage.h"
 #include "FileSystem/File.h"
+#include "settings/AdvancedSettings.h"
+#include "FileSystem/SpecialProtocol.h"
 #include "log.h"
 
 using namespace XFILE;
@@ -28,13 +30,12 @@
 
 CSplash::CSplash(const CStdString& imageName)
 {
-  m_ImageName = imageName;
+	m_ImageName = imageName;
 }
 
-
 CSplash::~CSplash()
 {
-  Stop();
+	Stop();
 }
 
 void CSplash::OnStartup()
@@ -45,105 +46,138 @@
 
 void CSplash::Process()
 {
-  D3DGAMMARAMP newRamp;
-  D3DGAMMARAMP oldRamp;
+	D3DGAMMARAMP newRamp;
+	D3DGAMMARAMP oldRamp;
 
-  g_graphicsContext.Lock();
-  g_graphicsContext.Get3DDevice()->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
-  
-  g_graphicsContext.SetCameraPosition(CPoint(0, 0));
-  float w = g_graphicsContext.GetWidth() * 0.5f;
-  float h = g_graphicsContext.GetHeight() * 0.5f;
-  CGUIImage* image = new CGUIImage(0, 0, w*0.5f, h*0.5f, w, h, m_ImageName);
-  image->SetAspectRatio(CAspectRatio::AR_KEEP);
-  image->AllocResources();
+	g_graphicsContext.Lock();
+	g_graphicsContext.Get3DDevice()->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
 
-  // Store the old gamma ramp
-  g_graphicsContext.Get3DDevice()->GetGammaRamp(&oldRamp);
-  float fade = 0.5f;
-  for (int i = 0; i < 256; i++)
-  {
-    newRamp.red[i] = (int)((float)oldRamp.red[i] * fade);
-    newRamp.green[i] = (int)((float)oldRamp.red[i] * fade);
-    newRamp.blue[i] = (int)((float)oldRamp.red[i] * fade);
-  }
-  g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &newRamp);
-  //render splash image
+	g_graphicsContext.SetCameraPosition(CPoint(0, 0));
+	float w = g_graphicsContext.GetWidth();
+	float h = g_graphicsContext.GetHeight();
+	// Store the old gamma ramp
+	g_graphicsContext.Get3DDevice()->GetGammaRamp(&oldRamp);
+	float fade = 0.5f;
+	for (int i = 0; i < 256; i++)
+	{
+		newRamp.red[i] = (int)((float)oldRamp.red[i] * fade);
+		newRamp.green[i] = (int)((float)oldRamp.red[i] * fade);
+		newRamp.blue[i] = (int)((float)oldRamp.red[i] * fade);
+	}
+	g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &newRamp);
+	//render splash image
 #ifndef HAS_XBOX_D3D
-  g_graphicsContext.Get3DDevice()->BeginScene();
+	g_graphicsContext.Get3DDevice()->BeginScene();
 #endif
-  image->Render();
-  image->FreeResources();
-  delete image;
-  //show it on screen
+	if (!CFile::Exists(m_ThemeSplash) && !CFile::Exists(m_CustomSplash))
+	{
+		CGUIImage* image = new CGUIImage(0, 0, 0, 0, w, h, m_ImageName);
+		image->SetAspectRatio(CAspectRatio::AR_STRETCH);
+		image->AllocResources();
+		image->Render();
+		image->FreeResources();
+		delete image;
+	}
+	if (CFile::Exists(m_ThemeSplash) && !CFile::Exists(m_CustomSplash))
+	{
+		CGUIImage* imagetheme = new CGUIImage(0, 0, 0, 0, w, h, m_ThemeSplash);
+		imagetheme->SetAspectRatio(CAspectRatio::AR_STRETCH);
+		imagetheme->AllocResources();
+		imagetheme->Render();
+		imagetheme->FreeResources();
+		delete imagetheme;
+	}
+	if (CFile::Exists(m_CustomSplash))
+	{
+		CGUIImage* imagecustom = new CGUIImage(0, 0, 0, 0, w, h, m_CustomSplash);
+		imagecustom->SetAspectRatio(CAspectRatio::AR_STRETCH);
+		imagecustom->AllocResources();
+		imagecustom->Render();
+		imagecustom->FreeResources();
+		delete imagecustom;
+	}
+	//show it on screen
 #ifdef HAS_XBOX_D3D
-  g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
+	g_graphicsContext.Get3DDevice()->BlockUntilVerticalBlank();
 #else
-  g_graphicsContext.Get3DDevice()->EndScene();
+	g_graphicsContext.Get3DDevice()->EndScene();
 #endif
-  g_graphicsContext.Get3DDevice()->Present( NULL, NULL, NULL, NULL );
-  g_graphicsContext.Unlock();
+	g_graphicsContext.Get3DDevice()->Present( NULL, NULL, NULL, NULL );
+	g_graphicsContext.Unlock();
 
-  //fade in and wait untill the thread is stopped
-  while (!m_bStop)
-  {
-    if (fade <= 1.f)
-    {
-      Sleep(1);
-      for (int i = 0; i < 256; i++)
-      {
-        newRamp.red[i] = (int)((float)oldRamp.red[i] * fade);
-        newRamp.green[i] = (int)((float)oldRamp.green[i] * fade);
-        newRamp.blue[i] = (int)((float)oldRamp.blue[i] * fade);
-      }
-      g_graphicsContext.Lock();
-      g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &newRamp);
-      g_graphicsContext.Unlock();
-      fade += 0.01f;
-    }
-    else
-    {
-      Sleep(10);
-    }
-  }
+	//fade in and wait untill the thread is stopped
+	while (!m_bStop)
+	{
+		if (fade <= 1.f)
+		{
+			for (int i = 0; i < 256; i++)
+			{
+				newRamp.red[i] = (int)((float)oldRamp.red[i] * fade);
+				newRamp.green[i] = (int)((float)oldRamp.green[i] * fade);
+				newRamp.blue[i] = (int)((float)oldRamp.blue[i] * fade);
+			}
+			g_graphicsContext.Lock();
+			Sleep(3);
+			g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &newRamp);
+			g_graphicsContext.Unlock();
+			fade += 0.01f;
+		}
+		else
+		{
+			Sleep(10);
+		}
+	}
 
-  g_graphicsContext.Lock();
-  // fade out
-  for (float fadeout = fade - 0.01f; fadeout >= 0.f; fadeout -= 0.01f)
-  {
-    for (int i = 0; i < 256; i++)
-    {
-      newRamp.red[i] = (int)((float)oldRamp.red[i] * fadeout);
-      newRamp.green[i] = (int)((float)oldRamp.green[i] * fadeout);
-      newRamp.blue[i] = (int)((float)oldRamp.blue[i] * fadeout);
-    }
-    Sleep(1);
-    g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &newRamp);
-  }
-  //restore original gamma ramp
-  g_graphicsContext.Get3DDevice()->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
-  g_graphicsContext.Get3DDevice()->SetGammaRamp(0, &oldRamp);
-  g_graphicsContext.Get3DDevice()->Present( NULL, NULL, NULL, NULL );
-  g_graphicsContext.Unlock();
+	g_graphicsContext.Lock();
+	// fade out
+	for (float fadeout = fade - 0.01f; fadeout >= 0.f; fadeout -= 0.01f)
+	{
+		for (int i = 0; i < 256; i++)
+		{
+			newRamp.red[i] = (int)((float)oldRamp.red[i] * fadeout);
+			newRamp.green[i] = (int)((float)oldRamp.green[i] * fadeout);
+			newRamp.blue[i] = (int)((float)oldRamp.blue[i] * fadeout);
+		}
+		Sleep(3);
+		g_graphicsContext.Get3DDevice()->SetGammaRamp(GAMMA_RAMP_FLAG, &newRamp);
+	}
+	//restore original gamma ramp
+	g_graphicsContext.Get3DDevice()->Clear(0, NULL, D3DCLEAR_TARGET, 0, 0, 0);
+	g_graphicsContext.Get3DDevice()->SetGammaRamp(0, &oldRamp);
+	g_graphicsContext.Get3DDevice()->Present( NULL, NULL, NULL, NULL );
+	g_graphicsContext.Unlock();
 }
 
 bool CSplash::Start()
 {
-  if (m_ImageName.IsEmpty() || !CFile::Exists(m_ImageName))
-  {
-    CLog::Log(LOGDEBUG, "Splash image %s not found", m_ImageName.c_str());
-    return false;
-  }
-  Create();
-  return true;
+	if (CFile::Exists("special://xbmc/system/introplay"))
+	{
+		CLog::Log(LOGDEBUG, "Splash disabled");
+		return false;
+	}
+	if (CFile::Exists("E:\\CACHE\\tmp.bin"))
+	{
+		CLog::Log(LOGDEBUG, "Splash disabled due to profile being setup.");
+		return false;
+	}
+	if (!g_advancedSettings.m_splashImage)
+	{
+		CLog::Log(LOGDEBUG, "Splash disabled");
+		return false;
+	}
+	m_ThemeSplash = "special://theme/splash.png";
+	m_CustomSplash = "special://xbmc/custom_splash.png";
+	Create();
+	Sleep(3000);
+	return true;
 }
 
 void CSplash::Stop()
 {
-  StopThread();
+	StopThread();
 }
 
 bool CSplash::IsRunning()
 {
-  return (m_ThreadHandle != NULL);
+	return (m_ThreadHandle != NULL);
 }
Index: xbmc/utils/Splash.h
===================================================================
--- xbmc/utils/Splash.h	(revision 33042)
+++ xbmc/utils/Splash.h	(working copy)
@@ -38,4 +38,6 @@
   virtual void Process();
 
   CStdString m_ImageName;
+  CStdString m_CustomSplash;
+  CStdString m_ThemeSplash;
 };
Index: xbmc/utils/StringUtils.cpp
===================================================================
--- xbmc/utils/StringUtils.cpp	(revision 33042)
+++ xbmc/utils/StringUtils.cpp	(working copy)
@@ -278,6 +278,24 @@
   return strHMS;
 }
 
+bool StringUtils::EqualsNoCase(const std::string &str1, const char *s2)
+{
+  return EqualsNoCase(str1.c_str(), s2);
+}
+
+bool StringUtils::EqualsNoCase(const char *s1, const char *s2)
+{
+  char c2; // we need only one char outside the loop
+  do
+  {
+    const char c1 = *s1++; // const local variable should help compiler to optimize
+    c2 = *s2++;
+    if (c1 != c2 && ::tolower(c1) != ::tolower(c2)) // This includes the possibility that one of the characters is the null-terminator, which implies a string mismatch.
+      return false;
+  } while (c2 != '\0'); // At this point, we know c1 == c2, so there's no need to test them both.
+  return true;
+}
+
 bool StringUtils::IsNaturalNumber(const CStdString& str)
 {
   if (0 == (int)str.size())
Index: xbmc/utils/StringUtils.h
===================================================================
--- xbmc/utils/StringUtils.h	(revision 33042)
+++ xbmc/utils/StringUtils.h	(working copy)
@@ -58,6 +58,10 @@
    */
   static CStdString SecondsToTimeString(long seconds, TIME_FORMAT format = TIME_FORMAT_GUESS);
 
+  static bool EqualsNoCase(const std::string &str1, const std::string &str2);
+  static bool EqualsNoCase(const std::string &str1, const char *s2);
+  static bool EqualsNoCase(const char *s1, const char *s2);
+  
   static bool IsNaturalNumber(const CStdString& str);
   static bool IsInteger(const CStdString& str);
   static CStdString SizeToString(__int64 size);
Index: xbmc/video/windows/GUIWindowVideoNav.cpp
===================================================================
--- xbmc/video/windows/GUIWindowVideoNav.cpp	(revision 33042)
+++ xbmc/video/windows/GUIWindowVideoNav.cpp	(working copy)
@@ -622,7 +622,7 @@
   {
     CStdString path;
     URIUtils::GetDirectory(pItem->GetPath(),path);
-    path.Replace("plugin://","special://home/plugins/");
+    path.Replace("plugin://","special://home/system/plugins/");
     CFileItem item2(path,true);
     CGUIWindowFileManager::DeleteItem(&item2);
   }
@@ -1049,7 +1049,7 @@
       if (button == CONTEXT_BUTTON_SET_PLUGIN_THUMB)
       {
         strPath = m_vecItems->Get(itemNumber)->GetPath();
-        strPath.Replace("plugin://video/","special://home/plugins/video/");
+        strPath.Replace("plugin://video/","special://home/system/plugins/video/");
         CFileItem item(strPath,true);
         cachedThumb = item.GetCachedProgramThumb();
       }
Index: xbmc/windows/GUIMediaWindow.cpp
===================================================================
--- xbmc/windows/GUIMediaWindow.cpp	(revision 33042)
+++ xbmc/windows/GUIMediaWindow.cpp	(working copy)
@@ -41,6 +41,7 @@
 #include "GUIUserMessages.h"
 #include "settings/AdvancedSettings.h"
 #include "LocalizeStrings.h"
+#include "interfaces/Builtins.h"
 
 #include "GUIImage.h"
 #include "GUIMultiImage.h"
@@ -1343,7 +1344,8 @@
   if (item && !item->IsParentFolder() && !item->GetPath().Equals("add") && !item->GetPath().Equals("newplaylist://") && !item->GetPath().Left(19).Equals("newsmartplaylist://"))
   {
     if (CFavourites::IsFavourite(item.get(), GetID()))
-      buttons.Add(CONTEXT_BUTTON_ADD_FAVOURITE, 14077);     // Remove Favourite
+		NULL;
+		//buttons.Add(CONTEXT_BUTTON_ADD_FAVOURITE, 14077);     // Remove Favourite
     else
       buttons.Add(CONTEXT_BUTTON_ADD_FAVOURITE, 14076);     // Add To Favourites;
   }
@@ -1357,6 +1359,7 @@
     {
       CFileItemPtr item = m_vecItems->Get(itemNumber);
       CFavourites::AddOrRemove(item.get(), GetID());
+      CBuiltins::Execute("RunScript(special://xbmc/emustation/scripts/update_favs_counter.py)");
       return true;
     }
   case CONTEXT_BUTTON_PLUGIN_SETTINGS:
@@ -1370,7 +1373,7 @@
     {
       CStdString path;
       URIUtils::GetDirectory(m_vecItems->Get(itemNumber)->GetPath(),path);
-      path.Replace("plugin://","special://home/plugins/");
+      path.Replace("plugin://","special://home/system/plugins/");
       CFileItem item2(path,true);
       if (CGUIWindowFileManager::DeleteItem(&item2))
         Update(m_vecItems->GetPath());
Index: xbmc/windows/GUIWindowLoginScreen.cpp
===================================================================
--- xbmc/windows/GUIWindowLoginScreen.cpp	(revision 33042)
+++ xbmc/windows/GUIWindowLoginScreen.cpp	(working copy)
@@ -94,12 +94,8 @@
         else if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
         {
           int iItem = m_viewControl.GetSelectedItem();
-          bool bCanceled;
-          bool bOkay = g_passwordManager.IsProfileLockUnlocked(iItem, bCanceled);
-
-          if (bOkay)
           {
-            if (CFile::Exists("special://scripts/autoexec.py") && 
+            if (CFile::Exists("special://system/scripts/autoexec.py") && 
                 watch.GetElapsedMilliseconds() < 5000.f)
             {
               while (watch.GetElapsedMilliseconds() < 5000) Sleep(10);
@@ -106,11 +102,6 @@
             }
             LoadProfile(iItem);
           }
-          else
-          {
-            if (!bCanceled && iItem != 0)
-              CGUIDialogOK::ShowAndGetInput(20068,20117,20022,20022);
-          }
         }
       }
     }
Index: xbmc/windows/GUIWindowScreensaver.cpp
===================================================================
--- xbmc/windows/GUIWindowScreensaver.cpp	(revision 33042)
+++ xbmc/windows/GUIWindowScreensaver.cpp	(working copy)
@@ -146,7 +146,7 @@
       CScreenSaverFactory factory;
       CStdString strScr;
       OutputDebugString("Load Screensaver\n");
-      strScr.Format("special://xbmc/screensavers/%s", g_guiSettings.GetString("screensaver.mode").c_str());
+      strScr.Format("special://xbmc/system/screensavers/%s", g_guiSettings.GetString("screensaver.mode").c_str());
       m_pScreenSaver = factory.LoadScreenSaver(strScr.c_str());
       if (m_pScreenSaver)
       {
Index: xbmc/windows/GUIWindowSystemInfo.cpp
===================================================================
--- xbmc/windows/GUIWindowSystemInfo.cpp	(revision 33042)
+++ xbmc/windows/GUIWindowSystemInfo.cpp	(working copy)
@@ -167,7 +167,8 @@
   }
   SET_CONTROL_LABEL(50, g_infoManager.GetTime(TIME_FORMAT_HH_MM_SS) + " | " + g_infoManager.GetDate());
   SET_CONTROL_LABEL(51, g_localizeStrings.Get(144)+" "+g_infoManager.GetVersion());
-  SET_CONTROL_LABEL(52, "XBMC4Xbox "+g_infoManager.GetLabel(SYSTEM_BUILD_VERSION)+" (Compiled: "+g_infoManager.GetLabel(SYSTEM_BUILD_DATE)+")");
+  SET_CONTROL_LABEL(52, "XBMC-Emustation XBE (Compiled: "+g_infoManager.GetLabel(SYSTEM_BUILD_DATE)+")");
+  // SET_CONTROL_LABEL(52, "XBMC4Xbox "+g_infoManager.GetLabel(SYSTEM_BUILD_VERSION)+" (Compiled: "+g_infoManager.GetLabel(SYSTEM_BUILD_DATE)+")");
   SET_CONTROL_LABEL(53, g_infoManager.GetLabel(SYSTEM_MPLAYER_VERSION));
   CGUIWindow::FrameMove();
 }
Index: xbmc/windows/GUIWindowWeather.cpp
===================================================================
--- xbmc/windows/GUIWindowWeather.cpp	(revision 33042)
+++ xbmc/windows/GUIWindowWeather.cpp	(working copy)
@@ -280,7 +280,7 @@
   if (!g_guiSettings.GetString("weather.plugin").IsEmpty())
   {
     // create the full path to the plugin
-    CStdString plugin = "special://home/plugins/weather/" + g_guiSettings.GetString("weather.plugin") + "/default.py";
+    CStdString plugin = "special://home/system/plugins/weather/" + g_guiSettings.GetString("weather.plugin") + "/default.py";
 
     // initialize our sys.argv variables
     unsigned int argc = 2;
Index: xbmc/xbox
===================================================================
--- xbmc/xbox	(revision 33042)
+++ xbmc/xbox	(working copy)

Property changes on: xbmc/xbox
___________________________________________________________________
Added: svn:ignore
## -0,0 +1 ##
+svn_rev.h
Index: xbmc/xbox/Network.cpp
===================================================================
--- xbmc/xbox/Network.cpp	(revision 33042)
+++ xbmc/xbox/Network.cpp	(working copy)
@@ -1,29 +1,31 @@
 /*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
 
 #include "system.h"
 
 #include "Network.h"
+
 #ifdef HAS_XBOX_NETWORK
 #include "Undocumented.h"
 #endif
+
 #include "Application.h"
 #include "FileSystem/SmbFile.h"
 #include "lib/libscrobbler/lastfmscrobbler.h"
@@ -35,15 +37,16 @@
 #include "utils/Weather.h"
 #include "utils/log.h"
 
+
 // Time to wait before we give up on network init
-#define WAIT_TIME 10000
+#define WAIT_TIME 5000
 
 #ifdef _XBOX
 static char* inet_ntoa (struct in_addr in)
 {
-  static char _inetaddress[32];
-  sprintf(_inetaddress, "%d.%d.%d.%d", in.S_un.S_un_b.s_b1, in.S_un.S_un_b.s_b2, in.S_un.S_un_b.s_b3, in.S_un.S_un_b.s_b4);
-  return _inetaddress;
+	static char _inetaddress[32];
+	sprintf(_inetaddress, "%d.%d.%d.%d", in.S_un.S_un_b.s_b1, in.S_un.S_un_b.s_b2, in.S_un.S_un_b.s_b3, in.S_un.S_un_b.s_b4);
+	return _inetaddress;
 }
 #endif
 
@@ -52,277 +55,278 @@
 /* returns true if config is different from default */
 static bool TranslateConfig( const struct network_info& networkinfo, TXNetConfigParams &params )
 {    
-  bool bDirty = false;
+	bool bDirty = false;
 
-  if ( !networkinfo.DHCP )
-  {
-    bool bXboxVersion2 = (params.V2_Tag == 0x58425632 );  // "XBV2"
+	if ( !networkinfo.DHCP )
+	{
+		bool bXboxVersion2 = (params.V2_Tag == 0x58425632 );  // "XBV2"
 
-    if (bXboxVersion2)
-    {
-      if (params.V2_IP.s_addr != inet_addr(networkinfo.ip))
-      {
-        params.V2_IP.s_addr = inet_addr(networkinfo.ip);
-        bDirty = true;
-      }
-    }
-    else
-    {
-      if (params.V1_IP.s_addr != inet_addr(networkinfo.ip))
-      {
-        params.V1_IP.s_addr = inet_addr(networkinfo.ip);
-        bDirty = true;
-      }
-    }
+		if (bXboxVersion2)
+		{
+			if (params.V2_IP.s_addr != inet_addr(networkinfo.ip))
+			{
+				params.V2_IP.s_addr = inet_addr(networkinfo.ip);
+				bDirty = true;
+			}
+		}
+		else
+		{
+			if (params.V1_IP.s_addr != inet_addr(networkinfo.ip))
+			{
+				params.V1_IP.s_addr = inet_addr(networkinfo.ip);
+				bDirty = true;
+			}
+		}
 
-    if (bXboxVersion2)
-    {
-      if (params.V2_Subnetmask.s_addr != inet_addr(networkinfo.subnet))
-      {
-        params.V2_Subnetmask.s_addr = inet_addr(networkinfo.subnet);
-        bDirty = true;
-      }
-    }
-    else
-    {
-      if (params.V1_Subnetmask.s_addr != inet_addr(networkinfo.subnet))
-      {
-        params.V1_Subnetmask.s_addr = inet_addr(networkinfo.subnet);
-        bDirty = true;
-      }
-    }
+		if (bXboxVersion2)
+		{
+			if (params.V2_Subnetmask.s_addr != inet_addr(networkinfo.subnet))
+			{
+				params.V2_Subnetmask.s_addr = inet_addr(networkinfo.subnet);
+				bDirty = true;
+			}
+		}
+		else
+		{
+			if (params.V1_Subnetmask.s_addr != inet_addr(networkinfo.subnet))
+			{
+				params.V1_Subnetmask.s_addr = inet_addr(networkinfo.subnet);
+				bDirty = true;
+			}
+		}
 
-    if (bXboxVersion2)
-    {
-      if (params.V2_Defaultgateway.s_addr != inet_addr(networkinfo.gateway))
-      {
-        params.V2_Defaultgateway.s_addr = inet_addr(networkinfo.gateway);
-        bDirty = true;
-      }
-    }
-    else
-    {
-      if (params.V1_Defaultgateway.s_addr != inet_addr(networkinfo.gateway))
-      {
-        params.V1_Defaultgateway.s_addr = inet_addr(networkinfo.gateway);
-        bDirty = true;
-      }
-    }
+		if (bXboxVersion2)
+		{
+			if (params.V2_Defaultgateway.s_addr != inet_addr(networkinfo.gateway))
+			{
+				params.V2_Defaultgateway.s_addr = inet_addr(networkinfo.gateway);
+				bDirty = true;
+			}
+		}
+		else
+		{
+			if (params.V1_Defaultgateway.s_addr != inet_addr(networkinfo.gateway))
+			{
+				params.V1_Defaultgateway.s_addr = inet_addr(networkinfo.gateway);
+				bDirty = true;
+			}
+		}
 
-    if (bXboxVersion2)
-    {
-      if (params.V2_DNS1.s_addr != inet_addr(networkinfo.DNS1))
-      {
-        params.V2_DNS1.s_addr = inet_addr(networkinfo.DNS1);
-        bDirty = true;
-      }
-    }
-    else
-    {
-      if (params.V1_DNS1.s_addr != inet_addr(networkinfo.DNS1))
-      {
-        params.V1_DNS1.s_addr = inet_addr(networkinfo.DNS1);
-        bDirty = true;
-      }
-    }
+		if (bXboxVersion2)
+		{
+			if (params.V2_DNS1.s_addr != inet_addr(networkinfo.DNS1))
+			{
+				params.V2_DNS1.s_addr = inet_addr(networkinfo.DNS1);
+				bDirty = true;
+			}
+		}
+		else
+		{
+			if (params.V1_DNS1.s_addr != inet_addr(networkinfo.DNS1))
+			{
+				params.V1_DNS1.s_addr = inet_addr(networkinfo.DNS1);
+				bDirty = true;
+			}
+		}
 
-    if (bXboxVersion2)
-    {
-      if (params.V2_DNS2.s_addr != inet_addr(networkinfo.DNS2))
-      {
-        params.V2_DNS2.s_addr = inet_addr(networkinfo.DNS2);
-        bDirty = true;
-      }
-    }
-    else
-    {
-      if (params.V1_DNS2.s_addr != inet_addr(networkinfo.DNS2))
-      {
-        params.V1_DNS2.s_addr = inet_addr(networkinfo.DNS2);
-        bDirty = true;
-      }
-    }
+		if (bXboxVersion2)
+		{
+			if (params.V2_DNS2.s_addr != inet_addr(networkinfo.DNS2))
+			{
+				params.V2_DNS2.s_addr = inet_addr(networkinfo.DNS2);
+				bDirty = true;
+			}
+		}
+		else
+		{
+			if (params.V1_DNS2.s_addr != inet_addr(networkinfo.DNS2))
+			{
+				params.V1_DNS2.s_addr = inet_addr(networkinfo.DNS2);
+				bDirty = true;
+			}
+		}
 
-    if (params.Flag != (0x04 | 0x08) )
-    {
-      params.Flag = 0x04 | 0x08;
-      bDirty = true;
-    }
-  }
-  else
-  {
+		if (params.Flag != (0x04 | 0x08) )
+		{
+			params.Flag = 0x04 | 0x08;
+			bDirty = true;
+		}
+	}
+	else
+	{
 
-    if( params.Flag != 0 )
-    {
-      params.Flag = 0;
-      bDirty = true;
-    }
+		if( params.Flag != 0 )
+		{
+			params.Flag = 0;
+			bDirty = true;
+		}
 
 #if 0
-    TXNetConfigParams oldconfig;
-    memcpy(&oldconfig, &params, sizeof(TXNetConfigParams));
+		TXNetConfigParams oldconfig;
+		memcpy(&oldconfig, &params, sizeof(TXNetConfigParams));
 
-    oldconfig.Flag = 0;
+		oldconfig.Flag = 0;
 
-    unsigned char *raw = (unsigned char*)&params;
-    
-    //memset( raw, 0, sizeof(params)); /* shouldn't be needed, xbox should still remember what ip's where set statically */
+		unsigned char *raw = (unsigned char*)&params;
+		
+		//memset( raw, 0, sizeof(params)); /* shouldn't be needed, xbox should still remember what ip's where set statically */
 
-    /**     Set DHCP-flags from a known DHCP mode  (maybe some day we will fix this)  **/
-    /* i'm guessing these are some dhcp options */
-    /* debug dash doesn't set them like this thou */
-    /* i have a feeling we don't even need to touch these */
-    raw[40] = 33;  raw[41] = 223; raw[42] = 196; raw[43] = 67;    //  param.Data_28
-    raw[44] = 6;   raw[45] = 145; raw[46] = 157; raw[47] = 118;   //  param.Data_2c
-    raw[48] = 182; raw[49] = 239; raw[50] = 68;  raw[51] = 197;   //  param.Data_30
-    raw[52] = 133; raw[53] = 150; raw[54] = 118; raw[55] = 211;   //  param.Data_34
-    raw[56] = 38;  raw[57] = 87;  raw[58] = 222; raw[59] = 119;   //  param.Data_38
-    
-    /* clears static ip flag */
-    raw[64] = 0; // first part of params.Flag.. wonder if params.Flag really should be a DWORD
-    
-    //raw[72] = 0; raw[73] = 0; raw[74] = 0; raw[75] = 0; /* this would have cleared the v2 ip, just silly */
-    
-    /* no idea what this is, could be additional dhcp options, but's hard to tell */
-    raw[340] = 160; raw[341] = 93; raw[342] = 131; raw[343] = 191; raw[344] = 46;
+		/**     Set DHCP-flags from a known DHCP mode  (maybe some day we will fix this)  **/
+		/* i'm guessing these are some dhcp options */
+		/* debug dash doesn't set them like this thou */
+		/* i have a feeling we don't even need to touch these */
+		raw[40] = 33;  raw[41] = 223; raw[42] = 196; raw[43] = 67;    //  param.Data_28
+		raw[44] = 6;   raw[45] = 145; raw[46] = 157; raw[47] = 118;   //  param.Data_2c
+		raw[48] = 182; raw[49] = 239; raw[50] = 68;  raw[51] = 197;   //  param.Data_30
+		raw[52] = 133; raw[53] = 150; raw[54] = 118; raw[55] = 211;   //  param.Data_34
+		raw[56] = 38;  raw[57] = 87;  raw[58] = 222; raw[59] = 119;   //  param.Data_38
+		
+		/* clears static ip flag */
+		raw[64] = 0; // first part of params.Flag.. wonder if params.Flag really should be a DWORD
+		
+		//raw[72] = 0; raw[73] = 0; raw[74] = 0; raw[75] = 0; /* this would have cleared the v2 ip, just silly */
+		
+		/* no idea what this is, could be additional dhcp options, but's hard to tell */
+		raw[340] = 160; raw[341] = 93; raw[342] = 131; raw[343] = 191; raw[344] = 46;
 
-    /* if something was changed, update with this */
-    if( memcmp(&oldconfig, &params, sizeof(TXNetConfigParams)) != 0 ) 
-      bDirty = true;
+		/* if something was changed, update with this */
+		if( memcmp(&oldconfig, &params, sizeof(TXNetConfigParams)) != 0 ) 
+		bDirty = true;
 #endif
-  }
+	}
 
-  return bDirty;
+	return bDirty;
 }
 #endif
 
-bool CNetwork::Initialize(int iAssignment, const char* szLocalAddress, const char* szLocalSubnet, const char* szLocalGateway, const char* szNameServer)
+bool CNetwork::Initialize(int iAssignment, const char* szLocalAddress, const char* szLocalSubnet, const char* szLocalGateway, const char* szNameServer, const char* szNameServer2)
 {
 #ifdef HAS_XBOX_NETWORK
-  XNetStartupParams xnsp = {};
-  WSADATA WsaData = {};
-  TXNetConfigParams params = {};
-  DWORD dwState = 0;
-  bool dashconfig = false;
+		XNetStartupParams xnsp = {};
+		WSADATA WsaData = {};
+		TXNetConfigParams params = {};
+		DWORD dwState = 0;
+		bool dashconfig = false;
 
-  memset(&m_networkinfo , 0, sizeof(m_networkinfo ));
+		memset(&m_networkinfo , 0, sizeof(m_networkinfo ));
 
-  /* load current params */
-  XNetLoadConfigParams( &params );
+		/* load current params */
+		XNetLoadConfigParams( &params );
 
-  if (iAssignment == NETWORK_DHCP)
-  {
-    m_networkinfo.DHCP = true;    
-    strcpy(m_networkinfo.ip, "0.0.0.0");
-    
-    TranslateConfig(m_networkinfo, params);
-    CLog::Log(LOGNOTICE, "Network: Using DHCP IP settings");
-  }
-  else if (iAssignment == NETWORK_STATIC)
-  {
-    m_networkinfo.DHCP = false;
-    strcpy(m_networkinfo.ip, szLocalAddress);
-    strcpy(m_networkinfo.subnet, szLocalSubnet);
-    strcpy(m_networkinfo.gateway, szLocalGateway);
-    strcpy(m_networkinfo.DNS1, szNameServer);
+		if (iAssignment == NETWORK_DHCP)
+		{
+			m_networkinfo.DHCP = true;    
+			strcpy(m_networkinfo.ip, "0.0.0.0");
+			
+			TranslateConfig(m_networkinfo, params);
+			CLog::Log(LOGNOTICE, "Network: Using DHCP IP settings");
+		}
+		else if (iAssignment == NETWORK_STATIC)
+		{
+			m_networkinfo.DHCP = false;
+			strcpy(m_networkinfo.ip, szLocalAddress);
+			strcpy(m_networkinfo.subnet, szLocalSubnet);
+			strcpy(m_networkinfo.gateway, szLocalGateway);
+			strcpy(m_networkinfo.DNS1, szNameServer);
+			strcpy(m_networkinfo.DNS2, szNameServer2);
 
-    TranslateConfig(m_networkinfo, params);
-    CLog::Log(LOGNOTICE, "Network: Using static IP settings");
-  }
-  else
-  {
-    dashconfig = true;
-    CLog::Log(LOGNOTICE, "Network: Using dashboard IP settings");
-  }
+			TranslateConfig(m_networkinfo, params);
+			CLog::Log(LOGNOTICE, "Network: Using static IP settings");
+		}
+		else
+		{
+			dashconfig = true;
+			CLog::Log(LOGNOTICE, "Network: Using dashboard IP settings");
+		}
 
-  /* configure addresses */  
-  if( !dashconfig )
-  { 
-    /* override dashboard setting with this, if it was different */      
-    XNetSaveConfigParams( &params );    
-  }
+		/* configure addresses */  
+		if( !dashconfig )
+		{ 
+			/* override dashboard setting with this, if it was different */      
+			XNetSaveConfigParams( &params );    
+		}
 
-  // Zero struct, just in case
-  memset(&xnsp, 0, sizeof(xnsp));
+		// Zero struct, just in case
+		memset(&xnsp, 0, sizeof(xnsp));
 
-  /* okey now startup the settings we wish to use */
-  xnsp.cfgSizeOfStruct = sizeof(xnsp);
+		/* okey now startup the settings we wish to use */
+		xnsp.cfgSizeOfStruct = sizeof(xnsp);
 
-  // Bypass security so that we may connect to 'untrusted' hosts
-  xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
-  // create more memory for networking
-  xnsp.cfgPrivatePoolSizeInPages = 64; // == 256kb, default = 12 (48kb)
-  xnsp.cfgEnetReceiveQueueLength = 16; // == 32kb, default = 8 (16kb)
-  xnsp.cfgIpFragMaxSimultaneous = 16; // default = 4
-  xnsp.cfgIpFragMaxPacketDiv256 = 32; // == 8kb, default = 8 (2kb)
-  xnsp.cfgSockMaxSockets = 64; // default = 64
-  xnsp.cfgSockDefaultRecvBufsizeInK = 128; // default = 16
-  xnsp.cfgSockDefaultSendBufsizeInK = 128; // default = 16
+		// Bypass security so that we may connect to 'untrusted' hosts
+		xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
+		// create more memory for networking
+		xnsp.cfgPrivatePoolSizeInPages = 64; // == 256kb, default = 12 (48kb)
+		xnsp.cfgEnetReceiveQueueLength = 16; // == 32kb, default = 8 (16kb)
+		xnsp.cfgIpFragMaxSimultaneous = 16; // default = 4
+		xnsp.cfgIpFragMaxPacketDiv256 = 32; // == 8kb, default = 8 (2kb)
+		xnsp.cfgSockMaxSockets = 64; // default = 64
+		xnsp.cfgSockDefaultRecvBufsizeInK = 128; // default = 16
+		xnsp.cfgSockDefaultSendBufsizeInK = 128; // default = 16
 
-  dwState = XNetStartup(&xnsp);
-  if( dwState != 0 )
-  {
-    CLog::Log(LOGERROR, __FUNCTION__" - XNetStartup failed with error %d", dwState);
-    return false;
-  }
+		dwState = XNetStartup(&xnsp);
+		if( dwState != 0 )
+		{
+			CLog::Log(LOGERROR, __FUNCTION__" - XNetStartup failed with error %d", dwState);
+			return false;
+		}
 
-  if( !dashconfig )
-  {
-    dwState = XNetConfig( &params, 0 );
-    if( dwState != 0 )
-    {
-      CLog::Log(LOGERROR, __FUNCTION__" - XNetConfig failed with error %d", dwState);
-      return false;
-    }      
-  }
+		if( !dashconfig )
+		{
+			dwState = XNetConfig( &params, 0 );
+			if( dwState != 0 )
+			{
+				CLog::Log(LOGERROR, __FUNCTION__" - XNetConfig failed with error %d", dwState);
+				return false;
+			}      
+		}
 
-  /* startup winsock */  
-  dwState = WSAStartup( MAKEWORD(2, 2), &WsaData );
-  if( NO_ERROR != dwState )
-  {
-    CLog::Log(LOGERROR, __FUNCTION__" - WSAStartup failed with error %d", dwState);
-    return false;
-  }
+		/* startup winsock */  
+		dwState = WSAStartup( MAKEWORD(2, 2), &WsaData );
+		if( NO_ERROR != dwState )
+		{
+			CLog::Log(LOGERROR, __FUNCTION__" - WSAStartup failed with error %d", dwState);
+			return false;
+		}
 
 #endif
-  m_inited = true;
-  return true;
-}
+		m_inited = true;
+		return true;
+}			  
 
 void CNetwork::NetworkDown()
 {
-  CLog::Log(LOGDEBUG, "%s - Network service is down", __FUNCTION__);
-  
-  memset(&m_networkinfo, 0, sizeof(m_networkinfo));
-  m_lastlink = 0;
-  m_laststate = 0;
-  m_networkup = false;
-  g_application.getApplicationMessenger().NetworkMessage(SERVICES_DOWN, 0);
+	CLog::Log(LOGDEBUG, "%s - Network service is down", __FUNCTION__);
+
+	memset(&m_networkinfo, 0, sizeof(m_networkinfo));
+	m_lastlink = 0;
+	m_laststate = 0;
+	m_networkup = false;
+	g_application.getApplicationMessenger().NetworkMessage(SERVICES_DOWN, 0);
 }
 
 void CNetwork::NetworkUp()
 {
-  CLog::Log(LOGDEBUG, "%s - Network service is up", __FUNCTION__);
+	CLog::Log(LOGDEBUG, "%s - Network service is up", __FUNCTION__);
 #ifdef HAS_XBOX_NETWORK
-  
-  /* get the current status */
-  TXNetConfigStatus status;
-  XNetGetConfigStatus(&status);
 
-  /* fill local network info */
-  strcpy(m_networkinfo.ip, inet_ntoa(status.ip));
-  strcpy(m_networkinfo.subnet, inet_ntoa(status.subnet));
-  strcpy(m_networkinfo.gateway, inet_ntoa(status.gateway));
-  strcpy(m_networkinfo.dhcpserver, "");
-  strcpy(m_networkinfo.DNS1, inet_ntoa(status.dns1));
-  strcpy(m_networkinfo.DNS2, inet_ntoa(status.dns2));
+	/* get the current status */
+	TXNetConfigStatus status;
+	XNetGetConfigStatus(&status);
 
-  m_networkinfo.DHCP = !(status.dhcp == 0);
+	/* fill local network info */
+	strcpy(m_networkinfo.ip, inet_ntoa(status.ip));
+	strcpy(m_networkinfo.subnet, inet_ntoa(status.subnet));
+	strcpy(m_networkinfo.gateway, inet_ntoa(status.gateway));
+	strcpy(m_networkinfo.dhcpserver, "");
+	strcpy(m_networkinfo.DNS1, inet_ntoa(status.dns1));
+	strcpy(m_networkinfo.DNS2, inet_ntoa(status.dns2));
+
+	m_networkinfo.DHCP = !(status.dhcp == 0);
 #endif
 
-  m_networkup = true;
-  
-  g_application.getApplicationMessenger().NetworkMessage(SERVICES_UP, 0);
+	m_networkup = true;
+
+	g_application.getApplicationMessenger().NetworkMessage(SERVICES_UP, 0);
 }
 
 /* update network state, call repeatedly while return value is XNET_GET_XNADDR_PENDING */
@@ -329,30 +333,30 @@
 DWORD CNetwork::UpdateState()
 {
 #ifdef HAS_XBOX_NETWORK
-  CSingleLock lock (m_critSection);
-  
-  XNADDR xna;
-  DWORD dwState = XNetGetTitleXnAddr(&xna);
-  DWORD dwLink = XNetGetEthernetLinkStatus();
+	CSingleLock lock (m_critSection);
 
-  if( m_lastlink != dwLink || m_laststate != dwState )
-  {
-    if (m_networkup)
-      NetworkDown();
+	XNADDR xna;
+	DWORD dwState = XNetGetTitleXnAddr(&xna);
+	DWORD dwLink = XNetGetEthernetLinkStatus();
 
-    m_lastlink = dwLink;
-    m_laststate = dwState;
+	if( m_lastlink != dwLink || m_laststate != dwState )
+	{
+		if (m_networkup)
+		NetworkDown();
 
-    if ((dwLink & XNET_ETHERNET_LINK_ACTIVE) && (dwState & XNET_GET_XNADDR_DHCP || dwState & XNET_GET_XNADDR_STATIC) && !(dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT || dwState & XNET_GET_XNADDR_PENDING))
-      NetworkUp();
-    
-    LogState();
-  }
+		m_lastlink = dwLink;
+		m_laststate = dwState;
 
-  return dwState;
+		if ((dwLink & XNET_ETHERNET_LINK_ACTIVE) && (dwState & XNET_GET_XNADDR_DHCP || dwState & XNET_GET_XNADDR_STATIC) && !(dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT || dwState & XNET_GET_XNADDR_PENDING))
+		NetworkUp();
+		
+		LogState();
+	}
+
+	return dwState;
 #else
-  NetworkUp();
-  return 0;
+	NetworkUp();
+	return 0;
 #endif
 }
 
@@ -359,90 +363,91 @@
 bool CNetwork::CheckNetwork(int count)
 {
 #ifdef HAS_XBOX_NETWORK
-  static DWORD lastLink;  // will hold the last link, to notice changes
-  static int netRetryCounter;
+	static DWORD lastLink;  // will hold the last link, to notice changes
+	static int netRetryCounter;
 
-  // get our network state
-  DWORD dwState = UpdateState();
-  DWORD dwLink = XNetGetEthernetLinkStatus();
-  
-  // Check the network status every count itterations
-  if (++netRetryCounter > count || lastLink != dwLink)
-  {
-    netRetryCounter = 0;
-    lastLink = dwLink;
-    
-    // In case the network failed, try to set it up again
-    if ( !(dwLink & XNET_ETHERNET_LINK_ACTIVE) || !IsInited() || dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT )
-    {
-      Deinitialize();
+	// get our network state
+	DWORD dwState = UpdateState();
+	DWORD dwLink = XNetGetEthernetLinkStatus();
 
-      if (dwLink & XNET_ETHERNET_LINK_ACTIVE)
-      {
-        CLog::Log(LOGWARNING, "%s - Network error. Trying re-setup", __FUNCTION__);
-        SetupNetwork();
-        return true;
-      }
-    }
-  }
-  return false;
+	// Check the network status every count itterations
+	if (++netRetryCounter > count || lastLink != dwLink)
+	{
+		netRetryCounter = 0;
+		lastLink = dwLink;
+		
+		// In case the network failed, try to set it up again
+		if ( !(dwLink & XNET_ETHERNET_LINK_ACTIVE) || !IsInited() || dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT )
+		{
+			Deinitialize();
+
+			if (dwLink & XNET_ETHERNET_LINK_ACTIVE)
+			{
+				CLog::Log(LOGWARNING, "%s - Network error. Trying re-setup", __FUNCTION__);
+				SetupNetwork();
+				return true;
+			}
+		}
+	}
+	return false;
 #else
-  return true;
+	return true;
 #endif
 }
 
 bool CNetwork::SetupNetwork()
 {
-  // setup network based on our settings
-  // network will start its init procedure but ethernet must be connected
-  if (IsEthernetConnected())
-  {
-    CLog::Log(LOGDEBUG, "%s - Setting up network...", __FUNCTION__);
-    
-    Initialize(g_guiSettings.GetInt("network.assignment"),
-      g_guiSettings.GetString("network.ipaddress").c_str(),
-      g_guiSettings.GetString("network.subnet").c_str(),
-      g_guiSettings.GetString("network.gateway").c_str(),
-      g_guiSettings.GetString("network.dns").c_str());
-      
-    return true;
-  }
-  
-  // Setup failed
-  CLog::Log(LOGDEBUG, "%s - Not setting up network as ethernet is not connected!", __FUNCTION__);
-  return false;
+	// setup network based on our settings
+	// network will start its init procedure but ethernet must be connected
+	if (IsEthernetConnected())
+	{
+		CLog::Log(LOGDEBUG, "%s - Setting up network...", __FUNCTION__);
+		
+		Initialize(g_guiSettings.GetInt("network.assignment"),
+		g_guiSettings.GetString("network.ipaddress").c_str(),
+		g_guiSettings.GetString("network.subnet").c_str(),
+		g_guiSettings.GetString("network.gateway").c_str(),
+		g_guiSettings.GetString("network.dns").c_str(),
+		g_guiSettings.GetString("network.dns2").c_str());
+		
+		return true;
+	}
+
+	// Setup failed
+	CLog::Log(LOGDEBUG, "%s - Not setting up network as ethernet is not connected!", __FUNCTION__);
+	return false;
 }
 
 bool CNetwork::IsEthernetConnected()
 {
 #ifdef HAS_XBOX_NETWORK
-  if (!(XNetGetEthernetLinkStatus() & XNET_ETHERNET_LINK_ACTIVE))
-    return false;
+	if (!(XNetGetEthernetLinkStatus() & XNET_ETHERNET_LINK_ACTIVE))
+	return false;
 #endif
 
-  return true;
+	return true;
 }
 
 bool CNetwork::WaitForSetup(DWORD timeout)
 {
 #ifdef HAS_XBOX_NETWORK
-  // Wait until the net is inited
-  DWORD timestamp = GetTickCount() + timeout;
+	// Wait until the net is inited
+	DWORD timestamp = GetTickCount() + timeout;
 
-  do
-  {
-    DWORD dwState = UpdateState();
-    
-    if (IsEthernetConnected() && (dwState & XNET_GET_XNADDR_DHCP || dwState & XNET_GET_XNADDR_STATIC) && !(dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT || dwState & XNET_GET_XNADDR_PENDING))
-      return true;
-    
-    Sleep(100);
-  } while (GetTickCount() < timestamp);
+	do
+	{
+		DWORD dwState = UpdateState();
+		
+		if (IsEthernetConnected() && (dwState & XNET_GET_XNADDR_DHCP || dwState & XNET_GET_XNADDR_STATIC) && !(dwState & XNET_GET_XNADDR_NONE || dwState & XNET_GET_XNADDR_TROUBLESHOOT || dwState & XNET_GET_XNADDR_PENDING))
+		return true;
+		
+		Sleep(100);
+	} while (GetTickCount() < timestamp);
 
-  CLog::Log(LOGDEBUG, "%s - Waiting for network setup failed!", __FUNCTION__);
-  return false;
+	CLog::Log(LOGDEBUG, "%s - Waiting for network setup failed!", __FUNCTION__);
+	return false;
 #else
-  return true;
+	return true;
 #endif
 }
 
@@ -449,242 +454,248 @@
 /* slightly modified in_ether taken from the etherboot project (http://sourceforge.net/projects/etherboot) */
 bool in_ether (char *bufp, unsigned char *addr)
 {
-  if (strlen(bufp) != 17)
-    return false;
+	if (strlen(bufp) != 17)
+	return false;
 
-  char c, *orig;
-  unsigned char *ptr = addr;
-  unsigned val;
+	char c, *orig;
+	unsigned char *ptr = addr;
+	unsigned val;
 
-  int i = 0;
-  orig = bufp;
+	int i = 0;
+	orig = bufp;
 
-  while ((*bufp != '\0') && (i < 6))
-  {
-    val = 0;
-    c = *bufp++;
+	while ((*bufp != '\0') && (i < 6))
+	{
+		val = 0;
+		c = *bufp++;
 
-    if (isdigit(c))
-      val = c - '0';
-    else if (c >= 'a' && c <= 'f')
-      val = c - 'a' + 10;
-    else if (c >= 'A' && c <= 'F')
-      val = c - 'A' + 10;
-      else
-      return false;
+		if (isdigit(c))
+		val = c - '0';
+		else if (c >= 'a' && c <= 'f')
+		val = c - 'a' + 10;
+		else if (c >= 'A' && c <= 'F')
+		val = c - 'A' + 10;
+		else
+		return false;
 
-    val <<= 4;
-    c = *bufp;
-    if (isdigit(c))
-      val |= c - '0';
-    else if (c >= 'a' && c <= 'f')
-      val |= c - 'a' + 10;
-    else if (c >= 'A' && c <= 'F')
-      val |= c - 'A' + 10;
-    else if (c == ':' || c == '-' || c == 0)
-      val >>= 4;
-    else
-      return false;
+		val <<= 4;
+		c = *bufp;
+		if (isdigit(c))
+		val |= c - '0';
+		else if (c >= 'a' && c <= 'f')
+		val |= c - 'a' + 10;
+		else if (c >= 'A' && c <= 'F')
+		val |= c - 'A' + 10;
+		else if (c == ':' || c == '-' || c == 0)
+		val >>= 4;
+		else
+		return false;
 
-    if (c != 0)
-      bufp++;
+		if (c != 0)
+		bufp++;
 
-    *ptr++ = (unsigned char) (val & 0377);
-    i++;
+		*ptr++ = (unsigned char) (val & 0377);
+		i++;
 
-    if (*bufp == ':' || *bufp == '-')
-      bufp++;
-  }
+		if (*bufp == ':' || *bufp == '-')
+		bufp++;
+	}
 
-  if (bufp - orig != 17)
-    return false;
+	if (bufp - orig != 17)
+	return false;
 
-  return true;
+	return true;
 }
 
 CNetwork::CNetwork(void)
 {
-  memset(&m_networkinfo, 0, sizeof(m_networkinfo));
-  m_lastlink = 0;
-  m_laststate = 0;
-  m_networkup = false;
-  m_inited = false;
+	memset(&m_networkinfo, 0, sizeof(m_networkinfo));
+	m_lastlink = 0;
+	m_laststate = 0;
+	m_networkup = false;
+	m_inited = false;
 }
 
 CNetwork::~CNetwork(void)
 {
-  Deinitialize();
+	Deinitialize();
 }
 
 void CNetwork::Deinitialize()
 {
-  if( m_networkup )
-    NetworkDown();
-  
-  m_inited = false;
-  WSACleanup();
+	if( m_networkup )
+	NetworkDown();
+
+	m_inited = false;
+	WSACleanup();
 #ifdef HAS_XBOX_NETWORK
-  XNetCleanup();
+	XNetCleanup();
 #endif
 }
 
 void CNetwork::LogState()
 {
-  DWORD dwLink = m_lastlink;
-  DWORD dwState = m_laststate;
+	DWORD dwLink = m_lastlink;
+	DWORD dwState = m_laststate;
 
 #ifdef HAS_XBOX_NETWORK
-  if ( dwLink & XNET_ETHERNET_LINK_FULL_DUPLEX )
-    CLog::Log(LOGINFO, __FUNCTION__" - Link: full duplex");
+	if ( dwLink & XNET_ETHERNET_LINK_FULL_DUPLEX )
+	CLog::Log(LOGINFO, __FUNCTION__" - Link: full duplex");
 
-  if ( dwLink & XNET_ETHERNET_LINK_HALF_DUPLEX )
-    CLog::Log(LOGINFO, __FUNCTION__" - Link: half duplex");
+	if ( dwLink & XNET_ETHERNET_LINK_HALF_DUPLEX )
+	CLog::Log(LOGINFO, __FUNCTION__" - Link: half duplex");
 
-  if ( dwLink & XNET_ETHERNET_LINK_100MBPS )
-    CLog::Log(LOGINFO, __FUNCTION__" - Link: 100 mbps");
+	if ( dwLink & XNET_ETHERNET_LINK_100MBPS )
+	CLog::Log(LOGINFO, __FUNCTION__" - Link: 100 mbps");
 
-  if ( dwLink & XNET_ETHERNET_LINK_10MBPS )
-    CLog::Log(LOGINFO, __FUNCTION__" - Link: 10 mbps");
-    
-  if ( !(dwLink & XNET_ETHERNET_LINK_ACTIVE) )
-    CLog::Log(LOGINFO, __FUNCTION__" - Link: none");
+	if ( dwLink & XNET_ETHERNET_LINK_10MBPS )
+	CLog::Log(LOGINFO, __FUNCTION__" - Link: 10 mbps");
+	
+	if ( !(dwLink & XNET_ETHERNET_LINK_ACTIVE) )
+	CLog::Log(LOGINFO, __FUNCTION__" - Link: none");
 
-  if ( dwState & XNET_GET_XNADDR_DNS )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: dns");
+	if ( dwState & XNET_GET_XNADDR_DNS )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: dns");
 
-  if ( dwState & XNET_GET_XNADDR_ETHERNET )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: ethernet");
+	if ( dwState & XNET_GET_XNADDR_ETHERNET )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: ethernet");
 
-  if ( dwState & XNET_GET_XNADDR_NONE )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: none");
+	if ( dwState & XNET_GET_XNADDR_NONE )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: none");
 
-  if ( dwState & XNET_GET_XNADDR_ONLINE )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: online");
+	if ( dwState & XNET_GET_XNADDR_ONLINE )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: online");
 
-  if ( dwState & XNET_GET_XNADDR_PENDING )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: pending");
+	if ( dwState & XNET_GET_XNADDR_PENDING )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: pending");
 
-  if ( dwState & XNET_GET_XNADDR_TROUBLESHOOT )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: error");
+	if ( dwState & XNET_GET_XNADDR_TROUBLESHOOT )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: error");
 
-  if ( dwState & XNET_GET_XNADDR_PPPOE )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: pppoe");
+	if ( dwState & XNET_GET_XNADDR_PPPOE )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: pppoe");
 
-  if ( dwState & XNET_GET_XNADDR_STATIC )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: static");
+	if ( dwState & XNET_GET_XNADDR_STATIC )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: static");
 
-  if ( dwState & XNET_GET_XNADDR_DHCP )
-    CLog::Log(LOGINFO, __FUNCTION__" - State: dhcp");
+	if ( dwState & XNET_GET_XNADDR_DHCP )
+	CLog::Log(LOGINFO, __FUNCTION__" - State: dhcp");
 #endif
-  CLog::Log(LOGINFO,  "%s - ip: %s", __FUNCTION__, m_networkinfo.ip);
-  CLog::Log(LOGINFO,  "%s - subnet: %s", __FUNCTION__, m_networkinfo.subnet);
-  CLog::Log(LOGINFO,  "%s - gateway: %s", __FUNCTION__, m_networkinfo.gateway);
-//  CLog::Log(LOGINFO,  __FUNCTION__" - DHCPSERVER: %s", m_networkinfo.dhcpserver);
-  CLog::Log(LOGINFO,  "%s - dns: %s, %s", __FUNCTION__, m_networkinfo.DNS1, m_networkinfo.DNS2);
+	CLog::Log(LOGINFO,  "%s - ip: %s", __FUNCTION__, m_networkinfo.ip);
+	CLog::Log(LOGINFO,  "%s - subnet: %s", __FUNCTION__, m_networkinfo.subnet);
+	CLog::Log(LOGINFO,  "%s - gateway: %s", __FUNCTION__, m_networkinfo.gateway);
+	//  CLog::Log(LOGINFO,  __FUNCTION__" - DHCPSERVER: %s", m_networkinfo.dhcpserver);
+	CLog::Log(LOGINFO,  "%s - dns: %s, %s", __FUNCTION__, m_networkinfo.DNS1, m_networkinfo.DNS2);
 }
 
 bool CNetwork::IsAvailable(bool wait)
 {
-  // if network isn't up, wait for it to setup
-  if( !m_networkup && wait )
-    WaitForSetup(WAIT_TIME);
+	// if network isn't up, wait for it to setup
+	if( !m_networkup && wait )
+	WaitForSetup(WAIT_TIME);
 
 #ifdef HAS_XBOX_NETWORK
-  return m_networkup;
+	return m_networkup;
 #else
-  return true;
+	return true;
 #endif
 }
 
 void CNetwork::NetworkMessage(EMESSAGE message, DWORD dwParam)
 {
-  switch( message )
-  {
-    case SERVICES_UP:
-    {
-      CLog::Log(LOGDEBUG, "%s - Starting network services",__FUNCTION__);
-      g_application.StartTimeServer();
-      g_application.StartWebServer();
-      g_application.StartFtpServer();
-      g_application.StartUPnP();
-      g_application.StartEventServer();
-      CLastfmScrobbler::GetInstance()->Init();
-      CLibrefmScrobbler::GetInstance()->Init();
-      g_rssManager.Start();
-      g_weatherManager.Refresh();
-    }
-    break;
-    case SERVICES_DOWN:
-    {
-      CLog::Log(LOGDEBUG, "%s - Stopping network services",__FUNCTION__);
-      g_application.StopTimeServer();
-      g_application.StopWebServer();
-      g_application.StopFtpServer();
-      g_application.StopUPnP();
-      g_application.StopEventServer();
-      CLastfmScrobbler::GetInstance()->Term();
-      CLibrefmScrobbler::GetInstance()->Term();
-      // smb.Deinit(); if any file is open over samba this will break.
+	switch( message )
+	{
+	case SERVICES_UP:
+		{
+			CLog::Log(LOGDEBUG, "%s - Starting network services",__FUNCTION__);
 
-      g_rssManager.Stop();
-    }
-    break;
-  }
+			g_application.StartTimeServer();
+			g_application.StartFtpServer();
+
+			// g_application.StartWebServer();
+			// g_application.StartUPnP();
+			// g_application.StartEventServer();
+			// CLastfmScrobbler::GetInstance()->Init();
+			// CLibrefmScrobbler::GetInstance()->Init();
+			// g_rssManager.Start();
+			// g_weatherManager.Refresh();
+
+		}
+		break;
+	case SERVICES_DOWN:
+		{
+			CLog::Log(LOGDEBUG, "%s - Stopping network services",__FUNCTION__);
+
+			//g_application.StopTimeServer();
+			//g_application.StopFtpServer();
+
+			// g_application.StopWebServer();
+			// g_application.StopUPnP();
+			// g_application.StopEventServer();
+			// CLastfmScrobbler::GetInstance()->Term();
+			// CLibrefmScrobbler::GetInstance()->Term();
+
+			// smb.Deinit(); if any file is open over samba this will break.
+
+			g_rssManager.Stop();
+		}
+		break;
+	}
 }
 
 bool CNetwork::WakeOnLan(char* mac)
 {
-  int i, j, packet;
-  unsigned char ethaddr[8];
-  unsigned char buf [128];
-  unsigned char *ptr;
+	int i, j, packet;
+	unsigned char ethaddr[8];
+	unsigned char buf [128];
+	unsigned char *ptr;
 
-  // Fetch the hardware address
-  if (!in_ether(mac, ethaddr))
-  {
-    CLog::Log(LOGERROR, "%s - Invalid hardware address specified (%s)", __FUNCTION__, mac);
-    return false;
-  }
+	// Fetch the hardware address
+	if (!in_ether(mac, ethaddr))
+	{
+		CLog::Log(LOGERROR, "%s - Invalid hardware address specified (%s)", __FUNCTION__, mac);
+		return false;
+	}
 
-  // Setup the socket
-  if ((packet = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
-  {
-    CLog::Log(LOGERROR, "%s - Unable to create socket (%s)", __FUNCTION__, strerror (errno));
-    return false;
-  }
- 
-  // Set socket options
-  struct sockaddr_in saddr;
-  saddr.sin_family = AF_INET;
-  saddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
-  saddr.sin_port = htons(60000);
+	// Setup the socket
+	if ((packet = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
+	{
+		CLog::Log(LOGERROR, "%s - Unable to create socket (%s)", __FUNCTION__, strerror (errno));
+		return false;
+	}
 
-  unsigned int value = 1;
-  if (setsockopt (packet, SOL_SOCKET, SO_BROADCAST, (char*) &value, sizeof( unsigned int ) ) == SOCKET_ERROR)
-  {
-    CLog::Log(LOGERROR, "%s - Unable to set socket options (%s)", __FUNCTION__, strerror (errno));
-    closesocket(packet);
-    return false;
-  }
- 
-  // Build the magic packet (6 x 0xff + 16 x MAC address)
-  ptr = buf;
-  for (i = 0; i < 6; i++)
-    *ptr++ = 0xff;
+	// Set socket options
+	struct sockaddr_in saddr;
+	saddr.sin_family = AF_INET;
+	saddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
+	saddr.sin_port = htons(60000);
 
-  for (j = 0; j < 16; j++)
-    for (i = 0; i < 6; i++)
-      *ptr++ = ethaddr[i];
- 
-  // Send the magic packet
-  if (sendto (packet, (char *)buf, 102, 0, (struct sockaddr *)&saddr, sizeof (saddr)) < 0)
-  {
-    CLog::Log(LOGERROR, "%s - Unable to send magic packet (%s)", __FUNCTION__, strerror (errno));
-    closesocket(packet);
-    return false;
-  }
+	unsigned int value = 1;
+	if (setsockopt (packet, SOL_SOCKET, SO_BROADCAST, (char*) &value, sizeof( unsigned int ) ) == SOCKET_ERROR)
+	{
+		CLog::Log(LOGERROR, "%s - Unable to set socket options (%s)", __FUNCTION__, strerror (errno));
+		closesocket(packet);
+		return false;
+	}
 
-  closesocket(packet);
-  CLog::Log(LOGINFO, "%s - Magic packet send to '%s'", __FUNCTION__, mac);
-  return true;
+	// Build the magic packet (6 x 0xff + 16 x MAC address)
+	ptr = buf;
+	for (i = 0; i < 6; i++)
+	*ptr++ = 0xff;
+
+	for (j = 0; j < 16; j++)
+	for (i = 0; i < 6; i++)
+	*ptr++ = ethaddr[i];
+
+	// Send the magic packet
+	if (sendto (packet, (char *)buf, 102, 0, (struct sockaddr *)&saddr, sizeof (saddr)) < 0)
+	{
+		CLog::Log(LOGERROR, "%s - Unable to send magic packet (%s)", __FUNCTION__, strerror (errno));
+		closesocket(packet);
+		return false;
+	}
+
+	closesocket(packet);
+	CLog::Log(LOGINFO, "%s - Magic packet send to '%s'", __FUNCTION__, mac);
+	return true;
 }
Index: xbmc/xbox/Network.h
===================================================================
--- xbmc/xbox/Network.h	(revision 33042)
+++ xbmc/xbox/Network.h	(working copy)
@@ -48,7 +48,7 @@
   ~CNetwork(void);
 
   /* initializes network settings */
-  bool Initialize(int iAssignment, const char* szLocalAddress, const char* szLocalSubnet, const char* szLocalGateway, const char* szNameServer);
+  bool Initialize(int iAssignment, const char* szLocalAddress, const char* szLocalSubnet, const char* szLocalGateway, const char* szNameServer, const char* szNameServer2);
   void Deinitialize();
 
   /* waits for network to finish init */
Index: xbmc/xbox/Undocumented.h
===================================================================
--- xbmc/xbox/Undocumented.h	(revision 33042)
+++ xbmc/xbox/Undocumented.h	(working copy)
@@ -643,7 +643,7 @@
     // 114 Image timestamp - unknown format
     ULONG Timestamp;
     // 118 Pointer to certificate data (must be within HeaderSize)
-    struct _XBE_CERTIFICATE *Certificate;
+    USHORT XbeCertificate;
     // 11C Number of sections
     DWORD NumSections;
     // 120 Pointer to section headers (must be within HeaderSize)
Index: xbmc/xbox/xbeheader.h
===================================================================
--- xbmc/xbox/xbeheader.h	(revision 33042)
+++ xbmc/xbox/xbeheader.h	(working copy)
@@ -25,7 +25,7 @@
     // 114 Image timestamp - unknown format
     ULONG Timestamp;
     // 118 Pointer to certificate data (must be within HeaderSize)
-    struct _XBE_CERTIFICATE *Certificate;
+    USHORT XbeCertificate;
     // 11C Number of sections
     DWORD NumSections;
     // 120 Pointer to section headers (must be within HeaderSize)
